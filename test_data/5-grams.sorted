73187
the // parent class. The	1
the function is not accessed	1
the function is also called	1
the function is called and	2
the function is less than	1
the function is always inlined	1
the function is small or	1
the function is doing multiple	1
the function is never called.	1
the function is called. The	1
the function is called. This	1
the function is called. You	1
the function is called. I	1
the function is called. Example:	1
the function is called. Lazy	1
the function is called. 118	1
the function is replaced by	1
the function is defined in	1
the function is called, a	1
the function is called, while	1
the function is inlined. An	1
the function is big. The	1
the function a different name	1
the function a member of	2
the function a constructor for	1
the function to work with	1
the function and to optimize	1
the function in which the	1
the function in which they	2
the function in which alloca	1
the function in terms of	1
the function for the next	1
the function that needs them.	1
the function can be inlined.	1
the function or class into	1
the function or variable is	1
the function or otherwise optimize	1
the function has only a	1
the function pointer is the	1
the function pointer and makes	1
the function pointer has changed	1
the function pointer has changed.	1
the function pointer follows a	1
the function library at www.agner.org/optimize/asmlib.zip.	1
the function library asmlib, which	1
the function where you want	1
the function we want to	1
the function return a pointer	1
the function cannot be called	1
the function address in the	1
the function call statement always	1
the function they are used	1
the function type and its	1
the function must check if	1
the function through a pointer	1
the function was called from),	1
the function name is not	1
the function calling method in	1
the function calling conventions are	1
the function go to the	1
the function names are not	1
the function directly if the	1
the function modify an existing	1
the function returns. The next	1
the function returns. The preferred	1
the function returns. This is	1
the function returns. There is	1
the function returns. Make the	1
the function returns. Alternatively, you	1
the function returns. alloca may	1
the function returns. Global or	1
the function returns. Every time	1
the function stores the thousand	1
the function could be a	1
the function body inside the	1
the function call. Load library	1
the function call. Algebraic reduction	1
the function returns even though	1
the function definition. This tells	1
the function longjmp is used	1
the function ReadTSC listed below	1
the function argument to be	1
the function inline. This may	1
the function inline. Replacing a	1
the function construct an object	1
the function declaration. This is	1
the function body. A function	1
the function prototype: void F1()	1
the function billions of times	1
the function add_horizontal) static inline	1
the function bodies above, it	1
the function scanf. Violation of	1
the if branch in example	1
the if statement and all	1
the if condition can be	1
the code is not optimized.	1
the code is compiled and	1
the code is compiled for	2
the code is optimized is	1
the code is implemented as	1
the code is likely to	1
the code is fast anyway	1
the code is running on	1
the code is later ported	1
the code is chosen only	1
the code is executed. Optimizes	1
the code is included in	1
the code is fragmented and	1
the code is exactly identical	1
the code is distributed between	1
the code is selected if	1
the code is indeed vectorized	1
the code is repetitive. The	1
the code of the next	1
the code to a specific	1
the code to be able	1
the code to call the	1
the code to support different	1
the code to tell the	1
the code to test. disable	1
the code and compile them	1
the code and put the	1
the code and divide it	1
the code in a way	1
the code in a separate	1
the code in a typical	1
the code in example 14.8	1
the code in example 14.14a	1
the code in example 11.1a	1
the code in multiple versions	1
the code in order to	1
the code that the compiler	1
the code that is distributed.	1
the code that a compiler	1
the code that it jumps	1
the code that you see	1
the code that use only	1
the code that allows you	1
the code that matters rather	1
the code are relative to	1
the code are modified, if	1
the code can be implemented	1
the code can be completely	1
the code can be vectorized,	1
the code can then be	1
the code can therefore suffer	1
the code can become very	1
the code can possibly be	1
the code can probably be	1
the code if we specify	1
the code with an inline	1
the code you are testing	1
the code have been reordered,	1
the code more efficient when	1
the code more complicated and	1
the code more compact so	1
the code more efficient, and	1
the code will be less	1
the code will not be	1
the code will run faster	1
the code then you may	1
the code from example 9.5a:	1
the code has a branch	1
the code has no pointer	1
the code cache is used	1
the code cache and the	1
the code cache and it	1
the code cache or micro-op	1
the code cache if there	1
the code size or data	1
the code where speed is	1
the code takes no extra	1
the code so that each	1
the code faster because testing	1
the code makes caching more	1
the code makes caching less	1
the code less clear and	1
the code rather than using	1
the code 16 will not	1
the code up to 5	1
the code must compute (FuncRow(i)*columns	1
the code inside square: //	1
the code contains only simple	1
the code contains natural parallelism.	1
the code memory. The functions	1
the code automatically in simple	1
the code automatically or does	1
the code cache. The register	1
the code cache. The subsequent	1
the code difficult to read.	1
the code becomes bigger if	1
the code becomes simpler because	1
the code becomes contiguous. The	1
the code becomes bulky and	1
the code together near each	1
the code smaller and more	1
the code section and read-only	1
the code section can be	1
the code section will be	1
the code section so that	1
the code section position-independent, makes	1
the code still needs careful	1
the code prevent the CPU	1
the code further by using	1
the code execute faster than	1
the code to: // Example	1
the code could benefit from	1
the code involves multiplication or	1
the code itself is a	1
the code automatically. It is	1
the code generated by the	2
the code relies on structured	1
the code itself. Another disadvantage	1
the code incompatible with old	1
the code only. This can	1
the code explicitly. There are	1
the code carefully to make	1
the code mixes float and	1
the code section, but it	1
the compiler is able to	2
the compiler is usually not	1
the compiler is prevented from	1
the compiler is unable to	2
the compiler to the value	1
the compiler to be able	1
the compiler to make more	1
the compiler to make register	1
the compiler to do more	1
the compiler to do any	1
the compiler to do interprocedural	1
the compiler to do cross-module	1
the compiler to inline the	1
the compiler to store x	1
the compiler to optimize code	1
the compiler to optimize register	1
the compiler to optimize away	2
the compiler to assume that	1
the compiler to assume no	1
the compiler to reduce example	1
the compiler to predict with	1
the compiler to evaluate whether	1
the compiler to ignore overflow	1
the compiler to vectorize, or	1
the compiler and it understands	1
the compiler in the following	1
the compiler that the function	1
the compiler that the arrays	1
the compiler that a specific	1
the compiler that you want	1
the compiler that this is	1
the compiler can make this	1
the compiler can do and	1
the compiler can replace all	1
the compiler can replace j	1
the compiler can automatically replace	1
the compiler can automatically generate	1
the compiler can see that	1
the compiler can align the	1
the compiler can safely assume	1
the compiler if the uses	1
the compiler not to vectorize.	1
the compiler may in some	1
the compiler may be able	1
the compiler may not be	2
the compiler may not take	1
the compiler may calculate it	1
the compiler may actually add	1
the compiler you are using	1
the compiler you will notice	1
the compiler have been replaced	1
the compiler will convert these	1
the compiler will vectorize a	1
the compiler will recognize that	1
the compiler from the command	1
the compiler from making a	1
the compiler from making an	2
the compiler from making optimizations	1
the compiler from doing the	1
the compiler from doing optimizations	1
the compiler from aligning the	1
the compiler at compile time.	1
the compiler has to take	1
the compiler has an option	1
the compiler has no information	1
the compiler has chosen for	1
the compiler takes the hint	1
the compiler takes care of	1
the compiler cannot know for	1
the compiler cannot know that	1
the compiler cannot rule out	1
the compiler does It can	1
the compiler does quite ingenious	1
the compiler does what you	1
the compiler does ............................................................................. 84	1
the compiler must calculate its	1
the compiler must convert it	1
the compiler (see page 103),	1
the compiler doesn't have the	1
the compiler doesn't have to	1
the compiler doesn't have an	1
the compiler doesn't make such	1
the compiler doesn't know the	1
the compiler doesn't know what	1
the compiler option -fno-pic when	1
the compiler option "assume no	1
the compiler manual for details.	1
the compiler manual or in	1
the compiler uses a different	1
the compiler uses position-independent code	1
the compiler would be able	1
the compiler optimize example 8.26a	1
the compiler needs to make	1
the compiler needs to look	1
the compiler optimizations that it	1
the compiler output can often	1
the compiler e.g. how often	1
the compiler explicitly that pointers	1
the compiler itself is. The	1
the compiler generates is to	1
the compiler .......................................................................................... 66 8.1	1
the compiler additional information about	1
the compiler 8.1 How compilers	1
the compiler documentation for the	1
the compiler documentation for detailed	1
the compiler optimizes a piece	1
the compiler bypassing the dispatch	1
the compiler sees the constant	1
the compiler treat a variable	1
the compiler interpret the bits	1
the compiler recognizes it as	1
the compiler knows that it	1
the time the variable pointed	1
the time the software was	2
the time is spent in	1
the time is spent on	1
the time of programming will	1
the time of programming. The	1
the time of programming. 13.3	1
the time to answer questions	1
the time and b is	1
the time and rarely the	1
the time it takes to	13
the time it takes before	1
the time it was programmed.	2
the time on processors that	1
the time you would have	1
the time used by all	1
the time we are swapping	1
the time before the end	1
the time before and after	1
the time goes to cache	1
the time delay that the	1
the time stamp counter in	1
the time stamp counter can	1
the time stamp counter before	1
the time stamp counter. The	1
the time consuming parts only.	1
the time spent in the	1
the time spent on function	1
the time consumption of each	1
the time consumption was down	1
the time slices is determined	1
the time slices to 120	1
the time slices allocated to	1
the time MemberPointer is declared.	1
the use of the micro-op	1
the use of integer operations.	1
the use of Intel vector	1
the use of two induction	1
the use of register variables.	1
the use of assembly language	1
the use of arrays in	1
the use of classes and	1
the use of intrinsic vectors	1
the use of << and	1
the use of RAM memory.	1
the use of longjmp if	1
the more important it is	1
the more complicated functions like	1
the memory is mirrored in	1
the memory to be fragmented	1
the memory to become fragmented	1
the memory if the size	1
the memory when exiting the	1
the memory used by a	1
the memory page size (4096).	1
the memory allocation is unnecessarily	1
the memory space is occupied	1
the memory model used here.	1
the memory block from one	1
the memory block should have	1
the memory block. This requires	1
the memory footprint is unreasonably	1
the memory bus is saturated.	1
the memory released when the	1
the data to the right	1
the data and resources should	1
the data in the file,	1
the data are used many	1
the data are stored in	2
the data are accessed sequentially.	1
the data are aligned to	1
the data are scattered around	1
the data with all the	1
the data as an array	1
the data more random than	1
the data cache (see page	1
the data set into sub-vectors	1
the data into multiple blocks	1
the data into groups of	1
the data object in the	1
the data object through this	1
the data elements are. For	1
the data caching less efficient.	1
the data cache. The same	1
the data cache. If the	1
the data cache. These instructions	1
the data cache. 2.2 Choice	1
the data cache. Single precision	1
the data cache. Bit-fields of	1
the data block to copy	1
the data section may contain	1
the data fit into the	1
the data fit nicely into	1
the data members. If the	1
the data members. But each	1
the data optimally, or from	1
the data structure, data flow	1
the program is compiled without	1
the program is never used.	1
the program is actually used.	1
the program is loaded into	1
the program is loaded rather	1
the program is executed. Furthermore,	1
the program is running. The	1
the program is running. If	1
the program is run. The	1
the program is run. Both	1
the program is loaded. This	1
the program is compiled. #if	1
the program is dividing repeatedly	1
the program is started. It	1
the program is loaded, the	1
the program is loaded, but	1
the program is busy doing	1
the program is terminated and	1
the program is shut down	1
the program of occupying a	1
the program to use a	1
the program to measure how	1
the program to issue an	1
the program in a debugger	1
the program in case of	1
the program that are very	1
the program that calls it.	1
the program that runs under	1
the program that waits for	1
the program are also stored	1
the program are often much	1
the program or because the	1
the program if there is	1
the program by their address	1
the program with profiling support.	1
the program code for making	1
the program code are uncached	1
the program as long as	1
the program as well as	1
the program - preferably isolated	1
the program than to type	1
the program may be selected	1
the program may need modification	1
the program have been found,	1
the program more clear unless	1
the program will be unable	1
the program will crash. See	1
the program then it can	1
the program has most cache	1
the program do the calculations.	1
the program takes too long	1
the program before the file	1
the program less efficient. Splitting	1
the program must clean up	1
the program uses a lot	1
the program uses more than	1
the program contains automatic CPU	1
the program under test but	1
the program under test finishes	1
the program under test, but	1
the program happen to be	1
the program logic allows parallel	1
the program logic allows it,	1
the program had read from	1
the program itself when running.	1
the program itself. You may	1
the program appear to take	1
the program runs satisfactorily on	1
the program starts running and	1
the program starts up. Some	1
the program 153 spends most	1
the program flow and the	1
the program flow at inconvenient	1
the program flow. However, this	1
the program afterwards reads or	1
the program slower. Another disadvantage	1
the program starts. The user	1
the program starts. The disadvantage	1
the program logic. Some guidelines	1
the vector class library have	1
the vector class library, SSE4.1	1
the vector size for the	1
the vector size then add	1
the vector size (16 or	1
the vector register size. Vectorized	1
the vector registers in the	1
the vector registers can hold	1
the vector registers are: It	1
the vector operations of modern	1
the vector operations mentioned in	1
the vector element level 9.	1
the vector element level 108	1
the vector size. There is	1
the vector registers. It may	1
the different functions in the	1
the different integer types available.	1
the different compilers succeeded in	1
the different instructions sets. The	1
the different versions of the	2
the different versions alternatingly several	1
the different execution units in	1
the different parts of the	1
the different tasks were not	1
the different cores is slow.	1
the different microprocessors. 7.13 Loops	1
the same in a more	1
the same in both cases.	1
the same for simple variables,	1
the same or a nearby	1
the same function or class	1
the same function on a	1
the same function may be	1
the same function calling conventions.	1
the same code and read-only	1
the same code in either	1
the same code can be	1
the same code as example	1
the same as the latency	1
the same as the C-style	1
the same as a pointer	1
the same as for switch	1
the same as for (i=0;	1
the same as if you	1
the same as i modulo	1
the same as last time	1
the same as C- style	1
the same as reflecting it	1
the same compiler option for	1
the same time to share	1
the same time to evaluate	1
the same time that it	1
the same time as the	1
the same time regardless of	1
the same memory space. A	1
the same memory pool. See	1
the same memory area for	2
the same memory area. The	1
the same memory area. Join	1
the same memory areas. Data	1
the same memory block, but	1
the same data in different	1
the same instruction set. Neither	1
the same cache is that	1
the same cache line. The	1
the same cache line. But	1
the same cache lines. The	1
the same cache lines. This	1
the same cache line, because	1
the same set in the	1
the same class and store	1
the same class will be	1
the same object (except for	1
the same array for multiple	1
the same version of the	1
the same member pointer. 7.9	1
the same way is predicted	1
the same way as in	1
the same way as an	1
the same way as last	1
the same address so a	1
the same critical part of	1
the same register for more	1
the same register for both,	1
the same register because their	2
the same time. The code	1
the same time. A code	1
the same time. A user	1
the same time. There are	1
the same time. Example: //	1
the same without discriminating between	1
the same dynamic library can	1
the same dynamic libraries without	1
the same part of the	3
the same bits in a	1
the same bits differently. A	1
the same type to avoid	1
the same result if we	1
the same processor core on	1
the same processor core. Unfortunately,	1
the same processor core. Two	1
the same processor core. Try	1
the same thread as very	1
the same precision in all	1
the same precision as the	1
the same few parameters. Or	1
the same structure or class.	1
the same inline assembly syntax	1
the same shared object. Obviously,	1
the same space for the	1
the same cache. Multithreaded programs	1
the same name for the	1
the same name as a	2
the same source code. The	1
the same source code. #if	1
the same source file. Keep	1
the same induction variable for	1
the same reason that they	1
the same after this statement	1
the same piece of code	1
the same piece of memory.	1
the same function, each optimized	1
the same compiler. It is	1
the same range of memory	1
the same core will always	1
the same errors can happen	1
the same variables. In these	1
the same operation is performed	2
the same level-1 cache. The	1
the same resources. But it	1
the same class. The static	1
the same object. There is	1
the same time, except for	1
the same priority is no	1
the same priority than the	1
the same thing and the	1
the same thing and if	1
the same thing and they	1
the same thing as p	1
the same logical register. This	1
the same subexpression occurs more	1
the same resource then it	1
the same generation can cause	1
the same address. There are	1
the same module then the	1
the same module (i.e. the	1
the same features as the	1
the same value. This is	1
the same unit as additions.	1
the same register. Everything that	1
the same DLL at the	1
the same object, except for	1
the same core. It is	1
the same constant. Example: //	1
the same principle as in	1
the same regardless of precision	1
the same result. A compiler	1
the same resources, such as	1
the same cache, at least	1
the same brand. Future processors	1
the same way, the first	1
the same chip can be	1
the same name. In the	1
the same arguments are sure	1
the same executable. SSE2 is	1
the same machine. The virtual	1
the same thing. Example: //	1
the same thing. An expression	1
the same template. 57 Templates	1
the same chip. Such hybrid	1
the same effect. Which method	1
the same class). If the	1
the same computer, including the	1
the same name, regardless of	1
the same algorithm, then you	1
the same directory as the	1
the same divisor. In this	1
the same queue, list, database,	1
the functions that are used	1
the functions that are needed	1
the functions that are called.	1
the functions that it calls.	2
the functions that have multiple	2
the functions that access the	1
the functions are never called.	1
the functions are actually called	1
the functions memset and memcpy:	1
the functions malloc and free.	1
the functions lrintf and lrint.	1
the only one that works	1
the only way to make	1
the only situation where they	1
the only reasonable solution is	1
the CPU is limited by	1
the CPU to generate interrupts	1
the CPU to start calculations	1
the CPU to increment the	1
the CPU to overlap the	1
the CPU and the operating	4
the CPU and prevent it	1
the CPU can do calculations	1
the CPU it is running	1
the CPU by giving it	1
the CPU than the main	1
the CPU may occasionally predict	1
the CPU time then there	1
the CPU from doing multiple	1
the CPU from doing out-of-order	1
the CPU from overlapping calculations.	1
the CPU has hardware support	2
the CPU has problems separating	1
the CPU which can be	1
the CPU used for temporary	1
the CPU clock by using	1
the CPU clock frequency is	1
the CPU clock frequency (in	1
the CPU doesn't support, and	1
the CPU doing multiple calculations	1
the CPU was started. The	1
the CPU dispatching and run	1
the CPU dispatching explicitly as	1
the CPU dispatcher to know	1
the CPU dispatcher in the	1
the CPU dispatch mechanism in	1
the CPU core is running	1
the CPU supports the corresponding	1
the CPU supports then you	1
the CPU (See manual 3:	2
the CPU cores and leave	1
the CPU dispatching. This function	1
the CPU brand check is	1
the CPU detection function of	1
the CPU detection function in	1
the CPU detection function that	1
the CPU detection function as	1
the CPU detection mechanism in	1
the CPU detection function, one	1
the CPU detection mechanism. The	1
the CPU family number, which	1
the CPU brand. Critical parts	1
the CPU chip. Such units	1
the CPU supports, rather than	1
the other is -0 (zero	1
the other with a 50-50	1
the other then put the	1
the other way is mispredicted	2
the other way three times.	1
the other thread increments seconds.	1
the other thread. However, in	1
the other way. A branch	1
the other hand, the compiler	1
the other hand, a just-in-time	1
the other hand, it is	1
the other hand, if your	1
the other hand, does not	1
the other way, etc. The	1
the other compilers). The best	1
the other volumes in this	1
the instruction set is the	1
the instruction set for the	1
the instruction set that you	1
the instruction set SSE2 or	1
the instruction code. You can	1
the instruction sets is provided	1
the instruction set. These new	1
the instruction xor eax,eax. This	1
the point is that the	1
the point where it is	1
the loop is in mathematical	1
the loop is long because	1
the loop is inside another	1
the loop is rolled out	1
the loop and have a	1
the loop and splitting the	1
the loop and reorganize: //	1
the loop in this case.	1
the loop in example 11.3	1
the loop in example 12.4a	1
the loop are finished. This	1
the loop can be implemented	1
the loop can change the	1
the loop or the series	1
the loop or add an	1
the loop if the results	1
the loop if you are	1
the loop if all the	1
the loop by the same	1
the loop by two and	1
the loop by two gives:	1
the loop by n and	1
the loop by four, we	1
the loop will take 1000	1
the loop branch must rely	1
the loop without checking all	1
the loop does not cost	1
the loop counter is an	1
the loop counter is used	1
the loop counter can be	1
the loop counter with its	1
the loop counter ahead of	1
the loop count is small	1
the loop count is too	1
the loop count is divisible	2
the loop count (ArraySize) is	1
the loop control it compares	1
the loop control branch is	1
the loop control branch depends	2
the loop control branch ahead	1
the loop control statement several	1
the loop control branch. There	1
the loop control branch. See	1
the loop control condition: //	1
the loop further if the	1
the loop unroll option in	1
the loop unroll factor. A	1
the loop condition i <	1
the loop buffer that some	1
the loop body is very	1
the loop is. The type	1
the loop counter. Example: //	1
the loop counter. Any expression	1
the loop increment i++. cmp	1
the loop index. The integer	1
the loop counter, which is	1
the loop exits, when in	1
the loop overhead. Example: //	1
the one that is used	1
the one that takes longer	1
the one that works best	1
the one that gives the	1
the one it is compiling.	1
the cache to load the	1
the cache in between the	1
the cache in just a	1
the cache will be filled	1
the cache will evict the	1
the cache then you can	1
the cache so we don't	1
the cache between each call,	1
the cache always chooses the	1
the cache line that was	1
the cache line size in	1
the cache line size (typically	1
the cache line would be	1
the cache line size, which	1
the cache contentions can be	1
the cache size. When the	1
the cache size. Alternatively, you	1
the cache lines we used	1
the cache lines follow the	1
the cache miss on a	1
the integer is signed, or	1
the integer in the loop	1
the integer in a different	1
the integer has enough bits	1
the integer size on AMD	1
the integer value of temp.	1
the integer registers is extended	1
the integer operations use different	1
the integer expression -a >	1
the integer calculations. The code	1
the integer factorial function (n!)	1
the set can be used.	1
the class is declared. An	1
the class of the object	1
the class that the member	1
the class or structure is	2
the class or give it	1
the class has at least	1
the class c1 other than	1
the class Vec16s when compiling	1
the class definition. This will	1
the class declaration. The type	1
the floating point and integer	1
the floating point code rather	1
the floating point value written	1
the floating point register stack	1
the floating point registers are	1
the floating point operations without	1
the floating point stack registers	2
the floating point calculations inside	1
the floating point rounding mode	1
the floating point representation directly	1
the floating point number. We	1
the floating point format is	1
the example of a Taylor	1
the example below shows. The	1
the compilers that are best	1
the compilers are able to	1
the compilers may behave differently	1
the compilers will not do	1
the compilers cannot do must	1
the compilers I have tested	4
the compilers I have tried.	1
the compilers reduced 15.1a to	1
the most used data. The	1
the most used parts of	1
the most efficient memory space	1
the most efficient integer size	1
the most efficient library and	1
the most efficient solution for	1
the most efficient solution may	1
the most efficient solution because	1
the most efficient solution. Is	1
the most efficient alternative. The	1
the most critical integer parameter	1
the most critical part of	7
the most critical parts of	1
the most critical modules with	1
the most often used data	1
the most often used variables	1
the most often used members	1
the most simple reductions on	1
the most important or critical	1
the most important functions are	1
the most common memory and	1
the most common cause of	1
the most common platforms with	1
the most common math functions	1
the most common obstacles to	1
the most complicated implementation of	1
the most advanced code version	1
the most significant part of	1
the most time-consuming part of	1
the most time-consuming parts of	1
the most frequent causes of	1
the most reliable solution. (In	1
the most predictable operand first.	1
the double precision constant and	1
the size is a power	1
the size of the program	1
the size of the vector	1
the size of the object	1
the size of the array	2
the size of the type	1
the size of the matrix	1
the size of the variable.	1
the size of the largest	1
the size of a memory	1
the size of a matrix	2
the size of an array	1
the size of data files.	1
the size of program or	1
the size of each integer	1
the size of each array	1
the size of abc is	2
the size of abc can	1
the size and type of	1
the size doesn't matter and	1
the size known at compile	1
the size known before the	1
the size parameter is bigger	1
the size parameter is wrong,	1
the size (in bytes) of	1
the Intel and PathScale compilers	1
the Intel function libraries do	1
the Intel compiler is that	1
the Intel compiler is less	1
the Intel compiler is used,	1
the Intel compiler in favor	1
the Intel compiler for Windows	1
the Intel compiler for Linux	1
the Intel compiler has an	1
the Intel compiler because it	1
the Intel compiler works only	1
the Intel compiler reduced 15.1a	1
the Intel compiler puts the	1
the Intel CPU dispatcher treats	1
the Intel CPU detection function	1
the Intel C++ compiler. This	1
the Intel C++ Compiler Documentation	1
the Intel libraries do not	1
the Intel mechanism executes a	1
the Intel compiler. This method	1
the Intel math function library	1
the Intel libraries. Supports 32-	1
the Intel Core and later	1
the pointer is used. For	1
the pointer is needed a	1
the pointer is deleted. Smart	1
the pointer or reference. Registers	1
the pointer it gets from	1
the pointer has to be	1
the pointer has been calculated.	1
the pointer does not alias	1
the pointer p has been	1
the library is very large	1
the library is loaded or	1
the library is needed. All	1
the library that is actually	1
the library that comes with	1
the library function calls. It	1
the library function 250 times	1
the library has no AVX	1
the library functions directly: Library	1
the library into memory. This	1
the library file and copies	1
the library function. 12.2 AVX-512	1
the library through the symbolic	1
the library functions. The CPU-	1
the library function, and the	1
the library www.agner.org/optimize/asmlib.zip. The name	1
the library libmmt.lib and the	1
the multiple data structures in	1
the multiple processor cores. Each	1
the multiple .cpp modules into	1
the two clock counts. The	1
the two operating systems are	1
the two functions. The difference	1
the two branches to feed	1
the two induction variables Y	1
the two types of floating	1
the two modules contiguous in	1
the two constants are identical	1
the two kinds of code	1
the two loops would make	1
the two loops (except in	1
the two AND operations: __m128i	1
the two parentheses can be	1
the two formulas in this	1
the object is no longer	1
the object is so small	1
the object is large then	1
the object is copied to	1
the object is treated as	1
the object is deleted properly	1
the object is known. This	1
the object of the class	1
the object in case memory	1
the object can be copied	1
the object or array coincides	1
the object it points to	1
the object on its final	1
the object x when it	1
the object then you don't	1
the object has no virtual	1
the object has no copy	1
the object file level, and	1
the object file level. My	1
the object does not use	1
the object doesn't need initialization.	1
the object files need to	1
the object instead of copying	1
the object file. Use another	1
the object pointed to. For	1
the object belongs to class	1
the object owns. A destructor	1
the number of different targets	1
the number of CPU cores.	1
the number of possible inputs	1
the number of clock pulses	1
the number of objects is	2
the number of elements is	1
the number of elements in	5
the number of elements per	2
the number of registers has	1
the number of bits in	1
the number of available registers	1
the number of times each	1
the number of times CriticalFunction	1
the number of calls to	1
the number of threads with	1
the number of points is	1
the number of columns a	1
the number of columns in	3
the number of lines is	1
the number of logical processors.	1
the number of cores or	1
the number of cores will	1
the number of iterations is	1
the number of machine instructions	1
the number of branches. Manual	1
the number of context switches	1
the number of physical processors	1
the number of allocations is	1
the number of jumps, calls	1
the number and sets all	1
the number and types of	1
the static version if speed	1
the static keyword to all	1
the static keyword has a	1
the static modifier will be	1
the static keyword: // Example	1
the static keyword, for floating	1
the 64-bit vector operations and	1
the 64-bit instruction set has	1
the 64-bit systems will dominate	1
the 64-bit systems. A software	1
the 64-bit vectors then you	1
the 64-bit versions. The x86	1
the 64-bit extension to the	1
the C++ compiler is available	1
the C++ template feature was	1
the C++ programming language and	1
the C++ language also includes	1
the C++ language While C++	1
the C++ language relates to	1
the C++ syntax in example	1
the C++ language, all conversions	1
the C++ language...................................................... 14 3	1
the array is not known	1
the array is stored. This	1
the array is defined. This	1
the array a and edx	1
the array to make the	1
the array or container is	1
the array size a multiple	1
the array pointer eax to	1
the array elements then this	1
the array address is. ecx	1
the array must begin at	1
the array element is accessed,	1
the array element has to	1
the array after all elements	1
the array index is out	1
the array i) { //	1
the array 800 bytes smaller.	1
the many rules of algebra	1
the many people who have	1
the possible alternatives to exception	1
the clock cycles spent on	1
the clock count before and	1
the clock frequency is 2	1
the clock frequency is limited	1
the clock frequency may vary	1
the clock frequency goes up	1
the clock counts that you	1
the clock counts should be	1
the clock frequency. The core	1
the clock frequency. For example,	1
the clock frequency, as explained	1
the clock period and by	1
the version in main will	1
the version that fits the	1
the version changes then you	1
the value is calculated from	1
the value is poorly predictable,	1
the value is already in	1
the value of the function	2
the value of the time	1
the value of the loop	1
the value of the pointer	3
the value of the parameter	1
the value of the second	1
the value of the divisor	2
the value of a class	1
the value of a pointer	1
the value of A is	1
the value of b is	1
the value of register temp	1
the value of N with	1
the value of ebx that	1
the value of seconds and	1
the value of ebx. Only	1
the value of m and	1
the value of b+c will	1
the value and write it	1
the value in the previous	1
the value in edx as	1
the value that is four	1
the value that is n	1
the value that is added	1
the value that lies r	1
the value it was assigned	1
the value from a variable	1
the value from memory plus	1
the value has changed five	1
the value each time the	1
the value before the decimal	1
the value 0 for false	1
the value 10 * 8	1
the value pointed to by	2
the value wrap around. Adding	1
the value 1000. The loop	1
the value -100+100+100 = 100.	1
the value infinity, and this	1
the value 0x2C so that	1
the objects in the same	1
the objects are accessed in	1
the objects are aligned. It	1
the objects should preferably be	1
the objects stored are containers	1
the objects they point to	1
the objects together into a	1
the objects (memory pooling) than	1
the variable is only used	1
the variable is stored in	2
the variable is used. An	1
the variable is declared. If	1
the variable to be stored	1
the variable in the global	1
the variable in many cases.	1
the variable that r points	1
the variable as function parameter.	1
the variable from RAM memory	1
the variable at the same	1
the variable two names, one	1
the variable always has the	1
the variable pointed to is	1
the variable pointed to can	1
the variable whose address is	1
the variable Day. Note the	1
the variable __intel_cpu_feature_indicator where each	1
the variable __intel_cpu_feature_indicator_x. You can	1
the variable 85 ; eax	1
the variable m. The advantage	1
the variables that are used	1
the variables might have other	1
the return address of the	1
the return statement: // Example	1
the table is not significant	1
the table is initialized when	1
the table is cached. Usually	1
the table to be evicted	1
the table to stack memory	1
the table in the program	1
the table in static memory	1
the table that is stored	1
the table are core clock	1
the table from static memory	1
the table at runtime, if	1
the table has const twice	1
the table takes extra time,	1
the table inside a function	1
the table values by hand	1
the table lookup. Lookup tables	1
the table static. This makes	1
the performance is not doubled.	1
the performance is limited by	1
the performance of the function	1
the performance of the STL	1
the performance of the final	1
the performance of this function	1
the performance of two different	1
the performance if the branch	1
the performance by organizing the	1
the performance by 5-10% for	1
the performance then there is	1
the performance because the integer	1
the performance because the contents	1
the performance even matters, which	1
the performance counters inside your	1
the performance during the development	1
the performance monitor counters when	1
the performance monitor counters before	1
the performance monitor counters. My	1
the performance under the worst-	1
the performance significantly simply by	1
the performance dramatically by unrolling	1
the performance somewhat. The AVX2	1
the performance costs. The time	1
the very time-consuming garbage collector	1
the software to be slower	1
the software for speed or	1
the software programming language defines	1
the software contains a negative	1
the software contains a positive	1
the software was coded. If	1
the software was developed. A	1
the software implementation is faster	1
the software implementation if the	1
the software development work as	1
the software development process. These	1
the software package in order	1
the order of the two	1
the order of the Boolean	1
the order of the operands	2
the order of functions in	1
the order of floating point	1
the order of Boolean operands.	1
the order in which the	3
the order in which they	3
the order a[0], b[0], a[1],	1
the long double format. The	1
the 32-bit version. The Gnu	1
the 32-bit integer. Floating point	1
the 32-bit case. The -fpie	1
the branch is poorly predictable.	1
the branch by a table	1
the branch inside the loop	1
the branch inside the loop.	1
the branch target buffer can	1
the branch target buffer (BTB).	1
the branch target buffer. Contentions	1
the branch prediction mechanism. See	1
the branch misprediction penalty. Branches	1
the member function is big	1
the member functions of a	1
the member functions of parent	1
the member pointer refers to.	1
the member function. But there	1
the member pointer. This can	1
the member relative to the	1
the way the register stack	1
the way the programming language	1
the way a profiler works	1
the way of example 12.4b	1
the way of declaring an	1
the way member pointers are	1
the way microprocessors are constructed.	1
the way m is transferred	1
the elements of a vector,	1
the elements in a[] which	1
the elements are stored in	1
the elements are accessed in	2
the elements are accessed sequentially.	1
the elements from row 28	1
the elements consecutively in memory.	1
the elements matrix[r][c] below the	1
the const int declaration may	1
the const keyword wherever appropriate	1
the const restriction on x.	1
the const restriction from a	1
the called function. Example: //	1
the called function. But in	1
the address of the data	1
the address of the array	1
the address of the variable	2
the address of the member	1
the address of the first	1
the address of the matrix	1
the address of the end	1
the address of the preceding	1
the address of the beginning	2
the address of the current	1
the address of a linked	1
the address of it (&ArraySize)	1
the address of an array	2
the address of each function	1
the address of each row	1
the address of array element	1
the address of element number	1
the address of matrix[j][0] is	1
the address can be expressed	1
the address calculation more efficient:	1
the address calculation faster. The	1
the address range from 0x2700	2
the 4 lines in the	1
the critical function is called.	1
the critical function is inserted	1
the critical function may be	1
the critical function many times	1
the critical function ten times	1
the critical code to see	1
the critical code are compiled	1
the critical code so that	1
the critical functions and hot	1
the critical functions take microseconds	1
the critical code. A test	1
the critical part of the	2
the critical part of a	4
the critical part can run	1
the critical function. The initialization	1
the critical function. The branching	1
the critical function. In some	1
the critical parts of the	1
the critical innermost loop of	2
the critical innermost loop. The	1
the critical innermost loop. log	1
the critical innermost loops. 13.1	1
the critical stride is a	2
the critical stride and cause	1
the critical stride will contend	1
the critical stride then this	1
the critical stride (see above,	1
the critical stride causes all	1
the critical stride, as explained	1
the critical stride. Variables whose	1
the call to square by	1
the call to CriticalFunction in	1
the call to Object1.Hello(), though	1
the call and return operations	1
the call stack in the	1
the call p->f() goes to	1
the 8 most popular version	1
the bit scan instruction is	1
the bit scan instruction and	1
the operating systems disappears when	1
the operating system is often	1
the operating system to avoid	1
the operating system to generate	1
the operating system to swap	1
the operating system and choose	1
the operating system for support	1
the operating system can be	2
the operating system or libraries	1
the operating system has support	1
the operating system which redirects	1
the operating system rather than	1
the operating system (see page	1
the operating system thread scheduler.	1
the operating system API and	1
the operating system kernel in	1
the operating system. This is	1
the operating system. It will	1
the operating system. See page	1
the operating system. AVX is	1
the operating system, and 512	1
the operating system, not by	1
the unsigned integer to a	1
the first in a series	1
the first time the function	2
the first time because it	1
the first time Func is	1
the first data member or	1
the first two (three on	1
the first two suggested improvements).	1
the first object to the	1
the first way and three	1
the first call to the	1
the first time. This is	1
the first processors that supported	1
the first result is stored	1
the first element is stored	1
the first element is stored?	1
the first element of the	1
the first 128 bytes then	1
the first 128 bytes. 7.19	1
the first four parameters are	1
the first program. An optimizing	1
the first application if dynamic	1
the first byte of zero	1
the first byte of zero.	1
the first algorithm that comes	1
the first operand of &&	1
the first operand of ||	1
the first operand determines whether	1
the first six integer parameters	1
the first PC's had an	1
the first sum, then f	1
the first sub-vector. A long	1
the first dimension may preferably	1
the register size in the	1
the register stack is organized.	1
the register stack are: All	1
the register usage convention says	1
the register keyword. The CodeGear	1
the optimization of performance has	1
the optimization unless the function	1
the optimization features of Intel	1
the optimization capabilities for 32-bit	1
the optimization effort on that	1
the optimization efforts on the	1
the optimization job. You have	1
the libraries named MKL, VML	1
the code. The third thing	1
the code. // Example 8.26a	1
the code. This is not	1
the code. This can lead	1
the code. It is also	1
the code. See ISO/IEC TR18015	1
the code. For my own	1
the code. Example: // Example	2
the code. Some profilers require	1
the code. Many of these	1
the code. Let's look at	1
the code. Sometimes the compiler	1
the code. C#, managed C++,	1
the code. Inserting your own	1
the time. The expression a	1
the time. This is faster	1
the time. A for-loop or	1
the template function is faster	1
the template function for each	1
the template parameters are always	1
the template parameters are replaced	1
the template parameters are exactly	1
the template parameters differ then	1
the template parameter is always	1
the template function, m is	1
the template parameter. The order	1
the template parameter. If MultiplyBy	1
the registers eax, ecx and	1
the need to store intermediate	1
the need to load more	1
the need to update the	1
the need for the first	1
the pointers and the texts	1
the test and setting the	1
the test program is likely	1
the test program itself and	1
the test loop. The time	1
the new version of the	1
the new version causes problem	1
the new value of i	1
the new function. The stack	1
the new bigger memory block.	1
the new block. Any pointers	1
the new features. Take user	1
the new context. It is	1
the user is far from	1
the user to turn off	1
the user to restart the	1
the user and a waste	1
the user and prevent legitimate	1
the user can see the	1
the user if such a	1
the user will be unable	1
the user has a virus	1
the user has to turn	1
the user but only show	1
the user must install a	1
the user never uses the	1
the user actually has to	1
the user interface is not	1
the user interface and other	1
the user interface than on	1
the user might experience unacceptably	1
the user interface. It is	1
the user interface. Applications that	1
the user expects an immediate	1
the user interface, another thread	1
the even integer is returned.	1
the method of storing data	1
the method that gives the	1
the method used here is	1
the access to individual array	1
the access non-sequential which makes	1
the SSE2 or later instruction	4
the SSE2 instruction set is	9
the SSE2 instruction set if	1
the SSE2 instruction set makes	1
the SSE2 instruction set (or	1
the SSE2 instruction set (requires	1
the SSE2 instruction set, and	1
the SSE2 instruction set, but	1
the SSE2 instruction set, one	1
the SSE2 instruction set: //	1
the SSE2 version of most	1
the SSE2 (or later) instruction	1
the following example, which calculates	1
the following assembly code from	2
the following methods could possibly	1
the following example: // Example	1
the following conditions are met:	1
the following conditions are satisfied:	1
the following way. The first	1
the following way. If the	1
the following way. First you	1
the following explanation if you	1
the following table. Type size,	1
the following disadvantages compared to	1
the following reasons: The function	1
the following reasons: The size	1
the following reasons: Each object	1
the following way: // Example	1
the following way: There are	1
the following way: bool a,	1
the following cases: If part	1
the following alternatives: Make the	1
the following steps to access	1
the following work-around can be	1
the following features: The code	1
the following sections. 3.3 Program	1
the following solutions, depending on	1
the system code is not	1
the system code is critical	1
the system may store the	1
the system database in Windows.	1
the system forbids the user	1
the 32 sets can be	1
the file is closed. The	2
the file to a floppy	1
the file for each line	1
the file has been copied	1
the file until the computer	1
the programming language is implemented.	1
the programming manuals from Intel:	1
the dynamic libraries need to	1
the dynamic libraries (*.dll or	1
the dynamic linker. The delay	1
the part of the library	1
the bits of the integer	1
the bits of an integer	1
the bits for Tuesday, Wednesday	1
the type of an object	1
the type of CPU that	1
the type of object pointed	1
the type of objects they	1
the type of registers used.	1
the type and size as	1
the type that is optimal	1
the type conversion takes zero	1
the type conversion generates no	1
the type T is a	1
the case a = ++b;	1
the case of the simple	1
the case of the Gnu	1
the case of data decomposition,	1
the case of Boolean algebra,	1
the case in loops. Consider	1
the case that the microprocessor	1
the case if alternative implementations	1
the case with programs written	1
the case then the optimal	1
the case we may need	1
the case labels follow a	1
the cases where dynamic linking	1
the cases described in the	1
the short vector method may	1
the & operator forces the	1
the & operator (bitwise and)	1
the & operation will be	1
the & operator; and you	1
the simple function because the	1
the simple function, the compiler	1
the simple function, m is	1
the instructions listed in table	1
the processors that were unknown	1
the processors on a graphics	1
the available vector classes. Including	1
the available instruction set. The	2
the available options for the	1
the constant is a power	1
the constant vector (1,2,3,4), and	1
the constant 8 rather than	1
the constant single precision or	1
the constant 5. But the	1
the constant 3.5 will be	1
the constant subexpression. A constant	1
the constant 2.5, which is	1
the error is not detected	1
the error code may be	1
the error code. If the	1
the error doesn't occur, but	1
the error condition. Replacing two	1
the stack is a waste	1
the stack and are in	1
the stack and reading them	1
the stack in 32-bit mode.	1
the stack in 32-bit systems,	1
the stack for all these	1
the stack can be allocated	1
the stack when CriticalInnerFunction is	1
the stack at address esp+8	1
the stack before the function	1
the stack before it is	1
the stack rather than the	1
the stack always belong to	1
the stack (see above, p.	1
the stack pointer. Likewise, all	1
the stack Variables and objects	1
the stack unwinding information can	1
the stack (three parameters on	1
the Gnu compiler in many	1
the Gnu compiler for Mac	1
the Gnu compiler for Windows,	1
the Gnu compiler on the	1
the Gnu compiler will make	1
the Gnu compiler will convert	1
the Gnu compiler mechanism because	1
the Gnu compiler reduced 15.1b	1
the Gnu compiler manual. This	1
the Gnu manual currently doesn't	1
the Gnu mechanism stores a	1
the Gnu directives work on	1
the Gnu compiler. Not optimized	1
the Gnu C function library	1
the Gnu C library. It	1
the Gnu compiler, the assumption	1
the Gnu utilities in 2010.	1
the function. The function may	1
the function. The assembly listing	1
the function. The automatic dispatching	1
the function. The overhead of	1
the function. This is efficient,	1
the function. This has the	2
the function. This fragmentation of	1
the function. In the simple	1
the function. Copying the table	1
the function. Compile once for	1
the extra function calls because	1
the extra operations outside the	1
the extra work needed for	1
the extra overhead of the	1
the extra bits. The unsigned	1
the assembly output of a	1
the assembly output more readable	1
the assembly output listing to	1
the assembly output (/FAs or	1
the large graphics frameworks, interpreters,	1
the large overhead of managing	1
the while loop is to	1
the while loop in example	1
the while loop because nothing	1
the while loop, the if	1
the arrays are accessed through	1
the arrays are aligned or	1
the arrays are aligned by	1
the arrays are sufficiently large	2
the arrays are properly aligned	1
the arrays are aligned, and	1
the arrays or structures are	1
the arrays as required, but	1
the arrays very big to	1
the work it has done	1
the work into multiple threads.	2
the work load is high	1
the work load is low	1
the work load. The clock	1
the work evenly between the	1
the Windows operating system, this	1
the Windows system. Note that	1
the Windows Template Library (WTL).	1
the calls to the copy	1
the calls to CriticalFunction. If	1
the calculations of loop iterations	1
the calculations in a safe	1
the calculations are available at	1
the calculations on the first	1
the calculations so that the	1
the calculations inside the loop.	1
the execution of everything else.	2
the execution to the point	1
the execution time when code	1
the execution time because the	1
the execution speed in any	1
the execution units rather than	1
the execution considerably. Another serious	1
the result is that x	1
the result is known to	1
the result is valid. Re-interpreting	1
the result of the expression	1
the result of the preceding	4
the result of the previous	1
the result of full optimization.	1
the result in a vector	1
the result in a different	1
the result in x. The	1
the result can be calculated	1
the result will be 2.	1
the result vector in eight	4
the result 100 rather than	1
the result back to single	1
the result -56 rather than	1
the processor is not an	1
the processor is an Intel	1
the processor is compatible with	1
the processor and the operating	1
the processor and the type	1
the processor can do while	1
the processor has hyperthreading. If	1
the compiled code may run	1
the compiled code big and	1
the compiled code. In general,	1
the compiled versions #include "instrset_detect.cpp"	1
the big registration database in	1
the threads are competing for	1
the threads use different memory	1
the threads will invalidate each	1
the threads write to the	1
the threads share the same	1
the best and most up-to-date	1
the best compiler and call	1
the best possible instruction set	1
the best possible branch if	1
the best possible version. See	1
the best way to avoid	1
the best way to prevent	1
the best way to identify	1
the best optimization it may	1
the best optimized function libraries	1
the best optimized math function	1
the best optimizing compilers available,	1
the best implementation for a	1
the best cases. It is	1
the best algorithm than by	1
the best Java implementations. However,	1
the best job optimizing a	1
the best optimizer. Borland/CodeGear/Embarcadero C++	1
the best algorithm. The choice	1
the necessary functions for distinguishing	1
the necessary instruction set. It	1
the necessary library files are	1
the necessary calculations of (2n	1
the necessary information about Func1	1
the necessary cleanup jobs to	1
the necessary initialization. The compiler	1
the speed of a program	1
the speed of functions with	1
the speed of each version	1
the speed of RAM memory.	1
the speed of addition, subtraction,	1
the speed or not. There	1
the speed by using short	1
the speed will be improved	1
the speed here is likely	1
the specific instruction set. 13.6	1
the specific purpose in order	1
the specific event it is	1
the specific literature for more	1
the virtual function is called	1
the virtual function is needed.	1
the virtual function dispatch mechanism	1
the virtual table lookup for	1
the virtual function. If the	1
the virtual functions. This so-called	1
the virtual table. Unfortunately, few	1
the virtual 53 function at	1
the common language runtime of	1
the common entry point extern	1
the thread to a specific	1
the thread in which they	1
the thread function so that	1
the thread have a destructor	1
the thread priority before the	1
the exception handling is negligible	1
the exception handling option in	1
the exception handler to call	1
the exception handler in the	1
the exception handler needs all	1
the exception handler, even if	1
the allocated memory into a	1
the allocated array into a	1
the allocated object, and ownership	1
the overflow and underflow neutralize	1
the overflow condition inside the	1
the overflow behavior well-defined with	1
the integers from 0 to	1
the option for "assume no	1
the option for "function level	1
the option that gives the	1
the option -fpic according to	1
the option -fno-pic and link	1
the option -fpie instead of	1
the option -mveclibabi=acml. Agner's vector	1
the option -ftrapv, but this	1
the option /QaxAVX or -axAVX.	1
the option -read_only_relocs suppress. GOT	1
the option -mveclibabi=svml. This library	1
the power of 10 double	2
the power of N template	1
the power function when the	1
the matrix is a multiple	1
the matrix is bigger than	1
the matrix when the size	1
the matrix into smaller squares	1
the matrix line size. I	1
the matrix longer than needed	1
the matrix 512 520 and	1
the matrix element. The multiplication	1
the AVX and later instruction	1
the AVX or later instruction	1
the AVX instruction set is	3
the AVX instruction set can	1
the AVX instruction set. The	1
the AVX instruction set, another	1
the AVX 32 instruction set	1
the AVX instructions. The automatic	1
the AVX instructions. A further	1
the AVX part. If a	2
the line that covered the	1
the line number information. It	1
the line containing the address	1
the optimized code will load	1
the optimized code (release version)	1
the optimized version of the	1
the optimized version because the	1
the manual for your compiler	1
the manual for my test	1
the calculated value. The keyword	1
the calculated result. Example: //	1
the calculation of the array	1
the calculation of the address	1
the calculation of the power	1
the calculation of the residual	1
the calculation of the factorials,	1
the calculation of A is	2
the calculation of A and	1
the calculation of one iteration	2
the calculation of B before	1
the calculation of self-relative references	1
the calculation of B. In	1
the calculation of (a+b). This	1
the calculation in a way	2
the calculation time is actually	1
the calculation time is doubled.	1
the uses of a and	1
the four cache lines in	1
the four cache lines from	1
the four results in a.	1
the four B value in	1
the four G values in	1
the four R value in	1
the four sums } This	1
the parameters of the new	1
the parameters are transferred in	1
the parameters on the stack	1
the parameters would be transferred	1
the check for CPU brand	1
the check after the loop	1
the problem is to make	1
the problem is likely to	1
the problem is too important	1
the problem and make the	1
the problem and assume that	1
the problem that the clock	1
the problem by increasing the	1
the problem cannot easily be	1
the solution is to make	1
the solution is more complicated.	1
the solution to these problems	1
the container is to hold	1
the container be recycled? There	1
the container may move the	1
the container rather than by	1
the container expandable, but it	1
the advantage of bigger vector	1
the advantage that the response	1
the advantage that it does	1
the supported instruction set. Aligning	1
the operators new and delete	1
the few cases where it	1
the list is large because	1
the list does not need	1
the list every time the	1
the list causes all subsequent	1
the likely case that the	1
the structure to make sure	1
the structure in example 9.1b.	1
the structure or class is	1
the structure 8 bytes smaller	1
the structure }; 52 or	1
the structure y into a	1
the inline keyword is used	1
the standard libraries are not	1
the standard template library (STL)	1
the standard stack frame makes	1
the standard calling conventions. Optimizes	1
the standard header file stdint.h	1
the standard PC processors is	1
the standard PC processors are	1
the standard PC processors with	1
the standard PC platform with	1
the hardware is updated. Most	1
the hardware can be wired	1
the hardware implementation in most	2
the hardware platform and operating	1
the hardware definition code in	1
the values of a and	2
the values of all variables.	1
the values of its arguments.	1
the values of A, B	1
the values in the code	1
the values in a pre-calculated	1
the values because a typo	1
the sign of a floating	1
the sign of a double:	1
the sign bit of x	1
the sign bit of i	2
the sign bit of f	1
the sign bit to compare	1
the sign bit to zero:	1
the sign bit in the	1
the sign bit are zero.	1
the sign bit so that	1
the sign bit: // Example	2
the sign bit. The fact	1
the sign bit. We can	1
the sign bit, the exponent,	1
the copy of the table	1
the copy constructor and the	1
the memory. The static memory	1
the memory. This makes data	1
the memory. It is therefore	1
the well optimized Intel function	1
the information is utilized appropriately.	1
the information in the database	1
the addresses of library functions	1
the addresses of array elements	1
the addresses of array elements.	1
the addresses of dynamically linked	1
the addresses are accessed in	1
the addresses are spaced a	1
the shared object without -fpic	1
the shared variable inside the	1
the shared resources are limiting	1
the shared object. This so-called	1
the shared object. Likewise, when	1
the shared object, then the	1
the program. The use of	1
the program. The CPU dispatcher	1
the program. The advantage of	1
the program. The map file	1
the program. This makes data	1
the program. This requires no	1
the program. In some programs,	1
the program. 3 Finding the	1
the program. Reading or writing	1
the program. 16.2 The pitfalls	1
the program. Small functions are	1
the program. Application programmers rarely	1
the intermediate code by emulating	1
the intermediate code. This framework	1
the intermediate result of each	1
the intermediate result (b+c) can	1
the intermediate expression b *	1
the allocation process because the	1
the write causes an entire	1
the above code in details.	1
the above example with floating	1
the above example with u.i[1]	1
the above example may fail	1
the above example, the compiler	1
the above example, the size	1
the above example, the template	1
the above example, then all	1
the above template class is	1
the above methods if the	1
the above examples will therefore	1
the above advantages of each	1
the above sections are dominating	1
the above table. If the	1
the above security advices in	1
the programs they are running.	1
the problems of the original,	1
the problems and planned solutions.	1
the problems that the clock	1
the problems mentioned above. Now	1
the problems associated with profiling,	1
the optimal code for this	1
the optimal version of the	1
the optimal branch can be	1
the optimal solution is a	1
the optimal platform ........................................................................................... 5	1
the optimal platform 2.1 Choice	1
the optimal choice for future	1
the optimal algorithm The first	1
the optimal algorithm before you	1
the optimal algorithm ....................................................................................... 24	1
the optimal order. Some compilers	1
the optimal decomposition of the	1
the space explicitly when alloca	1
the dispatching only for speed-critical	1
the dispatching should be based	1
the particular application. The integer	1
the microprocessor is doing an	1
the microprocessor is able to	1
the microprocessor and the operating	1
the microprocessor can predict the	1
the microprocessor can execute the	1
the microprocessor can begin the	1
the microprocessor it is running	1
the microprocessor has the SSE	1
the microprocessor has hardware support	1
the microprocessor has made the	1
the microprocessor has hyperthreading, then	1
the microprocessor doesn't know in	1
the microprocessor hardware for raising	1
the microprocessor jump to a	1
the microprocessor handles this code.	1
the microprocessor wastes several clock	1
the next time the function	1
the next new model comes	1
the next function. However, the	1
the next processor model will	1
the next model work better.	1
the next higher instruction set	1
the next instance of S1	1
the next generation of processors	1
the next generation of computers	1
the next block. A linked	1
the next element. I have	1
the next vector, and the	1
the next step in the	1
the next step. With a	1
the next calculation. However, the	1
the next paragraph. The target	1
the next section. 12.5 Using	1
the branches are poorly predictable.	1
the Mac platform, but also	1
the multiplication is done with	1
the multiplication is exact. Multiple	1
the multiplication of xxn rather	1
the multiplication can be replaced	1
the multiplication by changing this	1
the multiplication would take longer	1
the multiplication b[i]*c[i], though this	1
the application can make use	1
the application has a graphical	1
the application software is implemented	1
the application code. An interrupt	1
the application uses most of	1
the application program. The number	1
the application program. All in	1
the application program. Add to	1
the application programmer gets the	1
the application software. Such an	1
the application itself and take	1
the application programmer. There is	1
the caching conditions are optimal.	1
the expression is used, then	1
the expression a = (b*c)/d,	1
the expression a = b++;	1
the expression that is AND'ed	1
the expression contains a function	1
the expression y = a	1
the expression list[i] is invalid	1
the expression -(-a) to a.	1
the complicated address calculation and	1
the dependency chain in two:	1
the members of both parent	1
the members individually. Example: //	1
the Boolean operators because they	1
the Boolean operators && and	1
the Boolean operators &&, ||,	1
the Boolean operators (&& and	1
the Boolean operands because you	1
the cache. The cache works	1
the cache. The operating system	1
the cache. The problem only	1
the cache. When we reach	1
the intrinsic function _mm256_zeroupper() before	1
the intrinsic hardware functions. The	1
the methods in the above	1
the methods described on page	1
the development of a program.	1
the development process can influence	1
the mathematical notion of a	1
the block size grows by	1
the name of Func with	1
the name in the object	1
the name cannot be overloaded	1
the name _alloca) for (int	1
the systems. There is no	1
the needs of position- independent	1
the conversion is costly if	1
the conversion is valid. For	1
the conversion to signed integer	1
the conversion takes 50 -	1
the various optimization methods and	1
the disadvantage of a very	1
the disadvantage that the function	2
the disadvantage that the branching	1
the high processing power of	1
the high level framework still	1
the high level framework. The	1
the high complexity of modern	1
the zero flag and don't	1
the Microsoft directives work on	1
the Microsoft platform software development	1
the Microsoft compiler. Supports only	1
the Microsoft Visual Studio IDE.	1
the parameter is copied to	1
the parameter has a composite	1
the division faster. Of course,	1
the source is an arithmetic	1
the source code more complex,	1
the source code. It is	1
the source code, as the	1
the source files. 13.2 Model-specific	1
the source annotation option if	1
the cost of this solution	1
the cost of exception handling	1
the cost of longer response	1
the cost of keeping a	1
the cost of fine-tuning, testing,	1
the cost of verifying, debugging	1
the resources of the core	1
the induction variable can be	1
the induction variable as loop	1
the induction variable method unfavorable,	1
the reason why it is	1
the reason why all modern	1
the reason why there is	1
the reason why exception handling	1
the dispatcher function is usually	1
the dispatcher function and replaces	1
the dispatcher function. This will	1
the dispatcher function. When the	1
the dispatcher function. typeof(CriticalFunction) *	1
the dispatcher 128 function cannot	1
the dispatcher signal an error	1
the string is already known	1
the programmer to be aware	1
the programmer to make and	1
the programmer to make sure	5
the programmer to make explicit	1
the programmer to know what	1
the programmer to know about.	1
the programmer in a bad	1
the programmer that pointers to	1
the programmer can do to	1
the programmer has defined a	1
the programmer choosing the most	1
the programmer forgets that the	1
the programmer can. It is	1
the programmer hasn't thought about	1
the three functions. Sum1 has	1
the keyword static to the	2
the keyword __restrict or __restrict__,	1
the keyword volatile is that	1
the keyword far (arrays can	1
the keyword __thread or __declspec(thread).	1
the end of the array	1
the end of the array,	1
the end of a function	1
the end of an array	1
the end of this section	1
the end in order to	1
the end when all threads	1
the end user is likely	1
the end user will have	1
the end user who has	1
the end user gets the	1
the end user. The advantages	1
the end user. There may	1
the end user. Dynamic linking	1
the end user. Installation problems.	1
the end user. Menus, buttons,	1
the && expression to generate	1
the | operator which otherwise	1
the | operator; you can	1
the examples in the appendix	1
the examples have been tested	1
the examples I have tested.	1
the difference is simply a	1
the difference between the two	1
the difference between the Boolean	1
the difference between a function	1
the difference between two pointers	1
the difference between rounding and	1
the difference between commas and	1
the data. The effect is	1
the data. This is the	1
the data. A complete redesign	1
the data. Use OpenMP directives.	1
the runtime address calculations have	1
the runtime framework may use	1
the runtime polymorphism that is	1
the runtime polymorphism: // Example	1
the last cache level, and	1
the last 8 columns unused.	1
the last element outside the	1
the last index changes fastest:	1
the last index changing in	1
the last vector. Organize the	1
the last member. This pointer	1
the parts of the code	2
the optimizations that we want	1
the graphics processing unit for	1
the framework and compile the	1
the framework itself, during installation	1
the numbers in b[i] and	1
the numbers in question without	1
the numbers are powers of	1
the dispatch on first call	1
the dispatch on every call	1
the dispatch branch of the	1
the dispatch branches are scattered	1
the dispatch mechanism even when	1
the dispatch decision at different	1
the calling function can use	1
the calling program is more	1
the XMM registers for floating	1
the XMM registers are used.	2
the XMM registers are used,	1
the XMM registers (see page	1
the second result is stored	1
the second operand is not	2
the second operand is evaluated	1
the second operand is valid.	1
the second generation of processors	1
the second step where the	1
the second step. The intermediate	1
the second sum, then the	1
the second operand. Likewise, if	1
the second sub-vector before it	1
the higher bits. There is	1
the vectors of 64 bits	1
the vectors into C++ classes	1
the AVX2 instruction set gives	1
the piece of code to	1
the piece of code you	1
the x86 instruction set is	1
the x86 instruction set where	1
the x86 CPUs. However, a	1
the x86 family of microprocessors	1
the x86 family can run	1
the x86 family have two	1
the binary value of i	1
the binary decimals of the	1
the binary digits. The exponent	1
the advantages of object oriented	1
the advantages of C++ but	1
the advantages and drawbacks of	1
the advantages over the disadvantages	1
the results of the two	1
the results are combined by	1
the storage order is opposite).	1
the storage methods mentioned above.	1
the old memory block into	1
the old operating systems DOS	1
the old block then become	1
the old Pentium 4, while	1
the old Pentium 4. The	1
the old version. Updating mechanisms	1
the old fashioned C style	2
the options for fast math	1
the options -S or /Fa	1
the feature that there is	1
the feature information, such as	1
the link pointers and for	1
the appropriate function version CriticalFunctionType	1
the appropriate instruction set specified.	1
the appropriate version of the	4
the appropriate version (May use	2
the appropriate type of vector,	1
the appropriate header file for	1
the appropriate header file will	1
the constructor itself. Constructors are	1
the function, and it prevents	1
the function, but it has	1
the operands and add b	1
the operands are integer expressions	1
the operands are variables than	1
the operands are comparisons, etc.	1
the operands if the evaluation	1
the operands have other values	1
the operands have no other	1
the operands has side effects	1
the operands because the expression	1
the innermost loop is predicted	1
the innermost loop and without	1
the innermost loop that includes	1
the innermost loop by storing	1
the innermost loop A function	1
the innermost loop doing mathematical	1
the innermost loop bigger than	1
the innermost function, then the	1
the innermost loop. This is	1
the innermost loop. This reflects	1
the innermost loop. Another possibility	1
the compiler. The compilers are	1
the compiler. You can disable	1
the compiler. Some compilers have	1
the compiler. We can never	1
the compiler. Loop invariant code	1
the compiler. On the other	1
the compiler. Remember, therefore, always	1
the advanced version on all	1
the advanced version on, then	1
the advanced programming constructs are	1
the advanced principles of software	1
the range of code in	1
the range of an integer	1
the start of the function.	1
the start so that the	1
the modules of a big	1
the modules are linked together.	1
the modules appear in the	1
the smaller the data elements	1
the smaller the integer size	1
the core with another thread	1
the core clock cycle counter	1
the relevant optimization options and	1
the relevant books and manuals.	1
the negative effects of object	1
the reductions that the compilers	1
the reductions manually. I have	1
the example: // Example 7.9a	1
the contentions and the time	1
the main memory and therefore	1
the main memory in a	1
the main program. See page	1
the main executable to a	1
the main executable has the	1
the main executable because it	1
the main reasons why object	1
the main feedback comes from	1
the positive or the negative	1
the loop. The following example	1
the loop. The loop-branch is	1
the loop. It is not	1
the loop. Example 12.4b executes	1
the loop. Example 8.21 is	1
the loop. If each floating	1
the loop. In general, you	1
the loop. Some implementations use	1
the loop. Most compilers have	1
the computer is restarted anyway.	1
the computer is reset or	1
the computer is rebooted. To	1
the computer for security reasons	1
the computer has only one	1
the computer while he or	1
the computer during the update	1
the computer starts up, even	1
the overhead of the operating	1
the overhead of parameter transfer	1
the overhead of transferring the	1
the overhead of switching to	1
the pointer. These conversions do	1
the C style string functions	1
the global offset table (GOT).	1
the conversions and make the	1
the conversions by using different	1
the conversions out of the	1
the statement was executed. If	1
the relative efficiency of different	1
the installation process to take	1
the installation process can proceed	1
the installation process or by	1
the syntax is so kludgy	1
the syntax is very old-fashioned.	1
the syntax is fully standardized	1
the syntax described in the	1
the cases. The equivalent expression	1
the choice of user interface	1
the choice of programming language	2
the choice of hardware platform	1
the choice between optimizing for	1
the STL is not satisfactory.	1
the STL is designed for	1
the STL are universal, flexible,	1
the STL has been criticized	1
the STL also costs in	1
the STL containers is 95	1
the STL (Standard Template Library)	1
the profiler may sample more	1
the profiler itself. Function addresses	1
the index is out of	1
the index by 8. 71	1
the inlining causes technical problems	1
the size. However, it is	1
the size. Integers of smaller	1
the network is overloaded or	1
the network is unstable or	1
the network or database is	1
the slow GOT lookup process	1
the desired function version //	1
the desired program structure. It	1
the desired instruction set (/arch:SSE2,	1
the desired instruction set. If	1
the desired version of the	1
the desired version in a	1
the desired function. The PLT	1
the desired version. Note that	1
the desired polymorphism effect with	1
the desired functionality without polymorphism	1
the desired measurement instruments into	1
the desired interval is a	1
the #pragma vector always to	1
the #pragma vector nontemporal is	1
the whole program by turning	1
the whole program execution, even	1
the whole loop will take	1
the whole software project together	1
the whole software package, including	1
the whole structure of the	1
the whole program. During the	1
the inefficient virtual function dispatch	1
the level-2 cache is 512	1
the level-2 cache and the	1
the level-2 cache are so	1
the level-2 cache as when	1
the level-2 cache from loading	1
the level-2 cache because the	1
the level-2 cache cannot prefetch	1
the level-2 cache. The level-2	1
the level-2 cache. This has	1
the level-2 cache. Using the	1
the response time is so	1
the response time is consistent	1
the response time to user	1
the response time to e.g.	1
the response time under worst-case	1
the response times for network	1
the hot spots and measuring	1
the hot spots have been	1
the hot spot and make	1
the hot spot. Sometimes, the	1
the code, then you may	1
the code, which supposedly is	1
the code, cache misses and	1
the code, so you will	1
the code, including user interface	1
the instance in main will	1
the fact that n is	1
the position-independent code flag in	1
the position-independent code. These workaround	1
the out-of-order execution mechanism can	1
the out-of-order execution mechanism works	1
the out-of-order mechanism allows the	1
the out-of-order capabilities of modern	1
the output of the first	1
the output are unacceptable. Each	1
the level-1 and the level-2	1
the level-1 data cache is	1
the level-1 data cache and	1
the level-1 data cache, where	1
the level-1 cache are less	1
the level-1 cache may not	1
the level-1 cache from the	1
the level-1 cache size. This	1
the level-1 cache. The different	1
the level-1 cache. We can	1
the resources. In this case	1
the task in question. For	1
the local object is overwritten,	1
the local object static then	1
the local name for local	1
the costs of software development,	1
the costs of dynamic memory	1
the costs of position-independent code.	1
the costs to other parts	1
the costs in terms of	1
the costs if it is	1
the inlined function and the	1
the inlined function for the	1
the inlined function. Function inlining	1
the class. Data members of	1
the class. Calling a member	1
the class. Storing variables in	1
the class. Which solution you	1
the database anyway if you	1
the constants are defined with	1
the constants Sunday, Monday, etc.	1
the frame function or by	1
the frame function into a	1
the special feature that the	1
the destructor is called when	1
the destructor of x. This	1
the destructor to call or	1
the destructor for the object	1
the destructor by constructing the	1
the destructor causes another exception.	1
the preceding one is called	1
the preceding one (see page	1
the preceding value of sum.	1
the preceding example, this is	1
the preceding addition is finished.	1
the preceding addition then you	1
the preceding iteration is finished.	1
the preceding label plus one,	1
the preceding one. This prevents	1
the preceding one. You can	1
the preceding paragraph and manual	1
the preceding row. The same	1
the safe formula a[i] =	1
the Pentium 4 processor. Extra	1
the efficiency of the data	1
the efficiency of 32-bit integers	1
the repeat count is not	1
the repeat count is large	1
the repeat count is small	1
the repeat count is odd	1
the repeat count has been	1
the unroll factor. If not,	1
the unroll factor. For example,	1
the unroll factor. Loop unrolling	1
the algorithm in question. You	1
the algorithm in question: Put	1
the sum of 100 numbers:	1
the strings including the terminating	2
the exponent is a positive	1
the exponent is an integer	1
the exponent is biased allows	1
the exponent if there is	1
the possibility of using the	1
the possibility of compiling multiple	1
the possibility of algebraic reduction.	1
the possibility for other optimizations,	1
the possibility for further optimizations.	1
the possibility for significant improvements.	1
the possibility that the function	1
the possibility that the variable	1
the possibility that a particular	1
the discussion of container classes	1
the maximum loop count that	1
the maximum possible memory requirement.	1
the maximum repeat count and	1
the maximum value. There is	1
the alignment is not visible	1
the alignment explicitly by writing:	1
the alignment requirements are less	1
the right in order to	1
the right function for a	1
the right data into the	1
the right vector elements. 12.1	1
the right version of the	3
the right prediction. The time	1
the right format and getting	1
the right formula in each	1
the right positions in the	1
the offset of the member	1
the offset of the child	1
the offset of a data	1
the offset can be expressed	1
the offset as a 32-bit	1
the offset has to be	1
the offset relative to the	1
the compatibility with older microprocessors	1
the macro is referencing it	1
the object. The allocation of	1
the object. If the object	1
the object. Make the function	1
the object. 7.17 Structures and	1
the library. The application program	1
the library. This method is	1
the library. Add to this	1
the calculations. The time it	1
the calculations. The program can	1
the operand that is most	1
the operand that is calculated	1
the final program and whether	1
the final size cannot be	1
the final size needed before	1
the final array size right	1
the final version of the	1
the final value of the	1
the final result to see	1
the final result will be	1
the final program. This requires,	1
the final application depends on	1
the final program, it is	1
the final product. It is	1
the sake of the possibility	1
the sake of compatibility with	2
the sake of optimization. 14	1
the sake of parallel execution.	1
the sake of fastest possible	1
the sake of portability to	1
the sake of backwards compatibility	1
the sake of efficiency. Using	1
the sake of security. b	1
the sake of cross-platform portability.	1
the sake of modularity. For	1
the sake of security, but	1
the tasks into multiple threads.	1
the effect of nontemporal write	1
the amount of memory used.	1
the amount of memory needed	1
the amount of memory required	1
the amount of cache space	1
the amount of necessary communication	1
the amount of RAM memory	1
the variable. This can be	1
the variable. For example, a	1
the time, but expensive if	1
the copying process, and the	1
the performance. 14.4 Integer multiplication	1
the processing power. Connecting several	1
the so-called time stamp counter.	1
the so-called intrinsic functions. This	1
the so-called Java virtual machine.	1
the so-called position- independent code.	1
the so-called partial flags stall	1
the so-called commpage. These functions	1
the so-called CPU-dispatcher that checks	1
the total number of objects	1
the total number of elements	2
the total time. Optimizing less	1
the total execution time because	1
the total execution time. Loop	1
the total calculation time. A	1
the total amount of code	1
the total computation time. 4	1
the child class name and	1
the child class members. The	1
the priority back to normal	1
the disk cache. Files on	1
the iteration is repeated until	1
the counters when you are	1
the stack. The memory space	1
the stack. This can improve	1
the stack. This makes function	1
the stack. This behaviour is	1
the stack. A static member	1
the stack. Each thread has	1
the stack. Is the size	1
the stack. Deallocation has no	1
the stack. String constants and	1
the full advantage of a	1
the full information about the	1
the full 128-bit execution units	1
the full declaration of c1	1
the full generality and flexibility	1
the thread. The cost of	1
the RAM size is insufficient.	1
the rows in the matrix	1
the rows are accessed in	1
the rows are accessed consecutively	1
the rows are indexed in	1
the least significant bit of	1
the least significant n bits	1
the least recently 4 ?Func2@@YAXQAHAAH@Z	1
the algebraic reductions explicitly in	1
the logical register that appears	1
the logical structure and clarity	1
the logical architecture of the	1
the bitwise operators are calculated	1
the bitwise operators (& and	1
the bitwise OR operator, which	1
the handle is invalid. Boolean	1
the heap is reserved for	1
the heap to be filled	1
the heap has become fragmented.	1
the heap space to become	1
the heap space has become	1
the heap manager for each	1
the target if the changes	1
the target address is likely	1
the target address can be	1
the target pointed to is	1
the entire program in multiple	1
the entire program will be	1
the entire floating point library.	1
the entire library (or at	1
the entire 64 or 0x40	1
the entire file in a	1
the entire list from static	1
the entire level-1 cache is	1
the entire object. Any copy	1
the entire contents copied to	1
the executable to be as	1
the executable file and all	1
the executable file and one	1
the executable file needs to	1
the executable file. Only the	1
the subexpression c+b can be	1
the nontemporal write instruction prevents	1
the nontemporal write instructions are	1
the bounds of valid addresses,	1
the SSE and SSE2 instruction	1
the SSE and later instruction	1
the SSE or SSE2 instruction	1
the SSE or higher instruction	1
the updates if the current	1
the loading of several drivers,	1
the loading of modules or	1
the reading of the counters	1
the reading of x must	1
the directly compiled version is	1
the simplest possible implementation if	1
the simplest code. If the	1
the simplest cases, but its	1
the simplest cases, composite objects	1
the simplest expressions and operators.	1
the simplest cases. See manual	1
the simplest method, but it	1
the situation where the logic	1
the situation where a long	1
the situation where a task	1
the message loop of a	1
the condition is known from	1
the condition can be reduced	1
the condition clause. Comparing an	1
the resource use on such	1
the PathScale and Intel compilers	1
the previous value as xn	1
the previous value as n!	1
the previous value than from	1
the previous link pointer has	1
the previous iteration (except for	1
the previous chapter (page 146).	1
the previous value. It does	1
the previous value. Example: //	1
the previous one. It may	1
the previous iteration. This allows	1
the vector. The other STL	1
the vector. This is a	1
the program, and the runtime	1
the program, and one for	1
the program, and while the	1
the program, for example when	1
the program, it is likely	1
the program, one for initialized	1
the loops if the loop	1
the SSE4.1 instruction set is	2
the chapter "Register usage in	1
the risk of memory leaks	1
the risk of losing precision.	1
the risk of activating the	1
the header file timingtest.h from	1
the header file mathimf.h that	1
the header files are as	1
the future we may also	1
the future due to general	1
the fraction is stored as	1
the fraction bits: // Example	1
the sequence of calculations without	1
the sequence of calculations forms	1
the sequence to be moved.	1
the sequence in a temporary	1
the compiler, and the library	1
the compiler, you will notice	1
the CPU. It can be	1
the CPU. If the vector	1
the CPU. Algebraic reductions Most	1
the CPU. Unrolling a loop	1
the length of the string	1
the length of the desired	1
the length of a clock	1
the length of a row	1
the length of a string.	1
the length of each string	1
the module with, e.g. the	1
the beginning of the object	1
the beginning of the new	1
the beginning of the structure	2
the beginning of the program.	1
the beginning of the array.	1
the beginning of the object,	1
the beginning of a cache	1
the beginning of list plus	1
the beginning rather than allocating	1
the alternative version. The penalty	1
the current instruction set. Do	1
the current array element. Rather	1
the current version satisfies the	1
the current .cpp file) should	1
the current position. Windows DLLs	1
the 'this' pointer. You may	1
the problem. This new insight	1
the row length is not	1
the declaration class CChild1 :	1
the declaration "static" or "__attribute__((visibility	1
the series of statements that	1
the features of Java and	1
the user. Time is a	1
the user. Making exception-safe code	1
the user. With the high	1
the user. Compatibility problems. All	1
the user. Feature bloat. It	1
the chosen compiler doesn't provide	1
the chosen version return (*CriticalFunction)(parm1,	1
the chosen expression. Example 12.4b	1
the device itself is a	1
the subsequent times because of	1
the subsequent instructions. The 512	1
the subsequent counts represent the	1
the subsequent manuals. Please note	1
the subsequent counts. This is	1
the low priority of program	1
the latter is executed even	1
the latter function also has	1
the latter has one operator	1
the latter case the reading	1
the latter function, but it	1
the latter case, the calculation	1
the latter case, you may	1
the default integer size in	1
the default size when doing	1
the time-consuming data processing. Running	1
the diagonal is swapped with	1
the diagonal and swap these	1
the diagonal are accessed column-wise.	1
the diagonal are accessed row-wise,	1
the diagonal have been lost	1
the diagonal there is only	1
the diagonal remain unchanged. The	1
the logic structure of a	1
the logic behind the program	1
the Microsoft, Intel, Gnu and	2
the hard disk if the	1
the hard disk. A few	1
the typical repeat count is	1
the derived class in another	1
the derived class (see page	1
the derived class. This check	1
the derived class: // Example	1
the overflow. Taking the logarithm	1
the fully optimized code because	1
the factorial function looks like	1
the OpenMP directives for parallel	1
the OpenMP directives for multi-core	1
the parent class data members	1
the value. The loop would	1
the memcpy function implicitly when	1
the memcpy function. There are	1
the procedure linkage table (PLT).	1
the parallelism is obvious and	1
the parallelism is obvious. See	1
the prediction turns out to	1
the polymorphic member of its	1
the polymorphic functions. The second	1
the graphical user interface and	1
the lower 8 or 16	1
the lower 16 bits of	1
the label $B1$2:. This is	1
the iterations and start the	1
the misprediction before it is	1
the misprediction penalty is only	1
the background are unnecessary for	1
the background job can be	1
the chain of function calls	1
the PLT and GOT. The	1
the PLT entry with the	1
the heavy graphics calculations. In	1
the heavy background calculations piece	1
the additions are independent then	1
the system. The number of	1
the inputs to the calculations	1
the inputs have any other	1
the interrupt 3 breakpoint and	1
the interrupt 3 breakpoint again.	1
the fastest way to set	1
the fastest way to handle	1
the fastest solution on future	1
the fastest first. However, you	1
the DLL is relocated (rebased)	1
the DLL use absolute references	1
the factors that decide how	1
the factors are generated from	1
the Gnu, Clang and Intel	2
the Gnu, Clang, Intel or	2
the Gnu, Clang, Intel, Microsoft	1
the arrays. It is the	1
the arrays. An array overflow	1
the branch. It may seem	1
the required amount of memory	1
the required amount of space	1
the GOT and PLT lookups	1
the GOT through a self-relative	1
the array. This method requires	1
the array. eax holds the	1
the general case where you	1
the general case, but in	1
the general literature on algorithms	1
the preferred programming language when	1
the preferred language will often	1
the software. You should be	1
the software. Smaller microcontrollers have	1
the interpreted version of Basic	1
the vectors. This data conversion	1
the YMM register state. This	1
the YMM registers. Disadvantages are:	1
the purpose of finding a	1
the -fpic option. Then we	1
the D language. D has	1
the sections below. The stack	1
the carry and zero flags	1
the carry bit is kept	1
the carry bit must be	1
the carry flag or in	1
the carry flag then the	1
the carry flag (e.g. DEC,	1
the debugging options prevent optimization.	1
the table. The 16-byte instructions	1
the table. Optimization method Function	1
the object, and a member	1
the trick that N1 =	1
the disadvantages when deciding whether	1
the disadvantages mentioned above for	1
the update mechanism to advertise	1
the update process. 3.5 Program	1
the body of the called	1
the body of a loop	1
the Java virtual machine are	1
the memory, depending on how	1
the system, the more important	1
the system, as explained below.	1
the absolute value of the	2
the absolute value by setting	1
the machine code is the	1
the CPUID is artificially changed	1
the CPUID instruction doesn't give	1
the CPUID instruction was certain	1
the CPUID instruction directly, or	1
the CPUID information about supported	1
the CPUID was manipulated to	1
the saved variable members of	1
the changes of the function	1
the processor. This is called	1
the processor. Nested loops are	2
the linker to a specific	1
the linker to remove unreferenced	1
the linker and the loader.	1
the linker makes an error	1
the linker extracts the functions	1
the measurements as accurate and	1
the representation of the exponent	1
the factor is a power	1
the factor to multiply j	1
the core. It is often	1
the rules of algebra are	1
the rules of algebra, we	1
the smallest data size that	1
the smallest integer size that	3
the smallest list of data.	1
the smallest members last: //	1
the smallest devices, you don't	1
the responsibility of the operating	1
the responsibility of the exception	1
the responsibility of the programmer	5
the Borland and Digital Mars	1
the Borland compiler with other	1
the Borland C++ builder. Not	1
the sense that the template	1
the sense that the syntax	1
the sense that all operators	1
the sense that each calculation	1
the sense that each intrinsic	1
the sense that C++ compilers	1
the latest instruction set and	1
the latest instruction set extensions.	1
the latest compilers from Microsoft,	1
the latest version of the	2
the latest version of Mathcad	1
the reciprocal of the clock	2
the reciprocal in the code,	1
the reciprocal factorials so that	1
the log on process may	1
the thousand results in another	1
the break a few times	1
the break will occur in	1
the Common Language Runtime, CLR,	1
the scope of the function	1
the scope of a variable	1
the scope of this manual.	2
the scope of this manual,	1
the principle for a 2'nd	1
the throughput of the execution	1
the throughput of an execution	1
the throughput of CPU-intensive programs	1
the throughput (see p. 104).	1
the expected real-time speed. Delays	1
the application. The availability of	1
the application. In example 12.3a,	1
the application. You may use	1
the largest vector register size	1
the largest available register size.	1
the largest vector. These units	1
the dispatched function is never	1
the normal return route. This	1
the portability could be achieved	1
the availability of an update,	1
the availability of x for	1
the availability of these instruction	1
the availability of good development	1
the availability of powerful development	1
the .NET framework as well	1
the .NET framework. Obviously, the	1
the newest CPU of a	1
the newest CPU model, which	1
the newest instruction set is	1
the newest instruction set. High	1
the newest processors. Supports all	1
the B values. The choice	1
the debugger is not the	1
the debugger to identify the	1
the debugger then it will	1
the ^ operator. The &	1
the base classes. You may	1
the result. You can assume	1
the compilation is finished. Register	1
the behavior of the first	1
the behavior of static libraries.	1
the behavior of signed integers	1
the 7 program can take	1
the form of a linked	1
the form of a re-	1
the form of templates where	1
the worst possible case and	1
the worst possible performance. We	1
the worst case situation is	1
the worst case situation of	1
the job of the application	1
the job into multiple threads.	1
the job before you. Optimized	1
the job fast enough. For	1
the biggest time consumers ................................................................................	1
the biggest time consumers 3.1	1
the biggest vectors: for (int	1
the biggest time-consumer in the	1
the users with nagging pop-up	1
the structure. Incrementing or decrementing	1
the requirements of the task	1
the requirements of optimizing the	1
the requirements of compatibility with	1
the profiler. The result will	1
the __fastcall keyword is not	1
the increment and decrement operators.	1
the method. A longer loop-	1
the remote data locally. Access	1
the future. If a future	1
the future. 6 The 64-bit	1
the future. Typically, the full	1
the future. To use multiple	1
the swapping of memory to	1
the AVX512 instruction set is	1
the memset line if you	1
the rest of the code.	1
the rest of the program.	1
the rest of the installation	1
the rest of the code,	1
the rest of the present	1
the Digital Mars compiler is	1
the third generation class through	1
the CISC instruction set is	1
the effort to make a	1
the effort to make special	1
the reduction in this case.	1
the reduction would cause overflow	1
the strict aliasing rule of	2
the event of an exception.	1
the event that it becomes	1
the event that it attempts	1
the select function, and the	1
the actual clock frequency that	1
the actual load address. Relocation	1
the actual calculations. This should	1
the actual processor. However, this	1
the console or to an	1
the advice in the rest	1
the advice given here may	1
the advice given above. 7.	1
the pow function when the	1
the recommendation was the opposite:	1
the physical movements of objects	1
the pitfalls here: The inequality	1
the equivalent if(!(a || b))	1
the command line with all	1
the relatively small gain in	1
the guidelines below. You may	1
the excessive memory swapping and	1
the latency of the multiplication	1
the latency of a floating	1
the latency and the throughput	1
the latency or by memory	1
the larger vector size. Later	1
the larger address space of	1
the project at hand. Low-level	1
the project window or makefile.	1
the 107 number of elements	1
the upper 32 bits of	1
the key values are confined	1
the combined size of code	1
the combined size of all	1
the ever bigger software packages	1
the division. Some compilers will	1
the present manual is also	1
the present manual. There are	1
the strlen function in isolation	1
the strlen function for CPUs	1
the divisor is not known	1
the divisor is known at	1
the bit-mask: c2 = _mm_and_si128(c2,	1
the highest instruction set in	1
the highest level of optimization	1
the eight-element vectors: for (int	4
the obstacles to optimization are.	1
the asmlib function library and	1
the asmlib library at www.agner.org/optimize/asmlib.zip.	1
the modulo operator %. Conversion	1
the loader to a different	1
the loader will have more	1
the loader calls the dispatcher	1
the SVML and LIBM libraries	1
the "Intel Math Kernel Library"	1
the "Intel Performance Primitives" library	1
the drawbacks of the C++	2
the drawbacks of C++. Yet,	1
the commercial compilers. Mixing object	1
the x86-64 instruction set supports	1
the pipeline and later discovers	1
the pipeline then the error	1
the pipeline structure has one	1
the flush-to-zero mode rather than	1
the flush-to-zero mode unless you	1
the dispatcher. // After first	1
the queue of pending instructions	1
the {} brackets in which	1
the appendix at www.agner.org/optimize/cppexamples.zip for	1
the empty throw() specification to	1
the C-style type-casting without adding	1
the C-style type-casting. It is	1
the bottleneck is file access	1
the bottleneck is elsewhere then	1
the directive __declspec(cpu_dispatch(...)). See the	1
the lrint function is given	1
the lrint function: // Example	1
the user's time. The time	1
the user's time. Other programs	1
the user's needs. The search	1
the area of system programming,	1
the consequence of n being	1
the assumption that the variable	1
the assumption that signed integer	1
the double. Another problem with	1
the image base is not	1
the worst-case maximum repeat count	1
the individual bits of its	1
the diagonal. The elements at	1
the diagonal. The first eight	1
the diagonal. The c loop	1
the diagonal. Each element matrix[r][c]	1
the original is destroyed. In	1
the original pointer actually points	1
the original object is not	1
the mirror elements matrix[c][r] above	1
the functionality of an optimized	1
the counts. It is measured	1
the unit-test but has a	1
the unit-test does not give	1
the implicit pointer known in	1
the interval from 0 to	1
the interval 0 <= n	1
the interval [1.0, 2.0) by	1
the 33 result is known	1
the considerations that are particularly	1
the selected instruction set. Make	1
the selected version FuncType *	1
the techniques of multithreading. 7.30	1
the techniques in the present	1
the resolution of the CPU	1
the advices may apply to	1
the 49 first eight floating	1
the wrong branch is fed	1
the wrong branch. Microprocessor designers	1
the compiler-generated code in the	1
the combination of a dedicated	1
the distance between rows in	1
the C/C++ standard specifies truncation	1
the 124 necessary information about	1
the basis for this manual	1
the contents of the old	1
the contents of data cache,	1
the unfortunate consequence that it	1
the parameter, and the destructor,	1
the time- consuming features of	1
the divisions (Division is slow,	1
the dividend is unsigned Examples:	1
the dividend is unsigned. The	1
the dividend to unsigned if	1
the stack, which is very	1
the stack, which makes data	1
the stack, except for the	1
the residual error is lower	1
the residual error and compare	1
the residual error for each	1
the operations: // Example 7.41b	1
the operands. The advantages of	1
the nearest element to x?"	1
the nearest integer. If two	1
the 145 SSE2 instruction set	1
the correct result because the	1
the correct child class name	1
the contrary, the code becomes	1
the contrary, you should by	1
the contrary, each thread may	1
the Internet at regular time	1
the Internet where you can	1
the easiest and the most	1
the track backwards though the	1
the ReadTSC function. 154 //	1
the same. The maximum loop	1
the same. This is called	1
the same. If the template	1
the technical details of instruction	1
the specified instruction set. The	1
the specified types (See Sutter:	1
the history of CPU development,	1
the microprocessor. Integer division is	1
the microprocessor. Multiplication takes 4	1
the micro-op cache. Compilers will	1
the linker. The map file	1
the linker. Both code cache	1
the terminating zero and to	2
the numerically largest element in	2
the AVX-512 instruction set are	1
the market for many years	1
the logarithm of each factor	1
the logarithm would be re-calculated	1
the logarithm again, but it	1
the services only when activated	1
the product makes sure that	1
the $B1$2 label if i	1
the flags register into the	1
the past history of that	1
the object's class or structure.	1
the object's class. Make the	1
the context. The keyword static,	1
the goal of 18 software	1
the screen. There is no	1
the screen. However, such applications	1
the market. But the cost	1
the market. Such a list	1
the dangers of a relatively	1
the external clock. This gives	1
the CPU-specific versions of the	1
the mouse. The .NET framework	1
the mouse. This task must	1
the relocations in the code	1
the early planning stage that	1
the heap. The space is	1
the FDIV bug causes floating	1
the decimal point is 1.	1
the hint about no pointer	1
the loop, for example when	1
the loop: // Example 14.13c	1
the minimum supported instruction set	1
the destination array. But the	1
the CPU, which counts at	1
the answers in the relevant	1
the Standard Template Library (STL)	1
the const_cast operator here is	1
the resulting machine code becomes	1
the programmer. 79 Floating point	1
the unsafe code is limited	1
the movements of objects in	1
the executable. Most compilers offer	1
the lowest of the compiled	1
the parentheses manually. The effect	1
the exponent, and the most	1
the exponent, and fffff is	1
the cross-platform compatibility is not	1
the comments generated by the	1
the conflicting considerations of efficiency,	1
the 61 function calls to	1
the sampling generates too little	1
the theoretical possibility that such	1
the file, especially if the	1
the question when efficiency is	1
the denormals-are-zero mode if SSE2	1
the branching takes time. Dispatch	1
the caller to the called	1
the caller through a hidden	1
the G values, and last	1
the creation of temporary objects	1
the vectorclass manual for details.	1
the delay. But if the	1
the server. These problems should	1
the array, which it has	1
the "override" feature. This includes	1
the "worst case" and "best	1
the "worst case" counts. In	1
the first-in-last-out nature of the	1
the alignment. See www.agner.org/optimize/cppexamples.zip for	1
the template. The powN template	1
the container, then a linear	1
the container. STL deque (doubly	1
the container. Can the container	1
the inverted bit-mask: bc =	1
the inverted mask. The expression	1
the index, i. This index	1
the time-consumers mentioned in the	1
the recursion template<> class powN<true,1>	1
the planning phase in order	1
the R values first, then	1
the fraction. The sign is	1
the fraction. For example, to	1
the ones that are available	1
the ones mentioned in table	1
the trivial programming work automatically.	1
the symbolic link. Use different	1
the ability to define function	1
the ability to override public	1
the bottlenecks can lead to	1
the FMA4 instruction set. This	1
the processor). Integer division by	1
the processor). Optimizing compilers will	1
the corresponding instruction set. If	1
the corresponding bitwise operators &,	1
the generic branch, which is	1
the reader has a good	1
the reader what is happening.	1
the low-level C language as	1
the book "Performance Optimization of	1
the word static is removed	1
the obstacle of possible pointer	1
the IDE on some systems.	1
the factorials don't depend on	1
the subroutine for the critical	1
the time-critical part of the	1
the "best case" counts that	1
the effort. 7.21 Runtime type	1
the effort. Square blocking and	1
the overall performance of a	1
the overall computation time is	1
the factorials, but this is	1
the reinstallation work to take	1
the 512-bit ZMM registers by	1
the disassembly window of a	1
the FAQ for the newsgroup	1
the Xnu project. Some of	1
the rows, not the columns.	1
the LLVM is a new	1
the importance of structured and	1
the Boost collection contains well-tested	1
the tolerance may be so	1
the transformation of example 15.1b	1
the transitions between the two	1
the stack). ecx now contains	1
the worst- case conditions. For	1
the initial value of i	1
the workload between multiple CPU	1
the remaining bits represent a	1
the formula: (set) = (memory	1
the usual object file format.	1
the performance, it is also	1
the profile. It may be	1
the IDE, for debugging facilities,	1
the IEEE standard 754 (1985).	1
the arrays: // Example 12.4a.	1
the capability to reduce various	1
the programmers' time, but also	1
the processor) when the XMM	1
the CPU-type is already known	1
the even-numbered logical processors (0,	1
the __assume_aligned directive to tell	1
the lifetime of your software.	1
the "generate map file" option	1
the evaluation of the operands	1
the bias of the Intel	1
the MKL relies on the	1
the majority of end user's	1
the wheel. The containers in	1
the self-explaining menus of a	1
the resource-hungry applications to perform	1
the weekdays. The maximum number	1
the loader. 2. Position-independent code.	1
the strongest optimization option available.	1
the sizeof operator. The code	1
the GetTickCount or QueryPerformanceCounter functions	1
the original, poorly designed program.	1
the .exe file, is acceptable.	1
the burdensome position-independent code and	1
the scarcity of registers. This	1
the other, then put the	1
the rightmost 1-bit removed. If	1
the insertion of a new	1
the hint, but it can	1
the spell checking. Any task	1
the likelihood that certain parts	1
the preprocessor can do because	1
the Professional and Enterprise editions).	1
the responsi- bility of the	1
the "FDIV bug". The FDIV	1
the reciprocal: // Example 14.14a	1
the post-increment operator i++ are	1
the oldest Pentium CPUs which	1
the grandparent class: class CGrandParent	1
the integer-to-float conversion takes more	1
the BTB can cause branch	1
the label. It uses ebx	1
the framework, during start of	1
the end. The reason for	1
the STL. Some STL templates,	1
the user-written code with automatic	1
the following: 130 Compile for	1
the difference, let's say that	1
the truth depends on whether	1
the ADX instructions for high	1
the producer will try to	1
the iterator in some cases,	1
the standards for the C++	1
the broader perspective of usability.	1
the EXCLUSIVE OR operator (^)	1
the representation, except in the	1
the computational power of the	1
the next. The carry bit	1
the if-branch in example 7.30b.	1
the "Macro loops" chapter in	1
the possibilities for optimization. For	1
the <, <=, > and	1
the non-reduced expression better explains	1
the startup code and main()	1
the exponent: // Example 14.26	1
the conversion. The constructor or	1
the sign, eee is the	1
the GOT, and finally (4)	1
the fundamental laws of algebra.	1
the design of small microcontrollers:	1
the texts they point to	1
the dimensions of the array	1
the best-case conditions. All disturbing	1
the destructor, if any, must	1
the wires that connect them.	1
the _mm_clflush intrinsic function. Provoke	1
the SelectAddMul example (12.4e) with	1
the beginning. ret returns from	1
the former case x can	1
the pipeline. If the wrong	1
the sign-bit if the integer	1
the devirtualization (see page 73)	1
the attention of software programmers	1
the level- 1 cache. This	1
the opposite: Don't put something	1
the for-loop: i++; } }	1
the complication that the same	1
the std::unexpected() function in case	1
the strictness is required. See	1
the application, while dynamic linking	1
the essential task of the	1
the series: ex xn n	1
the pros and cons of	1
the leftmost column to the	1
the DelayFiveSeconds function will wait	1
the occurrence is rare. Testing	1
the exact time consumption as	1
the circumstances around the hot	1
the Pentium-II or later instruction	1
the device. Any language that	1
the single-thread speed. In this	1
the newsgroup comp.lang.asm.x86 for some	1
the C99 standard. An implementation	1
the columns. Every fourth of	1
the Active Template Library (ATL)	1
the resultant code will be	1
the sequence, where r is	1
the kind: "what is the	1
the unit- test because the	1
the granularity is too fine	1
the BIOS setup. on Intel	1
the task-specific part of the	1
is the function we want	1
is the code that is	1
is the code from example	1
is the time it takes	1
is the vector operations mentioned	1
is the same as the	1
is the same as a	1
is the same as for	2
is the same as i	1
is the same as last	1
is the same as reflecting	1
is the only one that	1
is the only way to	1
is the loop condition i	1
is the loop increment i++.	1
is the one that gives	1
is the most efficient memory	1
is the most efficient solution	2
is the most efficient solution.	1
is the number of elements	2
is the variable 85 ;	1
is the first in a	1
is the case if alternative	1
is the case then the	1
is the Windows Template Library	1
is the best way to	1
is the calculation of self-relative	1
is the name of Func	1
is the reason why it	1
is the reason why all	1
is the reason why there	1
is the reason why exception	1
is the binary decimals of	1
is the old fashioned C	1
is the feature information, such	1
is the range of code	1
is the simplest method, but	1
is the situation where a	1
is the D language. D	1
is the responsibility of the	7
is the reciprocal of the	2
is the job of the	1
is the biggest time-consumer in	1
is the combination of a	1
is the nearest element to	1
is the same. This is	1
is the minimum supported instruction	1
is the Standard Template Library	1
is the exponent, and fffff	1
is the "best case" counts	1
is the scarcity of registers.	1
is the responsi- bility of	1
is the sign, eee is	1
is a function that has	1
is a function that calls	1
is a function that doesn't	1
is a function that allocates	1
is a function which transposes	1
is a loop count. The	1
is a cache of 8	1
is a class with a	1
is a class template rather	1
is a double precision constant.	1
is a pointer to a	1
is a pointer or reference	1
is a library function which	1
is a float or double	1
is a multiple of the	5
is a clock cycle? In	1
is a clock cycle? ......................................................................................	1
is a performance penalty when	1
is a very efficient way	1
is a very user friendly	1
is a very useful way	1
is a very good choice	1
is a branch that goes	1
is a way of relieving	1
is a way to check	1
is a register variable. The	1
is a template class which	1
is a new compiler which	1
is a useful way of	1
is a useful source of	1
is a part of memory	1
is a simple integer counter.	1
is a simple pointer or	1
is a simple solution, but	1
is a constant known at	1
is a large cost to	1
is a large overhead cost	1
is a big waste of	1
is a specific advantage to	1
is a single task that	1
is a common way of	1
is a common programming error	1
is a common error that	1
is a common cause of	1
is a common source of	1
is a small piece of	1
is a good way of	1
is a good choice for	3
is a power of 2	12
is a power of 2.	2
is a power of 2,	1
is a power of two.	1
is a problem with vector	1
is a problem when mixing	1
is a problem then it	1
is a few clock cycles	1
is a list of some	1
is a list of short	1
is a structure where data	1
is a standard for specifying	1
is a copy constructor specifying	1
is a counter that measures	1
is a counter inside the	1
is a lot to gain	2
is a complicated process which	1
is a dependency chain where	1
is a model that was	1
is a disadvantage when the	1
is a high power of	2
is a reference or a	1
is a higher risk that	1
is a switch between different	1
is a positive integer constant.	1
is a positive integer: //	1
is a hot spot that	1
is a level-1 data cache	1
is a limited resource. The	1
is a sum of a	1
is a total waste of	1
is a risk that several	1
is a risk factor in	1
is a significant contribution to	1
is a linear function of	2
is a penalty for mixing	1
is a matter of programming	2
is a series of calculations,	1
is a waste of time	1
is a waste of cache	1
is a pure function. Example:	1
is a frequent cause of	1
is a frequent source of	1
is a kind of branch	1
is a try block. There	1
is a branch. If it	1
is a fixed size array	1
is a convenient way of	1
is a portability issue to	1
is a considerable debate about	1
is a compromise between efficiency,	1
is a valid 63 number	1
is a loop-invariant code that	1
is a loop-invariant expression that	1
is a scarce resource. Do	1
is a float, but not	1
is a pointer, but it	1
is a chip that can	1
is a minor error in	1
is a 90% chance that	1
is a proxy for the	1
is a cheap compiler for	1
is a precious resource for	1
is a compelling security reason	1
is a staircase function of	1
is a bottleneck. Organize the	1
is of course a considerable	1
is of course also time	1
is of course inefficient. Variables	1
is of course far from	1
is to have a standard	1
is to use the bit	1
is to use the Gnu,	1
is to use a compiler	1
is to use a new	1
is to use static linking,	1
is to use inline assembly	1
is to use string classes,	1
is to make the function	1
is to make the rows	1
is to make a new	1
is to make a small	1
is to make a negative	1
is to make a destructor.	1
is to make a bit-mask	1
is to make sure the	1
is to set up the	1
is to do it explicitly.	1
is to do multiple things	1
is to return from the	1
is to always use the	1
is to access an object	1
is to avoid long dependency	1
is to compile with the	1
is to compile with -mcmodel=large,	1
is to run the program	1
is to store all strings	1
is to replace arrays by	1
is to put measurement instruments	1
is to choose a software	1
is to turn on this	1
is to find the best	1
is to rely on automatic	1
is to save time for	1
is to divide the work	1
is to divide the matrix	1
is to divide the job	1
is to mix different kinds	1
is to insert the piece	1
is to enable the SSE2	1
is to keep multiple memory	1
is to allocate variable-size arrays	1
is to help the CPU	1
is to hold only one	1
is to remove the const	1
is to declare it locally	1
is to detect if any	1
is to roll out the	1
is to wrap the allocated	1
is to join all source	1
is to resume after exceptions:	1
is to combine the multiple	1
is and interpreted line by	1
is in mathematical iterations such	1
is in fact an integer	1
is in edx, to ebx.	1
is for the sake of	1
is for C++ for several	1
is for advanced programmers and	1
is that the code becomes	1
is that the compiler cannot	1
is that the compiler needs	1
is that the memory space	1
is that the CPU dispatcher	1
is that the cache will	1
is that the value of	1
is that the value pointed	1
is that the variables might	1
is that the software programming	1
is that the order of	1
is that the address of	1
is that the user must	1
is that the compiled code	1
is that the list does	1
is that the microprocessor can	1
is that the microprocessor wastes	1
is that the next instance	1
is that the name cannot	1
is that the overhead of	1
is that the choice of	1
is that the level-2 cache	1
is that the compatibility with	1
is that the linker extracts	1
is that the loader will	1
is that the C/C++ standard	1
is that a positive list	1
is that it is not	2
is that it is difficult	1
is that it is intended	1
is that it can be	1
is that it may cause	1
is that it makes program	1
is that it makes sure	1
is that it does some	1
is that it allows larger	1
is that it adds an	1
is that if the elements	1
is that if you are	1
is that x is treated	1
is that you don't have	1
is that all variables and	1
is that we can help	1
is that access times cannot	1
is that branches can be	1
is that modern processors prefetch	1
is that communication between threads	1
is that CParent::Hello() has multiple	1
is that r+i/2 could be	1
is // erroneously called with	1
is it unusual that a	1
is by a const reference.	1
is on a PC platform.	1
is on mathematical applications with	1
is as efficient as a	3
is as fast as calling	1
is as follows: Instruction set	1
is not the case we	1
is not the best optimizer.	1
is not the optimized version	1
is not a good idea	1
is not a power of	1
is not a manual on	1
is not a problem since	1
is not a safe programming	1
is not a profiler. It	1
is not a textbook on	1
is not in the same	1
is not in the cache.	1
is not in use. The	1
is not an advantage if	1
is not an optimal solution	1
is not an Intel, even	1
is not an issue because	1
is not i but i*12,	1
is not possible to do	1
is not possible to add	1
is not possible to contain	1
is not possible if the	1
is not possible when parts	1
is not less than ARRAYSIZE.	1
is not even compatible with	1
is not always as good	1
is not always possible to	1
is not always able to	1
is not always true. The	1
is not always comparable to	1
is not always optimal, though.	1
is not out of range	1
is not part of a	1
is not accessed by any	2
is not necessary to have	1
is not necessary to unroll	1
is not necessary for your	1
is not necessary when no	1
is not necessary because the	1
is not good to have	1
is not advantageous to use	2
is not advantageous to split	1
is not advantageous then it	1
is not known at compile	5
is not certain to be	1
is not shared between multiple	1
is not quite as versatile.	1
is not recommended to use	1
is not recommended to make	1
is not recommended to modify	1
is not optimal to do	1
is not optimal from a	1
is not optimal because it	2
is not efficient. If the	1
is not needed in 64-bit	2
is not needed for the	1
is not needed if the	2
is not divisible by the	2
is not predicted well. A	1
is not intended for finding	1
is not clear whether r	1
is not needed. Obviously, the	1
is not needed. Even better,	1
is not copied because the	1
is not significant as long	1
is not standardized across platforms.	1
is not included in the	1
is not resolved when the	1
is not allowed to change	1
is not allowed in C++	1
is not evaluated at all	1
is not permissible to assume	1
is not portable to systems	1
is not necessarily done by	1
is not necessarily newer. The	1
is not seen in the	1
is not necessary. A virtual	1
is not doubled. A thread	1
is not optimal. Use 12	1
is not guaranteed to be	1
is not expensive. You may	1
is not cached. See page	1
is not optimized. Jumps between	1
is not separated from the	1
is not unusual for the	2
is not modified. Unlike a	1
is not vacant then the	1
is not supported. The calculation	1
is not visible in the	1
is not allowed. Non-public distribution	1
is not uncommon for software	1
is not uncommon for virus	1
is not recognized in 64-bit	1
is not human readable and	1
is not referenced from any	1
is not evaluated, because the	1
is not detected until 10	1
is not standardized. It is	1
is not traditionally considered a	1
is not satisfactory. The following	1
is not met then it	1
is an integer because the	1
is an integer known at	1
is an Intel before it	1
is an object that behaves	1
is an array index than	1
is an even faster way	1
is an important part of	1
is an important distinction between	1
is an extra cost whenever	1
is an extra iteration that	1
is an extra layer of	1
is an advantage to using	1
is an expression that should	2
is an advanced high-level language	1
is an integer, then you	1
is an integer, so that	1
is an arithmetic expression. The	1
is an n'th degree polynomial	1
is an integer). All intermediate	1
is time consuming because it	1
is more than one call	1
is more efficient to use	2
is more efficient to make	1
is more efficient to store	2
is more efficient to convert	1
is more efficient to define	1
is more efficient to implement	1
is more efficient to determine	1
is more efficient in 64-bit	1
is more efficient than the	1
is more efficient than a	1
is more efficient than if	1
is more efficient than x	2
is more efficient than 64-bit	1
is more efficient than mov	1
is more efficient than post-increment.	1
is more important than optimizing	1
is more common to exchange	1
is more advantageous the smaller	1
is more advantageous if the	1
is more likely to inline	1
is more complicated to make	1
is more complicated in a	1
is more efficient. The SSE2	1
is more efficient. 64-bit Windows	1
is more difficult for the	1
is more relevant to test	1
is more safe to do	1
is more expensive than an	1
is more predictable than the	1
is more compact and efficient	1
is more compact if the	1
is more complex and often	1
is more complex if the	1
is more focus on the	1
is more difficult. The functions	1
is more complicated. If the	1
is more manageable and easier	1
is then stored at address	1
is then de-referenced in order	1
is memory pooling. It is	1
is data decomposition. It is	1
is different for different platforms	1
is because the critical stride	1
is because the register usage	1
is because the file has	1
is because it can cause	1
is because we forgot to	1
is because modern CPUs can	1
is because algebraic manipulations of	1
is because computers have very	1
is only a negligible contribution	1
is only a hint and	1
is only a minimal difference	1
is only an advantage in	1
is only used in a	1
is only one call to	1
is only possible if the	1
is only possible if F1	1
is only called once. The	1
is only calculated the first	1
is only calculated once, rather	1
is only safe if it	1
is only half a square.	1
is only 10% of the	1
is other code that uses	1
is other work that the	1
is all done in a	1
is all 1's when bb[i]	1
is used is branch prediction.	1
is used and this will	1
is used and popped from	1
is used in the Gnu	2
is used in the old	1
is used in the Active	1
is used in a number	1
is used in shared objects	1
is used in almost all	1
is used for the link	1
is used for all static	1
is used for pointer conversions.	1
is used for finding the	1
is used for debugging and	1
is used for Java today.	1
is used for storing function	1
is used for giving the	1
is used for converting a	1
is used for prefetching data	1
is used for jumping out	1
is used for relieving the	1
is used or if its	1
is used by multiple threads	1
is used by exception handlers	1
is used as an array	2
is used more efficiently. It	1
is used when it is	1
is used only for avoiding	1
is used only within the	1
is used inside the pow	1
is used during program development,	1
is one of the best	1
is one of the few	1
is one of the main	1
is one that saves time	1
is one set of counters	1
is no more than the	1
is no loop if the	1
is no such advantage in	1
is no performance cost to	1
is no performance penalty for	1
is no way the user	1
is no way to tell	2
is no operating system, and	1
is no need to use	1
is no need to take	2
is no need to break	1
is no need to organize	1
is no need to deallocate	1
is no need for garbage	1
is no extra cost to	1
is no big difference in	1
is no exception handling. It	1
is no check for overflow.	2
is no problem if the	1
is no advantage to using	1
is no cost in terms	2
is no automatic check for	1
is no reason to use	3
is no reason to add	1
is no reason to unroll	1
is no difference in performance	1
is no difference in speed	2
is no difference in performance.	1
is no difference between 32-bit	1
is no longer used. A	1
is no graphics processing unit.	1
is no checking for overflow,	1
is no clear correspondence between	1
is no risk of overflow,	1
is no risk of overflow:	1
is no risk of underflow.	1
is no penalty for mixing	1
is no easy way to	2
is no try block or	1
is no heavy marketing of	1
is no loop-carried dependency chain.	1
is no 51 performance penalty	1
is no doubt obtained with	1
is no guarantee that all	1
is set in the variable	1
is set by using the	1
is floating point. The reason	1
is most efficient if all	1
is most often true last	1
is most useful for finding	1
is most appropriate for the	1
is using a six years	1
is using one register less	1
is double There is no	1
is float 140 a =	1
is two or more iterations	1
is number one in a	1
is also a cache that	1
is also a language that	1
is also a common programming	1
is also a kind of	1
is also used in two	1
is also used for variables	1
is also used when the	1
is also possible to see	1
is also possible to tell	1
is also called from another	1
is also called Single-Instruction-Multiple-Data (SIMD)	1
is also useful in situations	1
is also useful for testing	1
is also available in the	1
is also available from the	1
is also likely to lead	1
is also quite efficient, but	1
is also recommended to declare	1
is also relevant to small	1
is also discussed which method	1
is also treated like a	1
is also deallocated. Failure to	1
is also de-allocated. This is	1
is efficient for simple types	1
is efficient when b is	1
is many times faster than	1
is possible to use the	1
is possible to make the	2
is possible to make a	1
is possible to make software	1
is possible to make shared	1
is possible to do the	1
is possible to do an	1
is possible to do integer	1
is possible to do things	1
is possible to avoid this	1
is possible to compile a	1
is possible to get a	1
is possible to calculate pow(x,10)	1
is possible to store objects	1
is possible to write the	1
is possible to replace the	1
is possible to replace a	1
is possible to give each	1
is possible to reduce the	1
is possible to start a	1
is possible to insert optimization	1
is possible to implement a	2
is possible to vectorize code	1
is possible to obtain the	1
is possible to utilize the	1
is possible to construct obscure	1
is possible to express any	1
is possible in some cases	1
is possible in Linux). Threads	1
is clock cycles per array	1
is so long that the	1
is so important and generally	1
is so large that we	1
is so big that caching	1
is so much stronger for	1
is so small that it	1
is so complicated that I	1
is so high that it	2
is so kludgy that it	1
is 2 GHz then the	1
is very time consuming. Therefore,	1
is very useful when testing	1
is very important to do	1
is very important to optimize	1
is very important for tasks	1
is very large or if	1
is very small or if	1
is very likely to be	1
is very likely that code	1
is very fast if the	1
is very inefficient because the	1
is very little overhead to	1
is very inefficient. Linear arrays	1
is very fast. The result	1
is very limited. There are	1
is very problematic because these	1
is very old-fashioned. Development in	1
is long because the speed	1
is long does not make	1
is branch prediction. Modern microprocessors	1
is member of the same	1
is faster the smaller the	1
is faster to use than	1
is faster to first convert	1
is faster to access a	1
is faster to calculate than	1
is faster to compose a	1
is faster // Still faster	2
is faster if the number	1
is faster if the constant	1
is faster if the dividend	2
is faster if a and	1
is faster with signed than	1
is faster than the function	1
is faster than the simple	1
is faster than the hardware	2
is faster than a non-static	1
is faster than x =	1
is faster than from floating	1
is faster than other methods	1
is faster than signed when	1
is faster than division by	2
is faster than reading or	1
is faster than calculating the	1
is faster than multiplying by	1
is faster than random access.	1
is faster than 15.1b, and	1
is faster when columns is	1
is faster because the template	1
is stored in a register	1
is stored in memory rather	1
is stored in stack memory	1
is stored in x, and	1
is stored in memory, but	1
is stored in y. The	1
is stored on the stack.	1
is stored as the binary	1
is stored as a register	1
is stored as a single	1
is stored as a biased	1
is stored at a memory	1
is stored (or if a	1
is called the branch misprediction	1
is called a frame function,	1
is called a leaf function.	1
is called a loop-carried dependency	1
is called and the local	1
is called and how much	2
is called in a typical	1
is called for the first	1
is called by the rest	1
is called with many different	1
is called on an object	1
is called when the original	1
is called from the message	1
is called from only one	1
is called from many different	1
is called only from one	1
is called CPU dispatching. For	1
is called before the first	1
is called register renaming. The	1
is called stack unwinding. All	1
is called through a function	1
is called name mangling. The	1
is called core clock cycles.	1
is called square blocking or	1
is called garbage collection. Objects	1
is called once or multiple	1
is called CodeAnalyst. These profilers	1
is called VTune; AMD's profiler	1
is 4 bytes in 32-bit	1
is critical when there is	1
is 8 kb = 8192	1
is less than the time	2
is less than 128 because	1
is less than 2n and	1
is less than 1/50 of	1
is less efficient if the	1
is less efficient than the	1
is less efficient than a	1
is less efficient than signed	1
is less efficient than accessing	1
is less efficient than relocation,	1
is less efficient when the	1
is less useful in 32-	1
is less important on most	1
is less advantageous to use	1
is less efficient. You may	1
is less reliable. Event-based sampling:	1
is unsigned Examples: // Example	1
is often the case in	1
is often a lot to	1
is often a disadvantage for	1
is often an obstacle to	1
is often more efficient to	1
is often more reliable than	1
is often possible to make	1
is often possible to insert	1
is often faster to use	1
is often faster than the	1
is often useful to put	1
is often necessary to do	1
is often necessary to check	1
is often implemented as a	1
is often easier to use	1
is often easier said than	1
is often determined by considerations	1
is often preferable to make	1
is often reorganized in such	1
is often seen, is certainly	1
is how the if branch	1
is template metaprogramming so complicated?	1
is useful to know how	1
is useful in situations like	1
is useful for the programmer	1
is useful for library functions.	1
is useful for calling from	1
is useful for checking how	1
is useful for random number	1
is useful for preventing program	1
is useful if the library	1
is useful on servers that	1
is useful when the number	1
is useful because it gives	1
is useful whenever a function	1
is even more important to	1
is sure to be loaded	1
is sure to work on	1
is always 0 or 1	1
is always position-independent because this	1
is always inlined even when	1
is always resolved at compile	1
is always enabled in 64-bit	1
is always one, and only	1
is always true/false Loopunrolling x-xxxx--x	1
is always normalized, if possible,	1
is 16 bits wide, while	1
is out of range and	1
is out of range (see	1
is out of range. This	1
is 32 bits in 32-bit	1
is 32 bits, so you	1
is file access or cache	1
is part of the operating	1
is part of a critical	1
is 0 and the other	1
is 0 for positive and	1
is short in duration compared	1
is available in the function	1
is available in different versions	1
is available in newer versions	1
is available for many platforms,	1
is available for free in	1
is available for free. Visual	1
is available then it is	1
is available then each vector	1
is available from www.intel.com. Manual	1
is available from www.agner.org/optimize/testp.zip. This	1
is constant and known to	1
is important to the end	1
is important to have a	1
is important to make sure	1
is important to do something	1
is important to consider which	1
is important to economize the	2
is important to economize resource	1
is important to distinguish between	1
is important to study the	1
is important to focus the	1
is important to decide which	1
is important to note that	1
is important to weigh the	1
is important to remember that	1
is important to realize that	1
is important for the programmer	1
is important that the integer	1
is important that the user	1
is important that all allocated	1
is accessed in more than	1
is accessed by several different	1
is accessed with a square	1
is accessed from within the	1
is accessed most efficiently if	1
is accessed much faster. There	1
is accessed through a pointer	1
is accessed quite fast. The	1
is accessed after it has	1
is large or constant. If	1
is large then it obviously	1
is large because the insertion	1
is compiled to binary code	1
is compiled and distributed as	1
is compiled in multiple versions	1
is compiled for the AVX	1
is compiled for a particular	1
is compiled for old processors	1
is compiled with AVX support	1
is compiled as position-independent has	1
is compiled when it is	1
is compiled into an intermediate	1
is compiled without AVX support	1
is big and is called	1
is big enough to hold	1
is big enough for the	1
is big enough for a	1
is best for all applications.	1
is best when the loop	1
is best suited for the	1
is necessary to use 64-bit	1
is necessary to do optimizations	1
is necessary to first look	1
is necessary to test the	1
is necessary to look up	1
is necessary to allocate a	1
is necessary to compromise on	1
is necessary to reload *p	1
is necessary to query certain	1
is necessary to adhere to	1
is necessary for verifying the	1
is necessary if the objects	1
is necessary here to draw	1
is specific to Microsoft compilers.	1
is much more efficient to	1
is much more dramatic when	1
is much faster. In the	1
is much faster. Division by	1
is much slower than a	1
is much simpler in 64-bit	1
is much faster, except perhaps	1
is common to make two	1
is common to make container	1
is common for software to	1
is common practice to test	1
is exception safe if there	1
is allocated is also de-allocated.	1
is allocated and the entire	1
is allocated dynamically (with new	1
is allocated separately. The allocation,	1
is small and always the	1
is small and changing then	1
is small or if it	2
is small then a sorted	1
is small enough to justify	1
is good to do a	1
is good for the logical	1
is good for the application.	1
is good if you can	1
is done in connection with	1
is done by the linker	1
is done by copying the	1
is done by declaring the	1
is done with the operators	1
is done with an extended	1
is done at the second	1
is done at runtime here	1
is done only once. One	1
is done every time the	1
is done simply by ignoring	1
is therefore a good idea	1
is therefore not possible to	1
is therefore more safe than	1
is therefore possible for the	1
is therefore important to understand	1
is therefore necessary to do	2
is therefore necessary to convert	1
is therefore certain to be	1
is therefore recommended to put	1
is therefore recommended that big	1
is therefore equal to the	1
is therefore becoming more and	1
is therefore safer to do	1
is optimized is to do	1
is optimized for accessing arrays	1
is optimized away. Note that	1
is inside a loop with	1
is inside another loop that	1
is explained on page 122.	1
is explained below on page	1
is calculated the fastest first.	1
is calculated in advance and	1
is calculated as ((a+b)+c)+d. This	1
is calculated from the value	1
is calculated from the previous	2
is calculated from a value	1
is calculated at compile time	1
is calculated fast if it	1
is calculated twice because the	1
is calculated first, then d+e,	1
is calculated internally as (int)&matrix[0][0]	1
is 128 bits (XMM) if	1
is 128 bytes or more	1
is four places back. Thus,	1
is another security problem. The	1
is advantageous to use the	2
is advantageous to use float	1
is advantageous to use hyperthreading	1
is advantageous to do things	1
is advantageous to replace the	1
is advantageous to roll out	1
is advantageous in most cases	1
is advantageous in cases where	1
is advantageous if the function	1
is advantageous if the typical	1
is advantageous because registers is	1
is advantageous if, and only	1
is implemented in the same	1
is implemented in a separate	2
is implemented with an intermediate	1
is implemented as a function	2
is implemented simply by storing	1
is implemented internally as a	1
is known to be an	1
is known to be 0	1
is known to be true	1
is known to be false	1
is known with certainty that	1
is known from a previous	1
is known at compile time	4
is known at compile time.	1
is known at compile-time whether	1
is known which version of	1
is known before the first	1
is supported in the latest	1
is supported in such applications.	1
is supported in Windows 7	1
is supported by the CPU	1
is supported by the processor	1
is supported by the microprocessor	1
is supported by all modern	1
is supported by most CPUs	1
is supported by some very	1
is supported by both the	1
is supported on all 64-bit	1
is eight in 32-bit systems	1
is likely to be the	1
is likely to be faster	1
is likely to be less	1
is likely to be limited	1
is likely to be slower	1
is likely to be obsolete.	1
is likely to be irrelevant	1
is likely to be mispredicted,	1
is likely to use the	1
is likely to work best	1
is likely to cause contentions	1
is likely to run most	1
is likely to generate a	1
is likely to require modifications	1
is likely to go away	1
is likely to execute slower	1
is likely to fail if	1
is likely to consume time	1
is likely to experience. Occasionally,	1
is likely in a more	1
is likely that the producer	1
is likely that memory access	1
is doing an addition to	1
is doing multiple logically distinct	1
is doing two iterations in	1
is 1 0.5ns. 2GHz A	1
is simply the address of	1
is simply a matter of	5
is simply not appropriate here.	1
is simply an integer in	1
is simply no difference in	1
is simply optimized away and	1
is simply predicted to go	1
is simply identical. For example,	1
is able to do the	1
is able to inline and	1
is able to overlap the	1
is certain to be inlined.	1
is certain to have no	1
is certain that a will	1
is shared between multiple threads	1
is quite efficient thanks to	1
is quite simple in most	1
is quite certain that the	1
is quite difficult to implement	1
is quite inefficient. The modern	1
is quite expensive - in	1
is quite inefficient, and it	1
is quite tedious indeed. It	1
is used. The operating system	1
is used. The advantages of	2
is used. A newer method	1
is used. It is recommended	1
is used. It takes between	1
is used. For example, x	1
is used. An optimizing compiler	1
is used. However, this does	1
is used. Dynamic linking makes	1
is recommended to use the	3
is recommended to use a	4
is recommended to use that	1
is recommended to make member	1
is recommended to return from	1
is recommended to calculate the	1
is recommended to put a	1
is recommended to turn on	1
is recommended to turn off	2
is recommended to enable the	1
is recommended to enable fast	1
is recommended to try different	1
is recommended to specify static	1
is recommended to wrap the	1
is recommended to place the	1
is fast and efficient, but	1
is fast anyway and you	1
is fast enough. A hash	1
is optimal to use exception	1
is optimal to inline the	1
is optimal in most cases.	1
is optimal for each calculation.	1
is optimal on the actual	1
is optimal only on CPUs	1
is typically between 5 and	1
is typically 64 bytes on	1
is typically 64 bytes. This	1
is typically implemented by the	1
is typically aligned by 8	1
is typically loaded at a	1
is preferably implemented on a	1
is automatically deallocated when returning	1
is implementation dependent. The stack	1
is never stored in a	1
is never used. A computer	1
is never used. Whenever a	1
is never called. This method	1
is never called. Unfortunately, the	1
is never changed. This will	1
is high and decreased when	1
is high then the most	1
is zero if all bits	1
is zero by testing all	1
is zero } We can	1
is Microsoft Visual Studio. This	1
is Microsoft Foundation Classes (MFC).	1
is running in the majority	1
is running on an Intel	1
is running on, while it	1
is running on. Replace or	1
is running at, rather than	1
is n places back, where	1
is better than the 32-bit	1
is better than its reputation.	1
is too important to ignore,	1
is too big for the	1
is too big. 7.14 Functions	1
is too fine then it	1
is too high. It may	1
is too late. You should	1
is needed a few clock	1
is needed in this case.	1
is needed for other reasons,	1
is needed for setting up	1
is needed only if it	1
is difficult to predict which	1
is difficult to predict whether	1
is difficult to implement in	1
is difficult to understand and	1
is difficult for the compiler	2
is difficult for the CPU	1
is transferred to the function.	1
is transferred as an implicit	1
is transferred from one auto_ptr	1
is transferred at runtime from	1
is longer than a few	1
is aligned #pragma vector aligned	1
is actually more than 250	1
is actually quite convenient. It	1
is actually used. No program	1
is actually needed by the	1
is actually hidden behind the	1
is later ported to another	1
is calling itself in order	1
is declared or created it	1
is declared by specifying the	1
is higher for single precision	1
is bigger than the cache	1
is bigger than the level-2	1
is bigger than the destination	1
is divisible by the size	1
is divisible by the number	1
is divisible by the unroll	1
is divisible by the 107	1
is divisible by 16 (see	1
is divisible by 16. In	1
is 512 kb / 8	1
is 512 kb, 8 ways.	1
is usually the order in	1
is usually not able to	1
is usually faster to transfer	1
is usually called in the	1
is usually called before the	1
is usually much faster to	1
is usually done in a	1
is usually higher than the	1
is usually predicted well if	1
is usually inlined if the	1
is usually divided into three	1
is called. The compiler will	1
is called. The values are	1
is called. This is done	1
is called. This has the	1
is called. If virtual functions	1
is called. You may declare	1
is called. I have added	1
is called. Example: // Example	1
is called. Lazy binding can	1
is called. 118 12.7 Mathematical	1
is based on the standard	1
is based on BSD, but	1
is based mainly on my	1
is made to the desired	1
is made to recover from	1
is made very big in	1
is just a matter of	1
is just an arbitrary name	1
is just long enough to	1
is just easier to write	1
is smaller and closer to	1
is smaller in a computer	1
is smaller because relative addresses	1
is relevant for the programmer	1
is relevant when the code	1
is relevant when CPU access	1
is replaced by the function	1
is replaced by its value	1
is replaced by x<<3, which	1
is negative or -0 }	1
is predicted if the value	1
is predicted well. A loop	1
is predicted well, of course.	1
is loaded or at run	1
is loaded into memory. If	1
is loaded cannot be determined	1
is loaded rather than each	1
is compatible with a better	1
is compatible with that branch.	1
is compatible with CPUs that	1
is compatible with old microprocessors	1
is 1. This '1' is	1
is intended to be platform-independent	1
is intended to mimic the	1
is intended for CPU dispatching	1
is intended for array sizes	1
is intended for variables that	1
is intended for 32-bit Windows	1
is intended for detecting errors	1
is intended as a plug-in	1
is intended for. In other	1
is intended for. Some systems	1
is avoided for these variables.	1
is slow // Division by	1
is slow // Modulo by	1
is slow unless the size	1
is inefficient to use an	1
is inefficient to use 32-bit	1
is inefficient because the compiler	1
is inefficient because of the	1
is inefficient because it is	1
is described in more detail	1
is described below. Make calls	1
is particularly critical. A very	1
is particularly interesting because it	1
is particularly risky because it	1
is particularly tricky. I have	1
is given in example 14.19	1
is given as a template	1
is outside the critical innermost	1
is outside this interval, for	1
is limited is to do	1
is limited to well-tested functions,	1
is limited and there are	1
is limited by the throughput	1
is limited by physical factors.	1
is sometimes more efficient than	1
is sometimes possible to obtain	1
is inlined - no need	1
is still the same regardless	1
is still the fastest way	1
is still frustrated by unacceptably	1
is safe to use algebraic	1
is safe and flexible, but	1
is further explained in the	1
is clear that static linking	1
is clear that p is	1
is obtained if the critical	1
is obtained by using a	1
is obtained by choosing a	1
is obtained by dropping the	1
is obtained with the Gnu,	1
is obtained with virtual member	1
is obtained when the code	1
is possibly more serious when	1
is overloaded or the user	1
is possible. A compiler that	1
is OS independent and checks	1
is needed. The C++ language	1
is needed. Example: // Example	1
is needed. These complicated cases	1
is needed. All the code	1
is needed. Objects inside containers	1
is changed to c =	1
is changed so that it	1
is true that some development	1
is true 50% of the	1
is true 10% of the	1
is initialized or comes from	1
is initialized when the program	2
is initialized only the first	1
is discussed on page 60.	1
is discussed which of the	1
is discussed how to identify	1
is discussed how to overcome	1
is discussed below. Signed /	1
is copied to the parameter,	1
is copied to a local	1
is copied by assignment, as	1
is copied from static memory	1
is defined in a different	1
is defined in a separate	1
is defined inside a class	1
is Visual Basic .NET, which	1
is rarely possible for the	1
is rarely necessary to use	1
is rarely needed anyway. You	1
is rarely needed. 11 Out	1
is rarely enough to justify	1
is rarely worth the effort	1
is easier to write 2.0/3.0	1
is easier to maintain. The	1
is easier to understand when	1
is identical to one of	1
is identical to some other	1
is similar to the Gnu	1
is similar to a macro	1
is significant if a parameter	1
is something that can be	1
is invalid when i is	1
is within a certain interval:	1
is used, for example, to	1
is used, it is recommended	1
is used, then use #pragma	1
is used, then there may	1
is used, but not if	1
is organized in a first-in-last-out	1
is organized if you are	1
is added to the first	1
is added to the second	1
is added to the offset	1
is added to a pointer	1
is added to p is	1
is approximately three times faster.	1
is approximately 12 - 25	1
is approximately six in 32-bit	1
is easy to make floating	1
is easy to trace with	1
is easy to port to	1
is chosen for the sake	1
is chosen as the basis	1
is chosen only when running	1
is slightly more efficient to	1
is slightly more efficient because	1
is slightly less compact. See	1
is independent of the loop	1
is independent of the value	1
is low in order to	1
is enabled. The compiler will	1
is enabled. The advantage of	1
is enabled. A more primitive,	1
is enabled. There are no	1
is enabled. Conversion from integer	1
is enabled. Conversions between integers	1
is enabled. Typically, the conversion	1
is enabled. Volatile The volatile	1
is enabled. Few compilers are	1
is near the maximum repeat	1
is provided in manual 4:	1
is provided as a template	1
is provided as an example	1
is inefficient. Division, square root	1
is critical. The fastest execution	1
is critical. The worst problem	1
is critical. Optimizing for speed	1
is available. The number of	1
is available. The best compilers	1
is available. The older MMX	1
is brand new today will	1
is executed. The compiler can	1
is executed. This has the	1
is executed. An example is	1
is executed. Furthermore, you may	1
is executed. Optimizes very well.	1
is executed. Without static, the	1
is faster. In the case	1
is pure if the function	1
is pure __attribute(( const)) __attribute((	1
is fully standardized and supported	1
is fully portable in the	1
is mispredicted only when it	3
is mispredicted only one time	1
is standardized allows us to	1
is included in the profile.	1
is included in a single	1
is included for the sake	1
is 12 bytes. The time	1
is now as follows. The	1
is lower than a certain	1
is converted to a pointer	1
is converted to a longer	1
is converted by the compiler	1
is equally fast whether p	1
is equally efficient. Simple function	1
is designed for a higher	1
is designed for generality and	1
is fragmented and scattered around	1
is fast. Value of b	1
is fast. Calculating the difference	1
is fastest on different processors.	1
is fastest because you can	1
is required for finding the	1
is required for putting the	1
is almost always advantageous to	1
is almost certain to become	1
is almost certain that this	1
is almost independent of changes	1
is preferred to use a	1
is preferred to declare objects	1
is preferred when speed is	1
is interpreted in the following	1
is interpreted as an unsigned	1
is interpreted again and again	1
is exactly as efficient as	1
is exactly identical for the	1
is determined by the floating	1
is determined by the operating	1
is determined where the object	1
is resolved when the library	1
is resolved at compile time	1
is resolved at runtime. #define	1
is poorly predictable then replace	1
is poorly predictable. For example:	1
is poorly predictable, then it	1
is important. This can be	1
is important. This manual does	1
is important. A language based	1
is important. Some systems allow	1
is important. An important disadvantage	1
is allowed only for classes.	1
is distributed and stored as	1
is distributed as it is	1
is distributed between multiple dynamic	1
is generally possible on Linux	1
is generally faster and more	1
is called, a dispatch is	1
is called, it is necessary	1
is called, it can use	1
is called, it allocates the	1
is called, while the Gnu	1
is free and open source.	1
is far from the server.	1
is hardly any performance penalty	1
is hardly worth the effort	1
is hardly ever used, though.	1
is waiting for response from	1
is waiting for response. It	1
is available, 256 bits (YMM)	1
is measured in this way	1
is measured with millisecond resolution	1
is measured simply by removing	1
is Intel's term for running	1
is equal to the number	1
is equal to the address	1
is equal to the preceding	1
is compact and takes little	1
is spent in the innermost	1
is spent on reading and	1
is 15 on the old	1
is expected to replace the	1
is convenient to make a	1
is costly if XMM registers	1
is costly when it occurs,	1
is efficient, but risky. The	1
is poor if data are	1
is evaluated only when needed.	1
is deallocated when the function	1
is permissible when it is	1
is 4. So the address	1
is obvious and the code	1
is swapped with element matrix[c][r]	1
is swapped with element matrix[c][r].	1
is portable in the sense	1
is becoming increasingly important. A	1
is executed only once for	1
is executed even though the	1
is executed 10 times rather	1
is finished. The optimal number	1
is finished. Example: // Example	1
is finished. Obviously, this is	1
is finished. Register allocation and	1
is split between several execution	1
is created or modified. This	2
is already in the cache	1
is already known then it	1
is already known at this	1
is nothing to gain by	1
is nothing to clean up	1
is increased when the work	1
is nonzero } else {	1
is equivalent to a function.	1
is relatively expensive, while the	1
is inefficient, of course, and	1
is inefficient, especially in 32-bit	1
is inefficient, however, when b	1
is necessarily accessed through a	1
is safer to use a	1
is safer to calculate the	1
is larger than the largest	1
is unfortunately very common. Even	1
is divided into many small	1
is valid only until the	1
is seen in 64 bit	1
is contiguous with other objects	1
is contiguous with other local	1
is necessary. 101 Multithreading works	1
is increasing faster than the	1
is AND'ed with the inverted	1
is AND'ed with this mask,	1
is AND'ed with all 0's	1
is AND'ed with all 1's	1
is definitely the preferred programming	1
is doubled. The time it	1
is doubled. The length of	1
is doubled. This makes it	1
is true, and all 0's	1
is true, then the second	1
is true, which is only	1
is true, which is 50%	1
is __asm int 3; or	1
is currently not up to	1
is currently only supported on	1
is better. Whenever a processor	1
is preferable to allocate the	1
is preferable for speed-critical functions.	1
is enabled there is no	1
is enabled (single precision requires	1
is sufficiently accurate for the	1
is bad The C/C++ standard	1
is said here about Linux	1
is said here about increment	1
is declared. If the variable	1
is declared. An object of	1
is declared. Therefore, it has	1
is declared. Avoid multiple inheritance,	1
is true. The trick of	1
is running. The main reason	1
is running. If there is	1
is serial in the sense	1
is serial because each value	1
is guaranteed to be in	1
is guaranteed to be 0	1
is commonly the case with	1
is extended to 64 bits.	1
is contained in p1 and	1
is going to be very	1
is cached. Usually it takes	1
is unsigned. The following guidelines	1
is treated as an integer.	1
is treated as bigger than	1
is prevented from assuming that	1
is prevented from cleaning up	1
is seldom used. It is	1
is double. Here we prefer	1
is 50% of the cases.	1
is illustrated in example 13.1	1
is illustrated in example 9.5b.	1
is optimized. We cannot change	1
is coded as an 8-bit	1
is coded as _mm_empty() as	1
is represented with 64 bits,	1
is kept in the carry	1
is selected if the processor	1
is multiplied by the size	1
is inferior to the Intel	1
is unable to predict which	1
is unable to vectorize the	1
is finished using the previous	1
is run. The time it	1
is run. Examples include JavaScript,	1
is run. Both the executable	1
is simpler than a frame	1
is simpler when using references.	1
is deleted when the pointer	1
is deleted properly and the	1
is slow, you know). The	1
is slow, then the microprocessor	1
is slow, difficult to use,	1
is performed on a sequence	1
is performed on multiple data	1
is removed from the above	1
is unfortunate because truncation takes	1
is loaded. This method requires	1
is implemented. The highest efficiency	1
is implemented. The recursion must	1
is annoying to the user.	1
is elsewhere then there is	1
is filled up, which happens	1
is supplied with Intel's compilers	1
is translated to just one	1
is translated into machine code	1
is correct or if the	1
is stored. This makes the	1
is inlined. An alternative solution	1
is probably the most common	1
is beyond the scope of	3
is infinity or NAN. Avoiding	1
is false, then the second	1
is negligible when the number	1
is negligible because there is	1
is best. These cases are	1
is best. 3.11 Other system	1
is odd and you unroll	1
is handled at half speed	1
is handled separately: for (r2	1
is implicitly converting a to	1
is valid. For example, when	1
is valid. For example: //	1
is valid. Re-interpreting the type	1
is slow. If the granularity	1
is slow. Value of a	1
is limited. Example: // Example	1
is limited. Dynamic memory allocation	1
is ported to multiple operating	1
is big. The compiler is	1
is extremely complicated and clumsy,	1
is extremely costly to many	1
is extremely inefficient, (4) get	1
is certainly a very inefficient	1
is certainly more convenient to	1
is certainly something that can	1
is indeed a very contrived	1
is indeed vectorized as intended	1
is sufficient to have just	1
is sufficient to make a	1
is evicted before we need	1
is impossible to work for	1
is mostly compatible with these.	1
is type-casted to a pointer	1
is 1024 bytes, so we	1
is 400 here. Any code	1
is freed when the function	1
is biased allows us to	1
is reused again and again.	1
is compiled. This is the	1
is compiled. #if directives are	1
is volatile. The volatile keyword	1
is supported. For example, use	1
is pure. Virtual functions and	1
is bypassed by any of	1
is -0 (zero with sign	1
is achieved when none of	1
is inserted in the final	1
is specified. The code will	1
is overwritten, possibly in a	1
is false. Likewise, you cannot	1
is small. The number of	1
is unsafe because serious errors	1
is concentrated on CPU efficiency	1
is concentrated on arranging data	1
is capable of making two	1
is worthwhile to invest more	1
is eliminated. Loop unrolling also	1
is profitable to use vectorized	1
is unstable or if the	1
is required. The Intel compiler	1
is required. See page 73	1
is 8192 / 4 =	1
is lost. This dilemma can	1
is obviously influenced by the	1
is allowed. The code examples	1
is (columns * sizeof(float)) =	1
is defined. This can cause	1
is known. This information is	1
is known. Example: // Example	1
is restarted anyway. Software distributors	1
is dividing repeatedly with the	1
is fed into the pipeline	1
is relocated (rebased) once more	1
is consistent for the function	1
is created. There is no	1
is started. It takes longer	1
is deleted. Smart pointers are	1
is needed: // Example 7.40c	1
is needed: // Example 7.44	1
is loaded, the loader calls	1
is loaded, but waits until	1
is 0. The constant N1	1
is rolled out by 2.	1
is busy doing the spell	1
is busy concentrating on important	1
is updated. Most copy protection	1
is wasted on software that	1
is wasted on runtime dispatch	1
is stronger when they are	1
is fast, compact, and simple	1
is somewhat more complicated because	1
is invalid. Boolean variables are	1
is heavily loaded. 21 3.13	1
is available: // Example 7.6.	1
is available: // Example 12.4c.	1
is closed. The same method	1
is closed. The file will	1
is avoided. The disadvantage is	1
is 95 not needed. You	1
is repeated until the residual	1
is accessed, and this error	1
is accessed, it is necessary	1
is inherently parallel because it	1
is safer. Type casting of	1
is 102 also useful to	1
is terminated. The purpose is	1
is moved, which may happen	1
is saturated. This can be	1
is incremented. See page 31	1
is insufficient. The user expects	1
is unacceptable to the user	1
is unchanged across a call	1
is compiling. This prevents it	1
is enabled: // Example 14.21.	1
is over. Virtualization is becoming	1
is dead code if no	1
is InstructionSet().The following example shows	1
is correlated with preceding branches	1
is ecx+eax*4. The result ebx	1
is system-independent, in another module.	1
is occupied throughout the whole	1
is referencing it twice. You	1
is unreasonably large. 156 16.3	1
is maintained for the sake	1
is aiming at explaining the	1
is pushed on the stack	1
is requested. See page 45.	1
is delayed for several seconds	1
is assumed that the reader	1
is (int)(&list[100]) = (int)(&list[0]) +	1
is mirrored in the level-1	1
is closest to the truth	1
is utilized appropriately. Users should	1
is developing so fast that	1
is supposed to call the	1
is copyrighted by Agner Fog.	1
is acceptable. 3.6 Dynamic linking	1
is unnecessarily wasteful in the	1
is caught by the operating	1
is checked before storing. The	1
is happening. It is possible	1
is OK, however, to pass	1
is opposite). 9.10 Cache contentions	1
is reset or goes into	1
is unchanged, while the expression	1
is reserved for dynamic allocation.	1
is ambiguous and may produce	1
is counting clock cycles at	1
is provoked here in a	1
is repetitive. The simplest case	1
is artificially changed to the	1
is advisable to make it	1
is inexact if b and	1
is exact. Multiple divisions can	1
is created, deleted, copied or	1
is organized. Floating point comparisons	1
is reflected, first and foremost,	1
is terminated and the user	1
is returned. There is no	1
is pipelined, as explained above,	1
is taken. A const pointer	1
is taken, i.e. if there	1
is clearly better. The loop	1
is destroyed. In 50 simple	1
is shut down and restarted	1
is re-allocated every time it	1
is signed, or by extending	1
is 83 called faster than	1
is virtually no cost to	1
is expanded like a macro	1
is fastest. The typical way	1
is distributed. The intermediate code	1
is unrealistic that you can	1
is deprecated. This is because	1
is strongly recommended to set	1
is obvious. See the compiler	1
is obvious, then it may	1
is servicing. A command received	1
is inferior. A model with	1
is cached, but several hundred	1
is rare. Testing for the	1
is "undefined". This allows the	1
is admittedly very kludgy. The	1
is 8*1024/64 = 128. These	1
is stored? If the total	1
is Borland's now discontinued Object	1
is Perl. Several modern programming	1
is wrong, but it is	1
is rebooted. To prevent this	1
is unlikely that the end	1
is profitable. On the other	1
is considerable. If two threads	1
is costless. It is simply	1
is responsible for creating and	1
is tempting to fine- tune	1
is minimized. For example, if	1
is minimized if the number	1
is re-loaded from memory a	1
is incurred on all non-static	1
a is true 50% of	1
a is true, which is	1
a is true. The trick	1
a is false. Likewise, you	1
a a & ~a =	1
a a && false =	1
a a | -1 =	1
a a ^ -1 =	1
a to the constant 5.	1
a to be signed. Be	1
a to this number we	1
a to double before multiplying	1
a to b for (i	1
a to b memcpy(b, a,	1
a to unsigned in order	1
a to zero for (i	1
a to zero memset(a, 0,	1
a and b in a	1
a and b in example	1
a and b are the	1
a and b are 32-bit	1
a and b are swapped	1
a and b have other	1
a and b have been	1
a and b will both	1
a and b different so	1
a and b because b	1
a and b because their	1
a and b should be	1
a and b double precision:	1
a and b take the	1
a and b overlap. You	1
a and r are transferred	1
a and b, and the	1
a and edx contains the	1
a and b. But in	1
a in a column-wise manner	1
a = a - n.a.	1
a = a x -	1
a = a * 2;	4
a = a * 3;	4
a = x > y	1
a = b + c	1
a = b + 2.0	1
a = b + 0.666666666666666666667;	1
a = b * 5	1
a = b * 2.5	1
a = b * 3.5;	1
a = b * 1.2;	2
a = b * (1.	1
a = b * 1.2f;	1
a = b / c;	1
a = b / 10;	1
a = b / 16;	1
a = b / 1.2345;	1
a = b % c;	1
a = b % 10;	1
a = b % 16;	1
a = b ? 1.5f	1
a = a, a |	1
a = b; A branch	1
a = b; } else	1
a = c; } Can	1
a = 0, b =	1
a = 0, b; b	1
a = (unsigned int)b /	2
a = (unsigned int)b %	2
a = parabola (2.0f); b	1
a = 0x2710 and (set)	1
a = (b == 0)	1
a = select(b > 0,	2
a = 1.0f + b	1
a = sin(0.8); The sin	1
a = -100, b =	1
a = lookup[b]; If a	1
a = _mm_or_si128(c2, bc); //	1
a = OneOrTwo5[b!=0]; will also	1
a = (int)d; // Truncation	1
a = (b*c)/d, it can	1
a = Func1(2); ... }	1
a = -1.0E8, b =	1
a = 5.0f; b =	1
a = OneOrTwo5[b & 1];	1
a = _mm_blendv_epi8(bc, c2, mask);	1
a = CriticalFunction(b, c); ...	1
a = 10000, then we	1
a = b++; will make	1
a = ++b; the compiler	1
a = (*CriticalFunction)(b, c); ...	1
a = Multiply(10,8); b =	1
a = select_gt(b, zero, c	1
a = FactorialTable[b]; ... }	1
a function is by a	1
a function is not allowed	1
a function is not referenced	1
a function is called for	1
a function is compiled in	1
a function is advantageous if	1
a function is pure if	1
a function is called, it	2
a function of a loop	1
a function to be pure.	1
a function in the main	1
a function in a library	1
a function in a dynamic	2
a function in a shared	2
a function in a DLL	1
a function in case of	1
a function for this purpose,	1
a function for different Intel	1
a function for register storage.	1
a function that is called	1
a function that has no	1
a function that does the	1
a function that calls at	1
a function that doesn't call	2
a function that doesn't add	1
a function that allocates memory	1
a function are stored on	2
a function can throw. In	1
a function or in a	1
a function if the inlining	1
a function if it is	1
a function with a lookup	1
a function which cannot be	1
a function which transposes a	1
a function but outside the	1
a function should also be	1
a function should preferably be	1
a function should never return	1
a function pointer to the	2
a function pointer which initially	1
a function pointer typically takes	1
a function pointer points to.	1
a function into multiple smaller	1
a function library or a	1
a function library with CPU	1
a function return value. The	1
a function call to a	1
a function call by the	1
a function call with a	1
a function template because partial	1
a function through a function	1
a function uses by looking	1
a function parameter is that	1
a function parameter and a	1
a function just because it	1
a function library. 78 Therefore,	1
a function call. (2) find	1
a function library, but this	1
a function opens a file	1
a function parameter, or as	1
a function prototype to tell	1
a function local: 1. Add	1
a code that current compilers	1
a code that copies the	1
a code then it is	1
a code one line at	1
a code version performs well.	1
a - n.a. - -	2
a - n.a. x x	1
a - n.a. a-a =	1
a - n.a. a*0 =	1
a - n.a. (-a)*(-b) =	1
a - 1; } }	2
a - a-a = 0	1
a - a*0 = 0	1
a - 0/a = 0	1
a - a/1 = a	1
a compiler to always behave	1
a compiler to reduce complicated	1
a compiler that can do	1
a compiler that supports automatic	1
a compiler can look like	1
a compiler with C++0x support.	1
a compiler may change the	1
a compiler option for assembly	1
a compiler generates to see	1
a compiler warning for such	1
a x - x x	1
a time and it avoids	1
a time and show the	1
a time and afterwards a	1
a time in vectors of	1
a time because each call	1
a time consumer if it	1
a time packed into a	1
a time measure. This is	1
a use situation where the	1
a more efficient way if	1
a more clear and intelligible	1
a more clear program structure	1
a more well-structured program that	1
a more distant future. 12.3	1
a will be 1 b	1
a will never be negative.	1
a memory address that is	2
a memory address which is	1
a memory block that has	1
a memory block turns out	1
a memory pointer. This is	1
a memory buffer and read	1
a memory address. Pointer arithmetic	1
a memory pool. 15 Integer	1
a memory heap. The heap	1
a memory pool, as explained	1
a data member is more	1
a data member of a	1
a data member pointer simply	1
a data member relative to	1
a program is an important	1
a program is compiled with	1
a program is bigger than	1
a program and concentrate the	1
a program for the following	1
a program that already works	1
a program than to execute	1
a program may in fact	1
a program you want to	1
a program then you may	1
a program has one or	1
a program has two arrays,	1
a program has many calls	1
a program has many branches	1
a program has several large	1
a program has too much	1
a program where the dispatch	1
a program uses many small	1
a program contains no calls	1
a program contains many variables	1
a program contains calls to	1
a program reads from address	1
a program package is not	1
a program repeats 1000 times	1
a program chooses between two	1
a program saying that it	1
a program executable: a debug	1
a program creates or modifies	1
a program dictates that an	1
a vector of eight 16-bit	1
a vector of e.g. four	1
a vector of (0,0,0,0,0,0,0,0) __m128i	2
a vector of (0,0,0,0,0,0,0,0) Is16vec8	1
a vector of vectors, as	1
a vector of (2,2,2,2,2,2,2,2) __m128i	2
a vector of (2,2,2,2,2,2,2,2) Is16vec8	1
a vector or the loop	1
a vector register which can	1
a vector implementation is optimal	1
a vector goes faster if	1
a vector just as fast	1
a vector register. The library	1
a vector simultaneously. This is	1
a vector register, add the	1
a make utility. The conclusion	1
a make utility. It supports	1
a different function library. If	1
a different code address and	1
a different compiler by including	1
a different way or bypassing	1
a different operating systems that	1
a different type by type-casting	1
a different implementation when b	1
a different name for each	1
a different platform is likely	1
a different compiler. Object files	1
a different thread. If you	1
a different way. There is	1
a different address. A call	1
a different module or a	1
a different kind of registers.	1
a different array. // Example	1
a different type. Likewise, a	1
a different meaning. 2. Put	1
a different meaning for member	1
a only when b is	1
a CPU of unknown brand	1
a CPU with the highest	1
a CPU with a higher	1
a CPU with multiple cores.	1
a CPU dispatcher that doesn't	1
a CPU dispatcher based on	1
a CPU dispatcher updated. It	1
a loop is interpreted again	1
a loop of ADC (add	1
a loop and use multiple	1
a loop in a program	1
a loop for trivial tasks	1
a loop that does floating	1
a loop that contains several	1
a loop or not. The	1
a loop if it is	1
a loop if this can	1
a loop with multiple counters,	1
a loop with few or	1
a loop where each iteration	1
a loop where almost the	1
a loop contains floating point	1
a loop counter can be	2
a loop counter by a	1
a loop count down to	1
a loop automatically if this	1
a loop needs a floating	1
a loop becomes a little	1
a loop depends on how	1
a loop repeats a thousand	1
a loop manually unless there	1
a loop counter, comparing the	1
a loop count. The method	1
a loop counter: // Example	1
a one parameter. Further details	1
a cache is organized if	1
a cache of 8 kb	1
a cache that can be	1
a cache line that we	1
a cache line will be	1
a cache line. This is	1
a cache line. Some compilers	1
a cache line. 132 Table	1
a cache line: static inline	1
a cache miss. But if	1
a set of test data	1
a set of special vector	1
a class is declared or	1
a class are stored in	1
a class are accessed through	1
a class or structure is	1
a class or structure are	1
a class or structure object	1
a class or structure. The	1
a class with a destructor	1
a class with a default	1
a class data member is	1
a class member function means	1
a class member function. The	1
a class template rather than	1
a class need not be	1
a class Variables declared inside	1
a class containing the functions	1
a class definition. Inlining a	1
a class (also called properties)	1
a floating point number is	1
a floating point number to	2
a floating point number in	1
a floating point number simply	1
a floating point variable as	1
a floating point counter then	1
a floating point multiplication at	1
a floating point addition on	1
a floating point addition takes	1
a floating point addition, and	1
a floating point addition. This	1
a floating point comparison. On	1
a double by modifying only	1
a double which gives access	1
a double takes 8 bytes	1
a double without loading a	1
a double precision constant. It	1
a double uses 64 bits.	1
a pointer of a different	1
a pointer to the next	1
a pointer to the desired	3
a pointer to a table	1
a pointer to a virtual	1
a pointer to a derived	1
a pointer to a base	1
a pointer to a contained	1
a pointer to an integer,	1
a pointer to one of	1
a pointer to one class	1
a pointer to its child	1
a pointer to another class.	1
a pointer to it. This	1
a pointer in an import	1
a pointer in assembly code.	1
a pointer can be converted	1
a pointer or a member	1
a pointer or a non-const	1
a pointer or reference to	6
a pointer or reference may	1
a pointer or reference, the	1
a pointer or reference, or	1
a pointer then its value	1
a pointer stored in a	1
a pointer does not require	1
a pointer well before the	1
a pointer points to and	1
a + b than to	1
a + b + c	1
a + b + c;	3
a + 2 thenaandbcannot use	1
a + 1; } This	1
a + 1; } }	1
a + 1; } else	2
a + 1; x[1] =	1
a + 1; 69 }	1
a + 1.0f; The compiler	1
a + b;} }; int	1
a library of math functions	1
a library function from www.agner.org/optimize/asmlib.zip.	1
a library function which we	1
a library other than the	1
a float or double because	1
a float or double takes	1
a float uses 32 bits	1
a float variable. Example: //	1
a multiple of the vector	1
a multiple of the size	1
a multiple of the critical	4
a multiple of the matrix	1
a multiple of the level-1	1
a multiple of 0x800 apart.	1
a number of possible remedies	1
a number of arrays that	1
a number of dangers to	1
a number of sources. For	1
a number to be calculated	1
a static object defined inside	1
a static part of the	1
a static link library because	1
a static library. A runtime	1
a static buffer or send	1
a static library, except when	1
a 64-bit integer rather than	1
a 64-bit double is that	1
a 64-bit double 32 bits	1
a 64-bit version for best	1
a 64-bit shared object made	1
a 64-bit double, then the	1
a C++ program that produces	1
a C++ program. This has	1
a C++ program, you should	1
a * 2; } else	2
a * 2; return a	2
a * 3; } if	1
a * 3; } return	1
a * 3; return a	2
a * (2n / b)	1
a * a;} float parabola	1
a * 2.5; // Use	1
a possible point of attack	1
a possible minor increase in	1
a clock cycle is the	2
a clock cycle is 1	1
a clock cycle on another	1
a clock cycle? In this	1
a clock cycle? ...................................................................................... 16	1
a version control tool. 7	1
a value is less than	1
a value that is a	1
a value that is two	1
a value from a table	1
a variable is the range	1
a variable is never stored	1
a variable is never changed.	1
a variable in memory takes	1
a variable in memory, as	1
a variable in parts, for	1
a variable for test purposes.	1
a variable that could benefit	1
a variable can be changed	1
a variable or object as	1
a variable or object through	1
a variable from address 0x2710	1
a variable because optimizing compilers	1
a variable which is known	1
a variable number of objects	1
a variable even smaller by	1
a variable through a pointer	1
a variable global if it	1
a variable until the function	1
a variable declaration to tell	1
a 2 GHz CPU. Should	1
a table of pointers to	3
a table of constants is	1
a table of jump targets.	1
a table in the level-1	1
a table // of function	2
a table with two entries.	1
a table lookup if the	1
a table lookup. For example:	1
a table lookup: // Example	2
a performance test that measures	1
a performance penalty when going	1
a very efficient way of	1
a very efficient solution in	1
a very long time unless	1
a very user friendly compiler	1
a very useful way to	1
a very large number of	1
a very large shared object	1
a very large runtime framework	1
a very large positive number	1
a very big problem if	1
a very good choice for	1
a very high resolution if	1
a very inefficient way. The	1
a very inefficient solution. Many	1
a very low repeat count	1
a very dramatic effect on	1
a very contrived example, but	1
a very obscure possibility of	1
a software optimization issue. But	1
a software programming language, e.g.	1
a software implementation is faster	1
a software implementation rather than	1
a software framework that uses	1
a software module for correctness	1
a software package and make	1
a software package on a	1
a software package several times	1
a long time to calculate.	1
a long time in case	1
a long time when the	1
a long time compared to	1
a long vector library is	1
a long vector library, you	1
a long time. It is	1
a long list of numbers:	1
a long dependency chain. If	1
a long dependency chain. We	1
a long time, such as	1
a long sequence of operations	1
a long delay. See page	1
a 32-bit integer has a	1
a 32-bit number (the instruction	1
a 32-bit number. If a	1
a 32-bit (signed) address. The	1
a branch that goes randomly	1
a branch that chooses between	2
a branch by a conditional	1
a branch will be mispredicted	1
a branch will go based	1
a branch into the pipeline	1
a branch inside the template.	1
a branch (e.g. an if-else	1
a branch misprediction is approximately	1
a branch tree. On older	1
a < b because of	1
a member of the class	1
a member of the object's	2
a member of a structure.	1
a member of a bitfield	1
a member function is as	1
a member function to be	1
a member function or friend	1
a member function which returns	1
a member function pointer is	1
a member function such as	1
a member function. Do not	1
a member function. 7.12 Branches	1
a way of relieving a	1
a way to work around	1
a way to check for	1
a way that can be	1
a way that there is	1
a way that takes more	1
a way that avoids overflow:	1
a faster vectorized code. Storing	1
a const function that is	1
a const reference if the	1
a const reference allows the	1
a const reference. A const	1
a critical function and you	1
a critical part of a	1
a critical dependency chain which	1
a critical dependency chain, especially	1
a critical piece of code	1
a call to a const	1
a call to _endthread() cleans	1
a register to zero that	1
a register and prevents all	1
a register if its address	1
a register variable in example	1
a register variable in eax.	1
a register rather than on	1
a register (see below) then	1
a register variable. The register	1
a register variable. The union	1
a register stack. These registers	1
a register except in the	1
a 64 64 matrix on	1
a rather unconventional manner by	1
a time. This is called	1
a time. A simple way	1
a time. You may mirror	1
a time. Do not read	1
a template has only one	1
a template class is more	1
a template class which gets	1
a template parameter rather than	1
a template parameter. It can	1
a template parameter. There is	1
a template parameter. No time	1
a template parameter. Templates may	1
a template parameter: // Example	1
a template parameter: template <typename	1
a test program that can	1
a test run with a	1
a test feature into the	1
a test tool for using	1
a new and better processor	1
a new compiler which is	1
a new memory block every	2
a new vector size often	1
a new instruction set opens	1
a new cache line in	1
a new floating point addition	1
a new object is not	1
a new object of a	1
a new version without the	1
a new value of temp	1
a new software project, it	1
a new branch of code	1
a new branch only when	1
a new register size only	1
a new register size comes	1
a new processor enters the	1
a new element in the	1
a new addition before the	1
a new bigger memory block	2
a new instance of the	2
a new one. The existing	1
a new one. I have	1
a new physical register to	1
a user is waiting for	1
a user has to reinstall	1
a useful way of making	1
a useful source of such	1
a system with only one	1
a system call (e.g. GetProcessAffinityMask	1
a file is faster than	1
a file in exclusive mode,	1
a file that has been	1
a file can be wrapped	1
a file by calling WritePrivateProfileString,	1
a file on a hard	1
a programming language that can	1
a dynamic library is loaded	1
a dynamic library is resolved	1
a dynamic library than in	1
a dynamic link library (DLL)	1
a part of the code	1
a part of memory that	1
a short time then the	1
a short vector library, you	1
a & a = a,	1
a & b if b	1
a & 0 = 0,	1
a & b; will make	1
a & b; d =	1
a & -1 = a,	2
a & ~a = 0	2
a & 0= 0 -	1
a & a= a a	1
a simple function with a	1
a simple integer counter. A	1
a simple class containing the	1
a simple pointer or a	1
a simple array is the	1
a simple array can be	1
a simple test setup but	1
a simple type casting, but	1
a simple algorithm can do	1
a simple variable. Most compilers	1
a simple variable. Using pointers	1
a simple regular pattern, while	1
a simple index. A good	1
a simple periodic pattern can	1
a simple periodic pattern or	1
a simple type, a pointer,	1
a simple solution, but it	1
a constant is faster //	2
a constant is faster if	2
a constant is faster than	2
a constant to the preceding	1
a constant to the previous	1
a constant that is divisible	1
a constant can be avoided	1
a constant with a combination	1
a constant should be done	1
a constant (see page 137).	1
a constant known at compile	1
a constant reference instead: //	1
a constant plus an index	1
a constant divisor that is	1
a stack frame unless your	1
a stack frame, saving and	1
a function. Using an overloaded	1
a function. Avoid the use	1
a large memory model where	1
a large part of it)	1
a large cost to creating	1
a large runtime framework for	1
a large positive number when	1
a large overhead cost to	1
a large delay due to	1
a large fraction of the	1
a large object, unless there	1
a must be read into	1
a ; parameter 2: 12	1
a ; r ; unused	1
a ; top of loop	1
a Windows compiler to work	1
a Windows program that created	1
a result of other optimizations	1
a result of macro expansions.	1
a result then we will	1
a processor will have an	1
a processor has a particular	1
a big program when the	1
a big loop then you	1
a big floating point library	1
a big matrix happen to	1
a big program. Frequent context	1
a big waste of resources.	1
a big mainframe computer. Big	1
a language that allows direct	1
a specific CPU model and	1
a specific CPU feature on	1
a specific CPU core by	1
a specific CPU core during	1
a specific instruction set, e.g.	1
a specific size is different	1
a specific pointer does not	1
a specific advantage to obtain,	1
a specific graphics framework is	1
a specific load address. If	1
a specific size. Integer operations	1
a specific purpose. It is	1
a specific purpose, you must	1
a specific purpose: Contain one	1
a specific interval. A hash	1
a much more complicated implementation	1
a single function or hot	1
a single function by adding	1
a single function from the	1
a single object file. This	2
a single branch if the	1
a single call to a	1
a single call to memcpy	1
a single bit which is	1
a single register the object	1
a single & operation, which	1
a single constant with a	1
a single function. Switch between	1
a single operation using the	1
a single task that consumes	1
a single executable file when	1
a single element. The most	1
a single step rather than	1
a single result. An uncaught	1
a single operation. Example: //	1
a single instruction. The CPU	1
a single container, preferably with	1
a single comparison: // Example	1
a single result, true (1)	1
a single session. But lazy	1
a virtual function will be	1
a virtual function call if	1
a virtual table to see	1
a virtual table before the	1
a virtual member function is	1
a virtual member function. See	1
a common way of setting	1
a common programming error known	1
a common programming error. The	1
a common error that hackers	1
a common cause of reduced	1
a common source of error	1
a common denominator can even	1
a common denominator: // Example	1
a thread is terminated. The	1
a thread to a specific	1
a thread that runs alone	1
a thread jumps between different	1
a thread environment block. Thread-local	1
a thread affinity mask. Poor	1
a small and fixed repeat	1
a small bit at a	1
a small test program that	1
a small part of the	1
a small block for each	1
a small piece of memory	1
a small piece at a	1
a small fraction of the	1
a += b; In this	1
a += 2; Common subexpression	1
a good compiler can often	1
a good performance for many	1
a good way of making	1
a good implementation of the	1
a good choice for code	1
a good choice for all	1
a good choice for Linux	1
a good idea to make	1
a good idea to put	1
a good idea to collect	1
a good deal of programming	1
a good deal of research	1
a good investment. A redesign	1
a good knowledge of the	1
a power of 2 is	1
a power of 2 and	1
a power of 2 in	2
a power of 2 can	1
a power of 2 //	2
a power of 2 or	1
a power of 2 if	5
a power of 2 by	1
a power of 2 then	3
a power of 2 return	1
a power of 2 template	1
a power of 2 does	1
a power of 2 Integer	1
a power of 2 (See	1
a power of 2. Example:	2
a power of 2. Objects	1
a power of 2, so	1
a power of 2: template	1
a power of two. In	1
a matrix is the same	1
a matrix is a power	1
a matrix is a high	1
a matrix is so big	1
a matrix a power of	1
a matrix and stores the	1
a matrix in STL as	1
a matrix for use as	1
a matrix when contentions occur	1
a matrix using example 9.5a	1
a matrix line (in bytes)	1
a matrix line. The delay	1
a Linux compiler, or vice	1
a precision of approximately seven	1
a line size of 64	1
a line size of 64.	1
a manual on usability, but	1
a / b as a	1
a 128 bit vector of	2
a 128 bit vector containing	1
a check before the loop	1
a problem with vector operations	1
a problem when mixing code	1
a problem then it may	1
a problem since we are	1
a known CPU model is	1
a solution where a soft	1
a container for a specific	1
a container for exclusive access	1
a container that contains only	1
a container that allows you	1
a container or memory pool.	1
a container than to delete	1
a container class that takes	1
a container class that behaves	1
a container class. The container	1
a few more integer vector	1
a few functions that are	1
a few clock cycles to	1
a few clock cycles more	2
a few clock cycles before	1
a few clock cycles after	1
a few clock cycles, but	1
a few cases where it	1
a few instructions that may	1
a few times may be	1
a few extra instructions for	1
a few arrays of variable	1
a few cases, however, where	1
a few unused points in	1
a few lines should be	1
a few machine instructions. Intrinsic	1
a few pitfalls here. You	1
a few lines. A few	1
a few kilobytes at a	1
a few comments about how	1
a few places. Constant folding	1
a list is almost certain	1
a list of some long	1
a list of short vector	1
a list of titles. Literature	1
a list should preferably be	1
a list float a[100]; float	1
a structure or class for	1
a structure or class with	1
a structure or class declaration	1
a structure or each of	1
a structure or class. The	1
a structure where data members	1
a standard for specifying parallel	1
a standard function library that	1
a hardware implementation of these	1
a hardware definition language is	1
a hardware definition language in	1
a hardware definition language defines	1
a hardware definition language. Such	1
a hardware definition language, such	1
a : b; } A	1
a : b) y =	1
a store operation doesn't delay	1
a store forwarding delay in	2
a copy constructor specifying otherwise.	1
a copy protection scheme should	1
a well optimized software design,	1
a certain modification is profitable.	1
a certain tolerance. The time	1
a certain interval: // Example	1
a counter that measures the	1
a counter inside the CPU	1
a shared object is called,	1
a shared object is accessed,	1
a shared object can be	1
a shared object which is	1
a shared object without the	1
a shared object. It is	1
a shared object, then the	1
a program. The time measurements	1
a program. The profilers are	1
a program. This is the	1
a program. Avoid unnecessary functions	1
a program. Whole program optimization	1
a was zero or infinity	1
a space in the branch	1
a lot of time both	1
a lot of time cleaning	1
a lot of data manipulation	1
a lot of data shuffling,	1
a lot of CPU time,	1
a lot of cache space	1
a lot of cache space.	1
a lot of optimization by	1
a lot of time. You	1
a lot of extra instructions	1
a lot of extra resources.	1
a lot of branches that	1
a lot of runtime DLL's	1
a lot of added information	1
a lot of background processes	1
a lot of computing resources.	1
a lot of resources, and	1
a lot of modifications to	1
a lot of bookkeeping in	1
a lot of jumping around	1
a lot of irrelevant software	1
a lot of CPU-time in	1
a lot to gain in	1
a lot to gain if	1
a lot to gain by	1
a lot in performance. I	1
a particular code implementation works	1
a particular code version. 2.	1
a particular compiler to do	1
a particular memory address by	1
a particular memory address cannot	1
a particular CPU or other	1
a particular CPU model is	1
a particular instruction set then	1
a particular instruction set, then	1
a particular integer size is	1
a particular set of CPUs.	1
a particular programming language and	1
a particular part of the	1
a particular processor model. You	1
a particular application uses a	1
a particular piece of code.	1
a particular brand is likely	1
a particular application. If hyperthreading	1
a particular reduction would be	1
a particular purpose. The clumsy	1
a particular weakness or bottleneck,	1
a particular meaning, then you	1
a particular subtask before coordination	1
a particular situation, but the	1
a microprocessor in an FPGA	1
a microprocessor that supports this).	1
a microprocessor because the hardware	1
a multiplication and an addition.	1
a multiplication but only an	1
a complicated code that is	1
a complicated implementation of the	1
a complicated process which is	1
a dependency chain where each	1
a dependency chain. 3.16 Execution	1
a Boolean vector. For example,	1
a Boolean NOT on a	1
a signed integer to a	1
a signed integer if there	1
a signed variable produces a	1
a model that was unknown	1
a separate function library and	1
a separate function library. The	1
a separate version for specific	1
a separate file than in	1
a separate dynamic link library	2
a separate function. Sometimes, functions	1
a separate thread in systems	1
a separate thread if the	1
a separate thread if it	1
a separate thread if there	1
a separate thread with lower	1
a separate C or C++	1
a separate module then it	1
a separate subroutine if it	1
a separate module, and to	1
a block of 16 bytes.	1
a needs to evaluate a	1
a disadvantage for the end	1
a disadvantage if the sequence	1
a disadvantage if other nearby	1
a disadvantage when the arrays	1
a high power of 2.	2
a high overhead cost of	1
a high repeat count is	1
a high level framework based	1
a high priority. Other tasks	1
a high degree of optimization	1
a high price, and in	1
a parameter is part of	1
a parameter of composite type	1
a parameter to the library	1
a reference to the object.	1
a reference or a simple	1
a reference or pointer to	1
a string is created or	2
a string of bytes to	1
a string and then interpret	1
a programmer may prefer to	1
a better version of the	1
a better result by using	1
a better solution to make	1
a better solution. It might	1
a better understanding of the	1
a lookup in a procedure	1
a lookup table is advantageous	1
a lookup table if you	1
a lookup table instead of	1
a lookup table: // Example	2
a && a = a	1
a && b with a	1
a && b needs to	1
a && b; d =	1
a && true = a,	1
a && false = false,	1
a && !a = false,	1
a | a = a	1
a | b if b	1
a | 0 = a	2
a | b; Here, I	1
a | -1 = -1	2
a difference in efficiency. For	1
a mechanism called stack unwinding	1
a runtime check that the	1
a runtime DLL or a	1
a means of making software	1
a || b with a	1
a || b; This is	1
a || true = true	1
a || false = a	1
a || !a = true	1
a > b ? a	1
a longer size by extending	1
a graphics function is time	1
a graphics function that draws	1
a graphics library or API	1
a graphics processing unit, either	1
a graphics card or integrated	1
a graphics accelerator card for	1
a graphics coprocessor or graphics	1
a public data object: (1)	1
a public variable in a	1
a public variable where it	1
a framework in its API.	1
a framework sometimes have unacceptably	1
a linked function is not	1
a linked list or with	1
a linked list has its	1
a linked list takes more	1
a linked list (see page	1
a linked list. Each element	1
a linked list. Do not	1
a linked list. 94 Are	1
a platform with a graphics	1
a dispatch is made to	1
a second application that uses	1
a second induction variable (eax)	1
a second step of interpretation	1
a higher instruction set than	1
a higher instruction set. Therefore,	1
a higher number is not	1
a higher clock frequency than	1
a higher address which can't	1
a higher risk that the	1
a piece of code is	1
a piece of code in	1
a piece of code that	2
a piece of code compiled	1
a piece of code once	1
a piece of program code	1
a piece of software specifies	1
a piece of code. Furthermore,	1
a piece of CPU-intensive software	1
a binary representation according to	1
a binary tree or a	1
a binary search, or even	1
a binary tree. Is searching	1
a 512 512 matrix in	1
a 512 512 matrix. My	1
a union is not a	1
a union is not optimal	1
a feature for making multiple	1
a feature for reserving memory	1
a feature called whole program	1
a link map or an	1
a constructor for the object.	1
a compiler. Some compilers can	1
a compiler. Many algebraic reductions	1
a #define directive never takes	1
a switch in your program	1
a switch between different tasks	1
a switch statement if it	1
a switch statement with sequential	1
a smaller memory footprint. If,	1
a smaller size is done	1
a negative list of which	1
a negative list of processors	1
a negative list of processor	1
a negative result. An overflow	1
a positive integer constant. //	1
a positive list of which	1
a positive list of processor	1
a positive list needs to	1
a positive integer: // Example	1
a loop. Example: // Example	1
a computer with multiple CPUs	1
a computer game or animation.	1
a pointer. The pointer is	1
a pointer. A variable in	1
a pointer. It is important	1
a pointer. It may be	1
a pointer. It has the	1
a pointer. It has some	1
a change in the YMM	1
a global variable in the	1
a global variable in main	1
a global variable means that	1
a global const variable or	1
a global object. The calling	1
a relative reference to a	1
a relative difference less than	1
a syntax restriction, but it	1
a profiler to find hot	2
a profiler that can tell	1
a profiler which determines the	1
a profiler works then you	1
a Windows, Linux, BSD or	1
a modern CPU. But it	1
a network with heavy traffic	1
a network may be both	1
a slow and fragmented hard	1
a slow bit scan instruction	1
a slow CPU, an insufficient	1
a whole polygon or bitmap	1
a whole workday or more.	1
a level-2 cache of 256	1
a level-2 cache miss can	1
a response is delayed for	1
a hot spot that uses	1
a hot spot has been	1
a hot spot. Use the	1
a given instruction set. The	1
a given task is often	1
a level-1 data cache of	1
a task is divided into	1
a task into a separate	1
a task switch occurs during	1
a limited number of possible	1
a limited range then a	1
a limited resource. The CISC	1
a limited audience for educational	1
a local const variable means	1
a local variable. This is	1
a database for storing user	1
a database by a plain	1
a bool is used as	1
a frame function because the	1
a frame function, while a	1
a special loop predictor. On	1
a special cache called the	1
a special trick which is	1
a shift operation which is	1
a shift operation. For example,a	1
a shift operation. x*8 is	1
a shift operation, which is	1
a destructor to make sure	1
a destructor that makes sure	1
a destructor that needs to	1
a destructor that destroys any	1
a destructor if it is	1
a safe way in case	1
a safe programming practice, of	1
a Pentium 4 with different	1
a Pentium 4 computer where	1
a Pentium 4 computer. The	1
a Pentium 4. The if	1
a further discussion of the	1
a sum of a long	1
a discussion of this problem.	1
a discussion of profiling. When	1
a non-Intel CPU. If not,	1
a maximum of four parameters	1
a macro to swap two	1
a macro in the sense	1
a macro so that each	1
a reduced number of cores	1
a variable. Make sure the	1
a variable. Efficiency Accessing a	1
a time, then the code	1
a processing speed exceeding that	1
a so-called soft processor. Such	1
a total offset bigger than	1
a total waste of the	1
a 128-bit vector so that	1
a 128-bit vector register, do	1
a 128-bit XMM register can	1
a 128-bit XMM register. In	1
a full size vector. The	1
a thread. You cannot be	1
a square brackets index, just	1
a little more complicated if	1
a little more syntax check.	1
a little faster than 32-bit	1
a little explanation. The value	1
a little odd here. The	1
a logical sequence. If you	1
a smart pointer is created,	1
a smart pointer (see page	1
a smart pointer. If a	1
a smart pointer. But there	1
a smart pointer. Accessing an	1
a subexpression to make sure	1
a bounds check on n	1
a message loop in the	1
a condition is relatively expensive,	1
a parallel structure that can	1
a ? b : c	2
a previous branch. Example: //	1
a vector. If n =	1
a vector. 6. If arrays	1
a program, especially if the	1
a similar utility for modifying	1
a risk that several variables	1
a risk factor in itself,	1
a garbage collector which is	1
a header file for a	1
a future version of C++	1
a newer instruction set when	1
a newer version of the	1
a sequence of calculations then	1
a sequence of consecutive variables.	1
a sequence where each label	1
a significant effect on older	1
a significant amount of time.	1
a significant contribution to the	1
a linear function of a	1
a linear function of i	1
a linear array for the	1
a linear array with a	1
a linear array will be	1
a linear list with a	1
a linear array. No link	1
a linear search, is fast	1
a penalty for mixing single	1
a module by compiling the	1
a 'this' pointer which is	1
a 'this' pointer. It is	1
a problem. If the number	1
a row to the address	1
a matter of programming style.	4
a matter of interpreting the	2
a matter of convenience -	1
a matter of habit, it	1
a series of branches every	1
a series of five manuals.	1
a series of five manuals:	1
a series of calculations: //	1
a series of calculations, where	1
a series of experiments on	1
a waste of the programmers'	1
a waste of time in	1
a waste of cache space.	1
a waste of cache space,	1
a waste of resources. Consider	1
a waste of time, it	1
a map file from the	1
a 256-bit vector as two	1
a device driver. A call	1
a non-static member function because	2
a low instruction set can	1
a low positive result. The	1
a low priority thread, and	1
a default constructor that does	1
a hard disk or other	1
a hard disk or network.	1
a hard disk because of	1
a hard disk often takes	1
a typical set of test	1
a typical software project goes	1
a typical application to calculate	1
a typical degree of randomness	1
a usability problem in interactive	1
a pure function with the	1
a pure function. Example: //	1
a derived class is implemented	1
a derived class are stored	1
a derived class through a	1
a derived class, it checks	1
a fully compiled code. Compiled	1
a standardized manner. 3.4 Automatic	1
a parent class and a	1
a parent class in one	1
a false model number to	1
a false vendor string. In	1
a temporary object for the	1
a temporary array before calling	1
a temporary variable outside the	1
a temporary register for computing	1
a procedure linkage table (PLT)	1
a procedure linkage table (PLT).	1
a procedure linkage table. If	1
a PC and then transferred	1
a PC platform. However, with	1
a frequent cause of unacceptably	1
a frequent source of errors	1
a prediction or estimate of	1
a polymorphic function goes in	1
a polymorphic class has a	1
a polymorphic member function is	1
a polymorphic function. The }	1
a register. The above example	1
a register. If the carry	1
a kind of branch that	1
a kind of branch. After	1
a graphical user interface (OnIdle	1
a graphical user interface. A	1
a graphical user interface. Otherwise	1
a lower instruction set. The	1
a lower priority level, typically	1
a misprediction every time the	1
a misprediction penalty of 10	1
a just-in-time compiler can optimize	1
a try block. There is	1
a background process running when	1
a PLT for all functions	1
a heavy graphics application is	1
a hash table for even	1
a hash map is needed	1
a hash map. Do objects	1
a profiling (see page 16)	1
a DLL can be accessed	1
a DLL with the best	1
a DLL goes through an	1
a branch. If it is	1
a GOT for all public	1
a GOT entry. You can	1
a fixed size array or	1
a fixed address might clash	1
a fixed breakpoint in the	1
a non-sequential order in order	1
a non-sequential order. The same	1
a non-sequential order. The advice	1
a non-sequential order. Example: //	1
a non-sequential manner then it	1
a non-sequential manner. It is	1
a jump from a=a*2; to	1
a random manner. This applies	1
a measure that is almost	1
a poorly predictable branch by	1
a vector, uses SSE3. //	1
a suitable set of test	1
a suitable choice of n.	1
a suitable pivot element. The	1
a suitable duration. The best	1
a serious legal issue. See	1
a serious legal issue, as	1
a far data segment by	1
a collection of example container	1
a composite type is more	1
a composite type can be	1
a composite type such as	1
a composite object, you may	1
a highly optimized program is	1
a debug version and a	1
a debug version with full	1
a factor of 1, 2,	1
a factor 4 in the	1
a reliable source so that	1
a reliable decision. 13.4 Test	1
a thousand cache misses have	1
a thousand times then the	1
a thousand times lower; and	1
a thousand numbers. With a	1
a compile-time polymorphism, which is	1
a constant. The compilers also	1
a complex framework requiring many	1
a dispatched function calls another	1
a normal array. The constructor	1
a convenient way of making	1
a portability issue to catching	1
a reference, or void. Returning	1
a self-relative address. (3) look	1
a Core i7 processor with	1
a debugger and press break	1
a ^ b ---xx---- a<<b<<c=a<<(b+c)	1
a ^ 1; You cannot	1
a ^ -1 = ~a	1
a ^ ~a = -1	1
a base class is converted	1
a base address plus a	1
a leaf function by inlining	2
a leaf function. Leaf functions	1
a six years old version	1
a structure. The extra time	1
a structure. For example: //	1
a profiler. A simple alternative	1
a profiler. It is not	1
a loss of precision, as	1
a remote database, and a	1
a considerable amount of time.	1
a considerable improvement in performance	1
a considerable job, but it	1
a considerable debate about which	1
a third thread can do	1
a multidimensional array sequentially. Some	1
a multidimensional structure needed? A	1
a strict formalism that requires	1
a portable way of defining	1
a computer. The proxy is	1
a computer. Security software that	1
a list, rolled out by	1
a realistic set of data	1
a realistic set of test	1
a realistic number of cache	1
a console mode program are	1
a console mode program. The	1
a hundred or even a	1
a hundred clock cycles to	1
a hundred times because the	1
a hundred times. This is	1
a loop-carried dependency chain. Such	1
a compromise between development time,	1
a compromise between efficiency, portability	1
a nonzero floating point number	1
a command or do other	1
a command line or a	1
a command line or an	1
a relatively primitive programming style	1
a latency which is the	1
a larger memory footprint than	1
a project built with another	1
a valid address. Pointers can	1
a valid 63 number (e.g.	1
a loop-invariant code that can	1
a loop-invariant expression that it	1
a key or moving the	1
a key press or mouse	1
a bit-mask: __m128i mask =	2
a type. The example on	1
a place indicated by the	1
a bad dilemma. You may	1
a mouse move or key	1
a non-inlined copy of the	2
a non-inlined copy Function inlining	1
a round function using assembly	1
a pipeline where instructions are	1
a Taylor series. The exponential	1
a dispatcher. The dispatcher changes	1
a class, structure or union	1
a queue as a circular	1
a protected operating system if	1
a protected operating system, but	1
a dramatic degradation of performance	1
a contained object because the	1
a bottleneck than memory access	1
a directive for a Windows	1
a scarce resource in 32-bit	1
a scarce resource. Do not	1
a scarce resource, especially in	1
a suboptimal way has become	1
a suboptimal way. The fact	1
a suboptimal way. Here you	1
a float, but not if	1
a detailed overview of the	1
a dedicated test server. Use	1
a dedicated microprocessor and therefore	1
a dedicated microprocessor core and	1
a dedicated physics processor for	1
a breakpoint in the fully	1
a unit-test without taking cache	1
a virus scanner that scans	1
a pointer, a reference, or	1
a pointer, but it is	1
a soft processor is much	1
a soft processor activates critical	1
a hyperthreading processor to give	1
a reasonable upper limit can	1
a reasonable estimate can be	1
a well-defined interface to the	2
a well-defined functionality and a	1
a wrong type. References are	1
a combination of additions and	1
a hidden pointer. The copy	1
a speed-critical program on the	1
a high-level language need only	1
a multithreaded program, or between	1
a parameter, so there may	1
a circular buffer with fixed	2
a circular buffer than as	1
a register, not even temporarily.	1
a natural order and there	1
a natural ordering? If you	1
a sorted list is the	1
a sorted list can be	1
a sorted list or a	1
a negligible contribution to the	1
a well-structured C++ program are	1
a micro-op cache (e.g. Sandy	1
a CPU- specific profiler. For	1
a backup copy of every	1
a nearby address again before	1
a pivot search: // Example	1
a float. (Both use 32	1
a built-in test feature called	1
a complete redesign of the	1
a variable, for example 32	1
a variable, pointer or member	1
a viable solution in such	1
a viable compromise when portability	1
a debugger. You may replace	1
a debugger. However, the code	1
a computationally intensive program is	1
a subexpression. For example, b*2.0/3.0	1
a chip that can be	1
a biased binary integer, and	1
a minor error in the	1
a non-member function, means that	1
a decimal point in your	1
a PC. Nevertheless, it is	1
a PC. Similarly, we are	1
a hint and the compiler	1
a case: // Example 7.45	1
a GOT. Another possibility is	1
a string. The old C-style	1
a 90% chance that the	1
a proxy for the main	1
a floppy disk. A big	1
a variable-size array with alloca:	1
a buffer. It should never	1
a name. #define directives when	1
a third-party graphics framework between	1
a null reference to provoke	1
a null reference. This will	1
a constructor, an overloaded assignment	1
a physics processing unit intended	1
a re- usable library if	1
a programmable logic device than	1
a time-consumer even for programs	1
a high-priority thread can possibly	1
a FIFO queue should be	1
a FIFO manner? If objects	1
a discussion. 7.33 Namespaces There	1
a cheap compiler for 32-bit	1
a division, which is slow	1
a first-in-last-out fashion. It is	1
a coprocessor might also be	1
a systematic and well thought-through	1
a systematic manner to make	1
a ^a = 0 a	1
a ^a = 0 -	1
a release version of object	1
a release version with all	1
a distinction between leaf functions	1
a symbolic link to the	1
a parenthesis around the constant	1
a parenthesis around such a	1
a bitfield is less efficient	1
a bitfield by the use	1
a slight degradation in code	1
a generic version that is	1
a word processor the user	1
a matrix. For example, a	1
a universal algorithm (e.g. QuineMcCluskey	1
a non-virtual member function, provided	1
a niche in scientific computing,	1
a "move constructor" to transfer	1
a typo in a hand-	1
a user-defined function is pure.	1
a union: // Example 9.2b	1
a macro, but the method	1
a macro. If you want	1
a precious resource for many	1
a not-too-big upper limit can	1
a basic understanding of how	1
a "function". Multiple calls to	1
a plug-in to Microsoft Visual	1
a hand- written table may	1
a low-priority thread steals resources	1
a monotonically increasing function of	1
a top-of-stack index. Are objects	1
a button or moving the	1
a minimal difference between the	1
a blend instruction if the	1
a wealth of advanced features	1
a zigzag course that reflects	1
a constructor. A default constructor	1
a number). Different compilers behave	1
a sensible balance between these	1
a compelling security reason for	1
a vector). The first generation	1
a formalism. The splitting of	1
a narrow range then a	1
a multitasking environment, between different	1
a valuable source of information	1
a learning process where the	1
a 50-50 chance of going	1
a double: // Example 14.23b	1
a First-In-Last- Out (FILO) basis	1
a non-const reference, a const	1
a key? If the key	1
a password. The log on	1
a year or two. Often,	1
a lineage of software that	1
a server in full use	1
a staircase function of the	1
a 2'nd order polynomial: //	1
a conditional move, depending on	1
a polynomial. Scheduling A compiler	1
a ready-made profiler. This does	1
a discrete icon signaling the	1
a disassembly, probably without information	1
a tag on a program	1
a balanced mix of additions	1
a First-In-First- Out (FIFO) basis	1
a fixed-size array is made	1
a lookup-table static. Example: //	1
a DLL. Another alternative worth	1
a request for inlining a	1
a #define, const or typedef	1
a plain old data file	1
a genuine compiler became available.	1
a thread-like scheduling in an	1
a non-recursing template specialization, not	1
a thorough analysis of the	1
a zero-terminated ASCII string to	1
a polymorphous class? This chapter	1
a technological point of view.	1
a bottleneck. Organize the data	1
a temp1 and temp2. Modern	1
a XOR b Bit vector	1
a stand alone compiler when	1
a zip file of every	1
a reply about investigation of	1
a graceful way. You may	1
a FILO manner? If objects	1
a driver involves the overhead	1
a Gauss elimination. The method	1
a funda- mentally flawed approach	1
a column-wise manner where the	1
a website. 5 Choosing the	1
a scalar (Scalar means not	1
a higher-priority thread running in	1
a destructor. A function that	1
a bit-mask which is all	1
a pre-calculated table. Even better:	1
a printer or other device	1
a union, as in example	1
a square. // This triangle	1
a strategy for saving a	1
a million times less than	1
a minute if the network	1
a textbook on test theory.	1
a level-3 cache. If the	1
a unique key. Do objects	1
a couple of things that	1
a template: // Example 7.34b.	1
a ^0 = a a	1
a menu click becomes inconsistent	1
a subset, giving access to	1
a BSF (bit scan forward)	1
a queue. It is more	1
a constant: Unsigned is faster	1
a quadratic matrix, i.e. each	1
of the function in which	1
of the function in terms	1
of the function pointer is	1
of the function pointer has	1
of the function pointer follows	1
of the function where you	1
of the code is not	1
of the code is chosen	1
of the code is executed.	1
of the code is selected	1
of the code to support	1
of the code and compile	1
of the code in a	2
of the code in multiple	1
of the code that use	1
of the code that matters	1
of the code can be	2
of the code can then	1
of the code can therefore	1
of the code can possibly	1
of the code have been	1
of the code where speed	1
of the code makes caching	2
of the code 16 will	1
of the code together near	1
of the code still needs	1
of the code could benefit	1
of the code only. This	1
of the compiler (see page	1
of the compiler optimizations that	1
of the time is spent	2
of the time and b	1
of the time and rarely	1
of the time it takes	1
of the time on processors	1
of the time goes to	1
of the time stamp counter	2
of the time slices is	1
of the memory is mirrored	1
of the memory if the	1
of the memory block from	1
of the memory block should	1
of the memory block. This	1
of the data cache (see	1
of the data object in	1
of the data cache. Bit-fields	1
of the data block to	1
of the data members. But	1
of the data structure, data	1
of the program is compiled	1
of the program is executed.	1
of the program of occupying	1
of the program to measure	1
of the program that runs	1
of the program that waits	1
of the program are also	1
of the program code are	1
of the program as long	1
of the program as well	1
of the program - preferably	1
of the program may be	1
of the program may need	1
of the program have been	1
of the program then it	1
of the program has most	1
of the program contains automatic	1
of the program under test,	1
of the program happen to	1
of the program appear to	1
of the vector registers in	1
of the vector size. There	1
of the different instructions sets.	1
of the same class and	1
of the same class will	1
of the same dynamic library	1
of the same type to	1
of the same structure or	1
of the same function, each	1
of the same compiler. It	1
of the same class. The	1
of the same logical register.	1
of the same features as	1
of the same brand. Future	1
of the same class). If	1
of the same algorithm, then	1
of the functions are never	1
of the functions are actually	1
of the CPU is limited	1
of the CPU time then	1
of the CPU clock by	1
of the CPU dispatching. This	1
of the CPU detection function,	1
of the instruction code. You	1
of the instruction sets is	1
of the loop in example	1
of the loop counter can	1
of the loop count (ArraySize)	1
of the loop counter. Example:	1
of the loop index. The	1
of the integer in a	1
of the integer registers is	1
of the class is declared.	1
of the class or structure	1
of the class or give	1
of the floating point representation	1
of the floating point number.	1
of the compilers I have	3
of the compilers reduced 15.1a	1
of the most used parts	1
of the most critical part	2
of the most important or	1
of the most important functions	1
of the most common memory	1
of the most common obstacles	1
of the size of a	1
of the Intel compiler is	1
of the Intel compiler in	1
of the Intel compiler puts	1
of the Intel compiler. This	1
of the pointer is needed	1
of the pointer or reference.	1
of the pointer has been	1
of the library that is	1
of the library into memory.	1
of the library functions. The	1
of the two branches to	1
of the two loops would	1
of the two loops (except	1
of the two AND operations:	1
of the object is known.	1
of the object or array	1
of the object pointed to.	1
of the number and sets	1
of the 64-bit systems. A	1
of the C++ compiler is	1
of the C++ programming language	1
of the C++ language While	1
of the C++ language...................................................... 14	1
of the array is not	1
of the array is stored.	1
of the array a and	1
of the array to make	1
of the array address is.	1
of the array element has	1
of the array i) {	1
of the clock frequency. For	1
of the clock frequency, as	1
of the value of the	1
of the value in the	1
of the objects should preferably	1
of the variable in the	1
of the variable that r	1
of the table that is	1
of the table has const	1
of the performance during the	1
of the software development process.	1
of the software package in	1
of the 32-bit integer. Floating	1
of the member function. But	1
of the member pointer. This	1
of the member relative to	1
of the way the register	1
of the elements in a[]	1
of the called function. Example:	1
of the address of the	1
of the 4 lines in	1
of the critical function may	1
of the critical code to	1
of the critical code are	1
of the critical function. The	1
of the critical function. In	1
of the critical stride and	1
of the critical stride will	1
of the critical stride then	1
of the critical stride (see	1
of the operating system is	1
of the operating system to	1
of the operating system can	1
of the operating system thread	1
of the first element of	1
of the first program. An	1
of the first application if	1
of the register size in	1
of the optimization job. You	1
of the code. This is	1
of the code. This can	1
of the code. It is	1
of the code. See ISO/IEC	1
of the code. Some profilers	1
of the code. C#, managed	1
of the code. Inserting your	1
of the time. The expression	1
of the time. This is	1
of the time. A for-loop	1
of the template function for	1
of the template parameter. If	1
of the new function. The	1
of the new bigger memory	1
of the user interface, another	1
of the following methods could	1
of the following conditions are	1
of the following solutions, depending	1
of the 32 sets can	1
of the bits for Tuesday,	1
of the type of object	1
of the & operation will	1
of the simple function, the	1
of the processors on a	1
of the Gnu directives work	1
of the Gnu compiler, the	1
of the function. The automatic	1
of the function. This has	2
of the function. Copying the	1
of the function. Compile once	1
of the extra work needed	1
of the extra bits. The	1
of the large overhead of	1
of the while loop is	1
of the execution units rather	1
of the compiled versions #include	1
of the best optimized function	1
of the best optimized math	1
of the best optimizing compilers	1
of the virtual function is	1
of the virtual function. If	1
of the virtual functions. This	1
of the virtual 53 function	1
of the exception handler to	1
of the power function when	1
of the matrix is a	1
of the matrix line size.	1
of the matrix element. The	1
of the AVX instruction set	1
of the AVX instruction set,	1
of the four cache lines	2
of the problem cannot easily	1
of the few cases where	1
of the structure or class	1
of the structure }; 52	1
of the standard PC processors	1
of the memory. The static	1
of the shared resources are	1
of the program. The use	1
of the program. The map	1
of the program. This makes	1
of the program. This requires	1
of the program. In some	1
of the program. 3 Finding	1
of the program. Application programmers	1
of the above methods if	1
of the problems and planned	1
of the next function. However,	1
of the multiplication of xxn	1
of the application program. All	1
of the application programmer. There	1
of the expression is used,	1
of the Boolean operators &&	1
of the Boolean operators (&&	1
of the Boolean operands because	1
of the needs of position-	1
of the Microsoft directives work	1
of the parameter is copied	1
of the source code, as	1
of the induction variable can	1
of the string is already	1
of the programmer to make	6
of the keyword volatile is	1
of the end of the	1
of the examples I have	1
of the difference is simply	1
of the data. Use OpenMP	1
of the graphics processing unit	1
of the framework itself, during	1
of the second operand. Likewise,	1
of the x86 instruction set	1
of the advantages of object	1
of the advantages of C++	1
of the advantages and drawbacks	1
of the storage methods mentioned	1
of the old memory block	1
of the function, but it	1
of the operands and add	1
of the operands has side	1
of the operands because the	1
of the innermost loop by	1
of the compiler. The compilers	1
of the advanced programming constructs	1
of the core with another	1
of the main reasons why	1
of the loop. Example 8.21	1
of the loop. Some implementations	1
of the installation process can	1
of the cases. The equivalent	1
of the STL is not	1
of the STL also costs	1
of the STL containers is	1
of the size. However, it	1
of the desired interval is	1
of the whole structure of	1
of the whole program. During	1
of the code, then you	1
of the code, which supposedly	1
of the code, cache misses	1
of the code, including user	1
of the fact that n	1
of the position-independent code. These	1
of the level-1 cache size.	1
of the resources. In this	1
of the task in question.	1
of the costs of dynamic	1
of the inlined function for	1
of the class. Data members	1
of the class. Calling a	1
of the class. Storing variables	1
of the preceding one is	1
of the preceding addition then	1
of the preceding one. This	1
of the preceding one. You	1
of the preceding row. The	1
of the exponent is biased	1
of the possibility that the	1
of the maximum possible memory	1
of the library. The application	1
of the library. This method	1
of the library. Add to	1
of the final size needed	1
of the final application depends	1
of the final product. It	1
of the variable. For example,	1
of the time, but expensive	1
of the total time. Optimizing	1
of the child class members.	1
of the counters when you	1
of the stack. Deallocation has	1
of the previous iteration (except	1
of the program, and while	1
of the program, for example	1
of the program, it is	1
of the header files are	1
of the sequence in a	1
of the beginning of the	1
of the beginning of list	1
of the current array element.	1
of the problem. This new	1
of the features of Java	1
of the latter is executed	1
of the default size when	1
of the derived class (see	1
of the derived class. This	1
of the factorial function looks	1
of the OpenMP directives for	1
of the parent class data	1
of the memcpy function. There	1
of the polymorphic functions. The	1
of the heavy graphics calculations.	1
of the arrays. It is	1
of the arrays. An array	1
of the branch. It may	1
of the GOT and PLT	1
of the array. eax holds	1
of the software. You should	1
of the object, and a	1
of the memory, depending on	1
of the absolute value of	1
of the largest vector. These	1
of the .NET framework. Obviously,	1
of the base classes. You	1
of the result. You can	1
of the increment and decrement	1
of the advice in the	1
of the advice given here	1
of the pitfalls here: The	1
of the present manual is	1
of the strlen function for	1
of the divisor is not	1
of the divisor is known	1
of the drawbacks of C++.	1
of the lrint function is	1
of the user's time. Other	1
of the considerations that are	1
of the techniques of multithreading.	1
of the advices may apply	1
of the residual error and	1
of the residual error for	1
of the specified types (See	1
of the micro-op cache. Compilers	1
of the object's class or	1
of the object's class. Make	1
of the const_cast operator here	1
of the executable. Most compilers	1
of the comments generated by	1
of the question when efficiency	1
of the array, which it	1
of the alignment. See www.agner.org/optimize/cppexamples.zip	1
of the time-consumers mentioned in	1
of the fraction. The sign	1
of the fraction. For example,	1
of the trivial programming work	1
of the subroutine for the	1
of the factorials, but this	1
of the Xnu project. Some	1
of the usual object file	1
of the programmers' time, but	1
of the weekdays. The maximum	1
of the original, poorly designed	1
of the user-written code with	1
of the iterator in some	1
of the kind: "what is	1
of a and b are	1
of a and b different	1
of a and b overlap.	1
of a function in case	1
of a function for different	1
of a function or in	1
of a function should preferably	1
of a code then it	1
of a compiler can look	1
of a will be 1	1
of a memory block that	1
of a data member relative	1
of a program is an	1
of a program is compiled	1
of a program and concentrate	1
of a program that already	1
of a program then you	1
of a program has many	1
of a program contains no	1
of a program contains calls	1
of a program executable: a	1
of a program dictates that	1
of a vector simultaneously. This	1
of a different type. Likewise,	1
of a loop is interpreted	1
of a loop if it	1
of a loop counter can	2
of a loop counter by	1
of a loop depends on	1
of a cache line. Some	1
of a class is declared	1
of a class or structure	2
of a class data member	1
of a class need not	1
of a class (also called	1
of a floating point number	2
of a floating point addition.	1
of a double which gives	1
of a pointer well before	1
of a 64-bit double is	1
of a 64-bit double, then	1
of a clock cycle is	3
of a variable is the	1
of a variable for test	1
of a variable number of	1
of a variable even smaller	1
of a very large runtime	1
of a very obscure possibility	1
of a long list of	1
of a 32-bit integer has	1
of a critical function and	1
of a critical dependency chain,	1
of a template parameter. Templates	1
of a new register size	1
of a new element in	1
of a simple class containing	1
of a function. Avoid the	1
of a ; top of	1
of a big program when	1
of a big program. Frequent	1
of a specific size is	1
of a specific size. Integer	1
of a virtual function will	1
of a matrix line (in	1
of a matrix line. The	1
of a list float a[100];	1
of a store forwarding delay	1
of a copy protection scheme	1
of a shared object can	1
of a program. The time	1
of a program. The profilers	1
of a program. This is	1
of a program. Avoid unnecessary	1
of a particular brand is	1
of a signed integer to	1
of a signed variable produces	1
of a parameter of composite	1
of a linked function is	1
of a linked list or	1
of a piece of code	1
of a change in the	1
of a program, especially if	1
of a row to the	1
of a hard disk or	1
of a derived class is	1
of a derived class through	1
of a parent class and	1
of a parent class in	1
of a temporary object for	1
of a polymorphic class has	1
of a polymorphic member function	1
of a graphical user interface	1
of a graphical user interface.	1
of a vector, uses SSE3.	1
of a suitable duration. The	1
of a composite type is	1
of a composite type can	1
of a structure. The extra	1
of a list, rolled out	1
of a relatively primitive programming	1
of a Taylor series. The	1
of a class, structure or	1
of a dedicated microprocessor core	1
of a variable, for example	1
of a debugger. However, the	1
of a string. The old	1
of a third-party graphics framework	1
of a re- usable library	1
of a bitfield is less	1
of a macro. If you	1
of a "function". Multiple calls	1
of a double: // Example	1
of that branch and other	1
of it (&ArraySize) is taken.	1
of function libraries Some applications	1
of function libraries Test Processor	1
of function pointers if there	2
of function calls and it	1
of function calls in the	1
of function inlining is that	1
of function inlining are: The	1
of function calls. The principle	1
of function libraries........................................................................................ 12 2.7	1
of code is so high	1
of code is intended for.	1
of code is fastest because	1
of code is serial in	1
of code to test in	1
of code and data can	1
of code and data A	1
of code and data memory	1
of code and data .........................................................................................	1
of code in which the	1
of code in multiple versions,	1
of code in general. Assume	1
of code that are used	1
of code that works for	1
of code that produces a	1
of code can be further	1
of code you want to	1
of code then you can	1
of code into multiple threads.	1
of code compiled with AVX	1
of code gives an 9	1
of code size. In fact,	1
of code execute faster. The	1
of code once the hot	1
of code optimization", Coriolis group	1
of an int is 4.	1
of an integer in one	1
of an integer if the	1
of an object It is	1
of an array can cause	1
of an array or the	1
of an array element if	1
of an array element. In	1
of an unsigned integer takes	1
of an unsigned variable produces	1
of an error then there	1
of an execution unit. For	1
of an exception or other	1
of an exception without using	1
of an optimized function, but	1
of an intermediate code. The	1
of an inlined function. The	1
of an overloaded function are	1
of an exception. The costs	1
of an exception. A frame	1
of an update, or update	1
of an error; and make	1
of compiler may in some	1
of compiler There are several	1
of compiler options Table 18.1.	1
of compiler .................................................................................................... 10 2.6	1
of compiler options....................................................................................... 160 19	1
of x is type-casted to	1
of x The syntax may	1
of x for approximately two	1
of x by using the	1
of x must wait until	1
of this is to help	1
of this function is InstructionSet().The	1
of this function on CPUs	1
of this by preferably using	1
of this bit scan instruction.	1
of this method is that	1
of this solution is too	1
of this section for some	1
of this fact by replacing	1
of this alignment automatically. The	1
of this problem. 7.11 Type	1
of this polynomial can be	1
of this method. Your measurement	1
of this manual. You have	1
of this manual. 2.3 Choice	1
of this option. Use the	1
of this bookkeeping depends very	1
of this manual, but you	1
of this capability: // Example	1
of time and resolve any	1
of time in most cases,	1
of time for software users	1
of time so that it	1
of time both during installation	1
of time cleaning up spaces	1
of when they are no	1
of when type-casting pointers: The	1
of A is not needed	1
of A is finished. Obviously,	1
of A is slow, then	1
of A and then B,	1
of memory to disk. Provoke	1
of memory and string functions	1
of memory for a new	1
of memory for all the	1
of memory that is organized	1
of memory or other resources.	1
of memory with new and	1
of memory will benefit from	1
of memory takes much more	1
of memory called the heap	1
of memory inside the CPU	1
of memory addresses is reused	1
of memory used. You may	1
of memory space can be	1
of memory needed in advance	1
of memory required is not	1
of memory blocks, for example:	1
of memory leaks if you	1
of memory blocks. A method	1
of data in order to	1
of data that are used	1
of data A variable is	1
of data structures to addresses	1
of data members. This alignment	1
of data files. This can	1
of data ...................................................................................................... 90 9.6	1
of data cache, code cache,	1
of data manipulation is required	1
of data shuffling, such as	1
of data (low numbers mean	1
of data decomposition, we should	1
of data elements, as follows:	1
of program or data exceeds	1
of program code is translated	1
of program performance because they	1
of program efficiency is reflected,	1
of program flow. Failure to	1
of vector register sizes to	1
of vector registers has been	1
of vector operations is more	1
of vector math libraries: long	1
of vector operations, as explained	1
of different function libraries. Numbers	1
of different integer types Unfortunately,	1
of different compilers I have	1
of different size matrices, clock	1
of different C++ language elements	1
of different C++ constructs Most	1
of different C++ constructs........................................................................ 26	1
of different type conversions is	1
of different intrinsic functions and	1
of different types or strings	1
of different types with the	1
of different types cannot point	2
of different sizes are allocated	2
of different algorithms for different	1
of different lengths in the	1
of different targets is small.	1
of different compilers............................................................................. 74 8.3	1
of functions in memory by	1
of functions that are not	1
of functions with integer parameters.	1
of functions A macro declared	1
of only half the size	1
of CPU that each particular	1
of CPU dispatching are: Optimizing	1
of CPU time, RAM and	1
of CPU cores. 60 The	1
of CPU development, each new	1
of other optimizations such as	1
of other tasks that are	1
of instruction latencies, throughputs and	1
of instruction timing, assembly language	1
of loop ; a[i] =	1
of loop ; unused label	1
of loop ; compute i/2	1
of loop iterations are: No	1
of which code branch to	1
of which functions take most	1
of which one is best.	1
of which method to use	1
of which processor models to	2
of which optimizations you can	1
of all the problems mentioned	1
of all data in a	1
of all but the first	1
of all variables. Obviously, this	1
of all cleanup of allocated	1
of one iteration should depend	1
of one iteration before the	1
of cache for the sake	1
of cache space by joining	1
of cache space used for	1
of cache lines to use	1
of cache space. A situation	1
of cache space. Putting simple	1
of cache misses is not	1
of cache misses and branch	1
of cache organization for different	1
of cache space, as explained	1
of cache evictions and other	1
of integer register variables is	1
of integer operations. This can	1
of class C1, so it	1
of floating point variables is	1
of floating point register variables	1
of floating point registers and	1
of floating point operations and	1
of floating point expressions may	1
of floating point operands cannot	1
of floating point instructions. Each	1
of floating point expressions. For	1
of floating point division. Correction	1
of each function relative to	1
of each vector can be	1
of each vector register is	1
of each integer type. Interrupt	1
of each object are called	1
of each object should preferably	1
of each array is a	1
of each array element in	1
of each version of the	1
of each table element Instruction	1
of each run in an	1
of each string is checked	1
of each row by adding	1
of each factor rather than	1
of each step of the	1
of each element, bits Number	2
of each method, it is	1
of example container classes that	1
of example 15.1b to metaprogramming	1
of example 12.4b and 12.4c	1
of most library functions without	1
of using the vector registers	1
of using the same inline	1
of using the register stack	1
of using the newest instruction	1
of using a software implementation	1
of using a long vector	1
of using a template parameter	1
of using a common denominator	1
of using an intermediate code	1
of using static linking rather	1
of using static here is	1
of using pointers and references.	1
of using pointers rather than	1
of using dynamic memory allocation.	1
of using exception handling then	1
of using references rather than	1
of using classes. 7.2 Integers	1
of using bitwise operators is	1
of using smart pointers is	1
of using powers of 2	2
of using ready made containers	1
of Intel vector classes: //	1
of Intel C++ compilers. Wikipedia	1
of Intel CPUs cannot be	1
of Intel microprocessors are able	1
of b is guaranteed to	1
of b is 400 here.	1
of b will be 2	1
of b into a 128-bit	1
of library functions linked from	1
of i to float in	1
of i to four bits,	1
of i in order to	1
of i will appear as	1
of i which can be	1
of i which will delay	1
of i into the least	1
of i must be adjusted	1
of i ; i +	1
of float or double to	1
of two different implementations of	1
of two double precision or	1
of two induction variables: //	1
of two double. The intrinsic	1
of object files and executables.	1
of object p points to	1
of object oriented programming are	1
of object oriented programming without	1
of object oriented programming are:	1
of object pointed to is	1
of static and global variables	1
of static data is that	1
of static linking is that	1
of static libraries. A shared	1
of 64-bit integer calculations. It	1
of 64-bit Windows may be	1
of 64-bit integers. The allocation	1
of 64-bit software, but it	1
of C++ and assembly code	2
of C++ and Fortran code.	1
of C++ but is not	1
of C++ should allow compile-	1
of C++ compilers to see	1
of C++ projects can be	1
of C++ relates to security.	1
of such container classes. Unfortunately,	1
of such contentions is that	1
of such checks makes the	1
of efficient container classes. An	1
of array elements of simple	1
of array ; jump to	1
of array element a[i] is	1
of array bounds is probably	1
of array elements. Example: //	1
of possible pointer aliasing is	1
of possible overflow on the	1
of possible inputs is limited	1
of possible inputs. Let's take	1
of possible remedies against this	1
of clock pulses since the	1
of objects is not known	1
of objects is often implemented	1
of objects is known at	1
of objects is high then	1
of objects in a computer	1
of objects in computer games.	1
of objects can be allocated	1
of objects they contain is	1
of variable size can be	1
of variable storage are explained	1
of variable storage Variables and	1
of variable size. The alternative	1
of variable storage............................................................................. 26 7.2	1
of any function are called	1
of any size other than	1
of some of the heavy	1
of some long vector math	1
of some help if you	1
of variables can be stored	1
of return prediction). 149 All	1
of 2 is faster than	1
of 2 and the matrix	1
of 2 in example 14.7b,	1
of 2 in order to	1
of 2 can be done	1
of 2 // Still faster	2
of 2 or not. The	1
of 2 if the objects	1
of 2 if the elements	1
of 2 if the rows	2
of 2 if a matrix	1
of 2 if possible and	1
of 2 by using a	1
of 2 when multiplying with	1
of 2 then the multiplication	2
of 2 then N&(N-1) is	1
of 2 double Intel SVML	1
of 2 return powN<(N &	1
of 2 template <int N>	1
of 2 does not always	1
of 2 does not apply	1
of 2 Integer division by	1
of 2 (See page 137	1
of 2 applies only when	1
of 2 (i.e. 2, 4,	1
of table lookup can be	1
of performance on AMD and	1
of performance has high priority.	1
of performance monitoring options. CPU	1
of software that dates back	1
of software can cause problems	1
of software with network access	1
of software into an excessive	1
of software programmers to some	1
of software specifies the calculation	1
of software development, and that	1
of software develop- ment in	1
of order or do more	1
of order execution All modern	1
of order execution ................................................................................................. 103	1
of 32-bit integers and 64-bit	1
of branch that can go	1
of branch prediction. A loop	1
of branch prediction. If one	1
of member pointers if it	1
of elements is small then	1
of elements is known at	2
of elements to store is	1
of elements in a vector	1
of elements in a vector.	2
of elements in an array	1
of elements in vector Type	1
of elements in each vector	1
of elements in table The	1
of elements in list in	1
of elements per vector. The	1
of elements per vector. You	1
of elements per row is	1
of elements Total size of	2
of elements Size of each	1
of const double A =	1
of 4 floats A structure	1
of 4 floats exp function	1
of call and return and	1
of 8 - 64 Kbytes	1
of 8 bits each, eight	1
of 8 bytes each. The	1
of 8 kb size with	1
of operating system All newer	1
of operating system......................................................................................... 6 2.4	1
of unsigned integers to floating	1
of register is volatile. The	1
of register stack versus XMM	1
of register variables. 9.5 Alignment	1
of register temp in one	1
of register renaming and doing	1
of 64 bits total size,	1
of 64 bits each. The	1
of 64 bytes. Each line	1
of optimization is needed. The	1
of optimization is requested. See	1
of optimization can sometimes be	1
of optimization by executing instructions	1
of how to use induction	1
of how to make different	1
of how to make aligned	1
of how to do this.	1
of how to avoid dynamic	1
of how to break a	1
of how compilers and microprocessors	1
of how compilers work. The	1
of code. The second way	1
of code. Example: // Example	1
of code. Each compiler does	1
of code. Furthermore, most C++	1
of time. The objects are	1
of time. A part of	1
of time. You can avoid	1
of template parameters. A template	1
of registers is very limited.	1
of registers is doubled. This	1
of registers has been doubled.	1
of registers used. Conversion of	1
of pointers to the different	1
of pointers to its variables	1
of pointers to its functions,	1
of pointers may not work	1
of pointers because this method	1
of test data and measure	1
of test data instead of	1
of test data. The test	1
of test data. That being	1
of user interface framework must	1
of user interface framework Most	1
of user interface framework........................................................................... 14	1
of user input in order	1
of user interfaces and interfaces	1
of these functions is higher	1
of these instruction sets. The	1
of these instruction sets. Most	1
of these cache lines belong	1
of these compilers can be	1
of these two values is	1
of these two gives the	1
of these also treat non-Intel	1
of these methods are time	1
of these methods then the	1
of these directives are compiler-specific.	1
of these conditions is not	1
of these classes. Size of	1
of these purposes. Unfortunately, the	1
of these manuals are always	1
of these guidelines by using	1
of these obstacles and to	1
of these categories: File input/output	1
of 16 bits each, four	1
of 16 bytes. Some CPUs	1
of system code. In this	1
of system programming, but in	1
of 32 bits each, or	1
of programming will typically get	1
of programming language is a	1
of programming language and interface	1
of programming language Before starting	1
of programming language ............................................................................... 8	1
of programming languages and their	1
of programming languages, operating systems,	1
of programming style. The time	1
of programming style. The advantages	1
of programming style. It is	1
of programming style. Some compilers	1
of programming experience before trying	1
of dynamic memory allocation is	1
of dynamic memory allocation can	1
of dynamic memory allocation are:	2
of dynamic memory allocation. This	1
of dynamic allocation and deallocation	1
of dynamic linking are: 146	1
of bits in an integer,	1
of operations in order to	1
of operations can be carried	1
of type short int in	1
of type T // Constructor	1
of type int. Therefore, it	1
of short vector math libraries:	1
of simple types because the	1
of instructions for fast access	1
of processors is better. Whenever	1
of processors that support a	1
of processors that support it.	1
of processors on which it	1
of available registers is limited.	1
of error is to access	1
of error known as memory	1
of error reporting. For example,	1
of making the number of	1
of making the arrays very	1
of making the container expandable,	1
of making the entire program	1
of making two threads where	1
of making software more clear	1
of making sure that one	1
of making sure that variables	1
of times to test //	1
of times each function and	1
of times before the performance	1
of times CriticalFunction is called	1
of stack unwinding The preceding	1
of stack unwinding .............................................................................. 65	1
of its time in library	1
of its time on processors	1
of its time waiting for	1
of its members are then	1
of its binary representation is	1
of its child class by	1
of its arguments. This closely	1
of its simplicity. But a	1
of CPUs is increasing faster	1
of CPUs such as AMD	1
of CPUs increased the available	1
of CPUs unequally can become	1
of extra instructions for converting	1
of extra resources. Each graphics	1
of assembly language for CPU-intensive	1
of large memory blocks, or	1
of large arrays if it	1
of arrays and structures. Useful	1
of arrays in C and	1
of arrays that you want	1
of arrays with bounds checking	1
of work into each thread.	1
of calls to log, and	1
of calculations then you have	1
of calculations without the need	1
of calculations forms a long	1
of execution speed to using	2
of processor models on which	2
of bytes to find the	1
of big memory blocks is	1
of threads is discussed on	1
of threads with the same	1
of necessary communication between threads	1
of element number i. The	1
of specific CPU models if	1
of specific processor models rather	1
of virtual function calls is	1
of virtual functions. The template	1
of several drivers, configuration files	1
of common string functions as	1
of exception handling Exception handling	1
of allocated resources. The system	1
of small microcontrollers: Smaller microcontrollers	1
of overflow is "undefined". This	1
of overflow and loss of	1
of overflow and redo the	1
of overflow Integer to float	1
of integers to floating point	1
of integers and other hardware-related	1
of integers with a very	1
of good development tools, rather	1
of Linux and perhaps Mac	1
of classes and member functions	1
of precision for reasons explained	1
of precision on most processors	1
of four parameters to be	1
of four (or eight) points	1
of four floats F32vec4 xxn(x4,	1
of four float. The type	1
of four float's fits into	1
of parameters then make it	1
of known type, but you	1
of container classes are given	1
of container classes on page	1
of eight 16-bit integers or	1
of eight 16-bit integers. The	1
of whether you are using	1
of whether they are integers	1
of list plus i*sizeof(S1). This	1
of structure and class members	1
of structure or class elements.	1
of structure or class objects.	1
of doing the same thing	1
of doing floating point operations	2
of doing type conversions: //	1
of doing things only after	1
of doing whole program 81	1
of every intermediate version. For	1
of every version. For team	1
of standard C, specifying that	2
of hardware platform The choice	1
of hardware platform for a	1
of hardware platform has become	1
of hardware platform ....................................................................................... 5	1
of optimizing the software for	1
of optimizing ............................................................................................... 4 2	1
of optimizing University courses in	1
of memory. See page 89	1
of memory. These methods are	1
of memory. One kilobyte is	1
of information about bugs, compatibility	1
of intermediate code is that	1
of both parent and child	1
of programs should be standardized	1
of problems you must make	1
of space on the stack	1
of microprocessor The benchmark performance	1
of microprocessor ........................................................................................... 6 2.3	1
of branches and function calls	1
of branches and switch statements	1
of branches that take up	1
of branches every time the	1
of typically 30 ms for	1
of complicated algorithms is that	1
of handling errors without using	1
of handling cleanup jobs is	1
of dependency chains is stronger	1
of their time waiting for	1
of their execution time on	1
of their 23 software. This	1
of their superior performance/price ratio.	1
of Boolean operands The operands	1
of Boolean operands. You cannot	1
of Boolean algebra, it is	1
of 256 Kbytes to 2	1
of intrinsic vectors requires alignment	1
of signed integers in case	1
of development are more important	1
of mathematical functions that 150	1
of mathematical purity. In many	1
of mathematical purity. For example,	1
of separate layers of abstraction	1
of #include directives and declare	1
of #include directives. This is	1
of various instruction sets can	1
of zero within a block	1
of parameter transfer is avoided	1
of parameter transfer is avoided.	1
of parameter transfer for 'this'	1
of induction variables can also	1
of n being out of	1
of n floats: float *	1
of string classes use dynamic	1
of end user's computers. At	1
of && is false, then	1
of data. The code goes	1
of data. The need for	1
of data. The similarity between	1
of data. This is data	1
of data. This makes position-	1
of data. A hash table	1
of data. Use an old	1
of runtime DLL's (dynamically linked	1
of || is true, then	1
of expressions and other compilers	1
of expressions where operands have	1
of longer response times for	1
of optimizations is that it	1
of optimizations in different C++	1
of graphics objects in computer	1
of graphics cards, etc. Use	1
of public functions and data	1
of Intel, AMD and VIA	9
of microprocessors are very similar	1
of microprocessors from Intel, AMD	1
of platform is obviously influenced	1
of your software. A negative	1
of bigger vector registers. The	1
of << and | operations	1
of binary data storage is	1
of storage is determined where	1
of storage space. It should	1
of 10 - 20 clock	1
of 10 double xpow10(double x)	2
of CPUs. The performance on	1
of CPUs. These costs can	1
of a[i] and shift out	1
of advanced development tools. The	1
of advanced mathematical functions are	1
of advanced features rarely found	1
of points is not divisible	1
of range is possibly more	1
of range and we don't	1
of range } } This	1
of range (see page 134	1
of range printf(Greek[n]); } The	1
of modules or resource files	1
of smaller sizes (char, short	1
of things that the programmer	1
of things you can do	1
of main memory. A register	1
of my experiment are given	1
of errors in C++ programs	1
of errors in C++ programs.	1
of unused bytes in a	1
of unused bytes can be	1
of columns a power of	1
of columns in a matrix	3
of dynamically linked library functions.	1
of consecutive variables. Example: //	1
of modern microprocessors is obtained	1
of modern microprocessors is split	1
of modern CPUs, as described	2
of modern software, it is	1
of 2. The following example	1
of 2. Example: // Example	2
of 2. Using hexadecimal numbers,	1
of 2. Objects bigger than	1
of 2. Contentions in the	1
of variables. Move the conversions	1
of lines is 8*1024/64 =	1
of position-independent code. 147 14.12	1
of out-of-order execution. The most	1
of out-of-order execution, you have	1
of resources. For these reasons,	1
of resources. Consider running the	1
of task switching. This cost	1
of costs to multithreading that	1
of S1 in the array	1
of S1 aligned // Structure	1
of math functions should work	1
of temp before it is	1
of inlined functions may not	1
of constants is very fast	1
of constants we can define	1
of bool in order to	1
of special vector registers. The	1
of algorithm is very important	1
of sum depends on the	1
of Linux, BSD and Mac	1
of registers. This problem has	1
of registers. There are eight	1
of alignment problems. It is	1
of compatibility with some legacy	1
of compatibility with existing systems	1
of compatibility with legacy code,	1
of compatibility problems and system	2
of macro expansions. Programmers do,	1
of 100 floats for (int	1
of 100 numbers: // Example	1
of 100 doubles: union {double	1
of reduced performance. 25 Since	1
of operations. A complex digital	1
of time, it also makes	1
of copying it Use a	1
of copying blocks of memory.	1
of optimization. 14 Portability C++	1
of containers is the Standard	1
of disk caching, but it	1
of unknown brand or model	1
of counters in each CPU	1
of 2, so the compiler	1
of full optimization. It is	1
of N with the rightmost	1
of N into the individual	1
of N template <int N>	1
of RAM memory may even	1
of RAM memory. Big arrays	1
of RAM memory. Efficient caching	1
of rows and columns in	2
of compiling multiple .cpp files	1
of compiling without -fpic in	1
of precision. Let's repeat the	1
of algebraic reduction. For example,	1
of structures and classes. The	1
of structures (without member functions)	1
of logical processors available can	1
of logical processors. There is	1
of heap management and garbage	1
of smart pointers are auto_ptr	1
of nontemporal write instructions becomes	1
of bounds checking is explained	1
of resource problems and compatibility	1
of cores in order to	1
of cores or logical processors	1
of cores will grow in	1
of parallel execution. Example: //	1
of calculating the value each	1
of ebx that was saved	1
of e.g. four floats. The	1
of sizes other than 8,	1
of sizes 1, 2, 3,	1
of list[i] is equal to	1
of statements that you want	1
of course a considerable job,	1
of course be the easiest	1
of course be a destructor	1
of course make the program	1
of course also time consuming,	1
of course inefficient. Variables declared	1
of course far from optimal.	1
of course system-specific. In order	1
of templates where the type	1
of templates makes the code	1
of CriticalFunction in example 13.1	1
of seconds and wait until	1
of CPU. These methods also	1
of f is set by	1
of f cout << x.f;	1
of F1 without returning. F1	1
of setting a register to	1
of added information about the	1
of approximately seven significant digits,	1
of order. See page 103	1
of order. Long dependency chains	1
of situations where the number	1
of 256-bit size are only	1
of finding a suitable pivot	1
of purposes such as email	1
of usability problems and necessary	1
of overflow. The exception is	1
of overflow. Table 8.1 (page	1
of storage. See page 26.	1
of addition, subtraction, multiplication, etc.	1
of everything else. This normally	1
of everything else. System code	1
of (or in addition to)	1
of parent and child are	1
of parent and child class	1
of parent class and derived	1
of temporary objects for intermediate	1
of procedure 4 Most of	1
of iterations is not divisible	1
of background processes running, and	1
of CPUs, different types of	1
of additions and shift operations.	1
of additions and multiplications. Subtractions	1
of j as index then	1
of fastest possible access to	1
of devices and machines with	1
of branch. After each iteration	1
of zero. A good implementation	1
of multiplying by 3, 5	1
of software. For more on	1
of jump targets. A switch	1
of vectors. 12.10 Conclusion There	1
of lazy loading of the	1
of lazy binding is that	1
of 1, 2, 4 or	1
of vector, such as 32-bit	1
of vector, bits Vector class,	1
of vector, bits Instruction set	1
of algebra in a compiler.	1
of algebra are the same	1
of suitable containers class templates	1
of Java and C# and	1
of Java are based on	1
of optimizations. The results are	1
of exceptions a function can	1
of machine instructions executed, cache	1
of changes in the clock	1
of storing data without caching	1
of storing strings in character	1
of 2: // Example 14.7b.	1
of 2: template <bool IsPowerOf2,	1
of composite type is most	1
of bits. The method is	1
of bits. This is usually	1
of speed. Assume that you	1
of thousand numbers as a	1
of Intel's Math Kernel Library	1
of course, and causes the	1
of course, that you compile	1
of course, if the value	1
of course, because you will	1
of course, but this is	1
of scope or namespaces. Therefore,	1
of Func with a lot	1
of Func ;a ;r ;	1
of c1 before MemberPointer is	1
of portability to 64-bit mode,	1
of comparing signed with unsigned	1
of computers and my manual	1
of B before the calculation	1
of five manuals is copyrighted	1
of five manuals. See page	1
of five manuals: 1. Optimizing	1
of poor CPU dispatching. For	1
of self-relative references in 32-bit	1
of truncation and make a	1
of powerful development tools. One	1
of C++, directly compiled code	1
of C++, Pascal and Fortran	1
of mixed sizes. For example:	1
of branches. Manual 3: "The	1
of communication with a remote	1
of inheritance is now as	1
of backwards compatible instruction sets	1
of backwards compatibility with a	1
of memset and memcpy is	1
of context switches is smaller	1
of context switches by making	1
of reducing the number of	1
of development, testing and maintenance	1
of abc is a power	1
of abc is 12 bytes.	1
of abc can be increased	1
of 250 ms. This delay	1
of computing resources. Typically, a	1
of pointers, by initializing pointers	1
of physical processors and the	1
of nonzero floating point numbers	1
of unacceptably long response times	1
of n! is calculated from	1
of Basic is Visual Basic	1
of Basic was too slow.	1
of valid addresses, or if	1
of CPU-intensive software is to	1
of CPU-intensive programs when the	1
of manuals. 7.1 Different kinds	1
of 18 software optimization is	1
of two. In the preceding	1
of ebx. The next two	1
of ebx. Only the registers	1
of m and therefore cannot	1
of bad CPU dispatching. Obviously,	1
of resources, and the transitions	1
of declaring an integer of	1
of defining integer types of	1
of precision, as explained on	1
of precision, especially in floating	1
of u.f We can take	1
of overflow, such as simple	1
of modifications to the code	1
of efficiency. The expression (Tuesday	1
of efficiency. Using unaligned reads	1
of transferring the variable as	1
of structured and object-oriented programming,	1
of structured software development and	1
of going either way. Such	1
of float, double and long	1
of alloca over new and	1
of unit-testing It is common	1
of unit-testing ...................................................................................... 156 16.3	1
of sequential instructions, where a	1
of error. The calculations may	1
of abstraction is a common	1
of abstraction in the logical	1
of abstraction which makes detailed	1
of code). If the repeat	1
of aligning dynamically allocated memory.	1
of numbers: // Example 12.8a.	1
of calculations: // Example 8.3a	1
of calculations, where each calculation	1
of xxn rather than the	1
of int. A short int	1
of position- independent code, see	1
of C++. Yet, D is	1
of A, B and C	1
of text strings in classes	1
of Pascal used an intermediate	1
of overflow: // Example 7.25	1
of coefficients is calculated at	1
of longjmp if possible. Don't	1
of competing brands of microprocessors	1
of efficiency, platform independence, and	1
of bookkeeping in order to	1
of technical problems. Some common	1
of organizing the data. A	1
of measuring performance by unit-testing	1
of (0,0,0,0,0,0,0,0) __m128i zero =	2
of (0,0,0,0,0,0,0,0) Is16vec8 zero(0,0,0,0,0,0,0,0); //	1
of microprocessor. These algorithms are	1
of returning a composite object,	1
of security. b & 1	1
of (2n / b) etc.	1
of vectors, as is often	1
of truncation. This is approximately	1
of double, then sizeof(S1) would	1
of mispredictions (see page 43).	1
of allocations is limited. Dynamic	1
of n. The constant (2n	1
of interpreting the same bits	2
of jumping around and less	1
of x. This is only	1
of (2,2,2,2,2,2,2,2) __m128i two =	2
of (2,2,2,2,2,2,2,2) Is16vec8 two(2,2,2,2,2,2,2,2); //	1
of accumulators for floating point	1
of interpretation or compilation before	1
of expressions, but no compiler	1
of jobs. For example, one	1
of c+b will generate an	1
of CriticalFunction. You cannot avoid	1
of keeping a CPU dispatcher	1
of keeping data together. Data	1
of dangers to be aware	1
of semaphores, mutexes, etc. is	1
of course. A branch that	1
of course. It is the	1
of it, for example if	1
of range"; } else {	1
of range"; 134 } else	1
of range. The next line	1
of range. This may typically	1
of programming. The CPU dispatcher	1
of programming. 13.3 Difficult cases	1
of starting and stopping threads.	1
of underflow. The fact that	1
of predefined vector classes are	1
of ArraySize by the value	1
of experiments on seven different	1
of irrelevant software installed, a	1
of cross-platform portability. Unfortunately, the	1
of iterations. The advantage of	1
of Numerically Intensive Codes", by	1
of Numerically Intensive Codes", SIAM	1
of sharing the same cache	1
of digital building blocks such	1
of received data in a	1
of matrix[j][0] is calculated internally	1
of squares: const int TILESIZE	1
of sources. For example, the	1
of algebra, we may write:	1
of factorials: static const int	1
of factorials: const int FactorialTable[13]	1
of coprocessors is beyond the	1
of removing superfluous code, but	1
of relieving a syntax restriction,	1
of b+c will be rounded	1
of convenience - there is	1
of B. In order to	1
of sets). Here, / means	1
of strange and unexpected behaviors.	1
of sets) (line size) =	1
of frustration and waste of	1
of algebra. For example, a	1
of cc[i]+2 is AND'ed with	1
of titles. Literature on code	1
of 64. Each cache line	1
of fine-tuning, testing, verifying and	1
of Mathcad (v. 15.0) is	1
of simultaneous lookups Max. number	1
of view. This instruction set	1
of 0x800 apart. I will	1
of switching to protected mode	1
of i&15 is guaranteed to	1
of if. This is a	1
of solving the problem is	1
of (a+b). This can save	1
of underflow: // Example 7.5.	1
of it). This can be	1
of randomness in order to	1
of &list[100] is (int)(&list[100]) =	1
of it) load into memory	1
of doubles by comparing bits	1
of verifying, debugging and maintaining	1
of downloaded program updates should	1
of structures: // Example 9.1a	1
of multithreading. 7.30 Exceptions and	1
of 1/n! 1., 1./2., 1./6.,	1
of N: #define N1 (N	1
of profiling. When a hot	1
of modularity. For example, it	1
of yesterday's big mainframe computers.	1
of identifier names. We can	1
of attack for hackers. It	1
of security, but may be	1
of matrices. An efficient solution	1
of Denmark. Copyright  2004	1
of temp. The compiler doesn't	1
of ADC (add with carry)	1
of synchronizing and communicating between	1
of habit, it is true	1
of CPU-time in library functions,	1
of DLLs, configuration files, resource	1
of redesign. Some software development	1
of -fpic. This will generate	1
of research on CPU dispatching	1
of rows/columns in matrix 96	1
of inte- ger or double)	1
of sum. The trick is	1
of managing a memory heap.	1
of people. I simply don't	1
of jumps, calls and branches	1
of RAM, a lot of	1
of data", where it is	1
of rounding, but neither faster	1
of losing precision. The compilers	1
of pending instructions in the	1
of usability. This is not	1
of ways). If a program	1
of range"); or better, make	1
of activating the very time-consuming	1
of occupying a cache line.	1
to the function through a	1
to the function go to	1
to the function definition. This	1
to the function declaration. This	1
to the function prototype: void	1
to the code in order	1
to the code cache and	1
to the compiler at compile	1
to the time it takes	2
to the different versions of	1
to the same memory area.	1
to the same memory areas.	1
to the same cache line.	1
to the same cache line,	1
to the same set in	1
to the same object (except	1
to the same object. There	1
to the same resource then	1
to the same object, except	1
to the CPU than the	1
to the instruction set is	1
to the instruction set. These	1
to the instruction xor eax,eax.	1
to the point where it	1
to the integer value of	1
to the class or structure	1
to the most used data.	1
to the most critical part	1
to the Intel libraries. Supports	1
to the library function, and	1
to the object instead of	1
to the number of bits	1
to the value 0x2C so	1
to the called function. But	1
to the address of the	3
to the critical function. The	1
to the critical stride, as	1
to the operating system can	1
to the operating system. This	1
to the first sum, then	1
to the new block. Any	1
to the new context. It	1
to the user and prevent	1
to the user if such	1
to the user interface. Applications	1
to the constant 5. But	1
to the stack is a	1
to the stack when CriticalInnerFunction	1
to the stack pointer. Likewise,	1
to the Gnu compiler in	1
to the Gnu compiler manual.	1
to the function. The overhead	1
to the function. In the	1
to the calculations are available	1
to the best possible version.	1
to the thread in which	1
to the exception handler in	1
to the power of 10	2
to the power of N	1
to the AVX instructions. A	1
to the standard template library	1
to the standard calling conventions.	1
to the sign bit, the	1
to the copy constructor and	1
to the allocation process because	1
to the next block. A	1
to the next step in	1
to the dispatcher function. When	1
to the programmer that pointers	1
to the end user. The	1
to the end user. There	1
to the end user. Dynamic	1
to the end user. Menus,	1
to the calling program is	1
to the second sum, then	1
to the x86 instruction set	1
to the old Pentium 4.	1
to the appropriate function version	1
to the appropriate version of	2
to the appropriate version (May	2
to the desired function version	1
to the desired version of	1
to the desired version in	1
to the desired function. The	1
to the desired version. Note	1
to the inlined function and	1
to the inlined function. Function	1
to the preceding one (see	1
to the preceding label plus	1
to the right in order	1
to the right version of	2
to the right format and	1
to the offset of the	1
to the object. The allocation	1
to the object. If the	1
to the so-called partial flags	1
to the total execution time.	1
to the total calculation time.	1
to the total computation time.	1
to the disk cache. Files	1
to the situation where a	1
to the previous value. Example:	1
to the vector. The other	1
to the length of a	1
to the beginning of the	4
to the current position. Windows	1
to the user. Making exception-safe	1
to the user. Compatibility problems.	1
to the hard disk if	1
to the required amount of	1
to the general case where	1
to the table. Optimization method	1
to the rules of algebra,	1
to the availability of powerful	1
to the structure. Incrementing or	1
to the profiler. The result	1
to the rest of the	1
to the console or to	1
to the modulo operator %.	1
to the dispatcher. // After	1
to the area of system	1
to the diagonal. The elements	1
to the selected version FuncType	1
to the parameter, and the	1
to the nearest integer. If	1
to the $B1$2 label if	1
to the CPU-specific versions of	1
to the first-in-last-out nature of	1
to the container. Can the	1
to the reader what is	1
to the tolerance may be	1
to the IEEE standard 754	1
to the truth depends on	1
to the standards for the	1
to the next. The carry	1
to the exponent: // Example	1
to the design of small	1
to the device. Any language	1
to is a power of	1
to is identical to some	1
to is deleted when the	1
to is known. Example: //	1
to a = b *	1
to a function is by	1
to a function in a	2
to a function that doesn't	1
to a function prototype to	1
to a more well-structured program	1
to a different code address	1
to a different platform is	1
to a different address. A	1
to a class member function	1
to a class member function.	1
to a floating point number	1
to a pointer of a	1
to a pointer to a	1
to a pointer to an	1
to a pointer to its	1
to a pointer to another	1
to a pointer then its	1
to a float or double	1
to a static object defined	1
to a clock cycle on	1
to a variable in memory	1
to a variable that could	1
to a variable declaration to	1
to a table of pointers	1
to a branch tree. On	1
to a < b because	1
to a const function that	1
to a new version without	1
to a file is faster	1
to a function. Using an	1
to a specific CPU model	1
to a specific CPU core	2
to a specific load address.	1
to a virtual table before	1
to a signed integer if	1
to a better understanding of	1
to a longer size by	1
to a graphics function is	1
to a graphics function that	1
to a graphics library or	1
to a public variable where	1
to a smaller size is	1
to a pointer. It is	1
to a global variable means	1
to a limited audience for	1
to a local const variable	1
to a local variable. This	1
to a macro in the	1
to a usability problem in	1
to a pure function with	1
to a derived class, it	1
to a base class is	1
to a structure. For example:	1
to a command or do	1
to a valid address. Pointers	1
to a dispatcher. The dispatcher	1
to a dramatic degradation of	1
to a contained object because	1
to a wrong type. References	1
to a complete redesign of	1
to a non-member function, means	1
to a floppy disk. A	1
to a matrix. For example,	1
to a narrow range then	1
to a driver involves the	1
to a printer or other	1
to and you can do	1
to be the optimal choice	1
to be the fastest solution	1
to be a register variable.	1
to be a bottleneck than	1
to be in the level-1	1
to be in the interval	1
to be as small as	1
to be an expression or	1
to be an obvious thing	1
to be an annoying time	1
to be very long and	1
to be faster than a	1
to be stored in a	1
to be stored in memory,	1
to be less than the	1
to be less than 231.	1
to be 0 or 1	1
to be 0 or 1.	1
to be available in 2015	1
to be compiled with different	1
to be done at every	1
to be done outside the	1
to be calculated with two	1
to be able to inline	1
to be able to recover	2
to be put into the	1
to be too small. Are	1
to be too small, then	1
to be transferred in registers	2
to be transferred in registers.	1
to be transferred in registers,	1
to be read and written	1
to be aligned by the	1
to be higher due to	1
to be divisible by the	1
to be called. It is	1
to be predicted by the	1
to be loaded from memory	1
to be loaded at an	1
to be limited by the	1
to be inlined by declaring	1
to be possible. Template meta-	1
to be changed to truncation	1
to be true anyway. It	1
to be initialized when the	1
to be scattered around at	1
to be mispredicted (See manual	1
to be mispredicted whenever it	1
to be false regardless of	1
to be converted to OMF	1
to be designed so as	1
to be fragmented and involve	1
to be distributed to the	2
to be slower or require	1
to be slower than the	1
to be aware of when	1
to be aware of these	1
to be available, we may	1
to be equal to the	1
to be updated every time	1
to be expressed as a	1
to be cleaned up include:	1
to be cleaned up, as	1
to be obsolete. Programmers very	1
to be spaced by a	2
to be filled up. This	1
to be stored. All identical	1
to be inlined. But beware	1
to be evicted from the	1
to be pure. This allows	1
to be overwritten, and even	1
to be irrelevant within a	1
to be profitable (see page	1
to be cached more efficiently	1
to be deleted. User work	1
to be slower. Many compilers	1
to be moved. A binary	1
to be installed. The installation	1
to be mispredicted, which causes	1
to be restored before the	1
to be saved. Any other	1
to be renewed. Context switches	1
to be platform-independent and compact.	1
to be reloaded eight times	1
to be signed. Be sure	1
to be noticeable but not	1
to be resized in the	1
to be annoying. We may	1
to are constant. 14.2 Bounds	1
to can be accessed approximately	1
to can be accessed. Pointer	1
to function names. But a	1
to by r is re-loaded	1
to by p is identical	1
to code the offset as	1
to an integer takes a	1
to an object of the	1
to an object of class	1
to an array of structure	1
to an array and for	1
to an address divisible by	1
to an intermediate file format	1
to an output file. A	1
to an inlined 15.1b and	1
to an integer, and this	1
to an integer, or an	1
to an existing program. Weighing	1
to int in the critical	1
to int x = 10;	1
to x 43 speculatively executing	1
to have the same value.	1
to have the member functions	1
to have a standard function	1
to have a strategy for	1
to have no other value	1
to have two or more	1
to have many different CPUs	1
to have separate containers for	1
to have just two branches:	1
to have constructors and destructors.	1
to this the time it	2
to this number we get	1
to this manual at www.agner.org/optimize/cppexamples.zip	2
to this manual at www.agner.org/optimize/cppexamples.zip.	1
to this problem is to	2
to this problem are the	1
to this argument is that	1
to use the same memory	1
to use the functions memset	1
to use the most complicated	1
to use the Intel compiler	1
to use the static version	1
to use the const keyword	1
to use the bit scan	1
to use the AVX instructions.	1
to use the well optimized	1
to use the high processing	1
to use the vectors of	1
to use the #pragma vector	1
to use the bitwise operators	1
to use the default integer	1
to use the memcpy function	1
to use the Gnu, Clang,	1
to use the smallest data	1
to use the smallest integer	2
to use the newest instruction	1
to use the lrint function:	1
to use a compiler option	1
to use a different operating	1
to use a loop for	1
to use a loop counter:	1
to use a set of	1
to use a version control	1
to use a new register	1
to use a constant reference	1
to use a container that	1
to use a container or	1
to use a lookup table	1
to use a lookup table:	1
to use a systematic and	1
to use a union, as	1
to use and returns a	1
to use in case the	1
to use for a particular	1
to use for each processor	1
to use for many programmers	1
to use that for a	1
to use it for lists	1
to use an integer size	1
to use than pointers because	1
to use than others. While	1
to use this complicated template	1
to use vector operations on	1
to use vector instructions (see	1
to use vector operations. You	1
to use vector classes, as	1
to use float rather than	1
to use multiple CPU cores	1
to use static linking, as	1
to use 64-bit systems if	1
to use 32-bit integers in	1
to use dynamic memory allocation	1
to use dynamic memory allocation.	1
to use assembly code or	1
to use assembly language. In	1
to use exception handling even	1
to use inline assembly code	1
to use intrinsic functions or	1
to use induction variables for	1
to use string classes, such	1
to use later in the	1
to use depends on what	1
to use vectorized code or	1
to use it. Complicated code	1
to use algebraic manipulations on	1
to use hyperthreading or not	1
to use denormal numbers. You	1
to use SafeArray: // Example	1
to use try, catch, and	1
to memory without loading a	1
to memory management and garbage	1
to at a lower priority	1
to data in the old	1
to data through function calls.	1
to data within the DLL	1
to make the function a	2
to make the code more	3
to make the code smaller	1
to make the compiler treat	1
to make the data fit	1
to make the functions that	1
to make the most critical	1
to make the number of	1
to make the array size	1
to make the address calculation	2
to make the matrix 512	1
to make the division faster.	1
to make the local object	1
to make the rows in	1
to make the measurements as	1
to make the scope of	1
to make the SelectAddMul example	1
to make a function local:	1
to make a CPU dispatcher	1
to make a loop count	1
to make a pointer to	1
to make a variable global	1
to make a test program	1
to make a new branch	1
to make a new instance	1
to make a single call	1
to make a small test	1
to make a multiplication and	1
to make a piece of	2
to make a negative list	1
to make a positive list	1
to make a misprediction every	1
to make a reliable decision.	1
to make a non-inlined copy	1
to make a variable-size array	1
to make a sensible balance	1
to make a lookup-table static.	1
to make a thread-like scheduling	1
to make a zip file	1
to make a destructor. A	1
to make a bit-mask which	1
to make and therefore more	1
to make it in the	1
to make it possible to	1
to make code that makes	1
to make this work on	1
to make more efficient code,	1
to make different objects share	1
to make one version that	1
to make floating point register	1
to make multiple code versions	1
to make two versions of	1
to make table of const	1
to make software that runs	1
to make software packages faster	1
to make member functions static	1
to make register variables because	1
to make pointers efficient, and	1
to make sure the compiler	1
to make sure the object	1
to make sure the arrays	2
to make sure the result	1
to make sure the information	1
to make sure that the	3
to make sure that no	2
to make sure that they	1
to make sure that overflow	1
to make sure that certain	1
to make sure that everything	1
to make sure it is	1
to make sure its size	1
to make sure everything that	1
to make overflow checks where	2
to make container classes in	1
to make support for the	1
to make shared objects without	1
to make their software faster.	1
to make better use of	1
to make aligned arrays with	1
to make special versions of	1
to make 16-bit programs, except	1
to make profiling feasible. Interference	1
to make explicit checks for	1
to make CPU- specific optimizations	1
to make thread-specific data is	1
to make log2 a global	1
to make memory-hungry software in	1
to different dynamically allocated objects	1
to different platforms because it	1
to different tasks. For example,	1
to functions and public variables	1
to CPU dispatching. Underestimating the	1
to other parts of the	1
to other platforms and other	1
to other platforms as well,	1
to point to a valid	1
to all of these classes.	1
to all class objects and	1
to all allocated objects and	1
to all local non-member functions.	1
to all instances of the	1
to all zeroes. Example: //	1
to one of the elements	1
to one of the base	1
to one of these categories:	1
to one class to a	1
to one thread than another.	1
to cache misses, branch misprediction,	1
to integer can be done	1
to integer takes a long	1
to integer without SSE2 typically	1
to integer conversion Conversion of	1
to integer According to the	1
to set the flush-to-zero mode	1
to set the parentheses manually.	1
to set an array to	1
to set number 0x1C. There	1
to set up the performance	1
to set seconds to zero	1
to class C1 or C2,	1
to floating point is faster	2
to floating point if the	1
to floating point numbers is	1
to floating point expressions. Floating	1
to floating point Conversion of	1
to floating point. Conversion of	1
to floating point: // Example	1
to each compiler with the	1
to each other (not member	1
to each new version for	1
to each element in vector	2
to each task or thread	1
to do the CPU dispatching	1
to do the necessary calculations	1
to do the check after	1
to do the dispatching only	1
to do the reductions manually.	1
to do the algebraic reductions	1
to do the reduction in	1
to do the divisions (Division	1
to do the conversion. The	1
to do the devirtualization (see	1
to do is to enable	1
to do a floating point	1
to do a lot of	1
to do a thorough analysis	1
to do and which optimizations	1
to do it explicitly. In	1
to do as much as	1
to do an integer addition,	1
to do this optimization explicitly.	1
to do this optimization. 8.2	1
to do this manually. This	1
to do more complicated reductions.	1
to do more reductions on	1
to do when you want	1
to do different kinds of	1
to do integer operations in-between	1
to do multiple things at	1
to do two additions with	1
to do two jobs simultaneously.	1
to do such a check	1
to do any algebraic reductions	1
to do some measurements to	1
to do so is a	1
to do so is also	1
to do so will cause	1
to do so (i.e. if	1
to do operations on all	1
to do simple integer calculations	1
to do calculations on the	1
to do optimizations such as	1
to do things in parallel.	1
to do things in parallel:	1
to do things with pointers	1
to do something about it.	1
to do something about them.	1
to do this: Use assembly	1
to do this. Unfortunately, the	1
to do so. The compilers	1
to do so. See page	1
to do so. 58 If	1
to do manually. It must	1
to do interprocedural optimizations of	1
to do experiments in order	1
to do immediately before the	1
to do so). A template	1
to do cross-module optimizations when	1
to do searches of the	1
to example 15.1b and d	1
to using a profiler. A	1
to using new and delete	1
to using templates (see p.	1
to using templates. Two or	1
to using templates. Ready made	1
to using namespaces. 65 8	1
to using hyperthreading. On the	1
to using hyperthreading, but the	1
to using inheritance. There may	1
to double In example 7.4	1
to double before multiplying with	1
to double precision before multiplying	1
to b for (i =	1
to b memcpy(b, a, sizeof(b));	1
to i and shifts one	1
to float in this example	1
to float conversion Conversion of	1
to float conversions can sometimes	1
to multiple operating systems. 10	1
to multiple inheritance class B1;	1
to static or global arrays	1
to 64-bit mode, as explained	1
to such a formalism. The	1
to such an object to	1
to efficient use of software.	1
to array elements. The instruction	1
to many hard working software	1
to many users. Firewalls, virus	1
to any other address in	1
to any other number. Therefore,	1
to any known hardware CPU.	1
to some of the most	1
to some other variable in	1
to some extra complications. A	1
to some positive value, n.	1
to return from the function.	1
to return from functions that	1
to return a+1;. The compiler	1
to 2 by putting the	1
to 2 Mbytes. There may	1
to very big data structures.	1
to software optimization. Everything that	1
to 32-bit integers, and they	1
to const definitions when used	1
to 4 clock cycles. In	1
to call the function billions	1
to call the library function	1
to call the library functions	1
to call the version that	1
to call the destructor of	1
to call the destructor for	1
to call the ReadTSC function.	1
to call a function in	1
to call a virtual member	1
to call a polymorphic function	1
to call a polymorphic function.	1
to call a non-virtual member	1
to call or any other	1
to unsigned in order to	1
to unsigned for fast division	1
to unsigned if you are	1
to unsigned int before dividing	1
to first look up the	1
to first convert the unsigned	1
to 64 bits. This is	1
to take a whole workday	1
to take more than an	1
to take into account when	1
to take branch prediction into	1
to take extra precautions to	1
to take advantage of this	1
to take advantage of out-of-order	1
to take longer time than	1
to take special precautions for	1
to take maximum advantage of	1
to take care of all	1
to take care of some	1
to optimization are discussed below.	1
to optimization by compiler There	1
to optimization by compiler .......................................................................	1
to optimization by CPU Modern	1
to optimization by CPU.............................................................................81 8.5	1
to optimization MS compiler Windows	2
to optimization are. Dynamic memory	1
to test the different versions	1
to test the performance under	1
to test the sign of	1
to test a software module	1
to test in the test	1
to test for the availability	1
to test // Time difference	1
to test // (time after)	1
to test on several different	1
to test this is to	1
to test when software uses	1
to test all branches for	1
to test each function or	1
to test 16 bytes at	1
to test several different algorithms	1
to systems with big-endian storage.	2
to user input never exceeds	1
to these problems is quite	1
to even allocate more memory	1
to always use the safe	1
to always true or always	1
to always behave according to	1
to access the system database	1
to access the file until	1
to access a floating point	1
to access a file that	1
to access a public data	1
to access a multidimensional array	1
to access it the first	1
to access an object after	1
to access an element in	1
to access x as an	1
to access these instructions. Function	1
to 16 bytes by adding	1
to 16 lines in a	1
to 32 bit systems: Pointers,	1
to 0 and generate a	2
to 0 // this function	1
to type in the values	1
to & unless you expect	1
to simple things like a	1
to simple actions like a	1
to error handling. You have	1
to stack memory at the	1
to stack memory outside the	1
to stack memory. Copying constant	1
to its variables called global	1
to its own caller, and	1
to its functions, called procedure	1
to its child class. This	1
to assembly language modules when	1
to ; store result in	1
to arrays of structure or	1
to arrays that are bigger	1
to work in both Windows	1
to work for very long	1
to work with any type	1
to work on a Linux	1
to work on all compilers.	1
to work best on future	1
to work around this limitation	1
to (see page 73). Current	1
to execution time. 4 2	1
to avoid the loop overhead.	1
to avoid the calls to	1
to avoid the overhead of	1
to avoid the time- consuming	1
to avoid the burdensome position-independent	1
to avoid that the critical	1
to avoid that some expression	1
to avoid this problem by	1
to avoid this wasteful copying	1
to avoid multiple threads writing	1
to avoid long dependency chains.	2
to avoid these problems. More	1
to avoid dynamic memory allocation.	2
to avoid running the advanced	1
to avoid running two threads	1
to avoid conversions from integer	1
to avoid this. See page	1
to avoid this. (In Windows,	1
to avoid them. Some important	1
to avoid modulo operations: //	1
to avoid hard-to-find errors, and	1
to speed up the calculation	1
to speed up multiplications and	1
to c = a +	1
to single precision. These conversions	1
to virtual function } };	1
to virtual member functions if	1
to compile a shared object	1
to compile for different instruction	1
to compile with the option	1
to compile with -mcmodel=large, but	1
to compile for. The names	1
to exception handling in this	1
to small devices, but there	1
to integers of the default	1
to integers use truncation towards	1
to matrix a in a	1
to Linux in almost all	1
to cause contentions in the	1
to cause seven memory allocations	1
to cause overflow, this code	1
to four bits, and the	1
to another by assignment. shared_ptr	1
to another class. It makes	1
to another platform. 14.8 Conversions	1
to get a good performance	1
to get a realistic number	1
to get as much data	1
to get an integral number	1
to get x to the	1
to get more reproducible time	1
to get used to read	1
to get library versions instead.	1
to get access to the	1
to get reliable results for	1
to get reproducible results. This	1
to get rid of the	1
to check the code that	1
to check for the supported	1
to check for all the	1
to check for overflow outside	1
to check for exceptions thrown	1
to check that thrown exceptions	1
to check if the compiler	1
to check if an array	1
to check if your modifications	1
to check whether an integer	1
to support different CPUs. This	1
to list and make this	1
to run the program in	1
to run the most advanced	1
to run a little faster	1
to run a speed-critical program	1
to run most of its	1
to run two threads in	2
to calculate the function is	1
to calculate the time delay	1
to calculate the same function	1
to calculate the most common	1
to calculate the value of	1
to calculate the value and	1
to calculate the table is	1
to calculate the table in	1
to calculate the table at	1
to calculate the table values	1
to calculate the address of	1
to calculate the addresses of	1
to calculate the absolute value	1
to calculate than the other	1
to calculate when long double	1
to calculate each value from	1
to calculate self-relative addresses is	1
to calculate (c+d) before it	1
to calculate pow(x,10) with only	1
to inline the function and	1
to inline the function, and	1
to inline a function if	1
to inline and optimize both	1
to inline this function and	1
to hardware interfaces and system	1
to add the last element	1
to add i to p	1
to add new features to	1
to add unused columns to	1
to add statements like throw(A,B,C)	1
to store the intermediate result	1
to store is known before	1
to store x in memory	1
to store data because the	1
to store all strings in	1
to store each object in	1
to store many objects together	1
to store objects of different	1
to store intermediate data and	1
to store intermediate results in	1
to store aligned integer vector	1
to store strings in a	1
to store unaligned integer vector	3
to store help files and	1
to store application-specific information in	1
to copy the table from	1
to copy the entire object.	1
to copy that the only	1
to certain programming principles in	1
to addresses divisible by the	1
to addresses divisible by 16.	1
to count how many times	1
to count certain events, such	1
to program. Many programmers have	1
to write the same in	1
to write the variable at	1
to write the file to	1
to write the members individually.	1
to write a + b	1
to write 2.0/3.0 than to	1
to write _mm_add_epi16(a,b). Two libraries	1
to write if(!a && !b)	1
to optimize the code and	1
to optimize the parts of	1
to optimize a piece of	1
to optimize for several different	1
to optimize code that uses	1
to optimize this with induction	1
to optimize this loop? Certainly	1
to optimize register allocation and	1
to optimize away the variable	1
to optimize away an overflow	1
to optimize across function calls.	1
to optimize anything else than	1
to optimize access, as given	1
to optimize caching. Smaller microcontrollers	1
to optimize anything, you have	1
to problems of overflow and	1
to replace the CPU detection	2
to replace the branch by	1
to replace the Gnu compiler	1
to replace a database by	1
to replace a poorly predictable	1
to replace arrays by well-tested	1
to replace u[1] by u[0].	1
to automatically prefetch data for	1
to see the result of	1
to see the excessive memory	1
to see the compiler-generated code	1
to see if the code	1
to see if a certain	1
to see if it is	1
to see if our estimate	1
to see which part of	1
to see which solution is	1
to see how well it	1
to see whether the call	1
to see whether they were	1
to see this. It also	1
to their 32-bit counterparts. In	1
to signed integer doesn't cause	1
to signed before converting to	1
to signed integers before conversion	1
to put the operand that	1
to put the task-specific part	1
to put a test feature	1
to put a parenthesis around	1
to put a tag on	1
to put file access and	1
to put file access in	1
to put time-consuming tasks into	1
to put measurement instruments directly	1
to put time- consuming calculations	1
to zero is sometimes more	1
to zero and then call	1
to zero for (i =	1
to zero that is more	1
to zero // Return the	1
to zero by using memset:	1
to zero than making it	1
to zero at the same	1
to zero We can check	1
to zero whenever the objects	1
to zero memset(a, 0, sizeof(a));	1
to Microsoft compilers. // It	1
to Microsoft Visual Studio when	1
to what the preprocessor can	1
to end of a ;	1
to read the performance monitor	1
to read and write configuration	1
to read and understand compiler-generated	1
to read from a table	1
to read from memory address	1
to give the compiler additional	1
to give the variable two	1
to give each thread its	1
to give higher priority to	1
to look up the function	1
to look up in a	1
to actually doing something on	1
to load the dynamic linker.	1
to load the framework and	1
to load the entire 64	1
to load a program than	1
to load a new cache	1
to load more than one	1
to load several files when	1
to load aligned integer vector	1
to load unaligned integer vector	3
to control the way member	1
to control the addresses of	1
to assume the worst possible	1
to assume that F1 will	1
to assume that *p+2 is	1
to assume no pointer aliasing	1
to dispatch by CPU brand.	1
to your programming questions if	1
to improve the performance significantly	1
to improve cache efficiency, then	1
to improve speed without jeopardizing	1
to improve performance. It is	1
to improve efficiency. These are	1
to binary code and can	1
to know how a cache	1
to know how to avoid	1
to know how to recover	1
to know how this works,	1
to know whether the largest	1
to know what the compiler	1
to know about. Function inlining	1
to generate a store forwarding	1
to generate a piece of	1
to generate an assembly language	1
to generate an interrupt, e.g.	1
to generate many branch mispredictions.	1
to generate interrupts at certain	1
to reduce the number of	1
to reduce this problem. The	1
to reduce example 12.1b to	1
to reduce complicated algebraic expressions.	1
to reduce various algebraic expressions	1
to reduce (a*b*c)+(c*b*a) to a*b*c*2.	1
to 10 means that it	1
to choose the optimal algorithm	1
to choose a software framework	1
to choose between c2 and	1
to choose between. It is	1
to link with external libraries.	1
to just one or a	1
to a[i] More examples of	1
to require modifications in the	1
to switch to protected mode	1
to start the next calculation.	1
to start a new floating	1
to start and stop the	1
to start at an address	1
to start calculations on the	1
to start up, which is	1
to around 1980 where RAM	1
to 5 by another thread.	1
to 5 } } In	1
to 5 times faster either	1
to go the same way	1
to go one way two	1
to go away in the	1
to go deeper into the	1
to change the value of	1
to p is not i	1
to p is therefore equal	1
to become fragmented and caching	1
to become fragmented. An alternative	1
to become invalid, and by	1
to become obsolete within the	1
to turn on this option.	2
to turn off the loop	1
to turn off the computer	1
to turn off the reading	1
to turn off or log	1
to turn off support for	2
to network resources, databases, etc.	1
to desired values before the	1
to code, you may consider	1
to find the one that	1
to find the address of	1
to find the first byte	1
to find the best algorithm.	1
to find the optimal decomposition	1
to find the right function	1
to find and resolve compatibility	1
to find out which one	1
to find out whether it	1
to find hot spots Before	1
to find hot spots ..................................................................................	1
to find elsewhere. Faster than	1
to rely on compiler optimization	1
to rely on automatic vectorization.	1
to produce the same result.	1
to produce binary code). Supports	1
to produce tables of mathematical	1
to out-of-order execution and advanced	1
to platforms that use big	1
to temp even though the	1
to frame functions then the	1
to frame functions. While an	1
to prevent memory leaks and	1
to prevent cache contention. You	1
to prevent such errors is	1
to prevent such errors in	1
to prevent such errors. See	1
to prevent optimizing // Time	1
to save time for the	1
to save some information for	1
to save time. The code	1
to save power. There are	1
to save recovery information for	1
to tell the compiler to	2
to tell the compiler that	4
to tell the compiler not	1
to tell the compiler e.g.	1
to tell a hyperthreading processor	1
to tell these compilers that	1
to tell explicitly what kind	1
to repeat or to exit	1
to unroll the loop and	1
to unroll the loop further	1
to unroll a loop and	1
to unroll a loop manually	1
to unroll a loop. Example:	1
to exponent } Example 14.26	1
to it. This is inefficient	1
to it. Therefore, you should	1
to optimization. Prefetching data The	1
to accessing an object through	1
to divide the work into	2
to divide the work evenly	1
to divide the matrix into	1
to divide the job into	1
to divide the workload between	1
to divide i by 2.	2
to mix the two types	1
to mix different kinds of	1
to mix integer and floating	1
to mix floating point addition	1
to mix simple integer with	1
to mix signed and unsigned	1
to mix mathematical calculations with	1
to fit the biggest vectors:	1
to fit the actual load	1
to fit the eight-element vectors:	4
to fit specific needs. 9.8	1
to predict the target if	1
to predict a switch statement	1
to predict with certainty which	1
to predict which compiler will	1
to predict which variables will	1
to predict which way a	1
to predict which resources are	1
to predict whether the compiler	1
to predict correctly whether vectorization	1
to 128-bit XMM and 256-bit	1
to execute the program, and	1
to execute then the profiler	1
to execute then measurements can	1
to execute it. The load	1
to execute CriticalFunction when code	1
to execute slower than intended	1
to execute _mm_empty() after the	1
to square by the code	1
to fail if the destructor	1
to convert b from single	1
to convert float to int.	1
to convert unsigned integers to	1
to handle the strings including	2
to handle an unrecoverable error	1
to handle only known processors.	1
to handle strings is the	1
to handle unknown processors properly.	1
to insert the piece of	1
to insert a switch in	1
to insert a fixed breakpoint	1
to insert an instruction that	1
to insert optimization hints as	1
to consider which method is	1
to reading as well as	1
to enable the SSE2 or	1
to enable the SSE2 instruction	1
to enable the desired instruction	1
to enable constant propagation and	1
to enable fast floating point	1
to e.g. a menu click	1
to keep the same precision	1
to keep the two modules	1
to keep multiple memory blocks,	1
to keep pointers to all	1
to keep up with the	1
to keep their CPU dispatchers	1
to keep together on the	1
to keep track of the	1
to align its b member	1
to align large objects and	1
to align dynamically allocated memory.	1
to align arrays. // Example	1
to BSD systems. The Intel-based	1
to come from example 15.1b	1
to SSE4.1 and integer division.	1
to CriticalFunction in example 16.2.	1
to swap memory to disk.	1
to swap two array elements:	1
to swap two elements: #define	1
to modify the program to	1
to modify a double by	1
to F1 only if all	1
to gain in speed by	1
to gain if such dependency	1
to gain by optimizing database	1
to gain by unrolling the	1
to apply to. It is	1
to allocate the final array	1
to allocate a new memory	1
to allocate a new bigger	1
to allocate a small block	1
to allocate more RAM than	1
to allocate one big block	1
to allocate variable-size arrays with	1
to metaprogramming would be straightforward.	1
to define function names and	1
to define 64-bit integers, but	1
to define your own error-handling	1
to define application-specific instructions that	1
to implement the many rules	1
to implement the dispatch on	1
to implement a microprocessor in	1
to implement a queue as	1
to implement a universal algorithm	1
to implement in a compiler.	1
to implement this "override" feature.	1
to 256-bit registers named YMM	1
to contain all data members	1
to integers. It is faster	1
to integers. 7.25 Bitfields Bitfields	1
to help the CPU doing	1
to help the programmer choosing	1
to transfer a pointer or	1
to transfer ownership of the	1
to multiply j by is	1
to share the same piece	1
to default constructors, copy constructors,	1
to vectorize the code automatically	1
to vectorize the code explicitly.	1
to vectorize the loop in	1
to vectorize code explicitly by	1
to include the appropriate header	1
to include a performance test	1
to fully utilize systems with	1
to care about the sign	1
to memcpy rather than moving	1
to lower case: // Example	1
to try different libraries and	1
to account for unaligned arrays.	1
to heavy competition. Processors with	1
to general improvements in microprocessor	1
to zero. The [] operator	1
to zero. You may remove	1
to zero. 14.3 Use bitwise	1
to measure the clock count	1
to measure // Number of	1
to measure how much time	1
to measure exactly what you	1
to delete the object. 7.17	1
to delete it and create	1
to disk. Memory swapping is	1
to disk. Software that relies	1
to disk. Provoke cache misses	1
to update the program that	1
to integer. The conversion time	1
to hold the value of	1
to hold the numbers in	1
to hold only one element	1
to 120 ms by selecting	1
to eliminate common sub-expressions. Why	1
to eliminate everything that depends	1
to 127 will generate -128,	1
to debug and maintain. Most	1
to vectorization. The newest instruction	1
to do. The reason why	1
to do. This is called	1
to do. It is important	1
to remove the const restriction	1
to remove the interrupt 3	1
to remove all disturbing influences	1
to remove unreferenced functions. It	1
to transpose the matrix when	1
to transpose a matrix when	1
to transpose a matrix using	1
to transpose and copy matrix	2
to transpose matrix // define	1
to wait for the new	1
to wait for the result	1
to wait for a result	1
to wait for another memory	1
to break a dependency chain.	1
to break down dependency chains	1
to increase the throughput of	1
to increase the likelihood that	1
to identify the critical parts	1
to identify the circumstances around	1
to identify a hot spot.	1
to identify and isolate the	1
to identify performance bottlenecks is	1
to identify individual functions or	1
to call. I have implemented	1
to declare the table static.	1
to declare it locally in	1
to declare objects and fixed	1
to dispatched function call inline	1
to dispatched version return (*SelectAddMul_pointer)(aa,	1
to detect if any objects	1
to normal afterwards. The clock	1
to show how tortuous and	1
to evaluate the loop control	1
to evaluate a only when	1
to evaluate and are equally	1
to evaluate b when a	1
to evaluate whether it is	1
to five or ten years	1
to poor documentation and lack	1
to prefetch data explicitly if	1
to truncation and back again.	1
to base a software package	1
to completely rule out the	1
to roll out the loop	2
to roll out the calculation	1
to roll out a loop	1
to roll out a big	1
to anything it has allocated	1
to increment the loop counter	1
to increment an integer variable,	1
to economize the use of	2
to economize the resource use	1
to economize resource use in	1
to seven times faster than	1
to overcome the dangers of	1
to overcome the obstacle of	1
to overcome this limitation). 14.11	1
to overcome these disadvantages when	1
to maintain. The time you	1
to maintain. If the compiler	1
to maintain. Any specific bottleneck	1
to maintain. And it is	1
to fourteen register parameters. In	1
to fourteen parameters to be	2
to 122 this the time	1
to remote databases usually requires	1
to memset and memcpy, at	1
to install a program package	1
to install a software package	1
to install automatic updates to	1
to consume time at unpredictable	1
to consume more time than	1
to select all installation options	1
to recover in the event	1
to recover from a branch	1
to recover from errors. The	1
to recover from errors. If	1
to recover from exceptions. See	1
to split the tasks into	1
to split up the data	1
to limit the range of	1
to follow the track backwards	1
to compromise on the advanced	1
to understand and therefore difficult	1
to understand when we roll	1
to understand how variables are	1
to specify the compiler option	1
to specify static linking for	1
to compare the performance of	1
to compare two positive floating	1
to compare absolute values: //	1
to valid values or if	1
to CPU-intensive code. But many	1
to wrap the allocated memory	1
to wrap the allocated array	1
to wrap around, (3) trap	1
to sum1 from time T	1
to 15.1c as intended, while	1
to 15.1c would of course	1
to 15.1c was done by	1
to recommend that no function	1
to recommend any specific model.	1
to lead to a more	1
to place the user interface	1
to overlap the call and	1
to overlap the calculations of	1
to obtain the desired polymorphism	1
to obtain the desired functionality	1
to ebx. The square brackets	1
to modulo calculations: // Example	1
to round addresses in order	1
to protected mode and back	2
to distinguish between coarse-grained parallelism	1
to distinguish between recoverable and	1
to distinguish elements with a	1
to distinguish these two versions	1
to clean up in case	1
to clean up then it	1
to contained objects? It may	1
to unsigned. // Example 7.4.	1
to sum2 from time T+1	1
to suboptimal code. Intrinsic functions	1
to uncached memory and we	1
to individual array elements more	1
to begin calculating a new	1
to another. The object that	1
to another. These costs are	1
to recognize VIA processors because	1
to mirror the remote data	1
to force the swapping of	1
to virus attacks and other	1
to alias upon the double.	1
to well-tested functions, classes, templates	1
to zero, by setting pointers	1
to reload the value from	1
to reload the level-1 cache	1
to reload *p and calculate	1
to 12. Higher inputs give	1
to optimization, it does have	1
to ignore overflow or assume	1
to manipulate the data cache.	1
to manipulate the different parts	1
to study the code that	1
to study the available options	1
to 0x273F will be evicted	1
to 0x273F into one of	1
to 0x273F would still be	1
to int. Reinterpret cast The	1
to nearest integer int n;	1
to justify the method. A	1
to justify such a complicated	1
to cover the worst case	2
to focus the optimization efforts	1
to issue an error message	1
to solve this problem is	1
to solve this problem. These	1
to utilize the multiple processor	1
to utilize the computational power	1
to top of loop ;	1
to decide which programming language	1
to security. There are no	1
to security. Standard C++ imple-	1
to decrement operators on integer	1
to determine the worst-case maximum	1
to determine if the processor	1
to determine whether it is	1
to 3-dimensional geometry and other	1
to a. I don't think	1
to post-increment. There are also	1
to invest in ever more	1
to invest more efforts in	1
to 1024 bits is likely	1
to override the CPU dispatching	1
to override public symbols, but	1
to CriticalFunction. If your optimization	1
to exit the loop. The	1
to emulate the while loop	1
to C1::f } 73 Without	1
to worry about loss of	1
to worry much about overflow	1
to 15. If i is	1
to develop and market the	1
to develop and publish a	1
to non-AVX code because of	1
to non-AVX code. This can	1
to -56 which will generate	1
to assembly: ALIGN 4 PUBLIC	2
to construct obscure examples where	1
to 15.1c. We can only	1
to join all source files	1
to join them into one	1
to note that this method	1
to creating and deleting containers.	1
to reorder instructions without help	1
to windows, graphic brushes, etc.	1
to pressing a key or	1
to date. A more realistic	1
to date. Mac The libraries	1
to test, maintain and verify	1
to isolate the hot spot	1
to 12.1a. Enable the AVX	1
to use. I am not	1
to use, incompatible or error	1
to read. It is often	1
to read. If a template	1
to lock a thread to	1
to load. A light-weight alternative	1
to push and pop ebx.	1
to verify that all code	1
to draw the attention of	1
to draw each pixel or	1
to 155 test. You can	1
to distribute function libraries in	1
to distribute all the dynamic	1
to reserve the amount of	1
to reserve resources for other	1
to 11.1b automatically, although it	1
to test. disable power-save options	1
to respond quickly to keyboard	1
to provoke error // Return	1
to interrupts and task switches;	1
to do, at least in	1
to organize the code in	1
to organize data to optimize	1
to log, and logarithms take	1
to low-level optimizations. Most C++	1
to fix the thread to	1
to fix the problem and	1
to keyboard and mouse inputs	1
to keyboard or mouse input.	1
to obey any specific calling	1
to obey certain rules about	1
to 99 read from the	1
to flip the sign bit	1
to me. You will not	1
to a[i+2] ; compare with	1
to answer questions from everybody.	1
to C1::Disp() or C2::Disp() is	1
to resume after exceptions: while	1
to zero: // Example 14.24	1
to seek information elsewhere and	1
to mind. In some cases	1
to finish. 3.8 System database	1
to NULL. There should of	1
to be. The distinctions between	1
to x?" or "how many	1
to re-use a container than	1
to +127. An integer overflow	1
to relocate, but these address	1
to diagnose. It is the	1
to 15.1c). 16 Testing speed	1
to thank the many people	1
to trace with a debugger.	1
to experience. Occasionally, the clock	1
to _endthread() cleans up the	1
to fine- tune the code	1
to date): Microsoft Visual studio	1
to pool all the objects	1
to Eclipse when compiling for	1
to print out results printf("\n%2i	1
to obtain, such as eliminating	1
to come. Even big software	1
to weigh the advantages over	1
to truly represent a known	1
to express any algorithm with	1
to restart the computer while	1
to vectorize, or #pragma novector	1
to remember that your code	1
to translate these addresses to	1
to query certain operating system	1
to compose a bitfield by	1
to compensate for the difference	1
to exchange data or pointers	1
to fetch the variable from	1
to facilitate porting between platforms,	1
to perform poorly for the	1
to T+6, and the whole	1
to OMF format. Alternatively, make	1
to calculate. If there is	1
to localize the first byte	1
to optimize, and reading the	1
to T+5, then it can	1
to reinvent the wheel. The	1
to combine the multiple .cpp	1
to pass a pointer or	1
to reinstall a software package	1
to 36. There may be	1
to temporarily lock a container	1
to advertise new versions of	1
to realize that such devices	1
to objects) are possible only	1
to great lengths to reduce	1
to port to different platforms	1
to controversies over the C99	1
to deallocate the space explicitly	1
to catching hardware exceptions. The	1
to Func1, while other compilers	1
to receive new relevant information.	1
to 12.8b automatically and vectorize	1
to ignore, then the solution	1
to consult the general literature	1
to minimize the amount of	1
to reflect this or for	1
to refresh the screen. There	1
to adhere to certain programming	1
to feed into the pipeline.	1
to 15.1c, but none of	1
to a*b*c*2. It is quite	1
to x^0/0! // n factorial	1
to collect the functions that	1
to fake an Intel Pentium	1
to develop. It is easy	1
to 15.1c? We took advantage	1
to relax floating point precision	1
to Object1.Hello(), though future compilers	1
to 151 15.1c automatically, and	1
to vectorize. The pragmas must	1
to multithreading that we have	1
to C0::f or C1::f. But	1
to 100000000. When we add	1
to mimic the behavior of	1
to adapt to the new	1
and the function is big.	1
and the function stores the	1
and the code takes no	1
and the code contains only	1
and the code becomes bulky	1
and the compiler may not	1
and the compiler manual for	1
and the time it takes	1
and the time consumption was	1
and the memory released when	1
and the data are scattered	1
and the data cache. 2.2	1
and the program will crash.	1
and the program logic allows	1
and the vector class library	1
and the other is -0	1
and the other way three	1
and the loop counter is	1
and the most often used	1
and the most significant part	1
and the most reliable solution.	1
and the Intel compiler for	1
and the library has no	1
and the object files need	1
and the number of different	1
and the number of times	1
and the number of logical	1
and the array 800 bytes	1
and the elements are accessed	1
and the critical functions take	1
and the operating system and	1
and the operating system for	1
and the operating system (see	1
and the operating system. See	1
and the operating system. AVX	1
and the operating system, and	1
and the template parameter. The	1
and the user will be	1
and the system forbids the	1
and the type of registers	1
and the Gnu compiler for	1
and the Gnu compiler reduced	1
and the work it has	1
and the result is that	1
and the result will be	1
and the best Java implementations.	1
and the speed will be	1
and the matrix is bigger	1
and the calculation of the	1
and the calculation of A	1
and the four B value	1
and the dispatching should be	1
and the multiplication is done	1
and the application software. Such	1
and the caching conditions are	1
and the cost of verifying,	1
and the runtime framework may	1
and the second operand is	1
and the AVX2 instruction set	1
and the options -S or	1
and the whole loop will	1
and the level-2 cache. Using	1
and the local object is	1
and the destructor is called	1
and the destructor by constructing	1
and the possibility of using	1
and the amount of RAM	1
and the entire contents copied	1
and the SSE or higher	1
and the header file mathimf.h	1
and the fraction is stored	1
and the subsequent counts represent	1
and the low priority of	1
and the derived class in	1
and the Gnu, Clang, Intel	1
and the Java virtual machine	1
and the CPUID instruction doesn't	1
and the throughput of an	1
and the availability of good	1
and the rest of the	1
and the Digital Mars compiler	1
and the "Intel Performance Primitives"	1
and the 49 first eight	1
and the corresponding bitwise operators	1
and the 512-bit ZMM registers	1
and the FAQ for the	1
and the transitions between the	1
and the loader. 2. Position-independent	1
and the post-increment operator i++	1
and the EXCLUSIVE OR operator	1
and the texts they point	1
and the destructor, if any,	1
and the wires that connect	1
and the resultant code will	1
and is not efficient. If	1
and is used in the	1
and is called from many	1
and is available in newer	1
and is compiled when it	1
and is therefore more safe	1
and a floating point multiplication	1
and a pointer to the	1
and a 64-bit version for	1
and a table of pointers	1
and a member function pointer	1
and a template parameter: //	1
and a hardware definition language	1
and a Windows, Linux, BSD	1
and a slow and fragmented	1
and a level-2 cache of	1
and a processing speed exceeding	1
and a waste of resources.	1
and a derived class are	1
and a GOT for all	1
and a third thread can	1
and a well-defined interface to	1
and a release version of	1
and a release version with	1
and a generic version that	1
and a basic understanding of	1
and a server in full	1
and to make overflow checks	2
and to optimize across function	1
and to put the task-specific	1
and to know how to	1
and to mix mathematical calculations	1
and to Eclipse when compiling	1
and in this case it	1
and in most libraries it	1
and in some cases on	1
and in some cases even	1
and in 32-bit systems when	1
and for code that is	1
and for more advanced data	1
and for information stored by	1
and for fast and easy	1
and for saving registers that	1
and for minimizing memory fragmentation.	1
and that the value is	1
and that there are 100	1
and that threads can share	1
and that measurements are unstable	1
and that computers have become	1
and are in fact addressed	1
and are difficult to maintain.	1
and are equally likely to	1
and can be linked together	1
and can calculate the address	1
and it is available from	1
and it can be difficult	1
and it can be expected	1
and it can calculate each	1
and it can move out	1
and it may be difficult	2
and it will not have	1
and it will generate relocations	1
and it makes it possible	1
and it needs to switch	1
and it needs to follow	1
and it prevents the compiler	1
and it avoids the branch	1
and it fills up the	1
and it understands only the	1
and function libraries that are	1
and function libraries have features	1
and function pointers It is	1
and function calls in the	1
and function calls are saved	1
and function inlining is done	1
and if an exception occurs	1
and if you look at	1
and by the number of	1
and by not using position-independent	1
and by avoiding pointer arithmetics	1
and by changing the dividend	1
and on Intel Atom processors,	1
and code size have got	1
and code addresses. The names	1
and not not _WIN32 n.a.	1
and not negative by AND'ing	1
and not easily ported to	1
and not __INTEL_COMPILER __INTEL_COMPILER 161	1
and an error condition terminates	1
and an FPGA in the	1
and an addition. If the	1
and compiler makers. 4. Instruction	1
and may be sufficient for	1
and may produce undesired results.	1
and you can do arithmetic	1
and you can rely on	1
and you can toggle multiple	1
and you may want to	1
and you cannot make any	1
and you cannot expect the	1
and you want the code	1
and you want the executable	1
and you want to be	1
and you want to avoid	1
and you want to find	1
and you want to prevent	1
and you unroll by two	1
and have a temp1 and	1
and have implemented a separate	1
and this will make the	1
and this will trigger the	1
and this pointer is then	1
and this value will propagate	1
and this error is easy	1
and time consuming. A collection	1
and use the induction variable	1
and use the local name	1
and use a console mode	1
and use multiple accumulators if	1
and use alternative implementations. 7.22	1
and more efficient in 64-bit	1
and more efficient than investing	1
and more error prone. A	1
and more efficient. You can	1
and more difficult to debug	1
and more important. 9.2 Cache	1
and more compact than an	1
and more complex, that there	1
and will have one and	1
and then use only the	1
and then use binary search	1
and then call __intel_cpu_features_init_x(). In	1
and then calls exit. Calling	1
and then transferred as machine	1
and then convert the result	1
and then think that you	1
and then B, and the	1
and then interpret that string	1
and then 0+1.23456 = 1.23456.	1
and then merge the multiple	1
and memory access are critical	1
and data in Linux and	1
and data are not cached.	1
and data are cached as	1
and data can exceed 2	1
and data A cache is	1
and data memory used by	1
and data cache are critical	1
and data cache use can	1
and data caching less efficient.	1
and data structures for standard	1
and data ......................................................................................... 87 9.2	1
and data decomposition. Functional decomposition	1
and vector operations (chapter 12)	1
and vector processors are becoming	1
and make the code up	1
and make the next model	1
and make a complicated implementation	1
and make a round function	1
and make it work cannot	1
and make this extra element	1
and make one instance for	1
and make sure that they	1
and make sure you are	1
and make parts of the	1
and make appropriate error messages	1
and make measurements on this	1
and different user access rights.	1
and different sizes of the	1
and functions consume a significant	1
and only the Gnu compiler	1
and only if the program	1
and only one instance. Non-static	1
and only one, auto_ptr that	1
and only if, a level-2	1
and CPU hardware. Porting such	1
and other data structures that	1
and other compilers can reduce	1
and other extra software layers	1
and other compiled programming languages	1
and other big objects come	1
and other common programming errors	1
and other container class libraries	1
and other resources than doing	1
and other resources locally or	1
and other things very stupid.	1
and other languages in Microsoft's	1
and other resource problems that	1
and other resource conflicts. But	1
and other features it has.	1
and other optimizations. In most	1
and other protection means are	1
and other nearby branches. The	1
and other complications that make	1
and other hardware-related details depend	1
and other system- specific parts	1
and other flaws in the	1
and other odd-sized vector data.	1
and other abuse is extremely	1
and instruction sets. Likewise, the	1
and which are cheap, in	1
and which optimizations you have	1
and which reductions they cannot	1
and which not. You cannot	1
and all the integer calculations.	1
and all the dynamic libraries	1
and all three versions should	1
and all 0's when false.	1
and used for an increasing	1
and one for AVX2 and	1
and one for uninitialized variables	1
and one that is compatible	1
and one that doesnt. The	1
and one or more dynamic	1
and one from me. My	1
and one local, and use	1
and cache size. If this	1
and cache sizes. Fortunately, the	1
and integer division. Older CPUs	1
and integer representations in two	1
and no branches inside can	1
and no induction variable would	1
and no destructor the object	1
and no multiplications. The following	1
and page 87 about memory	1
and class objects can often	1
and class members may cause	1
and floating point calculations as	1
and floating point numbers is	1
and floating point constants are	1
and floating point variables, if	1
and floating point numbers. It	1
and each CPU model has	1
and each value of n!	1
and most clean solution is	1
and most up-to-date solution. The	1
and using the integer in	1
and using advanced facilities of	1
and using overloaded operators for	1
and double is bad The	1
and double (see page 140).	1
and double precision in programs	1
and double precision when the	1
and double vectors AVX2 256	1
and double vectors SSE3 horizontal	1
and double Floating point calculations	1
and double precision. Long double	1
and size as template parameters,	1
and Intel vector math libraries.	1
and Intel compilers for Windows	1
and Intel compilers for Linux.	1
and Intel compilers can use	1
and Intel compilers. We want	1
and pointer type casting. Linked	1
and b is true 10%	1
and b in a union:	1
and b in example 8.15a	1
and b are the same	1
and b are 32-bit integers,	1
and b are swapped then	1
and b have other values	1
and b have been initialized	1
and b will both get	1
and b different so that	1
and b because b has	1
and b because their live	1
and b should be of	1
and b double precision: //	1
and b take the same	1
and b overlap. You should	1
and i >= size can	1
and static variables if possible,	1
and static const int ABC	1
and static data. 148 It	1
and 64-bit code for the	1
and 64-bit operating systems are	1
and 64-bit Windows and 32-bit	1
and 64-bit Windows and Linux.	1
and 64-bit Linux and BSD.	1
and 64-bit Linux as well	1
and 64-bit systems. The appropriate	1
and 64-bit systems. Applications that	1
and 64-bit Windows, Linux and	1
and 64-bit Linux, BSD, Windows	1
and 64-bit mode. 16-bit mode	1
and 64-bit Windows. The integrated	1
and 64-bit Windows. Borland /	1
and 64-bit Linux. Has many	1
and 64-bit integers, as long	1
and there is no big	1
and there is no risk	1
and there are no cache	1
and there are no long	1
and there are search requests	1
and there will be cache	1
and C++ is Microsoft Foundation	1
and C++ faster than in	1
and also a possible point	1
and efficient if the data	1
and array indices when you	1
and where the size of	1
and possible workaround. Supports all	1
and objects that are scattered	1
and objects are stored in	1
and objects will be stored	1
and objects should preferably be	2
and objects declared in a	1
and objects declared inside a	2
and takes little space in	1
and variable names from string	1
and variable names. Remember to	1
and any other constructors. A	1
and we do not expect	1
and we don't need an	1
and some of these also	1
and some other functions that	1
and some operating systems are	1
and some tips on improving	1
and so on. 7.31 Other	1
and return a pointer to	1
and return and parameter transfer	1
and return operations with other	1
and table lookup is to	1
and table lookup mechanisms explained	1
and very useful for many	1
and very time- consuming. There	1
and software developers who want	1
and software engineering principles to	1
and long double take no	1
and long double reflects the	1
and between simple processors and	1
and 32-bit and 64-bit Linux	1
and 32-bit Windows in this	1
and 32-bit Linux with Microsoft,	1
and branch is executed. The	1
and branch mispredictions. When the	1
and branch mispredictions. Test the	1
and member functions is not	1
and makes it point to	1
and makes an extra register	1
and before any floating point	1
and before any constructors are	1
and stored in edx. Furthermore,	1
and stored as it is,	1
and call the std::unexpected() function	1
and call it from a	1
and 8 floating point). There	1
and 8 bytes in 64-bit	1
and less efficient code caching.	1
and operating systems are most	1
and operating systems available today.	1
and operating systems (but not	1
and operating systems. The 64	1
and operating systems. 3 The	1
and operating system. See page	1
and operating systems". The parameters	1
and operating systems". For this	1
and operating systems". 7.16 Function	1
and operating systems"). An application	1
and operating systems" for details	1
and unsigned integers is costless.	1
and unsigned integers in comparisons,	1
and unsigned integers int a,	1
and unsigned integers simply makes	1
and unsigned variables. A positive	1
and unsigned integers. But there	1
and 64 bits in 64-bit	1
and 64 bits are less	1
and take more time to	1
and often inefficient. Objects of	1
and often excessively so. These	1
and how the microprocessor handles	1
and how you can use	1
and how much time it	2
and test their functionality. This	1
and new objects can be	1
and user settings are lost.	1
and these two functions are	1
and these operations are very	1
and they are not necessary	1
and they are equally efficient.	1
and they can be signed	1
and they always evaluate both	1
and they waste a lot	1
and without the static keyword:	1
and without AVX using CPU	1
and without AVX support. There	1
and even worse, it can	1
and always the same. The	1
and always use this number	1
and SSE2 instruction sets have	1
and system calls. These are	1
and system modules. 3.12 Network	1
and system crash. Furthermore, it	1
and system breakdown. Many copy	1
and 32 bit offsets). Example:	1
and dynamic versions. It is	1
and dynamic linking. The file	1
and type of data elements,	1
and short vector libraries. To	1
and simple to develop. It	1
and constant propagation is not	1
and constant propagation and reduce	1
and constant propagation An expression	1
and error handling Exception handling	1
and error handling ................................................................................ 61	1
and I believe that software	1
and making an explicit induction	1
and stack entries use 64	1
and want to get as	1
and Gnu compilers are actually	1
and Gnu compilers. // Example	1
and Gnu compilers. See www.openmp.org	1
and its return value depends	1
and its parameters. This is	1
and accessed non-sequentially because it	1
and assembly code for Intel	1
and assembly code for AMD	1
and while the program is	1
and arrays can be allocated	1
and arrays by the cache	1
and Windows platforms. The Clang	1
and Windows platforms. This library	1
and Windows Template Library (WTL):	1
and Windows 3.x. These systems	1
and Windows Server 2008 R2	1
and calls alternately FuncA and	1
and execution time. No universal	1
and execution units. If any	1
and avoid dynamic memory allocation	1
and compiled for the desired	1
and big structures by 16	1
and doesn't take any extra	1
and necessary support. Hardware updating.	1
and c are integers, while	1
and c can share the	1
and c __m128i bc =	2
and c first. b+c =	1
and much time is wasted	1
and much less efficiently when	1
and virtual function tables. The	1
and virtual functions or when	1
and several other less well-known	1
and AMD processors are sure	1
and AMD CodeAnalyst. There are	1
and compile the program are	1
and compile them separately with	1
and exception handling. Omitting the	1
and small code size has	1
and integers Conversion from floating	1
and integers ................................... 141 14.9	1
and Linux operating systems give	1
and cause large delays. The	1
and cause contentions in the	1
and cause delays in the	1
and cause fatal errors if	1
and classes Nowadays, programming textbooks	1
and done by the operating	1
and therefore the system code	1
and therefore it is accessed	1
and therefore not advantageous by	1
and therefore not recommended if	1
and therefore more error prone.	1
and therefore cannot do the	1
and therefore likely to be	1
and therefore count as true,	1
and therefore difficult to maintain.	1
and therefore fail to start	1
and works only for positive	1
and optimized function libraries. C++	1
and manual 3: "The microarchitecture	1
and manual 5: "Calling conventions	1
and uses more cache space.	1
and another part of the	1
and get a good deal	1
and known to the compiler	1
and supported by the Gnu	1
and supported on all major	1
and operators Integer sizes Integers	1
and operators Modern microprocessors in	1
and operators ...................................................................... 32 7.4	1
and whether there is other	1
and doing multiple calculations in	1
and run any code branch	1
and calculate it at compile	1
and calculate *p+2 a hundred	1
and 1 for negative numbers.	1
and 1 for true. Boolean	1
and add b and c	1
and add Divide by constant	1
and store the result in	1
and store the four results	1
and store the shared variable	1
and store it in a	1
and copy the contents of	1
and copy matrix void TransposeCopy(double	2
and optimizing for speed. Optimizing	1
and well thought-through approach to	1
and simply put 80 into	1
and addresses in the code	1
and shared between multiple processes.	1
and intermediate code for the	1
and intermediate results are always	1
and write it with many	1
and write configuration files (*.ini	1
and optimize both functions and	1
and programs compiled for the	1
and microprocessor microarchitecture. A higher	1
and branches in a function	1
and Mac systems normally use	1
and Mac programs but rarely	1
and Mac platforms. 2. Optimizing	1
and Mac platforms By Agner	1
and Mac OS X operating	1
and Mac OS X, 32-bit	1
and Mac allow up to	1
and Mac systems, this may	1
and multiplication are permissible in	1
and multiplication may be three	1
and multiplication (27 - 80	1
and multiplication (20 - 45	1
and see which one works	1
and caching becomes inefficient. There	1
and sets all other bits	1
and complicated algorithm if a	1
and their implementations reveal a	1
and don't modify the carry	1
and model numbers are not	1
and model number. The only	1
and model number. I have	1
and model number. Failure to	1
and model numbers, but on	1
and development time. Interpreted languages	1
and development tool is faster	1
and development tools. A popular	1
and mathematical functions are calculated	1
and mathematical functions take more	1
and mathematical operations on vectors	1
and mathematical calculations. In such	1
and put the different functions	1
and put an equal amount	1
and put seldom used branches	1
and various efficient container classes.	1
and various programming languages. www.yeppp.info	1
and zero flags on certain	1
and Microsoft C++ compilers www.agner.org/	1
and what it can not	1
and parameter transfer are eliminated.	1
and parameter transfer across all	1
and division take longer time.	1
and automatic vectorization (see page	1
and automatic vectorization. It is	1
and automatic vectorization. Optimizes reasonably	1
and automatic parallelization. Supports vector	1
and automatic parallelization of code	1
and automatic CPU-dispatching (see page	1
and resources should be organized	1
and resources cleaned up. If	1
and induction variables (see below).	1
and string functions and some	1
and string instructions. The built-in	1
and string manipulation Mathematical functions	1
and three times the other	1
and better at vectorization. 3.	1
and better processor appears on	1
and | operations than to	1
and last the second result	1
and last all the B	1
and || are evaluated in	1
and types of elements is	1
and difficult to maintain. And	1
and difficult to read. It	1
and after the piece of	1
and after each of the	1
and after executing the critical	1
and after executing a critical	1
and read or write it	1
and give the result 100	1
and give the result -56	1
and directives which are used	1
and public data can be	1
and public variables go through	1
and microprocessors work. The recommendations	1
and assume that the next	1
and later instruction sets. Supports	1
and later instruction sets. Vector	1
and later instruction sets. Does	1
and later Intel processors. AMD	1
and later reads from addresses	1
and later deleted by another	1
and later discovers that it	1
and calling any necessary destructors	1
and interface frameworks. This is	1
and 512 bits when the	1
and generate a bit-mask: __m128i	2
and r in Sum2 and	1
and r are transferred on	1
and b, and the elements	1
and reduce a to the	1
and 10 ms for background	1
and choose the type that	1
and choose the appropriate version	1
and choose this method for	1
and link with the option	1
and advanced prediction mechanisms. Modern	1
and switch statements The high	1
and switch statements should preferably	1
and switch statements............................................................................. 43 7.13	1
and start the calculation of	1
and replaced by storage on	1
and negative inputs give infinity.	1
and negative impacts on program	1
and go back into the	1
and tested it. The insight	1
and references in the code	1
and references are equally efficient	1
and references Pointers versus references	1
and references ............................................................................................ 36 7.7	1
and loaded into ecx and	1
and VIA processors. It is	1
and VIA processors. See page	1
and VIA processors. Explicit CPU	1
and VIA CPUs. 5. Calling	1
and VIA including the 64-bit	1
and VIA processors, and it	1
and VIA CPUs"). This is	1
and VIA CPUs"). This can	1
and VIA CPUs"). Const cast	1
and VIA CPUs" for an	2
and VIA CPUs" gives more	1
and VIA CPUs: An optimization	1
and VIA CPUs". A branch	1
and VIA CPUs". 9.3 Functions	1
and C are too small	1
and global variables by using	1
and my manual will soon	1
and off by default unless	1
and columns in matrix //	2
and 1. The reason why	1
and 1. Note that there	1
and turn on all relevant	1
and turn off debugging and	1
and inlining the call to	1
and network access in separate	1
and network connections. Temporary files	1
and >= operators). The same	1
and desired new features. User	1
and hot spots. The test	1
and position-independent code Function libraries	1
and position-independent code ....................................................... 20	1
and output should be measured	1
and task switches; so that	1
and sometimes it does incredibly	1
and sometimes unacceptably long. Lazy	1
and local variables in registers	1
and frame functions. A frame	1
and prevent it from fully	1
and prevent legitimate backup copying	1
and shift out sign bit:	1
and shift operations take only	1
and shift Floating point algebra	1
and shift operations. Multiplying by	1
and prevents all optimizations on	1
and d in assembly language	1
and d would all be	1
and Linux, 32-bit and 64-bit.	1
and compatibility problems and they	1
and compatibility problems into account	1
and writing from the same	1
and writing data files while	1
and copying different size matrices,	1
and causes the heap space	1
and divide it into multiple	1
and 16-bit Windows, allow variables	1
and child are typically stored	1
and child class are accessed	1
and child class. Members of	1
and disk space were scarce	1
and disk space. It may	1
and possibly also a lookup	1
and possibly save exception handling	1
and overloaded operators. Function parameters	1
and overloaded operators. Vectorized code	1
and classes. The object oriented	1
and % means modulo. For	1
and precision. The speed is	1
and algebraic reductions in my	1
and handle one square at	1
and handle text strings in	1
and initialized arrays. I have	1
and insert the values in	1
and insert the reciprocal in	1
and insert a code that	1
and insert only the SSE2	1
and reading the performance counters	1
and reading them again takes	1
and message systems. All of	1
and enable one or more	1
and keep track of when	1
and PathScale compilers can in	1
and PathScale compilers can automatically	1
and PathScale compilers. Intel C++	1
and PathScale compilers. 8.3 Obstacles	1
and PathScale compilers. (The PGI	1
and BSD comes at a	1
and rarely the other way	1
and easier to test, maintain	1
and 20 clock cycles. It	1
and expect this to be	1
and references. Most importantly, it	1
and references. Arrays are always	1
and similar objects of variable	1
and similar methods are further	1
and back again. This may	1
and back again. If there	1
and back again. Obviously, it	1
and back again. Accessing system	1
and garbage collection can occur	1
and garbage collection takes a	1
and garbage collection. A more	1
and garbage collection, as mentioned	1
and templates for several different	1
and header files. 121 13	1
and swap these elements with	1
and sets. Let me explain	1
and invalid pointers. The absence	1
and invalid pointers. This is	1
and setting the priority back	1
and checks both the CPU	1
and current operating systems need	1
and 3 - 4 clock	1
and waste of time for	1
and map are prone to	1
and easy development of user	1
and easy development. For example,	1
and 256-bit YMM registers. The	1
and scattered around in memory.	1
and writes may slow down	1
and device drivers are particularly	1
and destructors of each object	1
and destructors to call. I	1
and destructors A constructor is	1
and destructors .................................................................................. 55 7.24	1
and stores the time consumption	1
and stores the result in	1
and search facilities, binary trees,	1
and usability A better performing	1
and usability ............................................................................................... 23 5	1
and vectorize the code if	1
and derived class are called	1
and standardized file formats should	1
and memcpy is unsafe because	1
and c2 for elements inside	1
and misprediction of virtual function	1
and just-in-time compilation may be	1
and just-in-time compilation. Some early	1
and algorithms in the planning	1
and PLT for internal references.	1
and PLT tables are not	2
and PLT lookups for local	1
and profiling support in the	1
and fragmented hard disk. Test	1
and who is still frustrated	1
and fixed size arrays inside	1
and fixed repeat count and	1
and interpreted line by line	1
and YMM registers The 128-bit	1
and YMM registers ................................................................. 107	1
and measure how long time	1
and lazy binding by default,	2
and delete is to allocate	1
and delete to allocate a	1
and delete or with the	1
and delete or malloc and	1
and delete (or malloc and	1
and distributed as binary executable	1
and generally used that most	1
and Linux. The compiler comes	1
and Linux. Asmlib My own	1
and Open BSD are identical	1
and free are: There is	1
and rounding 137 errors must	1
and far procedures are inefficient.	1
and 120 for discussion of	1
and highly compatible with Gnu.	1
and again for every iteration	1
and Clang compilers. The code	1
and log are pure functions,	1
and compile-time while loops, then	1
and wait until the value	1
and 15 clock cycles (depending	1
and declare all functions static	1
and normal unsigned int exponent	1
and show the values of	1
and show a disassembly, probably	1
and c1 for all squares:	1
and efficient, but not safe	1
and again. If there are	1
and deallocated in random order.	2
and edx can be changed	1
and edx contains the address	1
and soon also 512 bits	1
and edx, respectively. (In 64-bit	1
and branches. The following methods	1
and internal functions in a	1
and loss of precision for	1
and Fortran are based on	1
and Fortran code. The main	1
and drivers differ a lot	1
and economize the library function	1
and maintain. Most compiler packages	1
and fourteen in 64-bit systems.	1
and fourteen integer registers in	1
and bc for each element	1
and Digital Mars compilers produce	1
and CISC processors, between PC's	1
and 22 one or two	1
and searching for vacant spaces.	1
and _WIN64 _M_X64 _M_X64 162	1
and pow at compile- time,	1
and computing power than PCs.	1
and 90 for examples of	1
and understand compiler-generated assembly code.	1
and returns a pointer to	1
and frameworks typically used on	1
and compare it to the	1
and manuals. I want to	1
and loop-invariant code motion manually	1
and loop-invariant code motion. See	1
and jumps back to the	1
and 13 objects, respectively (MS	1
and written back. The so-called	1
and BSD, the slow GOT	1
and sixteen in 64-bit operating	1
and sixteen in 64-bit systems.	1
and enables interprocedural optimizations. See	1
and databases with lots of	1
and loader (requires binutils version	1
and objects. Storage on the	1
and mouse inputs when the	1
and subtraction (3 - 10	1
and ownership is transferred from	1
and drawbacks of using dynamic	1
and x86-64 platforms. AMD AMD	1
and x86-64 platforms. Comparison of	1
and Watcom compilers are not	1
and 14.9 is changed so	1
and maintenance - to make	1
and maintenance There are two	1
and maintenance .......................................................................................... 126 13.5	1
and maintenance easier. I have	1
and underflow except in special	1
and underflow neutralize each other.	1
and splitting the dependency chain	1
and video processing, signal processing,	1
and sum2 are called accumulators.	1
and avoids many of the	1
and image processing. Yeppp. Open	1
and interfaces to network resources,	1
and aliasing. Operations that are	1
and changing then the CPU	1
and smaller. This manual discusses	1
and structures. Useful for vector	1
and reproducible as possible. However,	1
and reproducible results. If you	1
and operators. Make a C++	1
and (set) = (0x2710 /	1
and fine-grained parallelism when deciding	1
and compact. The biggest disadvantage	1
and FPGA soft cores that	1
and earlier Intel processors are	1
and 119 for more information	1
and compiler-generated code by making	1
and perhaps }; // constant	1
and perhaps Mac OS. See	1
and main() are compiled without	1
and 14.30 will therefore need	1
and keywords relevant to optimization	1
and divisions are given on	1
and trigonometric functions. The code	1
and 64, depending on the	1
and copies them into the	1
and 135 show various ways	1
and leave the last 8	1
and leave them enabled (there	1
and c[i] are so big	1
and c[i] are too big	1
and ZMM registers The first	1
and ZMM registers .......................................................... 107	1
and logarithms take a long	1
and pop ebx. 9 Optimizing	1
and s3 can be combined	1
and open source. It comes	1
and measuring the overall performance	1
and read-only data sections can	1
and read-only data. The disadvantage	1
and well-structured code and for	1
and multiplications. Subtractions use the	1
and market the application program.	1
and frameworks, rather than isolating	1
and truncation. The missing functions	1
and truncation. Efficient conversion from	1
and deallocation of memory takes	1
and deallocation of big memory	1
and decrement operators The pre-increment	1
and decrement operators. 7.7 Function	1
and free. This can be	1
and free. These operators and	1
and references, which can be	1
and LIBM libraries are not	1
and complexity (en.wikipedia.org/wiki/Standard_Template_Library). The objects	1
and memcpy, at least in	1
and Sum3 in 32-bit Windows	1
and Sum3 are doing exactly	1
and lack of advanced development	1
and mostly relative references in	1
and resolve any branch misprediction	1
and resolve compatibility problems. Software	1
and discovered that many common	1
and scientific vector processors. Henry	1
and throw. It is more	1
and that's what they are.	1
and GOT. The symbol interposition	1
and destination both have addresses	1
and 72 for discussions. Turn	1
and 0x4700. These addresses all	1
and 14.13b works only if	1
and underflow. The range of	1
and web browsing that previously	1
and p2 having different types.	1
and maintaining a new branch	1
and maintaining such code is	1
and sound processing Memory and	1
and servers should be tested	1
and MOVNTDQ require that the	1
and 64-bit. Supports OpenMP and	1
and 64-bit. They have not	1
and isolate the most critical	1
and v.f are both positive.	1
and afterwards a BSF (bit	1
and denormals-are-zero mode (SSE2): #include	1
and machines with embedded microcontrollers.	1
and debugging. A command-line version	1
and synchronization between the different	1
and synchronization between threads, such	1
and high-priority threads are areas	1
and verify than a program	1
and searching, or the specific	1
and restarted anyway. Updates to	1
and IDE's for D are	1
and fine-tuned for a particular	1
and redo the calculations in	1
and redo the calculation in	1
and deleting the object then	1
and deleting containers. If the	1
and flexible, but quite inefficient	1
and Gnu. There is a	1
and Mac. The Gnu compiler	1
and Mac. Supports parallel processing,	1
and subtracting 1 from -128	1
and reusable classes. Security The	1
and stop the program in	1
and stop the thread. The	1
and attempts to translate these	1
and recovering from error conditions	1
and direct hardware access. Available	1
and studying the bottlenecks can	1
and press break while the	1
and involve a high overhead	1
and statistics, and the "Intel	1
and later. The AVX instruction	1
and 9. Multiplications are done	1
and "best case" values. Which	1
and delete, and often excessively	1
and delete, or malloc and	1
and BSD. The Windows version	1
and BSD. If a function	1
and executables. Make sure to	1
and clumsy, as you will	1
and repagination are running in	1
and esp+12 and loaded into	1
and "More Effective C++". Addison-Wesley,	1
and IA-32 Architectures Optimization Reference	1
and C# and avoids many	1
and FuncB, then FuncC. Unrolling	1
and Newton-Raphson iterations. Here the	1
and |) instead of the	1
and object-oriented programming, modularity, reusability	1
and Adolfy Hoisie: "Performance Optimization	1
and destructors. The copy constructors	1
and de-allocation of memory with	1
and off. It is important	1
and unexpected behaviors. Arrays are	1
and flexibility of the STL	1
and A. Hoisie, SIAM 2001.	1
and matrixes. Algorithms that are	1
and uninstallation of programs should	1
and temp++ actually adds 16	1
and 2B. There are hundreds	1
and lrint. Unfortunately, these functions	1
and communicating between threads. The	1
and USB sticks may not	1
and finally (4) access the	1
and analyzing program performance and	1
and disadvantages. The original method	1
and fence instructions, but these	1
and 12.4c is quite tedious	1
and shared_ptr. auto_ptr has the	1
and databases. The operating system	1
and Fortran. These directives are	1
and investigated by the methods	1
and error-prone. The program has	1
and reorganize: // Example 15.1c.	1
and convoluted template metaprogramming is.	1
and create a new one.	1
and popped from the stack	1
and delete). 88 Object oriented	1
and classes............................................................................................ 51 7.18 Class	1
and decoded in several stages	1
and 3B. developer.intel.com. AMD: "AMD64	1
and ||). The bitwise operators	1
and animations is of course	1
and cons of using classes.	1
and "Integrated Performance Primitives". These	1
and UNIX shell script. Interpreted	1
and '$' are allowed in	1
and FPGAs. The difference between	1
and cryptography (www.intel.com). If you	1
and Itanium systems. The Intel	1
and Z. Each dependency chain	1
and correspondingly two different types	1
and hence higher speed. In	1
and systematization of the software	1
and memcpy: // Example 7.33b	1
and parsing are provided in	1
and 137, respectively. Increment and	1
and reorganize the code so	1
and micro-operation breakdowns for Intel,	1
and _mm_free. A more general	1
and non-constant references require a	1
and irregular response times. It	1
and temp2. Modern CPUs are	1
and stopping threads. Don't put	1
and double..................................................................................... 140 14.8 Conversions	1
and operators............................................................................... 29 7.3 Floating	1
and tedious. The code becomes	1
and free) causes the memory	1
and Sum3. Whether you want	1
and bb[i]*cc[i] is AND'ed with	1
and semicolons in a loop	1
and intelligible way by wrapping	1
and b. But in more	1
and VIA. The next section	1
and SVML. The IPP library	1
and Enterprise editions). Do not	1
and fffff is the binary	1
and closer to the CPU	1
and foremost, in the choice	1
and list[i].b. It can also	1
and flexibility, while execution speed,	1
and 3A and 3B. developer.intel.com.	1
and shifts one place to	1
and y?" then you may	1
and suggestions for my optimization	1
and increment. The three clauses	1
and restoring registers, and possibly	1
and newsgroups contain useful discussions	1
and non-recoverable errors; make sure	1
and concentrate the optimization effort	1
and down. Remember to insert	1
and modular. The so-called objects	1
and WritePrivateProfileString to read and	1
and invoked with automatic vectorization.	1
and Func2 were in the	1
and maintainability of C++ projects	1
and relational operators (e.g. '>')	1
and decreased when the work	1
and publish a function library	1
and mirroring is not allowed.	1
and Gnu). Other compilers need	1
and suggests methods for avoiding	1
and mainframes, and between simple	1
and ease of development are	1
and recompile it. I am	1
and planned solutions. Patches should	1
and API's. Memory swapping. Software	1
and shuffling can sometimes take	1
and closes the file for	1
and well- tested library modules	1
and similarly sets the variable	1
and clarity of the program	1
and __intel_new_strlen in library libircmt.lib.	1
and ARM platforms and various	1
and getting them into the	1
and replaces the PLT entry	1
in the // parent class.	1
in the function in which	1
in the function library at	1
in the function library asmlib,	1
in the function name is	1
in the code to call	1
in the code to tell	1
in the code and divide	1
in the code are relative	1
in the code are modified,	1
in the code with an	1
in the code then you	1
in the code cache and	1
in the code cache or	1
in the code cache if	1
in the code memory. The	1
in the code cache. The	2
in the code section will	1
in the code section so	1
in the code prevent the	1
in the code itself is	1
in the code carefully to	1
in the code section, but	1
in the compiler manual or	1
in the compiler .......................................................................................... 66	1
in the compiler 8.1 How	1
in the data cache. The	1
in the data cache. If	1
in the program that are	1
in the program if there	1
in the program by their	1
in the program code for	1
in the program than to	1
in the program under test	1
in the program flow at	1
in the program flow. However,	1
in the different microprocessors. 7.13	1
in the same time that	1
in the same memory pool.	1
in the same memory block,	1
in the same way as	1
in the same part of	3
in the same processor core	1
in the same processor core.	3
in the same thread as	1
in the same source file.	1
in the same core will	1
in the same generation can	1
in the same module then	1
in the same core. It	1
in the same chip can	1
in the same chip. Such	1
in the same directory as	1
in the CPU and prevent	1
in the CPU (See manual	2
in the CPU detection mechanism.	1
in the CPU chip. Such	1
in the other volumes in	1
in the instruction set for	1
in the loop control it	1
in the loop control condition:	1
in the cache so we	1
in the set can be	1
in the class declaration. The	1
in the most critical part	3
in the most common platforms	1
in the Intel compiler is	1
in the Intel compiler works	1
in the library www.agner.org/optimize/asmlib.zip. The	1
in the object file. Use	1
in the 64-bit extension to	1
in the array must begin	1
in the clock frequency. The	1
in the variable Day. Note	1
in the table are core	1
in the order in which	3
in the order a[0], b[0],	1
in the long double format.	1
in the branch target buffer	2
in the way of example	1
in the way microprocessors are	1
in the way m is	1
in the critical part of	5
in the operating system kernel	1
in the first 128 bytes.	1
in the code. For my	1
in the code. Example: //	2
in the code. Many of	1
in the code. Let's look	1
in the template function, m	1
in the test program itself	1
in the following way. The	1
in the following way. If	1
in the following way. First	1
in the following table. Type	1
in the following way: //	1
in the following way: There	1
in the following way: bool	1
in the following cases: If	1
in the following sections. 3.3	1
in the programming manuals from	1
in the case a =	1
in the case that the	1
in the Gnu manual currently	1
in the Gnu C function	1
in the Gnu C library.	1
in the assembly output (/FAs	1
in the while loop because	1
in the Windows system. Note	1
in the big registration database	1
in the best cases. It	1
in the thread function so	1
in the thread have a	1
in the matrix longer than	1
in the AVX instruction set.	1
in the optimized version of	1
in the calculation of one	1
in the container rather than	1
in the list causes all	1
in the likely case that	1
in the structure to make	1
in the values because a	1
in the memory. This makes	1
in the memory. It is	1
in the shared object, then	1
in the program. Reading or	1
in the program. Small functions	1
in the above example with	1
in the above example may	1
in the above examples will	1
in the above sections are	1
in the above table. If	1
in the optimal order. Some	1
in the particular application. The	1
in the next vector, and	1
in the next paragraph. The	1
in the next section. 12.5	1
in the multiplication b[i]*c[i], though	1
in the application software is	1
in the expression a =	1
in the cache. The cache	1
in the cache. The problem	1
in the cache. When we	1
in the high level framework.	1
in the Microsoft platform software	1
in the source code. It	1
in the source files. 13.2	1
in the end of a	1
in the end in order	1
in the end when all	1
in the last vector. Organize	1
in the XMM registers (see	1
in the second generation of	1
in the second step where	1
in the x86 CPUs. However,	1
in the x86 family can	1
in the x86 family have	1
in the old operating systems	1
in the old block then	1
in the old version. Updating	1
in the old fashioned C	1
in the innermost loop A	1
in the innermost loop doing	1
in the innermost loop bigger	1
in the innermost function, then	1
in the innermost loop. This	1
in the compiler. You can	1
in the compiler. Loop invariant	1
in the compiler. Remember, therefore,	1
in the relevant books and	1
in the main program. See	1
in the main executable has	1
in the main executable because	1
in the global offset table	1
in the choice of programming	1
in the STL are universal,	1
in the STL (Standard Template	1
in the level-2 cache are	1
in the level-2 cache as	1
in the level-2 cache. The	1
in the level-2 cache. This	1
in the code, so you	1
in the output are unacceptable.	1
in the level-1 data cache,	1
in the level-1 cache are	1
in the level-1 cache. The	1
in the level-1 cache. We	1
in the database anyway if	1
in the calculations. The program	1
in the final program and	1
in the final version of	1
in the final program. This	1
in the final program, it	1
in the copying process, and	1
in the so-called commpage. These	1
in the logical architecture of	1
in the entire program will	1
in the simplest cases, but	1
in the simplest cases. See	1
in the situation where the	1
in the condition clause. Comparing	1
in the previous chapter (page	1
in the previous iteration. This	1
in the chapter "Register usage	1
in the future due to	1
in the sequence of calculations	1
in the sequence to be	1
in the CPU. It can	1
in the CPU. If the	1
in the subsequent manuals. Please	1
in the latter case the	1
in the latter case, the	1
in the fully optimized code	1
in the procedure linkage table	1
in the background are unnecessary	1
in the system. The number	1
in the array. This method	1
in the general case, but	1
in the software. Smaller microcontrollers	1
in the vectors. This data	1
in the YMM register state.	1
in the YMM registers. Disadvantages	1
in the sections below. The	1
in the carry flag or	1
in the carry flag then	1
in the table. The 16-byte	1
in the machine code is	1
in the core. It is	1
in the sense that the	2
in the sense that all	1
in the sense that each	2
in the sense that C++	1
in the latest compilers from	1
in the scope of the	1
in the debugger is not	1
in the debugger to identify	1
in the debugger then it	1
in the form of a	2
in the form of templates	1
in the future. If a	1
in the future. 6 The	1
in the future. Typically, the	1
in the future. To use	1
in the rest of the	1
in the event of an	1
in the event that it	2
in the select function, and	1
in the project window or	1
in the present manual. There	1
in the asmlib library at	1
in the SVML and LIBM	1
in the appendix at www.agner.org/optimize/cppexamples.zip	1
in the unit-test but has	1
in the interval from 0	1
in the interval 0 <=	1
in the interval [1.0, 2.0)	1
in the early planning stage	1
in the CPU, which counts	1
in the file, especially if	1
in the container, then a	1
in the container. STL deque	1
in the planning phase in	1
in the book "Performance Optimization	1
in the disassembly window of	1
in the profile. It may	1
in the arrays: // Example	1
in the MKL relies on	1
in the majority of end	1
in the Professional and Enterprise	1
in the oldest Pentium CPUs	1
in the grandparent class: class	1
in the BTB can cause	1
in the end. The reason	1
in the STL. Some STL	1
in the broader perspective of	1
in the representation, except in	1
in the "Macro loops" chapter	1
in the GOT, and finally	1
in the beginning. ret returns	1
in the former case x	1
in the level- 1 cache.	1
in the Active Template Library	1
in the sequence, where r	1
in the unit- test because	1
in the BIOS setup. on	1
in a function for register	1
in a function that is	1
in a function should also	1
in a use situation where	1
in a more efficient way	1
in a more clear and	1
in a more distant future.	1
in a memory buffer and	1
in a memory pool. 15	1
in a memory pool, as	1
in a program is bigger	1
in a program repeats 1000	1
in a vector or the	1
in a vector register which	1
in a different way or	1
in a different thread. If	1
in a different way. There	1
in a different module or	1
in a different array. //	1
in a loop of ADC	1
in a loop with multiple	1
in a loop where each	1
in a loop where almost	1
in a class are accessed	1
in a class or structure	1
in a library other than	1
in a number of arrays	1
in a static part of	1
in a static link library	1
in a static buffer or	1
in a 64-bit shared object	1
in a C++ program. This	1
in a very inefficient way.	1
in a way that can	1
in a way that takes	1
in a way that avoids	1
in a critical part of	1
in a register and prevents	1
in a register if its	1
in a register rather than	1
in a register (see below)	1
in a register except in	1
in a rather unconventional manner	1
in a dynamic library is	1
in a dynamic library than	1
in a short time then	1
in a simple test setup	1
in a large memory model	1
in a big matrix happen	1
in a big mainframe computer.	1
in a specific interval. A	1
in a single operation using	1
in a single executable file	1
in a single step rather	1
in a single operation. Example:	1
in a single instruction. The	1
in a single session. But	1
in a virtual table to	1
in a thread environment block.	1
in a small part of	1
in a matrix is a	2
in a matrix a power	1
in a matrix for use	1
in a structure or class	2
in a hardware definition language	1
in a hardware definition language.	1
in a hardware definition language,	1
in a shared object is	2
in a shared object which	1
in a shared object, then	1
in a particular CPU model	1
in a particular application. If	1
in a particular situation, but	1
in a microprocessor because the	1
in a separate function library	1
in a separate file than	1
in a separate dynamic link	2
in a separate function. Sometimes,	1
in a separate thread if	2
in a separate C or	1
in a separate subroutine if	1
in a separate module, and	1
in a linked list has	1
in a binary representation according	1
in a 512 512 matrix.	1
in a compiler. Some compilers	1
in a compiler. Many algebraic	1
in a computer with multiple	1
in a computer game or	1
in a global object. The	1
in a network may be	1
in a special cache called	1
in a safe way in	1
in a message loop in	1
in a vector. If n	1
in a vector. 6. If	1
in a module by compiling	1
in a series of five	2
in a low priority thread,	1
in a typical software project	1
in a typical application to	1
in a standardized manner. 3.4	1
in a temporary array before	1
in a temporary variable outside	1
in a procedure linkage table	1
in a procedure linkage table.	1
in a register. The above	1
in a register. If the	1
in a DLL can be	1
in a DLL goes through	1
in a non-sequential order in	1
in a non-sequential order. The	2
in a non-sequential order. Example:	1
in a non-sequential manner then	1
in a non-sequential manner. It	1
in a random manner. This	1
in a far data segment	1
in a debugger and press	1
in a computer. The proxy	1
in a bad dilemma. You	1
in a protected operating system	1
in a protected operating system,	1
in a suboptimal way has	1
in a suboptimal way. The	1
in a suboptimal way. Here	1
in a high-level language need	1
in a multithreaded program, or	1
in a register, not even	1
in a well-structured C++ program	1
in a pivot search: //	1
in a computationally intensive program	1
in a PC. Nevertheless, it	1
in a programmable logic device	1
in a high-priority thread can	1
in a FIFO manner? If	1
in a first-in-last-out fashion. It	1
in a systematic manner to	1
in a word processor the	1
in a union: // Example	1
in a hand- written table	1
in a multitasking environment, between	1
in a DLL. Another alternative	1
in a graceful way. You	1
in a FILO manner? If	1
in a Gauss elimination. The	1
in a column-wise manner where	1
in a pre-calculated table. Even	1
in code caching for the	1
in an object of the	2
in an array grows during	1
in an application program without	1
in an && expression, or	1
in an || expression. Assume,	1
in an unused fourth value	1
in an STL container are	1
in an inefficient way. See	1
in an integer, usually 32.	1
in an array. The values	1
in an appendix to this	1
in an FPGA as a	1
in an import table and	1
in an array, or approximately	1
in compiler price GNU General	1
in this example is a	1
in this example is called	1
in this example can be	2
in this example has three	1
in this example should be	1
in this example so that	1
in this table may be	1
in this way is equal	1
in this way includes the	1
in this case is to	1
in this case is faster	1
in this case it may	1
in this case it will	1
in this case so we	1
in this range then the	1
in this example: 38 //	1
in this hot spot. Repeating	1
in this series of manuals.	1
in this case. The best	1
in this case. A binary	1
in this case. You cannot	1
in this case. Loop unrolling	1
in this example. We might	1
in this format. Other compilers	1
in this column. Number 17	1
in this block: 62 __try	1
in this chapter. Using the	1
in this respect. 7.15 Function	1
in more than one way	1
in more complex cases it	1
in more detail in manual	1
in memory is a multiple	1
in memory or accessed in	1
in memory or cache. Most	1
in memory if organized as	1
in memory by requesting a	1
in memory then there is	1
in memory takes only 2-3	1
in memory rather than in	2
in program execution may be	1
in program memory. This can	1
in program memory. If several	1
in vector c __m128i c2	2
in vector c2 with the	1
in vector Type of elements	1
in vector bc with the	1
in different C++ compilers The	1
in different versions for different	1
in different source files for	1
in different parts of the	1
in different places making the	1
in different ways. Example: //	1
in different modules. This may	1
in different browsers, different platforms,	1
in only the lowest of	1
in other programming languages, but	1
in other threads with lower	1
in other compilers. #include <excpt.h>	1
in other ways than by	1
in other modules than the	1
in other languages. But the	1
in other ways, as explained	1
in which the array is	1
in which the variable is	2
in which the elements are	1
in which the modules are	1
in which the modules appear	1
in which data are stored	1
in which they are used.	2
in which they are declared	1
in which they are created.	1
in which they appear in	2
in which alloca was called.	1
in all the CPU cores	1
in all possible cases of	1
in all systems that have	1
in all cases, while many	1
in all operands in case	1
in one memory pool. See	1
in one way or another.	1
in one big memory block	1
in one source file and	1
in one operation rather than	1
in one iteration of the	1
in one vector. It may	1
in one vector, the four	1
in one vector, while you	1
in one operation. A good	1
in one operation. For example,	1
in one contiguous memory block.	1
in integer registers. Typical candidates	1
in set number 28. The	1
in floating point variables in	1
in floating point expressions (see	1
in each vector depends on	1
in each CPU core). The	1
in each part of the	1
in each set. If the	1
in each case. Inlined functions	1
in each core. For example,	1
in example 15.1b is easier	1
in example 15.1b is implemented.	1
in example 13.1 can be	1
in example 13.1 page 127.	1
in example 13.1 below. 126	1
in example 16.2 calls the	1
in example 16.2 above, but	1
in example 15.1c is faster	1
in example 14.8 and 14.9	1
in example 12.4b can be	1
in example 14.28 can be	1
in example 14.28 will shift	1
in example 9.6b. The MOVNTQ	2
in example 9.5a goes from	1
in example 11.3 is independent	1
in example 11.3 even without	1
in example 14.12b and 14.13b	1
in example 14.14a with 14.14b	1
in example 12.4a so that	1
in example 8.15a were float	1
in example 14.19 below. The	1
in example 14.1c is copied	1
in example 11.2b was an	1
in example 11.1a to 11.1b	1
in example 15.1b. Branches are	1
in example 14.23 page 143.	1
in example 14.7b is converted	1
in example 7.32b. A for-loop	1
in example 8.15b. The integer	1
in example 16.2. The measured	1
in example 8.23b has two	1
in example 14.7b, we are	1
in example 8.24 can be	1
in example 16.1. This code	1
in example 7.35 page 52.	1
in example 12.1b, the compiler	1
in example 7.22. // Example	1
in example 9.5b. // Example	1
in example 7.43b is admittedly	1
in example 14.21 is faster	1
in example 9.1b. On the	1
in example 7.30b. The loop	1
in most libraries it is	1
in most cases be linked	1
in most cases you can	1
in most cases when the	1
in most cases where the	1
in most cases they are	1
in most cases, an optimizing	1
in most cases, but it	1
in most cases, even for	1
in most cases, regardless of	1
in most cases. The so-called	1
in most cases. This means	1
in most cases. Don't change	1
in most cases: The CPU	1
in using the larger vector	1
in Intel function libraries and	1
in Intel compiler Intel compilers	1
in Intel compiler ......................................................................... 130	1
in Intel compilers has several	1
in Intel processors is called	1
in Intel header files For	1
in b to 0 and	2
in library functions then it	1
in library functions, or if	1
in library libircmt.lib. Function names	1
in multiple versions for different	3
in multiple versions with and	1
in multiple versions should be	1
in multiple applications, but not	1
in multiple versions, each carefully	1
in two different registers. You	1
in two other situations: The	1
in two libraries It is	1
in two ways. The first	1
in two versions. A 32-	1
in two steps. All source	1
in static memory and will	1
in static memory and insert	1
in static memory can cause	1
in static memory. Example: //	1
in static memory. Most compilers	1
in 64-bit operating systems. Some	1
in 64-bit code. However, we	1
in 64-bit systems and in	1
in 64-bit systems by using	1
in 64-bit Windows (See page	1
in 64-bit Linux than in	3
in 64-bit mode or when	2
in 64-bit mode than in	1
in 64-bit mode because the	3
in 64-bit mode where the	1
in 64-bit systems. The latter	1
in 64-bit systems. It is	1
in 64-bit systems. If you	1
in 64-bit systems. Some compilers	1
in 64-bit systems. Floating point	1
in 64-bit systems. 67 The	1
in 64-bit mode. A conversion	1
in 64-bit mode. Therefore, the	1
in 64-bit mode. Make functions	1
in 64-bit Windows. The disadvantage	1
in 64-bit Windows. In 64-bit	1
in 64-bit device drivers for	1
in C++ is quite efficient	1
in C++ and Fortran. These	1
in C++ so you need	1
in C++ take more resources	1
in C++ An optimization guide	1
in C++ programs and also	1
in C++ programs. Writing past	1
in such a way that	1
in such cases. The most	1
in such applications. Alternatively, use	1
in array ; i++ ;checkifi<100	1
in many different applications. Therefore,	1
in many cases. For example:	1
in many cases. Integer expressions	1
in many commercial compilers due	1
in many respects and highly	1
in any of the examples	1
in any situation where a	1
in some very old DOS	1
in some systems because of	1
in some cases to use	1
in some cases and it	1
in some cases be advantageous	1
in some cases be determined	1
in some cases on Windows	1
in some cases take memory	1
in some cases even the	1
in some cases ignore a	1
in some cases, for example	1
in some cases, but not	1
in some cases, there is	1
in some compilers. If exception	1
in some cases. An even	1
in some cases. Multiple threads?	1
in some cases. Does not	1
in some embedded systems. A	1
in some situations, and which	1
in some rare cases of	1
in so that they are	1
in table The following table	1
in table 19 in manual	1
in table 8.1 below. Devirtualization	1
in table 9.1 show that	1
in table 8.1. The table	1
in table 9.2. All these	1
in table 9.2, such as	1
in performance can easily justify	1
in performance if the time-critical	1
in performance between the systems.	1
in performance between 32-bit and	1
in performance over other programming	1
in software writing style are	1
in software development. This unit-testing	1
in order to make the	5
in order to make a	1
in order to make it	1
in order to make software	1
in order to make sure	1
in order to make better	1
in order to make profiling	1
in order to test all	1
in order to access x	1
in order to avoid that	1
in order to avoid multiple	1
in order to avoid conversions	1
in order to get a	1
in order to get an	1
in order to get access	1
in order to get reliable	1
in order to calculate the	1
in order to optimize access,	1
in order to improve cache	1
in order to improve performance.	1
in order to know how	1
in order to find the	2
in order to find and	1
in order to prevent such	1
in order to save power.	1
in order to divide the	1
in order to divide i	2
in order to predict which	1
in order to enable constant	1
in order to align its	1
in order to implement this	1
in order to help the	1
in order to increase the	1
in order to identify individual	1
in order to force the	1
in order to cover the	1
in order to utilize the	1
in order to determine whether	1
in order to emulate the	1
in order to reserve resources	1
in order to minimize the	1
in between the calls to	1
in 32-bit or 64-bit mode.	1
in 32-bit operating systems and	2
in 32-bit systems and 8	1
in 32-bit systems and 64	1
in 32-bit systems and fourteen	1
in 32-bit systems and sixteen	1
in 32-bit systems when the	1
in 32-bit systems unless the	1
in 32-bit systems gives rise	1
in 32-bit Windows by transferring	1
in 32-bit Linux is that	1
in 32-bit mode so that	1
in 32-bit mode unless the	1
in 32-bit Mac code uses	1
in 32-bit systems. Virtual member	1
in 32-bit mode. The first	1
in 32-bit mode. The next	1
in 32-bit mode. The 32-	1
in 32-bit mode. If there	1
in 32-bit mode. Storing the	1
in 32-bit systems, but in	1
in 32-bit systems, especially if	1
in 32-bit mode, and more	1
in 32-bit mode, for reasons	1
in member functions is also	1
in member functions counts a	1
in critical parts of the	1
in 64 bit Windows and	1
in 64 bit Linux The	1
in 64 bit mode if	1
in 64 bit mode than	1
in 64 bit mode. The	1
in 64 bit mode, we	1
in registers in 64-bit systems.	1
in registers are accessed very	1
in registers by default in	1
in registers only in the	1
in registers rather than in	1
in registers rather than on	4
in registers (see page 27).	1
in registers instead of main	1
in registers anyway. Pure function.	1
in registers (6 integer and	1
in registers (8 float or	1
in test situations to avoid	1
in systems with only one	1
in these manuals can be	1
in system code or in	1
in system code. Dynamic memory	1
in 32 bit Linux Shared	1
in 32 bit mode and	1
in 32 bit mode. Some	1
in programming nowadays stress the	1
in case the function is	1
in case the code is	1
in case the array index	1
in case of an error	1
in case of an exception	2
in case of an exception.	1
in case of an error;	1
in case of large arrays	1
in case of overflow is	1
in case of overflow and	1
in case of overflow. The	1
in case of error. The	1
in case of mispredictions (see	1
in case of underflow: //	1
in case memory re-allocation is	1
in case F2 actually throws	1
in cases where the size	1
in cases where the performance	1
in cases where the parallelism	1
in cases where we are	1
in cases where they cannot	1
in simple cases where the	1
in simple cases. The explicit	1
in simple cases. 7.28 Templates	1
in simple cases. Database queries	1
in stack memory which is	1
in Gnu compiler // Same	1
in Gnu compiler A feature	1
in Gnu compiler ......................................................................... 128	1
in its own allocated memory	1
in its API. In some	1
in assembly code. Register ebx	1
in assembly language is provided	1
in assembly language. Here are	1
in assembly names. The details	1
in assembly language". The method	1
in assembly language". While we	1
in assembly language", section 17.9:	1
in assembly language: An optimization	1
in large data structures It	1
in large data structures .............................................................	1
in large arrays. Array size	1
in large applications. The string	1
in Windows 7 and Windows	1
in Windows MFC). This method	1
in compiled C++ or assembly	1
in compiled languages such as	1
in compiled C++. This typically	1
in big blocks rather than	1
in speed by using a	1
in speed by using vectors	1
in speed between using signed	1
in speed between single and	1
in speed between rounding and	1
in several stages before they	1
in small embedded applications have	1
in matrix // function to	2
in matrix 96 void transpose(double	1
in Linux and supported by	1
in Linux and BSD comes	1
in Linux and BSD. If	1
in Linux kernel version 2.6.30	1
in classes like string, wstring	1
in optimized programs. The profiler	1
in manual 3: "The microarchitecture	2
in manual 2: "Optimizing subroutines	3
in manual 5: calling conventions.	1
in manual 5: "Calling conventions	3
in manual 4: "Instruction tables".	2
in another source file. If	1
in another array. The disadvantage	1
in another module. The size	1
in eight consecutive elements in	4
in list in example 11.2b	1
in hardware in the x86	1
in optimizing library functions than	1
in optimizing application-specific code. The	1
in memory. The renaming mechanism	1
in memory. This prevents the	1
in memory. It will not	1
in memory. Example: // Example	1
in memory. Function parameters are	2
in memory. No information about	1
in memory. Variables and objects	1
in memory. They may be	1
in shared objects in Unix-like	1
in both the level-1 and	1
in both static and dynamic	1
in both Windows and Linux,	1
in both Windows and Linux.	1
in both cases. This is	1
in both compiler, operating system	1
in both 16-bit, 32-bit and	1
in programs that have many	1
in programs with many Boolean	1
in programs where security matters.	1
in programs compiled for 64-bit	1
in microprocessor hardware design. The	1
in Mac systems. 14 Specific	1
in Mac OS X. 14.13	1
in multiplication here: a[i] =	1
in mathematical iterations such as	1
in separate threads so that	1
in separate modules if necessary,	1
in various ways depending on	1
in applications that can take	1
in applications without an operating	1
in addition to the code	1
in addition to) the time	1
in your program to turn	1
in your program, you will	1
in XMM registers can benefit	1
in vectors of eight 16-bit	1
in x86 systems). 42 If	1
in binary representation of N:	1
in binary form than if	1
in just a few clock	1
in just one clock cycle.	1
in main will be used,	1
in main will take precedence,	1
in main has the same	1
in computer games and animations	1
in computer games. Such a	1
in C and C++ faster	1
in my vector class library).	1
in my test examples. The	1
in my blog. Here, you	1
in my experiments. Contentions in	1
in my crystal ball reveals	1
in STL for accessing container	1
in STL as a vector	1
in dynamically allocated memory, using	1
in Windows, you may write	1
in turn calls another function,	1
in fact be less than	1
in fact it does not,	1
in fact an integer that	1
in fact only 64-bit execution	1
in fact using each bit	1
in fact accessed through pointers	1
in fact doing the same	1
in fact represented as two	1
in fact addressed relative to	1
in vectorized code when the	1
in special cases where the	1
in special mathe- matical applications.	1
in Linux, BSD and Mac	1
in Linux, sched_setaffinity). The program	1
in registers. 64-bit Unix systems	1
in registers. Except for the	1
in performance. A good optimizing	1
in performance. There are cases,	1
in performance. I have no	1
in performance. Integer size conversion	1
in 16-bit systems or 64-bit	1
in 16-bit systems: int 16	1
in 16-bit systems: long int	1
in 16-bit systems: unsigned int	1
in 16-bit systems: unsigned long	1
in x, and last the	1
in full use rather than	1
in RAM memory. This may	1
in parallel if certain conditions	1
in either case. Intrinsic functions	1
in ebx ; shift down	1
in BSD work the same	1
in BSD Shared objects in	1
in chapter 12. If the	1
in chapter 12. Most modern	1
in chapter 9.10, then the	1
in chapter 11. Using the	1
in newer versions of Linux	1
in sequence are not necessarily	1
in linear algebra) require other	1
in row 28 share the	1
in Windows. It is more	1
in situations where the compiler	1
in situations where code caching	1
in situations where automatic vectorization	1
in situations like example 12.4a	1
in device drivers for 64-bit	1
in terms of code size.	1
in terms of program performance	1
in terms of execution speed	2
in terms of specific processor	1
in terms of usability problems	1
in terms of speed. Assume	1
in terms of development, testing	1
in addition, set the denormals-are-zero	1
in PC processors. The application	1
in almost all modern microprocessors	1
in almost all respects relevant	1
in interpreted languages where everything	1
in interpreted script languages, it	1
in vectors. These function libraries	1
in random order. The heap	1
in random order. This makes	1
in Linux. 32-bit Mac OS	1
in Linux. Address calculation is	1
in memory, as in example	1
in memory, at least temporarily.	1
in memory, but not if	1
in details. The funny looking	1
in thousand so the misprediction	1
in Intel's Math Kernel Library,	1
in registers, not in memory.	1
in registers, regardless of whether	1
in registers, whereas 64-bit Linux,	1
in registers, totaling up to	1
in dispatched version return (*SelectAddMul_pointer)(aa,	1
in column 28 because the	1
in column 28, the cache	1
in embedded systems ............................................................................. 158	1
in embedded systems Microcontrollers used	1
in 32- bit mode, where	1
in edx as a memory	1
in one. The compiler has	1
in edx, to ebx. The	1
in Fortran where the storage	1
in list, the compiler must	1
in ever more powerful computers	1
in b[i] and c[i] are	1
in regular patterns with fixed	1
in parallel. Modern CPUs are	1
in parallel. Small lightweight processors	1
in parallel. Fine-grained parallelism is	1
in parallel. Coarse-grained parallelism refers	1
in advance and the multiplication	1
in advance and stored in	1
in advance which of the	1
in advance rather than allocating	1
in efficiency. For example, x	1
in aa: StoreVector(aa + i,	3
in aa: a.store(aa+i); } }	1
in C, C++ or assembly	1
in sequential order and it	1
in www.agner.org/optimize/cppexamples.zip. An array using	1
in www.agner.org/optimize/cppexamples.zip. These may be	1
in tests on Intel compiler	1
in detail in manual 3:	1
in detail on page 146	1
in advance. The frequent allocation	1
in advance. The disadvantages of	1
in advance. This reduces the	1
in character arrays is fast	1
in Windows). There are several	1
in Windows). Alternatively, you may	1
in comparisons, such as <.	1
in kernel code" in manual	1
in Unix-like systems use position-independent	1
in Unix-like systems. Mac systems	1
in vectors, but the asmlib	1
in Day for signifying one	1
in x. The compiler is	1
in a. This operation will	1
in Sum2 and Sum3. Whether	1
in ASCII form. A disadvantage	1
in scientific computing, but for	1
in stdint.h char 8 -128	1
in non- sequential order. If	1
in itself, and the cost	1
in 36 C++ as 'this'.	1
in p1 and p2 having	1
in question. You may choose	1
in question. For example, a	1
in doubt how big a	1
in use. The installation of	1
in question without generating overflow.	1
in develop- ment time when	1
in C++: An optimization guide	1
in C++: Preprocessor directives. For	1
in loops. Consider the following	1
in Wikipedia under CPU cache	1
in Java, C#, Visual Basic,	1
in reusable and well- tested	1
in time-critical code. 7.32 Preprocessing	1
in exclusive mode, and an	1
in precompiled code. The history	1
in eax. The loop initialisation	1
in popularity when a genuine	1
in y. The purpose of	1
in duration compared with the	1
in interactive programs because the	1
in relation to execution time.	1
in edx. Furthermore, this solution	1
in general. Assume that a	1
in scope. A macro will	1
in advance, because a fixed	1
in two: // Example 11.2b	1
in 2015 or 2016. The	1
in nn ifbit=1 bitofn //	1
in Microsoft's .NET framework are	1
in F1? Then we are	1
in connection with reading the	1
in mind, that many users	1
in parts, for example if	1
in all, it will often	1
in applying the various optimization	1
in 2010. This feature is	1
in a[] which will change	1
in disguise. Enums are exactly	1
in question: Put in an	1
in Windows) to determine if	1
in isolation have been unsatisfied	1
in parallel: Using multiple CPUs	1
in green. It takes some	1
in favor of Intel CPUs	1
in a[i]. Note how efficient	1
in Linux). Threads are useful	1
in nature, it is important	1
in meaningless event counts for	1
The function is also available	1
The function is called through	1
The function that detects an	1
The function code is not	1
The function may return an	1
The function library at www.agner.org/optimize/asmlib.zip	1
The function call makes the	1
The function names in the	1
The function F1 is supposed	1
The function rounds a floating	1
The if branch is eliminated.	1
The if statement in this	1
The code is inlined -	1
The code is compact and	1
The code is __asm int	1
The code in the above	1
The code in this example	1
The code in example 16.2	1
The code in example 15.1c	1
The code in example 14.21	1
The code for accessing a	1
The code that accesses data	1
The code can be made	1
The code can now be	1
The code will read four	1
The code has a branch	1
The code cache works most	1
The code cache works less	1
The code examples in these	1
The code becomes more efficient	1
The code becomes more readable	1
The code becomes smaller if	1
The code goes through the	1
The code section is always	1
The code section contains no	1
The code section needs one	1
The compiler is not always	1
The compiler is more likely	1
The compiler is likely to	1
The compiler can use the	1
The compiler can then use	1
The compiler can also use	1
The compiler can replace a	1
The compiler can easily optimize	1
The compiler can eliminate this	1
The compiler may not be	1
The compiler may avoid the	1
The compiler may replace the	1
The compiler may replace this	4
The compiler may reduce this	2
The compiler may change this	1
The compiler may report that	1
The compiler may interleave the	1
The compiler will always select	1
The compiler will calculate (1./1.2345)	1
The compiler will store the	1
The compiler will replace this	1
The compiler will choose the	1
The compiler will produce the	1
The compiler will vectorize the	1
The compiler has to make	1
The compiler has not noticed	1
The compiler has replaced i	1
The compiler makes a distinction	1
The compiler cannot rule out	1
The compiler does not produce	1
The compiler doesn't have information	1
The compiler doesn't need induction	1
The compiler option -fno-pic apparently	1
The compiler supports CPU dispatching	1
The compiler comes with some	1
The compiler sometimes uses 32-bit	1
The compiler generates the following	1
The compiler inserts extra code	1
The this pointer in member	1
The time that is measured	1
The time it takes to	9
The time you spend on	1
The time when the CPUID	1
The time used for file	1
The time unit is clock	1
The time stamp counter becomes	1
The time measurements may require	1
The time consumption of different	1
The use of vector operations	1
The use of threads is	1
The use of structures (without	1
The use of coprocessors is	1
The } 59 third generations	1
The memory address at which	1
The memory space never becomes	1
The memory space becomes more	1
The data in this example	1
The data have to be	1
The data cache is optimized	1
The data members of a	1
The data section is not	1
The program is exception safe	1
The program can check the	1
The program or library has	1
The program code is distributed	2
The program may have to	1
The program will not be	1
The program has to keep	1
The program has an initialization	1
The program should be tested	1
The program should automatically detect	1
The program uses a procedure	1
The program logic may need	1
The vector class library will	1
The vector operations use a	1
The vector instructions cannot multiply	1
The different versions of an	1
The different versions of CriticalFunction	1
The different threads need separate	1
The different kinds of variable	1
The same can be expected	1
The same can happen in	1
The same example using Agner's	1
The same register can be	1
The same method can be	1
The same applies to an	1
The same applies to 3-dimensional	1
The same rules apply to	1
The same advice applies to	1
The same argument does not	1
The same coding rules apply	1
The functions are usually stored	1
The functions must have extern	1
The only way to make	1
The only allowed inputs are	1
The only CPUID information that	1
The CPU can hold many	1
The CPU will start to	1
The CPU dispatcher should not	1
The CPU dispatcher should have	1
The CPU dispatcher should give	1
The CPU dispatcher does not	1
The CPU dispatcher checks whether	1
The CPU dispatch mechanism in	1
The CPU dispatch mechanism can	1
The CPU supports this kind	1
The CPU family and model	1
The CPU market is developing	1
The other STL containers do	1
The instruction add ebx, DWORD	1
The instruction add eax,1 is	1
The loop in example 8.23b	1
The loop in example 8.24	1
The loop can still be	1
The loop will use the	1
The loop branch should be	1
The loop would be while	1
The loop counter i is	1
The loop count should preferably	1
The loop control condition The	1
The loop unrolling in example	1
The loop body now contains	1
The loop body begins at	1
The loop initialisation i=0; has	1
The cache line size is	1
The cache line size may	1
The cache works most efficiently	1
The integer size is not	1
The integer division prevents the	1
The integer representation of &list[100]	1
The integer comparison is likely	1
The floating point stack registers	1
The example on page 39	1
The compilers are better at	1
The compilers are becoming better	1
The compilers will not do	1
The compilers also have fast	1
The compilers I have studied	1
The most efficient vector operations	1
The most efficient loop control	1
The most critical part of	1
The most important method that	1
The most important disadvantage of	1
The most important addition to	1
The most important thing is	1
The most important remedy is	1
The most common mathematical functions	1
The most common implementations of	1
The most common pitfalls of	1
The most common time-consumers are	1
The most compatible way is	1
The most serious problem with	1
The most commonly used set	1
The most commonly used variables	1
The size of the integer	1
The size of the parent	1
The size of an int	1
The size of vector registers	1
The size of all but	1
The size of each object	1
The size of integers and	1
The size should always be	1
The size conversion often takes	1
The size (in bytes) of	1
The Intel compiler is a	1
The Intel compiler is capable	1
The Intel compiler can insert	1
The Intel compiler has solved	1
The Intel compiler allows you	1
The Intel compiler supports vector	1
The Intel compiler includes standard	1
The Intel compiler generates the	1
The Intel vector class library	1
The Intel compilers and function	1
The pointer is simply optimized	1
The library function will return	1
The library has preprocessing directives	1
The float type holds a	1
The multiple CPU cores or	1
The two comparisons i <	1
The two summation variables sum1	1
The object that looses ownership	1
The object oriented programming style	1
The object pointed to can	1
The number of elements in	1
The number of registers is	2
The number of branches and	1
The number of unused bytes	1
The number of logical processors	1
The number of context switches	1
The static memory is also	1
The static data area is	1
The static keyword has several	1
The static keyword also makes	1
The static declaration makes it	1
The 64-bit version is better	1
The 64-bit systems can improve	1
The C++ way of handling	1
The C++ language is chosen	1
The C++ language is portable	1
The C++ exception handling system	1
The C++ syntax has several	1
The clock frequency is increased	1
The clock frequency of the	1
The clock frequency may be	1
The clock counts are often	1
The version that works best	1
The version that performs best	1
The value is zero if	1
The value of the time	1
The value of cc[i]+2 is	1
The value of i&15 is	1
The objects are not stored	1
The objects stored in an	1
The return type of a	1
The table of coefficients is	1
The table can give some	1
The table should be declared	1
The table shows that it	1
The table shows whether the	1
The performance is inferior to	1
The performance can be improved	1
The performance on non-Intel processors	1
The performance monitor counters are	1
The performance measurement should not	1
The order of Boolean operands	1
The order of inheritance is	1
The order in which data	1
The branch inside the loop	1
The branch target buffer is	1
The member functions of parent	1
The way to use multiple	1
The way to increase the	1
The elements at the diagonal	1
The const keyword tells that	1
The address of x is	1
The address of list[i] is	1
The critical stride is 8192	1
The critical stride for the	1
The critical stride can be	1
The operating system may not	1
The operating system may have	1
The operating system may supply	1
The unsigned integer type size_t	1
The first time you activate	1
The first two integer parameters	1
The first way is to	1
The first processors that supported	1
The first processors with the	1
The first eight elements in	1
The first count is usually	1
The first count and the	1
The first thing to do	1
The first thing we notice	1
The first generation of processors	1
The first generation class (CGrandParent)	1
The register stack also has	1
The register keyword is only	1
The register keyword can be	1
The 64 bit instruction set	1
The 64 64 matrix size	1
The libraries included with the	1
The template parameter should be	1
The need for special position-independent	1
The test data should contain	1
The test should be performed	1
The test tool can set	1
The user may not need	1
The user interface library can	1
The user expects immediate responses	1
The method is faster if	1
The method is somewhat more	1
The method of induction variables	1
The method of bounds checking	1
The method in example 14.28	1
The method used in example	1
The method described above can	1
The method currently used for	1
The access is faster if	1
The SSE2 instruction set is	3
The following compiler versions were	1
The following example shows the	2
The following example shows a	1
The following example shows first	1
The following example shows how	5
The following example shows what	1
The following example illustrates the	1
The following example illustrates such	1
The following example illustrates how	1
The following example illustrates this.	1
The following example explains why	1
The following example transposes a	1
The following example converts a	1
The following table lists the	1
The following table summarizes the	1
The following list points out	1
The following methods may be	1
The following examples explain how	1
The following algorithm is used	1
The following sections describe some	1
The following guidelines can be	1
The following considerations should be	1
The following techniques can be	1
The system is likely to	1
The file will remain locked	1
The file http://www.agner.org/optimize/asmlib.zip contains complete	1
The dynamic libraries are loaded	1
The type of storage is	1
The type __m128i defines a	1
The type __m128 defines a	1
The type __m128d defines a	1
The & operator is also	1
The instructions mov ebx,eax /	1
The constant N1 could have	1
The constant (2n / b)	1
The stack is the most	1
The stack is a part	1
The stack unwinding mechanism is	1
The stack unwinding mechanism may	1
The Gnu function libraries are	1
The Gnu compiler is a	1
The Gnu compiler and the	1
The Gnu compiler can use	2
The Gnu compiler often inserts	1
The Gnu compiler allows "__attribute__((visibility("hidden")))".	1
The Gnu C++ compiler is	1
The Gnu libraries support 32-bit	1
The extra time may be	1
The assembly output option is	1
The assembly listing reveals three	1
The Windows and Linux operating	1
The Windows version is currently	1
The calculations may take more	1
The execution times per matrix	1
The execution core of modern	1
The result is the same	1
The result of the &	1
The result of comparing signed	1
The result will be misleading	1
The result ebx is then	1
The threads have each their	1
The best function libraries are	1
The best compilers use the	1
The best possible version of	1
The best performance is obtained	3
The best way to check	1
The best way to fully	1
The best solution is to	1
The best Java machines use	1
The speed is many times	1
The speed of CPUs is	1
The speed for certain tasks	1
The speed on non-Intel CPUs	1
The speed test should preferably	1
The c loop in example	1
The virtual processor may be	1
The common excuse that "we	1
The AMD math core library	1
The exception is costly when	1
The exception is caught by	1
The allocated memory is contiguous	1
The allocated memory may not	1
The AVX instruction set is	1
The AVX instructions have very	1
The optimized code looks like	1
The optimized part of the	1
The calculation of this polynomial	1
The calculation of expressions where	1
The calculation of graphics objects	1
The calculation of c+b will	1
The calculation becomes easier if	1
The calculation here gives a+b=0,	1
The parameters a and r	1
The problem is that it	1
The problem with this code	1
The problem only occurs because	1
The problem here is that	1
The solution a = 1.0f	1
The container class must have	1
The advantage of this method	1
The advantage of using a	2
The advantage of using static	1
The advantage of using powers	1
The advantage of using ready	1
The advantage of static data	1
The advantage of sharing the	1
The operators are inlined so	1
The operators &, |, ^,	1
The few clock cycles that	1
The standard template library (STL)	1
The standard stack frame is	1
The standard solution to this	1
The hardware definition language is	1
The values of nonzero floating	1
The values are then output	1
The values are simply put	1
The sign is stored as	1
The copy constructor can be	1
The copy constructors and destructors	1
The copy constructor, if any,	1
The intermediate code cannot be	1
The intermediate file format is	1
The intermediate files are then	1
The allocation of memory for	1
The allocation and deallocation of	1
The above code is serial	1
The above code can be	1
The above code will catch	1
The above example sets the	1
The above examples all use	1
The optimal number of accumulators	1
The space is automatically deallocated	1
The dispatching to C1::Disp() or	1
The dispatching mechanism can be	1
The next time a function	1
The next instruction mov DWORD	1
The next example shows this	1
The next two instructions add	1
The next line provokes an	1
The next section (page 131)	1
The next chapter describes how	1
The branches may take a	1
The multiplication by 2 in	1
The multiplication by columns in	1
The application program will be	1
The application program loads the	1
The expression a && b	1
The expression that is AND'ed	1
The expression (Tuesday | Wednesday	1
The Boolean operations can be	1
The Boolean operators produce a	1
The intrinsic vector functions have	1
The development time and maintainability	1
The development time for WTL	1
The name of this function	1
The name "position-independent code" actually	1
The conversion of i to	1
The conversion time is typically	1
The conversion from example 15.1b	1
The conversion between signed and	1
The disadvantage is that the	3
The disadvantage of function inlining	1
The disadvantage of using a	1
The disadvantage of 64-bit Windows	1
The disadvantage of compiling without	1
The high speed of modern	1
The high priority of structured	1
The Microsoft and Intel compilers	1
The Microsoft compiler does not	1
The division is inexact if	1
The source code is compiled	1
The cost of dynamic memory	1
The cost of task switching.	1
The cost of starting and	1
The cost of synchronizing and	1
The automatic dispatching can be	1
The automatic vectorization works best	1
The reason is that the	2
The reason is that a	1
The reason is that modern	1
The reason for this is	1
The reason for this efficiency	1
The reason for using an	1
The reason why the compiler	1
The reason why this effect	1
The reason why compilers do	1
The reason is, I guess,	1
The dispatcher function will most	1
The dispatcher changes the function	1
The string classes allocate a	1
The string length function scans	1
The programmer can use standard	1
The programmer does not have	1
The programmer typically thinks "what	1
The three functions Sum1, Sum2	1
The three clauses are separated	1
The keyword static, when applied	4
The keyword __fastcall changes the	1
The examples in this table	1
The examples are intended to	1
The examples on page 134	1
The difference is simply a	1
The difference between a software	1
The difference lies in the	1
The mechanism of static linking	1
The mechanism relies on non-	1
The last line is implicitly	1
The load time can be	1
The calling function must then	1
The XMM vector registers are	1
The second way is to	1
The second thing we notice	1
The second generation class gets	1
The second generation class (CParent<>)	1
The bigger vectors do not	1
The AVX2 instruction set also	1
The x86 processors are used	1
The process of dynamic allocation	1
The 512 512 matrix size	1
The advantages of function inlining	1
The advantages of using the	2
The advantages of using static	1
The advantages of using pointers	1
The advantages of using references	1
The advantages of dynamic memory	1
The advantages of dynamic linking	1
The advantages of alloca over	1
The results of my experiment	1
The results are listed in	1
The results are summarized in	1
The storage of text strings	1
The storage principles are the	1
The old C-style method of	1
The union forces the variable	1
The link to a function	1
The link order is usually	1
The appropriate version of the	1
The constructor or overloaded operator	1
The constructor sets all elements	1
The operands of the Boolean	1
The range of floating point	1
The smaller the system, the	1
The core clock cycles counter	1
The core clock cycle counter	1
The negative effects of object	1
The main advantage of the	1
The main reason why such	1
The main focus is on	1
The positive effects are: Variables	1
The overhead of call and	1
The overhead of parameter transfer	2
The overhead of semaphores, mutexes,	1
The change of a hard	1
The installation of downloaded program	1
The installation program makes a	1
The installation process should always	1
The syntax is simpler when	1
The syntax in example 7.43b	1
The syntax may seem a	1
The choice of compiler may	1
The choice of which method	1
The choice of hardware platform	1
The choice of platform is	1
The choice of algorithm is	1
The profiler counts how many	1
The profiler tells the CPU	1
The profiler tells the operating	1
The profiler inserts temporary debug	1
The profiler measures not only	1
The profiler identifies any hot	1
The modern microprocessors are not	1
The network access may be	1
The level-2 cache is 512	1
The fact that the floating	1
The fact that the Intel	1
The fact that the repeat	1
The fact that the representation	1
The output goes to the	1
The vectorized code should therefore	1
The costs of this bookkeeping	1
The costs of optimizing ...............................................................................................	1
The costs of optimizing University	1
The preceding paragraph described a	1
The safe way to handle	1
The Pentium 4 (NetBurst) CPU	1
The Pentium Pro instruction set	1
The efficiency of the final	1
The efficiency of a loop	1
The efficiency of different C++	2
The exponent is stored as	1
The exponent is always normalized,	1
The conditions that make it	1
The maximum loop count that	1
The maximum size of each	1
The maximum number of integer	1
The maximum number of floating	1
The maximum number of constants	1
The alignment of structure and	1
The offset of b is	1
The effect is much more	1
The effect is simply identical.	1
The effect of the keyword	1
The effect of the const_cast	1
The effect of dependency chains	1
The so-called objects are instances	1
The so-called nontemporal write instructions	1
The so-called iterators that are	1
The total size of each	1
The child class is given	1
The child classes implement the	1
The containers in the STL	1
The counters will stay on	1
The 128-bit XMM registers are	1
The 128-bit XMM vectors must	1
The names of the header	1
The names of inlined functions	1
The details of cache organization	1
The details about name mangling	1
The square brackets mean use	1
The bitwise operators are single	1
The bitwise operators produce 32	1
The bitwise operators &, |,	1
The bitwise AND operation isolates	1
The heap can easily become	1
The heap space becomes fragmented	1
The heap manager can spend	1
The heap manager will start	1
The heap manager has a	1
The target of branches and	1
The target address is predicted	1
The nontemporal write instructions are	1
The simplest and most clean	1
The simplest possible user interface	1
The simplest way to solve	1
The simplest case is a	1
The situation is more complex	1
The delay is less than	1
The delay is significant if	1
The delay on lazy binding	1
The newer instruction sets enable	1
The sequence of backwards compatible	1
The length of a clock	2
The penalty of cache misses	1
The reasons for this shift	1
The alternative solution of making	1
The 'this' pointer takes up	1
The gain in performance over	1
The gain depends on the	1
The declaration of the table	1
The map file includes the	1
The map file tells the	1
The microarchitecture of Intel, AMD	1
The 256-bit YMM vectors are	1
The subsequent counts give the	1
The subsequent sections describe various	1
The subsequent manuals are for	1
The transfer of a parameter	1
The latter is more efficient.	1
The latter is slightly more	1
The search for updates should	1
The logic of the program	1
The Microsoft, Intel and Gnu	1
The typical way to test	1
The usability may be poor	1
The procedure to calculate self-relative	1
The frequent allocation and de-allocation	1
The algorithms used for branch	1
The PLT entry initially points	1
The inputs for a console	1
The fastest execution is no	1
The Gnu, Intel and PathScale	1
The preferred method for transferring	1
The volatile keyword makes sure	1
The volatile keyword specifies that	1
The YMM registers are available	1
The purpose is to detect	1
The purpose of the while	1
The purpose of this is	1
The purpose of using smart	1
The D language allows compile-time	1
The carry bit can be	1
The trick is to roll	1
The trick of using a	1
The trick of using bitwise	1
The trick will fail if	1
The trick violates the strict	1
The disadvantages of dynamic memory	1
The update process should run	1
The developers may therefore fail	1
The profilers are not always	1
The linker will generate an	1
The representation of float, double	1
The Clang compiler is a	1
The Clang compiler combined with	1
The measured time is interpreted	1
The measured results were as	1
The factor sizeof(S1) = 16	1
The rules for prediction and	1
The latest versions of these	1
The log on process is	1
The CodeGear compiler cannot make	1
The principle of table lookup	1
The principle of lazy binding	1
The availability of various instruction	1
The .NET framework and the	1
The .NET framework should definitely	1
The newest instruction sets include	1
The prefetch instruction can be	1
The debugger cannot set a	1
The behavior of the Intel	1
The 32- bit x86 instruction	1
The worst case is a	1
The worst problem of the	1
The biggest disadvantage of using	1
The third thing that can	1
The CISC instruction set may	1
The CISC instruction set (called	1
The AND operator (&) and	1
The context switches after each	1
The live range of a	1
The OR operator (|) works	1
The advice of making the	1
The pow function uses logarithms	1
The pitfalls of unit-testing It	1
The pitfalls of unit-testing ......................................................................................	1
The equivalent expression b &&	1
The Codeplay compiler has some	1
The present manual is number	1
The highest performance that can	1
The highest efficiency is obtained	1
The "Intel Math Kernel Library"	1
The pre-increment operator ++i and	1
The older MMX registers, which	1
The 17 debug version of	1
The empty throw()specification is useful	1
The missing functions can be	1
The powN template is a	1
The powN template is calling	1
The lengths of the time	1
The splitting of software into	1
The splitting of N into	1
The consequence is that the	1
The consequence of such contentions	1
The original method of doing	1
The returned pointer or reference	1
The existing object can be	1
The explicit use of memset	1
The MOVNTQ instruction cannot be	1
The MOVNTQ instruction must be	1
The implicit 'this' pointer in	1
The tests were carried out	1
The conclusion is that the	1
The conclusion is that we	1
The conclusion to this argument	1
The C/C++ standard specifies that	1
The Intel-based Mac OS X	1
The updating mechanism should never	1
The exponential function can be	1
The generality of the STL	1
The initialization routine sets a	1
The -fpie option is less	1
The easiest way to make	1
The easiest way to overcome	1
The history of programming languages	1
The CPU- specific functions have	1
The InstructionSet() function is available	1
The unrolled loop takes up	1
The built-in code is not	1
The symbol interposition feature that	1
The fastcall modifier can make	1
The preprocessing macro INSTRSET is	1
The formats can be expressed	1
The FDIV bug is a	1
The dynamic_cast operator is used	1
The opposite of register is	1
The opposite order of the	1
The proxy is smaller and	1
The const_cast operator is used	1
The resulting code will be	1
The DLLs are relocated by	1
The renaming mechanism works only	1
The indirect function feature is	1
The theoretical background is further	1
The pragmas must be placed	1
The branching is done every	1
The creation of a temporary	1
The integrated development environment (IDE)	1
The recursion must always end	1
The insight you gain by	1
The funny looking name ?Func@@YAXQAHAAH@Z	1
The clumsy AND-OR construction in	1
The procedures for installation and	1
The [] operator will detect	1
The similarity between the operating	1
The vulnerability of software with	1
The 16-byte instructions MOVNTPS, MOVNTPD	1
The dot in the function	1
The Core2 processor performs better	1
The benchmark performance of competing	1
The recommendations are based on	1
The radical solution of making	1
The absence of such checks	1
The fallacy of measuring performance	1
The benefits of a copy	1
The allocation, deallocation and garbage	1
The ?: operator here is	1
The lesson we can learn	1
The FactorialTable in example 14.1c	1
The CodeGear, Codeplay and Watcom	1
The ultimate solution would be	1
The official C standard says	1
The reinterpret_cast operator is used	1
The characters '?', '@' and	1
The undocumented Intel library function	1
The static_cast operator does the	1
The IPP library does not	1
The distinctions between RISC and	1
The inequality sign must be	1
The i<20 loop control branch	1
The compactness of the code	1
The loop-branch is usually predicted	1
The advise of using powers	1
The sin function is defined	1
The MASM assembly language has	1
for the function call. Load	1
for the compiler to make	1
for the compiler to do	1
for the compiler to inline	1
for the compiler to optimize	1
for the compiler to predict	1
for the compiler to evaluate	1
for the compiler you are	1
for the memory model used	1
for the vector class library,	1
for the same cache lines.	2
for the same reason that	1
for the same variables. In	1
for the same resources. But	1
for the same resources, such	1
for the functions that are	1
for the CPU to overlap	1
for the CPU it is	1
for the CPU dispatcher to	1
for the other thread. However,	1
for the instruction set that	1
for the instruction set SSE2	1
for the loop counter, which	1
for the class Vec16s when	1
for the size of each	1
for the Intel Core and	1
for the two functions. The	1
for the object x when	1
for the C++ language, all	1
for the performance then there	1
for the 32-bit case. The	1
for the critical innermost loops.	1
for the first time because	1
for the first two suggested	1
for the new value of	1
for the user and a	1
for the SSE2 instruction set,	1
for the SSE2 instruction set:	1
for the following reasons: The	2
for the following reasons: Each	1
for the cases described in	1
for the error code. If	1
for the stack can be	1
for the result of the	1
for the specific instruction set.	1
for the specific purpose in	1
for the common language runtime	1
for the common entry point	1
for the exception handling is	1
for the exception handler, even	1
for the overflow condition inside	1
for the AVX and later	1
for the AVX instruction set	1
for the calculation of B.	1
for the parameters of the	1
for the supported instruction set.	1
for the hardware definition code	1
for the intermediate result (b+c)	1
for the next step. With	1
for the programmer to be	1
for the programmer to make	1
for the programmer to know	2
for the three functions. Sum1	1
for the end user who	1
for the end user. Installation	1
for the difference between rounding	1
for the link pointers and	1
for the appropriate type of	1
for the main memory in	1
for the installation process to	1
for the desired program structure.	1
for the desired instruction set.	1
for the whole program by	1
for the level-2 cache is	1
for the level-1 cache may	1
for the object. Make the	1
for the sake of the	1
for the sake of compatibility	2
for the sake of optimization.	1
for the sake of parallel	1
for the sake of fastest	1
for the sake of portability	1
for the sake of backwards	1
for the sake of efficiency.	1
for the sake of security.	1
for the sake of cross-platform	1
for the sake of modularity.	1
for the sake of security,	1
for the performance. 14.4 Integer	1
for the child class name	1
for the stack. The memory	1
for the stack. Is the	1
for the logical structure and	1
for the simplest cases, composite	1
for the CPU. Algebraic reductions	1
for the user. Time is	1
for the user. With the	1
for the Microsoft, Intel, Gnu	1
for the purpose of finding	1
for the latest instruction set	2
for the application. You may	1
for the availability of these	1
for the .NET framework as	1
for the project at hand.	1
for the commercial compilers. Mixing	1
for the linker. Both code	1
for the FDIV bug causes	1
for the reinstallation work to	1
for the IDE, for debugging	1
for the "FDIV bug". The	1
for the label. It uses	1
for the <, <=, >	1
for the pros and cons	1
for the newsgroup comp.lang.asm.x86 for	1
for is likely to be	1
for a and b because	1
for a very large shared	1
for a new object is	1
for a Windows compiler to	1
for a result then we	1
for a specific instruction set,	1
for a specific purpose. It	1
for a specific purpose, you	1
for a specific purpose: Contain	1
for a single function by	1
for a virtual function call	1
for a few functions that	1
for a list of titles.	1
for a particular memory address	1
for a particular CPU or	1
for a particular instruction set	1
for a particular set of	1
for a particular purpose. The	1
for a higher instruction set	1
for a higher clock frequency	1
for a 512 512 matrix	1
for a given instruction set.	1
for a given task is	1
for a further discussion of	1
for a discussion of this	1
for a discussion of profiling.	1
for a low instruction set	1
for a lower instruction set.	1
for a portable way of	1
for a console mode program	1
for a discussion. 7.33 Namespaces	1
for a 2'nd order polynomial:	1
for // multiply // square	1
for function libraries distributed as	1
for function F1. However, if	1
for code that is ported	1
for code that can benefit	1
for code bloat and complexity	1
for an integer constant, unless	1
for an example of how	2
for an explanation of this	1
for an explanation of return	1
for an explanation of branch	2
for an explanation of register	1
for an explanation and possible	1
for an increasing number of	1
for an explanation. Note that	1
for an explanation. (The Microsoft	1
for an example. A union	1
for x to the power	1
for this is that the	1
for this instruction set and	1
for this manual for reasons	1
for this function, though not	1
for this task when the	1
for this shift in software	1
for this efficiency lies in	1
for this purpose. It just	1
for this purpose, or you	1
for this reason. A program	1
for use as pivot in	1
for more than one variable	1
for more information about mathematical	1
for more complicated mathematical tasks.	1
for more advanced data structures	1
for more discussion of the	1
for vector operations. Algorithms that	1
for vector operations, see page	1
for vector intrinsics. Digital Mars	1
for different instruction sets from	1
for different instruction sets Microprocessor	1
for different instruction sets........................... 122	1
for different Intel CPUs. It	1
for different C++ compilers and	6
for different objects even when	1
for different processors and instruction	1
for different processors are covered	1
for different arrays even if	1
for different matrix sizes were	1
for different compilers. This function	1
for different CPUs. This is	1
for different CPUs. (See page	1
for different platforms as shown	1
for different purposes is beyond	1
for different microprocessors, different alignments	1
for functions that are not	1
for CPU dispatching and is	1
for CPU brand simply by	1
for other integer expressions Induction	1
for other virtual processors on	1
for other purposes. The use	1
for other purposes. This is	1
for other brands of CPUs	1
for other purposes than it	1
for other purposes than rendering	1
for other reasons, but part	1
for other optimizations, as explained	1
for all the objects (memory	1
for all the necessary cleanup	1
for all functions and a	1
for all static data, including	1
for all these purposes. This	1
for all public and static	1
for all modules that use	1
for all platforms. PathScale C++	1
for all unknown processors that	1
for all applications. 2.8 Overcoming	1
for all suitable functions in	1
for all objects. This is	1
for all Unix-like platforms. Clang	1
for all major platforms. Pascal	1
for all squares: for (r1	1
for one array rather than	1
for one segment then it	1
for integer vector division. 12.4	1
for integer division in vectors,	1
for integer overflow. Signed versus	1
for integer constants. Register storage	1
for class member functions because	1
for floating point calculations whenever	1
for floating point addition and	1
for floating point expressions or	1
for floating point overflow: _controlfp_s(&dummy,	1
for floating 26 point constants,	1
for each function call so	1
for each different value of	1
for each other in order	1
for each instruction set. A	1
for each set of template	1
for each version void FUNCNAME(short	1
for each version FuncType SelectAddMul,	1
for each test // Repeat	1
for each type of microprocessor.	1
for each processor model is	1
for each element __m128i a	1
for each thread than to	1
for each allocated block. Walking	1
for each line written. This	1
for each process when compiled	1
for each object. A little-known	1
for each iteration is a	1
for each thread. This structure	1
for each thread. It is	1
for each thread. Thread-local storage	1
for each version. The examples	1
for each row or column.	1
for each process. A dynamic	1
for each process. Obviously, we	1
for each calculation. In most	1
for example to produce tables	1
for example if you want	1
for example if you write	1
for example when you discover	1
for example when r =	1
for example i = 18,	1
for example 32 bits of	1
for example every time a	1
for example 9.5 because we	1
for compilers that support intrinsic	1
for most purposes the standard	1
for using the performance monitor	1
for using an intermediate code	1
for using overloaded functions. 7.27	1
for double precision. You may	1
for double precision. But the	1
for size is relevant when	1
for size and optimizing for	1
for Intel CPUs. New versions	1
for Intel CPUs, not for	1
for pointer conversions. It does	1
for library functions. The compiler	1
for float expressions Automatic vectorization	1
for multiple variables as long	1
for multiple purposes. All dynamic	1
for multiple purposes. Floating point	1
for 64-bit operating systems and	1
for 64-bit Linux and Windows	1
for 64-bit integers. Many 32-bit	1
for 64-bit Windows). The XMM	1
for C++ for several reasons.	1
for such optimizations with option	1
for such errors in cases	1
for such applications, but it	1
for array elements Induction variables	1
for array bounds violations, invalid	1
for array bounds violations and	1
for array bounds violation, integer	1
for array sizes and array	1
for many of these purposes.	1
for many different purposes. The	1
for many different purposes. However,	1
for many common purposes (www.boost.org).	1
for many standard tasks are	1
for many applications even on	1
for many computer users and	1
for many programmers and they	1
for many platforms, including 32-bit	1
for many years to come.	1
for objects stored in memory.	1
for objects stored in dynamically	1
for any other resource, such	1
for any library functions called	1
for any compile-time constant n,	1
for some small low-power CPUs	1
for some CPU-intensive applications with	1
for some caveats. We can	1
for some links. 20 Copyright	1
for variables that are shared	1
for variables declared with the	1
for performance reasons. Use these	1
for very long on a	1
for very large data bases,	1
for very large libraries. The	1
for software to add new	1
for software users as well	1
for software teachers to recommend	1
for 32-bit and 64-bit code	1
for 32-bit and 64-bit systems.	1
for 32-bit software because the	1
for 32-bit Windows and 32-bit	1
for 32-bit Mac OS X	1
for 32-bit Mac OS X,	1
for 32-bit Windows, including an	1
for 32-bit Windows. Does not,	1
for 32-bit Windows. Integrates into	1
for 32-bit integers, depending on	1
for branch prediction are different	1
for branch mispredictions. The performance	1
for member functions. You can	1
for elements in a specific	1
for elements inside sqaure: for	1
for address calculation in 64	1
for critical applications because the	1
for less intensive applications. Some	1
for example, to go one	1
for example, to convert float	1
for example, that a is	1
for example, you can double	1
for example, you should multiply	1
for example, you want to	1
for register variables are temporary	1
for register variables. This includes	1
for register storage. The same	1
for how to use the	1
for how to make this	1
for how to test for	1
for how to check for	1
for how to store strings	1
for how to align dynamically	1
for how to overcome this	1
for test purposes. The const	1
for test purposes. If the	1
for user input or network	1
for user input or reading	1
for user input. The time	1
for user input. Many programs	1
for user input. (In Windows	1
for these variables. The negative	1
for these calculations. Division of	1
for these methods. If you	1
for even the smallest list	1
for sure whether the arrays	1
for SSE2 and later instruction	1
for SSE2 or x64 141	1
for system code. System code	1
for file input and output	1
for dynamic allocation. The heap	1
for simple types such as	1
for simple tasks like pressing	1
for simple variables, arrays and	1
for simple tasks. Sometimes it	1
for making the structure in	1
for making a debug version	1
for making data more compact.	1
for making multiple versions of	1
for making clear and well-structured	1
for making plug-ins that add	1
for CPUs with only the	1
for CPUs with slow bit	1
for assembly language output. On	1
for assembly programmers and compiler	1
for assembly output. The assembly	1
for large data sets. However,	1
for large libraries where only	1
for arrays bigger than 2	1
for Windows and the Gnu	1
for Windows and to Eclipse	1
for Windows and C++ is	1
for Windows are fully compatible	1
for Windows applications. The choice	1
for execution speed and for	1
for big objects that take	1
for threads that jump between	1
for best performance. The Windows	1
for speed is relevant when	1
for speed or size. Today,	1
for speed /O2 or /Ox	1
for specific CPU brands or	1
for specific CPU models. However,	1
for single precision than for	1
for several different CPUs. On	1
for several different purposes. All	1
for several seconds because it	1
for several iterations of redesign.	1
for several reasons. C++ is	1
for common mathematical calculations including	1
for AMD CPUs use AMD	1
for AMD CPUs. New versions	1
for AMD Family 15h Processors".	1
for exception handling unless the	1
for small x // align	1
for small x // x^n	1
for small embedded systems. Today	1
for overflow of the arrays.	2
for overflow and works only	1
for overflow by checking if	1
for overflow before it occurs,	1
for overflow outside the loop	1
for good code performance is	1
for matrix a: // Example	1
for Linux have an attribute	1
for Linux systems. The user	1
for Linux platforms if the	1
for AVX or later with	1
for another memory access. Assume	1
for (i = 0; i	26
for (i = 2; i	1
for (i = StringLength; i	1
for (i = (int)n -	1
for support of the different	1
for doing two or more	1
for doing some calculations at	1
for doing parallel calculations on	1
for inline assembly on all	1
for every element in the	1
for every four objects. STL	1
for every iteration of the	1
for standard tasks such as	1
for sign and rounding 137	1
for copy constructors and overloaded	1
for optimizing execution speed or	1
for optimizing code, as explained	1
for information stored by the	1
for certain tasks on current	1
for intermediate results, which may	1
for fast and easy development	1
for fast 32-bit software development",	1
for fast access to array	1
for fast division c =	1
for fast math and the	1
for (int i = 0;	13
for (int n = 1;	1
for programs that are based	1
for programs implemented in compiled	1
for Mac OS X (Darwin)	1
for multiplication } // ipow	1
for handling a full size	1
for Boolean vector operations. 7.6	1
for intrinsic functions // This	1
for intrinsic functions You have	1
for intrinsic functions (i.e. Microsoft,	1
for intrinsic functions, but the	1
for mathematical functions such as	1
for high precision math allow	1
for high precision math. Memory	1
for source annotation in the	1
for running multiple threads in	1
for automatic CPU dispatching. Many	1
for automatic updates, remote help	1
for string searching and parsing	1
for better metaprogramming tools to	1
for applications that can be	1
for examples of how to	3
for char pointers. 144 The	1
for char pointers). An optimizing	1
for runtime type identification (RTTI).	1
for actually making a pointer.	1
for Intel, AMD and VIA	1
for later maintenance. However, this	1
for calling from other applications	1
for your compiler for restrictions	1
for your application then you	1
for XMM registers; see page	1
for vectors There are various	1
for AVX2 and all three	1
for x86 platforms. 3. The	1
for old processors without the	1
for advanced programmers and software	1
for switch statements because switch	1
for switch statements, as explained	1
for things like adding vectors.	1
for negative numbers. The exponent	1
for example: Use a reference	1
for positive and 1 for	1
for positive n. You can	1
for my optimization manuals. I	1
for my test tool for	1
for relative addressing of data.	1
for installation and uninstallation of	1
for Windows, while most of	1
for Windows, Linux and Mac	2
for Windows, -msse2, -mavx, etc.	1
for inlining a function if	1
for network resources cannot be	1
for whole program optimization or	1
for whole program optimization. This	1
for level-2 cache contentions than	1
for response from a hard	1
for vectorization Not all code	1
for checking multiple values at	2
for checking how well the	1
for level-1 cache contentions is	1
for vectorized table lookup Using	1
for vectorized table lookup. These	1
for local objects are called.	1
for local references. If we	1
for local references. Shared objects	1
for constants that are never	1
for special position-independent code is	1
for special purposes are also	1
for further discussion of the	1
for further discussion of this	1
for further discussion of system	1
for further optimizations. Loops with	1
for further explanation. The following	1
for further discussion. Integer to	1
for further expansions of the	1
for discussion of efficient container	1
for discussion of aligning dynamically	1
for testing multiple conditions in	1
for testing single assembly instructions	1
for tasks such as sorting,	1
for optimization. For example, the	1
for accessing the same data	1
for accessing a data member	1
for accessing arrays forwards, not	1
for accessing container elements are	1
for accessing list[i].a and list[i].b.	1
for adding bounds-checking to an	1
for 16-bit mode and some	1
for disk operations to finish.	1
for classes. The splitting of	1
for N a power of	1
for N = 0 //	1
for N = 1. This	1
for details on when objects	1
for details about rounding. Pointer	1
for details (www.agner.org/optimize/testp.zip). A particularly	1
for containing thread-specific data and	1
for initialized variables that may	1
for improved performance. A copy	1
for updates should be optional	1
for updates each time the	1
for updates every time the	1
for parallel processing. Scott Meyers:	1
for calculating the address of	1
for calculating the addresses of	1
for calculating the physical movements	1
for calculating the movements of	1
for calculating a polynomial. Scheduling	1
for calculating row addresses at	1
for calculating self- relative addresses	1
for SSE4.1 and one for	1
for garbage collection. The allocated	1
for buffer overflow on input	1
for future models of the	1
for unaligned arrays. There are	1
for significant improvements. Making too	1
for reasons of mathematical purity.	2
for reasons explained on page	4
for setting up a stack	1
for 'this' is incurred on	1
for Windows. 10 Multithreading The	1
for approximately two clock cycles.	1
for finding the hot spots	1
for finding the right version	1
for finding the right formula	1
for finding the numerically largest	1
for finding problems that relate	1
for finding hot spots, but	1
for finding elements. A hash	1
for hard disk copying. Security.	1
for usability reasons. The programmer	1
for overflow. This function is	1
for overflow. Example: // Example	1
for false and 1 for	1
for temporary storage. Variables that	1
for prediction and misprediction of	1
for background services under advanced	1
for background jobs. The context	1
for interrupt 3. The code	1
for general function libraries that	1
for general purposes in 32-bit	1
for multiplying the index by	1
for random number generators. In	1
for D are not yet	1
for debugging and exception handling.	1
for debugging facilities, easy GUI	1
for Linux. It can also	1
for Linux. 82 Keywords that	1
for Java today. But this	1
for executing the same piece	1
for free in the Microsoft	1
for ( ; i <	1
for exceptions thrown by F2	1
for storing function return addresses	1
for storing user data. A	1
for storing text or input	1
for powers of 2 (i.e.	1
for polymorphism A template class	1
for details. The behavior of	1
for details. // Example 12.7.	1
for details. Use function libraries	1
for details. Note that the	1
for details. Development time Some	1
for details. Inheritance from multiple	1
for speed. Optimizing for size	1
for giving the function a	1
for giving specific optimization instructions	1
for converting the data to	1
for converting a pointer to	1
for specifying parallel processing in	1
for self-relative addressing of data.	1
for 32- and 64-bit Windows,	1
for 32- and 64-bit Linux.	1
for security reasons before leaving	1
for communication and synchronization between	1
for communication between different threads,	1
for avoiding the costs of	1
for avoiding infinite loop if	1
for internal references. 64-bit Mac	1
for internal references. There is	1
for internal references. Therefore, it	1
for reducing the time spent	1
for strict floating point calculations	1
for (c = 0; c	4
for lists that are so	1
for computing mathematical functions such	1
for computing i/2+r. The instructions	1
for Basic soon became available	1
for CPU-intensive code, as described	1
for present processors rather than	1
for turning off all optimizations	1
for regular access patterns containing	1
for true. Boolean variables are	1
for defining constants. For example,	1
for restrictions on using alloca.	1
for overflow, and the code	1
for transferring composite objects to	1
for transferring additional parameters. Therefore,	1
for saving a backup copy	1
for saving memory space by	1
for saving registers that have	1
for (b + c) The	1
for mixing different floating point	1
for mixing single and double	1
for (r = 0; r	2
for (r = 1; r	2
for detailed instructions. Example: //	1
for application-specific code. If you	1
for virus scanners to consume	1
for constants. Integer constants are	1
for prefetching data for the	1
for aligning data #ifdef _MSC_VER	1
for assuming no pointer aliasing	1
for speed-critical functions by using	1
for speed-critical functions. Many function	1
for calculations: for ( ;	1
for multi-core processing. Visual Studio	1
for generality and flexibility, while	1
for (i=0; i<100; i++) sum	1
for (i=0; i<n; i++) is	1
for (i=0; i<n; ++i). But	1
for implementing a compile-time polymorphism,	1
for implementing polymorphic classes. Each	1
for cleaning up and calling	1
for improving the code. //	1
for improving code that contains	1
for organizing data into classes	1
for metaprogramming, as explained at	1
for InstructionSet() #include "asmlib.h" //	2
for (x = 0; x	2
for (x = 2.0; x	1
for free. Visual Studio can	1
for interpreting or compiling the	1
for jumping out of a	1
for modifying the name in	1
for vacant spaces. This is	1
for supporting multiple platforms or	1
for supporting multi-threaded software are	1
for uninitialized variables that may	1
for putting the right data	1
for preventing program errors in	1
for creating and deleting the	1
for Unix applications and the	1
for audio and video processing,	1
for updating. The update process	1
for (c2 = r1; c2	1
for (c2 = c1; c2	1
for marketing reasons. This may	1
for verifying the functionality of	1
for WTL applications can be	1
for millisecond resolution. A much	1
for "assume no pointer aliasing"	1
for manipulating floating point variables	2
for parallelization in the code	1
for AVX. These suffixes are	1
for AVX. 5. The loop	1
for Tuesday, Wednesday or Friday	1
for dealing with this problem:	1
for trivial tasks such as	1
for recovering or for issuing	1
for studying a piece of	1
for statistics, signal processing and	1
for exclusive access by each	1
for assigning different priorities to	1
for relieving the const restriction	1
for shared_ptr than for auto_ptr.	1
for (r2 = r1; r2	1
for (r2 = r1+1; r2	1
for exploiting fine-grained parallelism. The	1
for IA-32/Intel64, 2009. Gnu C++	1
for transposition of different size	1
for issuing an error message.	1
for incrementing a loop counter,	1
for Linux) 4. Align arrays	1
for those who want to	1
for investigating performance problems. The	1
for vectorization............................................................. 117 12.7 Mathematical	1
for detecting errors that seldom	1
for transposing and copying different	1
for foreground jobs and 10	1
for minimizing memory fragmentation. Bounds	1
for (j = 0; j	1
for auto_ptr. Smart pointers can	1
for response. It is the	1
for vectors........................................................................ 119 12.8 Aligning	1
for holding the pointer. These	1
for (c1 = 0; c1	1
for signifying one of the	1
for demonstration purposes. Available from	1
for SSE2, preferably 32 for	1
for hackers. It is necessary	1
for (row = 0; row	1
for (r1 = 0; r1	1
for pow(x,N) where N is	1
for both, while the expression	1
for combining multiple .cpp files	1
for (temp = &list[0]; temp	1
for correctness must be found	1
for vectorizing mathematical code. There	1
for Nerds at Wikibooks. The	1
for everything, which is quite	1
for analysis. If the program	1
for fetching a cache line	1
for Basic. A compiler for	1
for details). The Intel compiler	1
for educational purposes is allowed.	1
for correctness. It is therefore	1
for RTTI then turn it	1
for 80x86 / x64 (Visual	1
for speeding up 64-bit shared	1
for "standard stack frame" or	1
for AVX2, or two 128-	1
for "function level linking" if	1
for raising an exception in	1
for NOT. Instead, you can	1
for discussions. Turn on the	1
for (column = 0; column	1
for reserving memory in advance.	1
for identifying hot spots in	1
for distinguishing between the number	1
that the function is not	1
that the function is also	1
that the function is always	1
that the function cannot be	1
that the function call statement	1
that the function must check	1
that the if condition can	1
that the code is optimized	1
that the code is exactly	1
that the code you are	1
that the code cache is	1
that the code becomes bigger	1
that the compiler has chosen	1
that the compiler takes the	1
that the compiler takes care	1
that the compiler cannot rule	1
that the compiler uses a	1
that the compiler needs to	1
that the compiler generates is	1
that the compiler sees the	1
that the use of classes	1
that the memory space is	1
that the memory footprint is	1
that the same function may	1
that the only reasonable solution	1
that the CPU doesn't support,	1
that the CPU dispatcher in	1
that the CPU dispatch mechanism	1
that the CPU core is	1
that the CPU supports the	1
that the loop will take	1
that the loop exits, when	1
that the cache will be	1
that the integer has enough	1
that the floating point format	1
that the compilers may behave	1
that the compilers cannot do	1
that the most critical integer	1
that the Intel function libraries	1
that the Intel compiler has	1
that the Intel CPU dispatcher	1
that the pointer does not	1
that the two constants are	1
that the object it points	1
that the object owns. A	1
that the number of lines	1
that the number of cores	1
that the 64-bit systems will	1
that the clock cycles spent	1
that the clock frequency may	1
that the clock frequency goes	1
that the value is poorly	1
that the value of the	2
that the value of a	1
that the value of register	1
that the value before the	1
that the value pointed to	1
that the objects are aligned.	1
that the variable always has	1
that the variable pointed to	1
that the variables might have	1
that the table is initialized	1
that the software programming language	1
that the order of floating	1
that the member pointer refers	1
that the elements are accessed	1
that the address of a	1
that the critical stride is	1
that the bit scan instruction	1
that the operating system has	1
that the first two (three	1
that the template parameters are	1
that the user must install	1
that the user actually has	1
that the user interface is	1
that the system code is	1
that the system may store	1
that the type conversion takes	1
that the arrays are aligned	1
that the arrays are aligned,	1
that the result can be	1
that the processor can do	1
that the compiled code may	1
that the list does not	1
that the values of a	1
that the values of A,	1
that the addresses are accessed	1
that the microprocessor can execute	1
that the microprocessor has the	1
that the microprocessor has made	1
that the microprocessor wastes several	1
that the next processor model	1
that the next instance of	1
that the next generation of	1
that the name cannot be	1
that the conversion is valid.	1
that the dispatcher function is	1
that the programmer can do	1
that the programmer forgets that	1
that the end user is	1
that the end user will	1
that the last index changes	1
that the numbers in b[i]	1
that the operands are integer	1
that the operands have no	1
that the overhead of parameter	1
that the C style string	1
that the syntax is fully	1
that the choice of user	1
that the choice of programming	1
that the level-2 cache cannot	1
that the response time is	1
that the response time to	1
that the repeat count has	1
that the alignment is not	1
that the compatibility with older	1
that the final result will	1
that the amount of necessary	1
that the rows are accessed	1
that the beginning of the	1
that the declaration class CChild1	1
that the background job can	1
that the linker extracts the	1
that the representation of the	1
that the break will occur	1
that the portability could be	1
that the behavior of signed	1
that the rest of the	1
that the loader will have	1
that the original object is	1
that the C/C++ standard specifies	1
that the resulting machine code	1
that the branching takes time.	1
that the reader has a	1
that the overall computation time	1
that the remaining bits represent	1
that the producer will try	1
that the occurrence is rare.	1
that is a power of	2
that is a linear function	1
that is not part of	1
that is an n'th degree	1
that is more efficient than	1
that is used is branch	1
that is used for Java	1
that is used by multiple	1
that is used by exception	1
that is used only within	1
that is most often true	1
that is two or more	1
that is member of the	1
that is stored in stack	1
that is called from the	1
that is called before the	1
that is always true/false Loopunrolling	1
that is part of the	1
that is compiled for the	1
that is compiled as position-independent	1
that is big enough to	1
that is big enough for	1
that is allocated is also	1
that is allocated dynamically (with	1
that is calculated the fastest	1
that is four places back.	1
that is shared between multiple	1
that is optimal for each	1
that is n places back,	1
that is difficult to understand	1
that is longer than a	1
that is actually needed by	1
that is divisible by the	1
that is divisible by 16	1
that is divisible by 16.	1
that is compatible with that	1
that is compatible with CPUs	1
that is compatible with old	1
that is obtained with virtual	1
that is initialized when the	1
that is easier to maintain.	1
that is organized in a	1
that is added to p	1
that is almost independent of	1
that is measured in this	1
that is larger than the	1
that is AND'ed with all	2
that is said here about	2
that is coded as an	1
that is slow, difficult to	1
that is ported to multiple	1
that is distributed. The intermediate	1
that a is true 50%	1
that a function is not	1
that a function is pure	1
that a function opens a	1
that a compiler generates to	1
that a will never be	1
that a program reads from	1
that a loop in a	1
that a value is less	1
that a variable is never	2
that a variable can be	1
that a call to _endthread()	1
that a template class is	1
that a new bigger memory	1
that a user has to	1
that a must be read	1
that a specific pointer does	1
that a particular memory address	1
that a particular programming language	1
that a particular application uses	1
that a particular reduction would	1
that a binary search, or	1
that a positive list needs	1
that a detailed overview of	1
that a user-defined function is	1
that a low-priority thread steals	1
that of yesterday's big mainframe	1
that for a portable way	1
that are not known at	1
that are not critical. It	1
that are not computationally intensive	1
that are not accessible from	1
that are not reproducible. Such	1
that are only available with	1
that are used in the	3
that are used in multiple	1
that are used in STL	1
that are used by many	1
that are used most for	1
that are used together are	2
that are used together should	4
that are used near each	1
that are no longer used	1
that are so small that	1
that are very difficult to	1
that are stored in registers	1
that are available to fit	1
that are up to five	1
that are best at doing	1
that are allocated in sequence	1
that are shared between multiple	1
that are members of a	1
that are never used at	1
that are never modified by	1
that are running in parallel.	1
that are too large for	1
that are needed from the	1
that are difficult to find	1
that are declared as constant	1
that are declared outside of	1
that are bigger than the	1
that are called. A considerable	1
that are based on big	1
that are intended for system	1
that are particularly important on	1
that are particularly critical. 129	1
that are scattered around in	1
that are missing in the	1
that are coded in a	1
that are modified should be	1
that are read-only can be	1
that are impossible with references.	1
that are fine-tuned for specific	1
that are inherently serial, such	1
that can be used where	1
that can be optimized further.	1
that can be predicted depends	1
that can be predicted perfectly	1
that can be vectorized if	1
that can be improved is	1
that can be improved by	1
that can be critical. Therefore,	1
that can be divided into	1
that can be coded in	1
that can be moved out	1
that can be obtained. If	1
that can be cross- compiled	1
that can be improved. 3.2	1
that can be programmed in	1
that can be reduced. This	1
that can make dynamic link	1
that can do whole program	1
that can call all code	1
that can take advantage of	1
that can reduce any expression,	1
that can go more than	1
that can prevent the compiler	1
that can tell how many	1
that can possibly be obtained	1
that can possibly throw an	1
that can easily be organized	1
that can benefit from its	1
that can skip large expressions	1
that can steal the user's	1
that it is not accessed	1
that it is not portable	1
that it is not human	1
that it is more efficient	1
that it is possible to	1
that it is very important	1
that it is stored on	1
that it is necessary to	1
that it is necessary here	1
that it is difficult for	1
that it is relevant for	1
that it is intended to	1
that it is initialized only	1
that it is safer to	1
that it is unrealistic that	1
that it can be predicted	1
that it can be initialized	1
that it can be represented	1
that it can be disabled	1
that it can have no	1
that it can use the	1
that it can start a	1
that it can multiply by	1
that it can move outside	1
that it may not be	1
that it may cause a	1
that it may detect the	1
that it will not be	1
that it has i instead	1
that it has chosen the	1
that it takes to do	1
that it takes six times	1
that it takes 40% more	1
that it makes program development	1
that it makes sure the	1
that it cannot be shared.	1
that it cannot access any	1
that it does not spend	1
that it does some funny	1
that it doesn't have to	2
that it doesn't work well	1
that it doesn't occur. In	1
that it allows the compiler	1
that it allows larger floating	1
that it becomes full. This	1
that it calls. The best	1
that it calls. 48 Use	1
that it rarely justifies the	1
that it writes only, then	1
that it fits into a	1
that it adds an extra	1
that it jumps to. Example:	1
that it attempts to set	1
that if the elements matrix[r][c]	1
that if a piece of	1
that if you are doing	1
that if each addition depends	1
that code cache and data	1
that an object must be	1
that an optimizing compiler will	1
that compiler makers assume that	1
that x is treated as	1
that may be used for	1
that may be necessary. If	1
that may be modified by	2
that may need to be	1
that may improve the performance	1
that you are dealing with	1
that you can make an	1
that you can do is	1
that you can do this	1
that you can turn on	1
that you can predict where	1
that you have to call	1
that you have two different	1
that you should look at	1
that you want to compile	1
that you want to calculate	1
that you want to keep	1
that you want this to	1
that you want them to	1
that you compile the output	1
that you optimized for is	1
that you see in the	1
that you don't have to	2
that you measure are much	1
that you analyze all pointers	1
that have a special loop	1
that have to be restored	1
that have floating point capabilities	1
that have multiple // versions:	1
that have multiple versions. This	1
that have many file input/output	1
that have big data structures	1
that have support for intrinsic	1
that have values far from	1
that have Boolean variables as	1
that have tested the strlen	1
that have Booleans as output	1
that this is a pure	1
that this method works only	1
that this part of the	1
that use the same member	1
that use the zero flag	1
that use only a small	1
that use these methods to	1
that use large amounts of	1
that use big endian storage.	1
that memory access is the	1
that data are aligned at	1
that has a good implementation	1
that has to be done	1
that has no side-effects and	1
that has been accessed recently	1
that has been allocated is	1
that has already been allocated.	1
that make it possible to	1
that make it possible for	1
that make function calling more	1
that make member pointers less	1
that make up a program.	1
that make vectorization less favorable:	1
that make vectorization favorable: Small	1
that make developers choose other	1
that different threads are doing	1
that functions which are called	1
that only one constant needs	1
that all the cache lines	1
that all code versions work	1
that all code branches works	1
that all floating point constants	1
that all variables and objects	1
that all software be reinstalled	1
that all allocated objects are	1
that all operators that have	1
that all destructors for local	1
that all destructors are called	1
that all destructors are called.	1
that one function can modify	1
that one thread can do	1
that should not be evaluated	2
that no function or method	1
that no object is accessed	1
that no variable or object	1
that no overflow can occur,	1
that floating point comparisons are	1
that each value is calculated	1
that each value depends on	1
that each calculation depends on	1
that each particular branch of	1
that each intrinsic function call	1
that each statement that calls	1
that do not have the	1
that do not support static	1
that do not support SSE.	1
that do not 123 correspond	1
that do have such checks.	1
that do much of the	1
that most function libraries have	1
that most variables in a	1
that most software runs most	1
that double precision calculations are	1
that pointer aliasing does not	1
that b is always 0	1
that i can never be	1
that two pointers of different	1
that static linking is preferable	1
that there is more focus	1
that there is no clear	1
that there is often a	1
that there is always one,	1
that there is hardly any	1
that there are a few	1
that there are no caching	1
that there are 100 floating	1
that there are inherent performance	1
that there are smarter ways	2
that there was hardly any	1
that C++ compilers exist for	1
that also repeats 1000 times	1
that such feature will become	1
that such devices typically have	1
that such contrived examples exist.	1
that many common programs use	1
that many users will prefer	1
that takes a long time,	1
that takes more time but	1
that takes advantage of the	1
that takes longer time in	1
that takes care of the	2
that we are running this	1
that we can do four	1
that we can handle eight	1
that we can help the	1
that we can surely rely	1
that we may save by	1
that we have to take	1
that we do not have	1
that we want it to	1
that we don't have to	2
that we know that u.f	1
that we expect to use	1
that some compilers will make	1
that some expression is optimized	1
that some development tools have	1
that some microprocessors have. In	1
that variables that are used	1
that software performance should be	1
that software developers should be	1
that software projects have become	1
that branch and other nearby	1
that makes code. For example,	1
that makes sure the file	1
that take a lot of	1
that take only one clock	1
that take up cache space	1
that take up cache space.	1
that need to be cleaned	1
that need to be deleted.	1
that need to call a	1
that need relocation. All public	1
that need relocation, but only	1
that pointers of different types	1
that pointers to different dynamically	1
that pointers do not alias,	1
that these functions have no	1
that these integer operations do	1
that these methods are based	1
that these directives do not	1
that they are deallocated when	1
that they cannot use the	1
that they cannot make algebraic	1
that they always keep up	1
that they are. Declare the	1
that always goes the same	1
that access the saved variable	1
that access times cannot be	1
that I have supplied in	1
that I consider it unwise	1
that does the same thing.	1
that does the necessary initialization.	1
that does floating point calculations	2
that must be loaded every	1
that work on all C++	1
that calls the function is	1
that calls the critical function	1
that calls at least one	1
that calls other functions is	1
that calls it. A dynamic	1
that processor model numbers form	1
that processor model N supports	1
that big arrays and other	1
that doesn't call any other	2
that doesn't cause overflow in	1
that doesn't add or remove	1
that doesn't automatically check for	1
that doesn't handle current CPUs	1
that doesn't compromise safety is	1
that threads can share the	1
that several variables happen to	1
that exception handling takes no	1
that overflow can occur in	1
that overflow never occurs, even	1
that cause the resource-hungry applications	1
that works for any compile-time	1
that works on all the	1
that works best on the	1
that works best on a	1
that works well on all	1
that uses the cache in	1
that uses a newer version	1
that uses pointers because it	1
that uses few resources. On	1
that uses 90% of the	1
that container classes in the	1
that support the necessary instruction	1
that support a new vector	1
that support this instruction set	1
that support intrinsic functions. Alternatively,	1
that support it. There are	1
that supported 128-bit vector registers	1
that supported 256-bit instructions were	1
that contains only a single	1
that contains integer division: Integer	1
that contains several branches is	1
that would otherwise go undetected.	1
that run in the background	1
that run in parallel. Small	1
that run many processes simultaneously.	1
that every function that is	1
that standard library functions like	1
that add functionality to an	1
that simply prints an appropriate	1
that certain calculations are done	1
that certain parts of the	1
that count how many times	1
that was used by element	1
that was unknown at the	1
that was saved in the	1
that particular part. It is	1
that branches can be mispredicted	1
that typically use pointers may	1
that typically take much more	1
that automatically reduces example 15.1a	1
that caching becomes a problem.	1
that allows you to override	1
that allows you to reserve	1
that allows less precise floating	1
that allows bigger segments (32-bit	1
that allows overriding of public	1
that allows direct access to	1
that don't need the "override"	1
that signed integer overflow doesn't	1
that model N+1 supports at	1
that model N-1 is inferior.	1
that needs to be called.	1
that needs to be saved.	1
that needs to call a	1
that needs them. Pure functions	1
that what is brand new	1
that source and destination both	1
that n is known at	1
that string as code. Metaprogramming	1
that requires several layers of	1
that requires compilation or interpretation	1
that your code is likely	1
that generate floating point underflow	1
that r points to. A	1
that r points to. Now	1
that goes one way most	1
that goes many times one	1
that goes randomly one way	1
that 10 is an integer,	1
that were not present in	1
that were unknown at the	5
that require cleanup before terminating	1
that depends only on n,	1
that supports automatic vectorization, such	1
that supports this). Use rounding	1
that my optimization manuals are	1
that p is a pointer,	1
that p always points to	1
that index is not out	1
that modern processors prefetch data	1
that gives the simplest possible	1
that gives the simplest code.	1
that gives the worst possible	1
that comes to mind. In	1
that comes with the compiler,	1
that rely on the strict	1
that rely on the assumption	1
that rely heavily on table	1
that produce Boolean output. The	1
that produce streaming audio or	1
that macro parameters are evaluated	1
that variable. The different threads	1
that fit the size of	1
that fit their CPUs. Intel's	1
that includes the critical functions	1
that allow you to manipulate	1
that come with the Intel	1
that come with the operating	1
that come with compilers and	1
that similar solutions may some	1
that future compilers will do	1
that seconds remains zero in	1
that something takes 10 clock	1
that something takes 10 s	1
that F1 will never throw	1
that checks whether the code	1
that programmers write expressions like	1
that current compilers may not	1
that contain pure function calls	1
that could benefit from register	1
that everything that has been	1
that branch. The common excuse	1
that jump between multiple CPU	1
that volatile doesn't mean atomic.	1
that measurements are unstable due	1
that reads or writes a	1
that fits the microprocessor it	1
that fits the application. In	1
that follows a simple periodic	1
that computers have become more	1
that depend on network resources	1
that communication between threads becomes	1
that memset is deprecated. This	1
that specifies how to do	1
that select the best implementation	1
that select between two simple	1
that created a file by	1
that already works is of	1
that relies on network resources	1
that runs quite fast on	1
that runs under the framework,	1
that runs alone in the	1
that belong to each compiler	1
that performs best under this	1
that produces a string and	1
that produces another C++ program	1
that u.f and v.f are	1
that *p+2 is a loop-invariant	2
that chooses between two expressions	1
that chooses between two constants	1
that 150 you want as	1
that avoids overflow: a[i] =	1
that seldom occur and recovering	1
that begin with _mm. These	1
that N1 = N&(N-1) gives	1
that appears in the machine	1
that behaves like a pointer.	1
that behaves like an array	1
that consumes most of the	1
that reflects the conflicting considerations	1
that lies r places back	1
that copies the table to	1
that allocates memory on the	1
that scans all files on	2
that delays execution by causing	1
that holds a memory address.	1
that a+b is calculated first,	1
that decide how advantageous vectorization	1
that measures the number of	1
that measures the speed of	1
that accesses data members with	1
that accesses b through a	1
that thrown exceptions are indeed	1
that treats different brands of	1
that loads the appropriate version	1
that waits for user input.	1
that covered the address range	1
that begins with #) are	1
that previously required a PC.	1
that CParent::Hello() has multiple instances	1
that owns the allocated object,	1
that limits the CPU brand.	1
that transfers ownership of the	1
that looses ownership of the	1
that hackers often have exploited.	1
that dates back to around	1
that u < 231 then	1
that connect them. The hardware	1
that "we don't support processor	1
that draws a whole polygon	1
that violate or circumvent operating	1
that (b*c) overflows, even if	1
that saves time for the	1
that r+i/2 could be calculated	1
that crashes the program. The	1
that doesnt. The undocumented Intel	1
that discriminates between CPU brands,	1
that destroys any memory block	1
that relate to CPU-intensive code.	1
that shares the resources of	1
that detects an error can	1
that matters rather than the	1
be the one that takes	1
be the optimal choice for	1
be the fastest solution on	1
be the easiest and the	1
be a time consumer if	1
be a class containing the	1
be a very efficient solution	1
be a very big problem	1
be a member of the	1
be a register variable. The	1
be a simple type, a	1
be a constant that is	1
be a good idea to	1
be a power of 2	3
be a power of 2.	1
be a disadvantage if other	1
be a better solution to	1
be a better solution. It	1
be a difference in efficiency.	1
be a binary tree or	1
be a destructor that destroys	1
be a waste of the	1
be a waste of time,	1
be a hundred or even	1
be a compromise between development	1
be a type. The example	1
be a bottleneck than memory	1
be a viable solution in	1
be a viable compromise when	1
be a time-consumer even for	1
be a slight degradation in	1
be a million times less	1
be a level-3 cache. If	1
be of the same type	1
be of some help if	1
be to include a performance	1
be in the cache. The	1
be in the level-1 cache.	1
be in the interval from	1
be as small as possible	1
be as standardized as possible	1
be an efficient way of	1
be an efficient solution. Is	1
be an efficient solution. Sort	1
be an advantage to unroll	1
be an advantage because integer	1
be an expression or an	1
be an integer. If a	1
be an obvious thing to	1
be an annoying time consumer	1
be an infinite loop. The	1
be time consuming because it	1
be more efficient to re-use	1
be more efficient to pool	1
be more convenient to calculate	1
be more (128 or 256	1
be at a disadvantage if	1
be different for each process.	1
be different sizes, and they	1
be because the non-reduced expression	1
be only one statement in	1
be only one free register	1
be used to avoid modulo	1
be used to speed up	1
be used in two ways.	1
be used in 64-bit device	1
be used in any situation	1
be used for function libraries	1
be used for other purposes.	1
be used for multiple variables	1
be used for multiple purposes.	1
be used for any other	1
be used for vectorized table	1
be used for accessing the	1
be used for reducing the	1
be used for turning off	1
be used for saving memory	1
be used for implementing a	1
be used for improving code	1
be used for metaprogramming, as	1
be used for fetching a	1
be used if the value	1
be used if instruction sets	1
be used if there are	1
be used if elements have	2
be used with other microprocessors.	1
be used on completely independent	1
be used as a Boolean	1
be used as a stand	1
be used as alternatives to	1
be used as command-line versions	1
be used as coprocessors to	1
be used when a thread	1
be used only for very	1
be used only when instruction	1
be used where execution speed,	1
be used without restrictions. A	1
be used most. The opposite	1
be used freely without any	1
be cache contentions if the	1
be no extra overhead in	1
be no certain limit to	1
be set then the optimal	1
be set up to count	1
be two or three levels	1
be efficient whether the arrays	1
be possible to do the	1
be possible to do such	1
be possible to replace a	1
be possible to improve the	1
be possible to select all	1
be possible to organize the	1
be so many unknown factors	1
be so high that it	1
be 2 In 64-bit mode	1
be very efficient because it	1
be very long and very	1
be very long and difficult	1
be very useful to study	1
be very useful for investigating	1
be very inefficient if the	1
be very helpful for later	1
be faster than a floating	1
be faster than making a	1
be faster when the factor	1
be faster despite the extra	1
be stored in a register	2
be stored in a global	1
be stored in a far	1
be stored in one contiguous	1
be stored in integer registers.	1
be stored in static memory	1
be stored in static memory.	1
be stored in registers instead	1
be stored in memory, at	1
be stored with each instance	1
be stored on the stack,	1
be stored at an address	2
be stored together The code	1
be stored together Cache misses	1
be stored together ...................................... 88	1
be stored together...................................... 88 9.4	1
be called when the object	1
be called from any other	1
be called from programming languages	1
be called from another module.	1
be called only first time	1
be called before the function	1
be called whenever an object	1
be 8 and no induction	1
be less than the time	1
be less than the cache	1
be less than 231. This	1
be less efficient than non-object	1
be less efficient because the	1
be 64 bits (MMX), 128	1
be useful to make the	1
be useful to make a	1
be useful to copy the	1
be useful to turn off	1
be useful to roll out	1
be useful to isolate the	1
be useful in the situation	1
be useful in some cases,	1
be useful in test situations	1
be useful in compiled languages	1
be useful in programs with	1
be useful in situations where	1
be useful for making data	1
be useful for making plug-ins	1
be useful for large libraries	1
be useful for optimizing code,	1
be useful for finding the	1
be useful if the subexpression	1
be useful when the amount	1
be even faster to make	1
be sure that the compiler	1
be sure that all destructors	1
be 0 or 1 by	1
be 0 or 1. Writing	1
be cases where a particular	1
be cases where it is	1
be available in 2015 or	1
be important if you have	1
be accessed with the last	1
be accessed with an offset	1
be accessed from any function.	1
be accessed from main through	1
be accessed approximately two clock	1
be accessed sequentially in memory	1
be while (0 < 5)	1
be compiled with different compilers.	1
be compiled as a dynamic	1
be compiled three times, one	1
be necessary to optimize anything	1
be necessary to replace the	1
be necessary to modify the	1
be necessary in the following	1
be allocated for an integer	1
be allocated dynamically with new	1
be allocated dynamically when the	2
be allocated dynamically. The advantages	1
be allocated dynamically. Arrays that	1
be done in big blocks	1
be done by multiplying with	1
be done by controlling the	1
be done with the functions	1
be done with the resolution	1
be done with a special	1
be done with a shift	1
be done with just two	1
be done on the type	1
be done as a shift	1
be done at every access.	1
be done outside the loop.	1
be done manually by the	1
be optimized if a and	1
be optimized by using indexes,	1
be optimized to: // Example	1
be optimized further. The first	1
be inside the innermost loop.	1
be calculated in advance. This	1
be calculated by the series:	1
be calculated by a single	1
be calculated by an induction	2
be calculated by n additions	1
be calculated by adding a	1
be calculated with two decimals,	1
be calculated as follows: floatvalue	1
be calculated as (critical stride)	1
be calculated as (b*2.0)/3.0 rather	1
be calculated more efficiently from	1
be calculated at compile time.	1
be calculated using multiplications only.	1
be calculated independently. The CPU	1
be advantageous to make the	1
be advantageous to do simple	1
be advantageous to put the	1
be advantageous to put file	1
be advantageous to mix integer	1
be advantageous to mix floating	1
be advantageous to keep the	1
be advantageous or not. The	1
be advantageous if the loop	1
be advantageous if a lot	1
be advantageous when a program	1
be implemented in the high	1
be implemented in a more	1
be implemented in different places	1
be implemented in compiled C++	1
be implemented in various ways	1
be implemented in PC processors.	1
be implemented with intrinsic functions	1
be implemented as a table	1
be implemented as a circular	2
be implemented as vector operations.	1
be implemented as follows in	1
be implemented like this in	1
be implemented either as static	2
be known at compile time	1
be 1 b = lrint(d);	1
be able to do so.	1
be able to do so).	1
be able to avoid the	1
be able to inline this	1
be able to optimize this	1
be able to find the	1
be able to predict the	1
be able to define application-specific	1
be able to evaluate the	1
be able to completely rule	1
be able to recover from	2
be able do function inlining	1
be certain that a call	1
be shared between multiple threads,	1
be quite a good investment.	1
be quite inefficient if a	1
be quite time-consuming (see page	1
be quite tedious and the	1
be quite substantial. This gain	1
be used. If the number	1
be used. We can calculate	1
be used. Web systems should	1
be fast in a simple	1
be both cheaper and more	1
be optimal to use a	1
be optimal to mirror the	1
be optimal in special cases	1
be signed or unsigned. The	1
be separate for each thread.	1
be put into the list	1
be put away in reusable	1
be three or four, depending	1
be better to do the	1
be better to join them	1
be better than RISC in	1
be better because the code	1
be too small. Are objects	1
be too worried about this	1
be too small, then it	1
be needed for communication between	1
be needed because the CPU	1
be difficult to get reproducible	1
be difficult to find the	1
be difficult to measure exactly	1
be transferred in registers rather	1
be transferred in registers (6	1
be transferred in registers (8	1
be transferred in registers. 64-bit	1
be transferred in registers, whereas	1
be longer than a few	1
be read and written back.	1
be read into one of	1
be read before p is	1
be aligned by the vector	1
be aligned by at least	1
be aligned by 16, i.e.	1
be linked into the same	1
be linked into projects made	1
be linked together with C	1
be linked either as a	1
be declared in the function	1
be declared const in order	1
be declared inside the function	2
be declared volatile. This prevents	1
be higher due to poor	1
be bigger than the application	1
be divisible by the unroll	1
be divisible by TILESIZE //	1
be called. It is recommended	1
be based on which instruction	1
be made for all suitable	1
be made more compact by	1
be made available to the	1
be made about whether the	1
be made much more efficient	1
be made smaller by reordering	1
be made local. This makes	1
be just as fast as	1
be smaller as well. The	1
be relevant when testing worst-case	1
be replaced by the calculated	1
be replaced by a table	1
be replaced by a single	1
be replaced by a shift	1
be replaced by a blend	1
be replaced by // Example	1
be replaced by more efficient	1
be replaced with: // Example	2
be negative so that we	1
be tested in different browsers,	1
be tested with a realistic	1
be tested on a network	1
be tested on different platforms,	1
be tested under worst-case conditions	1
be predicted or if the	1
be predicted by the branch	1
be predicted quite well if	1
be predicted depends on the	1
be predicted well. Even function	1
be predicted perfectly on a	1
be predicted perfectly varies between	1
be predicted perfectly. As explained	1
be loaded from memory each	1
be loaded at an address	1
be loaded at an arbitrary	1
be loaded only when they	1
be loaded into an arbitrary	1
be loaded every time the	1
be loaded until the previous	1
be loaded anyway. If we	1
be C or C++. Critical	1
be compatible with all CPUs	1
be compatible with old microprocessors	1
be compatible with structured exception	1
be dynamically created by one	1
be avoided in 64-bit systems	1
be avoided by using references	1
be avoided by making the	1
be avoided by making an	1
be avoided by calling the	1
be avoided by inlining the	1
be avoided by copying the	1
be avoided by joining the	1
be avoided by rolling out	1
be avoided by replacing an	1
be avoided on processors with	1
be avoided when speed is	1
be avoided because of the	1
be avoided because they cannot	1
be avoided unless you have	1
be 2. The result is	1
be particularly time consuming. Sometimes	1
be given a false model	1
be given in advance. The	1
be limited by the latency	1
be vectorized if the code	1
be vectorized if you take	1
be vectorized with the current	1
be vectorized as follows (using	1
be vectorized automatically. For example,	1
be inlined for improved performance.	1
be inlined or cannot be	1
be inlined by declaring the	1
be safe to make a	1
be safe if there are	1
be further tested and investigated	1
be reduced to 2 by	1
be reduced to always true	1
be reduced to: // Example	1
be clear from this discussion	1
be obtained in a computationally	1
be obtained by the use	1
be obtained with the function	1
be obtained with the time	1
be overloaded or limited in	1
be possible. Template meta- programming	1
be changed to a =	1
be changed to truncation and	1
be changed by another thread.	1
be changed without the risk	1
be changed to: // Example	2
be changed freely. The loop	1
be true anyway. It may	1
be initialized to zero by	1
be initialized to desired values	1
be initialized when the function	1
be improved is that r+i/2	1
be improved in the following	1
be improved by a factor	1
be improved by using a	1
be improved by using one	1
be improved by using static	1
be improved by inlining the	1
be improved by adding an	1
be improved by modifications of	1
be improved by consistent modularity	1
be loading the entire floating	1
be below the maximum value.	1
be copied or moved with	1
be copied into registers. A	1
be copied simply by copying	1
be invalid and cause fatal	1
be invalid in a particular	1
be invalid if a was	1
be used, but any of	1
be used, even when accessed	1
be organized as a vector	1
be organized into vectors. A	1
be organized so that the	2
be enough to identify a	1
be added to a variable	1
be added at any time,	1
be situations where a high	1
be chosen based on the	1
be scattered around at different	2
be applied to a function	1
be applied to all instances	1
be applied to integers. It	1
be applied to integers. 7.25	1
be critical. The branch target	1
be critical. Therefore, the number	1
be mentioned here: A large	1
be mispredicted for this reason.	1
be mispredicted even if they	1
be mispredicted (See manual 3:	1
be mispredicted whenever it goes	1
be mispredicted 50% of the	1
be standardized and done by	1
be false regardless of the	1
be converted to a pointer	1
be converted to a pointer.	1
be converted to an integer,	1
be converted to OMF format.	1
be designed so as to	1
be fragmented and involve a	1
be 8, 16 or 32	1
be preferred to use the	1
be interpreted as a very	1
be determined in advance, because	1
be determined by the requirements	1
be determined by a system	1
be determined with system calls	1
be easily available from a	1
be allowed and which not.	1
be distributed to the end	2
be called, or what a	1
be called, even if the	1
be slower or require more	1
be slower than the subsequent	1
be expensive in some compilers.	1
be saved in registers, not	1
be saved from one iteration	1
be saved either in the	1
be aware of when type-casting	1
be aware of these obstacles	1
be aware of situations where	1
be aware that there is	1
be aware that there are	1
be aware of. Big runtime	1
be available, we may choose	1
be measured separately. The fallacy	1
be equal to the critical	1
be expected to be higher	1
be expected for further expansions	1
be expected that the number	1
be convenient to have the	1
be convenient for adding bounds-checking	1
be poor because it lacks	1
be static, as explained on	1
be evaluated if a is	2
be completely contained in a	1
be completely unrolled to avoid	1
be permissible if the unsafe	1
be mixed with x87 style	1
be turned into a leaf	1
be overcome by defining a	1
be worth the effort. 7.21	1
be worth the effort. Square	1
be obvious to the programmer	1
be obvious to do so.	1
be swapped to the hard	1
be portable to platforms that	1
be executed as it is,	1
be executed faster in a	1
be split up into multiple	1
be increased to 16 bytes	1
be increased by more than	1
be divided into multiple threads	1
be divided into small pieces	1
be seen in the broader	1
be necessary. If F1 calls	1
be updated to a new	1
be updated every time a	1
be combined into a 128-bit	1
be written in C, C++	1
be preferable to keep the	1
be said that the use	1
be true. template<> class powN<true,0>	1
be needed, however, if the	1
be extended to the general	1
be expressed as a 32-bit	1
be expressed as a base	1
be expressed as an 8-bit	1
be expressed as follows: struct	1
be cleaned up include: Memory	1
be cleaned up, as explained	1
be cached. This can have	1
be prevented in other ways,	1
be prevented by calling vector::reserve	1
be eliminated if the target	1
be eliminated if the condition	2
be eliminated completely. For example:	1
be illustrated by the following	1
be returned in registers only	1
be returned in registers. Except	1
be found in my vector	1
be found in Wikipedia under	1
be found elsewhere. 13.5 Implementation	1
be coded in a hardware	1
be represented with or without	1
be represented as an integer.	1
be identified by their index	1
be kept small in the	1
be kept entirely inside one	1
be selected during the installation	1
be multiplied by the size	1
be multiplied by the clock	1
be obsolete. But if I	1
be obsolete. Programmers very often	1
be unable to access the	1
be unable to respond quickly	1
be modified by the program.	1
be modified by the program,	1
be carried out independently of	1
be hidden by using the	1
be performed with a realistic	1
be removed after debugging if	1
be considered a container that	1
be considered metaprogramming in C++:	1
be spaced by a multiple	2
be filled up if the	1
be filled up. This is	1
be expected. The 64 64	1
be solved by making the	1
be solved by making sure	1
be stored. All identical constants	1
be inlined. But beware that	1
be inlined. (In the above	1
be infinity or NAN (Not	1
be taken into account when	3
be handled in a systematic	1
be moved out of the	1
be moved out of a	1
be joined into a single	1
be joined into one if	1
be joined together in order	1
be placed in a separate	1
be placed in separate modules	1
be placed immediately before the	1
be sufficient for less intensive	1
be evicted when we read	1
be evicted from the cache	1
be manipulated with C functions	1
be freed before the function	1
be justified in case of	1
be justified for general function	1
be vectorized, because a float	1
be vectorized, but the code	1
be disabled in the final	1
be ruled out or if	1
be ruled out by the	1
be reused elsewhere. In this	1
be pure. This allows common	1
be bypassed when the virtual	1
be achieved more efficiently by	1
be visible at all to	1
be overwritten, and even worse,	1
be annoyingly high for programs	1
be controlled. The network access	1
be controlled. Small hand-held devices	1
be worthwhile to unroll the	1
be irrelevant within a year	1
be careful when swapping the	1
be profitable (see page 70).	1
be negative. The method described	1
be negative. The last line	1
be defined. The cost of	1
be obtained. If a loop	1
be obtained. In the latter	1
be predicted. The target address	1
be predicted. This is no	1
be fed directly to the	1
be cached more efficiently than	1
be shared. You can't have	1
be shared. Any writable data	1
be optional and off by	1
be deleted. User work that	1
be left out if exceptions	1
be wrapped into a class	1
be slower. Many compilers have	1
be optimally aligned. See page	1
be fetched from the cache	1
be avoided, if possible, and	1
be avoided, there are various	1
be avoided. 37 A compiler	1
be misleading reports of which	1
be repeated 1024/4 = 256	1
be moved. A binary tree	1
be installed. The installation process	1
be mispredicted, which causes a	1
be tolerated. PGI C++ compiler	1
be regarded as a valuable	1
be obeyed. Copy protection. Some	1
be restored before the function	1
be undesired. Example: // Example	1
be passed as parameters to	1
be broken up. The two	1
be arranged in regular patterns	1
be cross- compiled on a	1
be combined. For example: //	1
be improved. 3.2 Use a	1
be rounded to 100000000. When	1
be straightforward. The MASM assembly	1
be prepared for several iterations	1
be non-zero, and therefore count	1
be saved. Any other allocated	1
be programmed in a hardware	1
be reached with a 32-bit	1
be renewed. Context switches are	1
be weighed against the costs	1
be reduced. This may be	1
be recycled? There is a	1
be postponed until the program	1
be omitted, of course, if	1
be considered. A realistic performance	1
be speeded up significantly just	1
be used: // Example 13.2.	1
be added. This method is	1
be adjusted if you change	1
be platform-independent and compact. The	1
be made) then it is	1
be reloaded eight times because	1
be evicted. Don't mix nontemporal	1
be mitigated by making critical	1
be signed. Be sure not	1
be emphasized that the compilers	1
be noticeable but not long	1
be reinstalled and user settings	1
be ameliorated by using nontemporal	1
be scheduled in a separate	1
be followed by an EMMS	1
be caused by random events	1
be wired for a specific	1
be responded to at a	1
be ignored if the goal	1
be re-calculated every time Func	1
be accomplished by doing the	1
be mainstream next year. Ignoring	1
be resized in the event	1
be overridden in Linux and	1
be huge). Far storage, far	1
be reversed if c <	1
be propagated through a series	1
be annoying. We may decide	1
be accessed. Pointer arithmetic A	1
are the same in both	1
are the same for simple	1
are the same after this	1
are the integers from 0	1
are the following: 130 Compile	1
are a number of possible	1
are a number of dangers	1
are a few cases where	1
are a few cases, however,	1
are a few pitfalls here.	1
are a scarce resource in	1
are a scarce resource, especially	1
are a couple of things	1
are of course system-specific. In	1
are in fact using each	1
are in fact accessed through	1
are in fact doing the	1
are in fact represented as	1
are in fact addressed relative	1
are in doubt how big	1
are for those who want	1
are that software projects have	1
are as fast as additions.	1
are as follows: Instruction set	1
are not used for internal	2
are not very good at	1
are not stored contiguously in	1
are not sure you need	1
are not always fully optimized.	1
are not always avoiding this.	1
are not always accurate, however,	1
are not always sequential, and	1
are not necessary if you	1
are not optimized for 16-bit	1
are not known at compile	1
are not supported at all.	1
are not doing divisions. It	1
are not well documented. The	1
are not able to do	1
are not used. The method	1
are not recommended for critical	1
are not compatible with the	1
are not compatible with other	1
are not compatible across compilers.	1
are not enough registers then	1
are not critical. It is	1
are not fully optimized yet.	1
are not suitable for example	1
are not permissible for reasons	2
are not backwards compatible with	1
are not necessarily stored sequentially	1
are not optimal. There are	1
are not cached. The subsequent	1
are not satisfied with the	1
are not overlapping or aliasing,	1
are not computationally intensive may	1
are not suited for vector	1
are not testing. Trying to	1
are not accessible from other	1
are not yet as well	1
are not safe, of course.	1
are not affected by __fastcall.	1
are not used). You may	1
are not reproducible. Such events	1
are time consuming. Therefore, the	1
are more efficient than frame	1
are more efficient alternatives that	1
are more useful methods for	1
are more important than speed.	1
are more frequent if the	1
are more predictable than integer	1
are then you may make	1
are then linked together in	1
are then output after the	1
are different for each type	1
are different ways of doing	1
are different opinions on which	1
are only available if supported	1
are only available with vector	1
are only four cache lines	1
are only slightly less efficient.	1
are other cache control instructions	1
are other possible ways of	1
are used in the same	2
are used in the most	2
are used in a critical	1
are used in multiple applications,	1
are used in so that	1
are used in STL for	1
are used for doing two	1
are used for giving specific	1
are used for implementing polymorphic	1
are used by many users	1
are used by thousands of	1
are used with other compilers.	1
are used at all is	1
are used only for objects	1
are used most for register	1
are used many times in	1
are used together are also	1
are used together are stored	1
are used together should be	4
are used near each other	1
are used twice for handling	1
are one byte longer in	1
are integer expressions rather than	1
are no cache problems. It	1
are no long dependency chains.	1
are no instructions for integer	1
are no big arrays, then	1
are no copy constructors and	1
are no caching problems for	1
are no longer used and	1
are no longer used. It	1
are no checks for array	1
are set to relax floating	1
are floating point-to-integer conversions in	1
are most efficient for such	1
are most efficient if the	1
are most critical. However, there	1
are using the same function	1
are using the same compiler	1
are using and turn on	1
are using an Intel function	1
are using an Intel compiler,	1
are using vector classes and	1
are using functions such as	1
are using single precision or	1
are using advanced algorithms to	1
are using 8-bit integers which	1
are using __fastcall. Function parameters	1
are using unions rather than	1
are double precision by default,	1
are two or more integer	1
are two or more versions	1
are two different kinds of	1
are two versions of the	1
are two things to test	1
are two main principles here:	1
are two commonly used methods	1
are there between x and	1
are also other advantages that	1
are also other details that	1
are also stored together if	1
are also stored near each	3
are also 4 unused bytes	1
are also situations where pre-increment	1
are also available. Microsoft Comes	1
are also available, such as	1
are also deallocated in all	1
are also third-party profilers such	1
are also included. Combining the	1
are efficient because the template	1
are many function calls, if	1
are many functions scattered around	1
are many cases where the	1
are many allocations of large	1
are many branches): if (level	2
are possible only if the	1
are objects in the container.	1
are some differences due to	1
are some examples: strlen function.	1
are so many different cases	1
are so big that overflow	1
are so small that a	1
are so fast that the	1
are so expensive that it	1
are variables than if the	1
are very difficult to diagnose.	1
are very similar thanks to	1
are very fast. This can	1
are very expensive. A variable	1
are very smart. They can	1
are 32-bit integers, then the	1
are faster than floating point	1
are faster than linked lists	1
are stored in the order	1
are stored in a static	1
are stored in a binary	1
are stored in different parts	1
are stored in static memory.	1
are stored in registers are	1
are stored in registers (see	1
are stored in memory. Example:	1
are stored in binary form	1
are stored in ASCII form.	1
are stored can be important	1
are stored on the stack	2
are stored on the stack,	1
are stored as 8-bit integers	1
are stored together in an	1
are stored near each other	1
are stored consecutively in the	1
are called and resources cleaned	1
are called from the same	1
are called every time an	1
are called global variables. They	1
are called near each other	1
are called accumulators. Current CPUs	1
are critical time consumers. Choose	1
are critical resources. Modern CPUs	1
are less efficient and you	1
are less efficient in some	1
are less efficient (see page	1
are less likely to be	1
are less efficient. In 64-bit	1
are less strict when compiling	1
are less expensive. Using complicated	1
are less susceptible to problems	1
are first compiled to an	1
are 64 bits wide, should	1
are often used for calculating	1
are often used by default	1
are often used as buffers	1
are often much more than	1
are often inlined automatically by	1
are often waiting for each	1
are often conflicting with the	1
are often mispredicted. A branch	1
are often abusing the update	1
are often fluctuating and it	1
are often unreliable. They sometimes	1
are useful for copy constructors	1
are useful for Boolean vector	1
are useful for finding the	1
are useful for supporting multiple	1
are useful for assigning different	1
are useful for vectorizing mathematical	1
are useful for identifying hot	1
are useful when doing calculations	1
are sure the code has	1
are sure to have the	1
are sure to make a	1
are sure to point to	1
are sure to produce the	1
are sure that the pointer	1
are sure that it will	1
are sure you know what	1
are always stored together in	1
are always available from www.agner.org/optimize.	1
are always calculated with the	1
are always transferred as pointers	1
are always resolved at compile	1
are out of the question	1
are part of the Xnu	1
are cases where it is	1
are available to fit specific	1
are available in all systems	1
are available in 64-bit systems	1
are available in both static	1
are available for the commercial	1
are available for many different	1
are available for Linux systems.	1
are available for doing parallel	1
are available if the AVX	1
are available as an appendix	1
are available from a number	1
are available from Intel. See	1
are available at compile time.	1
are up to five or	1
are making a shared object.	1
are making programs that have	1
are making branches that are	1
are accessed in the order	1
are accessed in a non-sequential	3
are accessed in a random	1
are accessed in sequential order	1
are accessed in non- sequential	1
are accessed on a First-In-Last-	1
are accessed on a First-In-First-	1
are accessed very fast. All	1
are accessed through the implicit	1
are accessed through pointers or	2
are accessed through pointers so	1
are accessed through pointers, e.g.:	1
are accessed equally fast. In	1
are accessed backwards and much	1
are accessed consecutively and can	1
are accessed sequentially. The opposite	1
are accessed sequentially. It works	1
are accessed column-wise. Assume now	1
are accessed row-wise, then the	1
are compiled with different compilers	1
are compiled without any option	1
are best at doing equivalent	1
are necessary then it may	1
are specific advantages that can	1
are much higher than normal.	1
are single instructions that take	1
are several different C++ compilers	1
are several different ways of	1
are several different profiling methods:	1
are several ways to divide	1
are several factors that can	2
are allocated and deallocated in	2
are allocated in sequence are	1
are allocated resources that need	1
are integers or floating point	1
are good for making clear	1
are good for optimizing execution	1
are done with long double	1
are done with single or	1
are done at compile time.	1
are done only once, while	1
are done under the best-case	1
are done implicitly when calculating	1
are therefore as efficient as	1
are therefore as fast as	1
are optimized for execution speed	1
are optimized well, others are	1
are explained in manual 5:	1
are explained in detail on	1
are explained on page 26.	1
are calculated faster than double	1
are calculated much faster than	1
are four kinds of costs	1
are advantageous for applications that	1
are implemented in hardware in	1
are implemented by (partial) template	1
are implemented with interpretation. The	1
are implemented as three branches.	1
are implemented as recursive templates.	1
are supported by the operating	1
are supported by the Gnu,	1
are supported by Microsoft, Intel,	1
are eight floating point registers	1
are likely to be scattered	1
are doing the same thing	1
are doing a sequence of	1
are doing different kinds of	1
are doing exactly the same	1
are simply put there when	1
are simply treated as different	1
are able to do the	1
are able to do this	1
are able to run two	1
are able to calculate the	1
are able to automatically prefetch	1
are able to generate an	1
are able to mix the	1
are able to do, at	1
are certain that u <	1
are certain restrictions on using	1
are certain restrictions on mixing	1
are shared between multiple threads,	1
are quite costly because all	1
are used. a and b	1
are used. It is possible	1
are used. See page 32	1
are used. See page 140.	1
are used. Example: // Example	1
are used. Such variables and	1
are used. Do not mix	1
are used. Conversions of float	1
are fast in most cases,	1
are both positive. It will	1
are cases, however, where template	1
are particular advantageous as replacements	1
are typically stored in different	1
are typically small pieces of	1
are typically specified on a	1
are preferably aligned by 32	1
are members of the same	1
are members of a class	1
are intrinsic instructions for mathematical	1
are never used at the	2
are never called. The disadvantage	1
are never modified by the	1
are various function libraries for	1
are various methods for communication	1
are various ways to do	1
are various ways to avoid	2
are various ways to get	1
are various ways around this	1
are various things you can	1
are various discussion forums on	1
are various profilers available which	1
are various alternatives to using	1
are running in other threads	1
are running in parallel. Fine-grained	1
are running this code with	1
are three ways to make	1
are three ways to do	1
are better at reducing integer	1
are too large for the	1
are too big before multiplying	1
are too small to cause	1
are needed from the library	1
are needed even when the	1
are difficult to find elsewhere.	1
are difficult to maintain. Any	1
are transferred in registers by	1
are transferred in registers rather	3
are transferred in registers anyway.	1
are transferred in registers, regardless	1
are transferred in registers, totaling	1
are transferred by value in	1
are transferred on the stack	2
are aligned to an address	1
are aligned or not. See	1
are aligned by 16, i.e.	1
are aligned at round addresses.	1
are actually called in a	1
are actually able to reorder	1
are actually quite powerful and	1
are actually reducing example 15.1d	1
are linked together. The link	1
are declared in a C++	1
are declared as constant references	1
are declared outside of any	1
are declared whenever an instance	1
are higher for shared_ptr than	1
are bigger than the level-1	1
are usually stored in the	1
are usually included as part	1
are usually dealt with in	1
are called. The program is	1
are called. The safe way	1
are called. A considerable delay	1
are called. Therefore, the dispatcher	1
are based on the x86	1
are based on an interpreter	1
are based on big runtime	1
are based on hardware identification.	1
are based on compilers. Several	1
are based on my own	1
are based on just-in-time compilation	1
are based on hacks that	1
are just as fast as	1
are core clock cycles per	1
are replaced by their values	1
are negative or if one	1
are predicted most of the	1
are predicted well only on	2
are loaded at round memory	1
are loaded into memory when	1
are relative to the current	1
are intended to work in	1
are intended for system code.	1
are slow unless the Pentium-II	1
are inefficient when the floating	1
are described in detail in	1
are including a header file	1
are particularly critical because they	1
are particularly important on small	1
are particularly fast on newer	1
are particularly critical. 129 13.7	1
are particularly problematic because there	1
are given in manual 5:	1
are given in www.agner.org/optimize/cppexamples.zip. An	1
are given on page 136	1
are given below. The time	1
are sometimes more efficient than	1
are sometimes able to predict	1
are inlined so that the	1
are special cases such as	1
are further described in the	1
are testing contains debug information	1
are 100 floating point operations	1
are writing to uncached memory	1
are adding -100 to -56	1
are containers 93 themselves. But	1
are discussed in the following	1
are discussed in manual 2:	1
are discussed below. Many libraries	1
are discussed below. Cannot optimize	1
are reading and writing from	1
are defined with enum, const,	1
are defined as powers of	1
are identical to Linux in	1
are identical so that only	1
are used, there is simply	1
are used, while the speed	1
are not. Supports 32-bit and	1
are organized as 32 sets	1
are organized into lines and	1
are approximately six integer registers	1
are situations where a vector	1
are scattered around in memory	2
are scattered everywhere in the	1
are scattered randomly around in	1
are independent then you can	1
are provided in the asmlib	1
are provided in an appendix	1
are provided below, on page	1
are 6 unused bytes between	1
are inefficient. If a program	1
are search requests for elements	1
are executed. However, the pipeline	1
are usability issues, and I	1
are pure functions, but unfortunately	1
are mentioned below. Microsoft Visual	1
are fully compatible on the	1
are included in the operating	1
are temporary intermediates, loop counters,	1
are frequent sources of compatibility	1
are frequent sources of resource	1
are now used in some	1
are equally efficient because they	1
are equally efficient because, in	1
are equally likely to be	1
are equally efficient. If you	1
are equally near then the	1
are designed to handle only	1
are designed to solve this	1
are listed in the compiler	1
are listed in table 19	1
are listed in table 8.1	1
are listed in manual 4:	1
are listed on page 164	1
are preferred because of their	1
are zero. Zero can be	1
are exactly the same. If	1
are exactly as efficient as	1
are resolved before the program	1
are poorly predictable. It may	1
are allowed to have constructors	1
are allowed in assembly names.	1
are serious limitations to what	1
are disadvantages of using pointers	1
are generally not thread safe	1
are generally very fast. Simple	1
are instances of structures and	1
are hardly relevant to optimization.	1
are saved in a special	1
are integers, while the multiplication	1
are highly system dependent and	1
are highly optimized for the	1
are highly optimized for large	1
are highly optimized, using assembly	1
are waiting for better metaprogramming	1
are available, i.e. in 64-bit	1
are powers of 2. Using	1
are constant. 14.2 Bounds checking	1
are expected to be available	1
are converting a to unsigned	1
are costly and which are	1
are evaluated in the following	1
are evaluated every time they	1
are deallocated when the function	1
are permissible in all cases,	1
are swapping column 29 with	1
are swapped then both can	1
are becoming more popular and	1
are becoming better and better	1
are becoming increasingly blurred as	1
are finished. This method is	1
are generated from the same	1
are equivalent to const definitions	1
are relatively costly because they	1
are relatively cheap if they	1
are frameworks that typically take	1
are safer to use than	1
are combined by some formula	1
are currently available, one from	1
are sufficiently large to handle	2
are needed, and new objects	1
are needed, or they may	1
are needed, but only after	1
are running. Such frameworks are	1
are optimal. Best-case testing is	1
are guaranteed to wrap around,	1
are missing in the instruction	1
are missing in many commercial	1
are extended to 256-bit registers	1
are cleaned up in case	1
are image processing, sound processing,	1
are uncached or even swapped	1
are returned by copying them	1
are coded in a hardware	1
are smaller. The lengths of	1
are identified by a unique	1
are identified by consecutive indices	1
are kept in different source	1
are incompatible with floating point	1
are incompatible with debugging. A	1
are normally compiled with the	1
are inferior to their 32-bit	1
are auto_ptr and shared_ptr. auto_ptr	1
are modified should be separate	1
are satisfied with more heuristic	1
are satisfied with making software	1
are assuming that the occurrence	1
are long. This is often	1
are implemented. Use the option	1
are spaced a multiple of	1
are comparisons, etc. For example:	1
are separated by commas. There	1
are separated by semicolons, while	1
are annoying to the user	1
are supplied in Intel's Math	1
are overriding Intel's CPU dispatcher.	2
are stored. The storage principles	1
are competing for the same	1
are read-only can be shared	1
are indeed of the specified	1
are impossible with references. You	1
are type-casted to a wrong	1
are aligned. It is preferred	1
are disabled will crash the	1
are CPU-specific and each CPU	1
are inherent performance costs to	1
are uninitialized or come from	1
are summarized in table 8.1.	1
are summarized below. Intrinsic function	1
are smarter ways of doing	1
are smarter ways of organizing	1
are capable of register renaming	1
are eliminated. Code caching will	1
are unstable due to interrupts	1
are lost. It is not	1
are mutually incompatible. A function	1
are mutually incompatible. You may	1
are properly aligned or not.	1
are fine-tuned for specific CPU	1
are sharing the same queue,	1
are cached as good as	1
are relocated by the linker	1
are dealing with in a	1
are created. Far Systems with	1
are covered in manual 3:	1
are overdetermined in the sense	1
are overdetermined Boolean variables are	1
are unnecessary for the user	1
are produced regularly. Intel: "Intel	1
are produced regularly. AMD: "Software	1
are lots of things you	1
are wrapped into a class	1
are fetched and decoded in	1
are accessible from compilers that	1
are primitive operations in the	1
are inherently serial, such as	1
are common, and there is	1
are constructed. All non-static variables	1
are prone to even allocate	1
are wrapper classes with destructors	1
are sufficient, and the caching	1
are advised to seek information	1
are seeing an increasing number	1
are doing. See the end	1
are among the most frequent	1
are cumbersome to use for	1
are dominating and there are	1
are instantiated at compile time.	1
are universal, flexible, well tested,	1
are undocumented. 2.7 Choice of	1
are aligned, and make sure	1
are offering profiling tools that	1
are areas where speed is	1
are unavoidable. It may be	1
are indexed in a non-sequential	1
are feeding an array of	1
are unacceptable. Each of the	1
are hundreds of different intrinsic	1
are modified, if necessary, to	1
are compiler-specific. You cannot expect	1
are dominating. At least, it	1
are short. In Windows, you	1
are met: the object is	1
are cheap, in relation to	1
are costless in terms of	1
are obscured in optimized programs.	1
are different. 64-bit Windows allows	1
are risking to insert an	1
are confined to a narrow	1
are satisfied. The conditions that	1
are satisfied: 1. Use a	1
are breaking out of F1	1
are CPLDs and FPGAs. The	1
are relying on the microprocessor	1
are uninitialized, if pointer arithmetic	1
are removed, all resources are	1
are incremental or iterative in	1
are limiting factors for the	1
are unrelated to each other	1
can in most cases be	1
can be a time consumer	1
can be a very efficient	1
can be a very big	1
can be a good idea	1
can be a viable solution	1
can be a time-consumer even	1
can be an efficient way	1
can be an advantage to	1
can be an advantage because	1
can be time consuming because	1
can be different sizes, and	1
can be used to avoid	1
can be used to speed	1
can be used in two	1
can be used in any	1
can be used for multiple	2
can be used for any	1
can be used for saving	1
can be used for implementing	1
can be used for improving	1
can be used for fetching	1
can be used if instruction	1
can be used if elements	1
can be used as command-line	1
can be used as coprocessors	1
can be used where execution	1
can be used without restrictions.	1
can be used freely without	1
can be set then the	1
can be set up to	1
can be very long and	1
can be very useful to	1
can be very useful for	1
can be very inefficient if	1
can be stored in integer	1
can be stored in registers	1
can be called from programming	1
can be less efficient than	1
can be 64 bits (MMX),	1
can be useful to turn	1
can be useful in the	1
can be useful in some	1
can be useful in test	1
can be useful in compiled	1
can be useful in programs	1
can be useful in situations	1
can be useful for making	1
can be useful for large	1
can be useful for optimizing	1
can be useful for finding	1
can be useful when the	1
can be important if you	1
can be accessed with an	1
can be accessed from any	1
can be accessed from main	1
can be accessed approximately two	1
can be accessed sequentially in	1
can be necessary in the	1
can be allocated dynamically with	1
can be allocated dynamically when	2
can be allocated dynamically. The	1
can be allocated dynamically. Arrays	1
can be done by controlling	1
can be done with the	2
can be done with a	2
can be done with just	1
can be done as a	1
can be optimized if a	1
can be optimized to: //	1
can be optimized further. The	1
can be calculated in advance.	1
can be calculated by the	1
can be calculated by a	1
can be calculated by an	1
can be calculated by n	1
can be calculated by adding	1
can be calculated as follows:	1
can be calculated as (critical	1
can be calculated more efficiently	1
can be calculated using multiplications	1
can be calculated independently. The	1
can be advantageous to put	1
can be advantageous to mix	1
can be advantageous to keep	1
can be implemented in the	1
can be implemented in a	1
can be implemented in different	1
can be implemented in compiled	1
can be implemented in various	1
can be implemented with intrinsic	1
can be implemented as a	1
can be implemented as follows	1
can be implemented like this	1
can be implemented either as	2
can be shared between multiple	1
can be quite inefficient if	1
can be quite time-consuming (see	1
can be quite tedious and	1
can be quite substantial. This	1
can be used. If the	1
can be used. We can	1
can be signed or unsigned.	1
can be difficult to find	1
can be read before p	1
can be linked together with	1
can be linked either as	1
can be made for all	1
can be made more compact	1
can be made available to	1
can be made about whether	1
can be made much more	1
can be replaced by a	4
can be replaced with: //	2
can be predicted depends on	1
can be predicted perfectly on	1
can be predicted perfectly varies	1
can be predicted perfectly. As	1
can be loaded at an	1
can be loaded until the	1
can be avoided in 64-bit	1
can be avoided by using	1
can be avoided by making	2
can be avoided by inlining	1
can be avoided by copying	1
can be avoided by joining	1
can be avoided by rolling	1
can be particularly time consuming.	1
can be given in advance.	1
can be vectorized if the	1
can be further tested and	1
can be reduced to 2	1
can be reduced to always	1
can be obtained with the	2
can be changed by another	1
can be changed to: //	2
can be changed freely. The	1
can be initialized to zero	1
can be initialized to desired	1
can be improved is that	1
can be improved in the	1
can be improved by using	3
can be improved by adding	1
can be improved by modifications	1
can be improved by consistent	1
can be copied or moved	1
can be copied into registers.	1
can be copied simply by	1
can be invalid and cause	1
can be used, but any	1
can be organized as a	1
can be added to a	1
can be added at any	1
can be chosen based on	1
can be applied to a	1
can be applied to all	1
can be critical. The branch	1
can be critical. Therefore, the	1
can be mentioned here: A	1
can be mispredicted for this	1
can be mispredicted even if	1
can be converted to a	2
can be converted to an	1
can be 8, 16 or	1
can be determined by a	1
can be determined with system	1
can be expensive in some	1
can be saved either in	1
can be expected to be	1
can be expected for further	1
can be expected that the	1
can be completely contained in	1
can be permissible if the	1
can be turned into a	1
can be overcome by defining	1
can be increased to 16	1
can be increased by more	1
can be divided into multiple	1
can be divided into small	1
can be updated to a	1
can be combined into a	1
can be said that the	1
can be extended to the	1
can be expressed as a	1
can be expressed as an	1
can be expressed as follows:	1
can be prevented in other	1
can be prevented by calling	1
can be eliminated if the	2
can be illustrated by the	1
can be returned in registers	1
can be returned in registers.	1
can be found in my	1
can be found in Wikipedia	1
can be coded in a	1
can be represented with or	1
can be represented as an	1
can be carried out independently	1
can be considered metaprogramming in	1
can be expected. The 64	1
can be solved by making	2
can be inlined. (In the	1
can be moved out of	1
can be joined into a	1
can be placed in separate	1
can be manipulated with C	1
can be justified for general	1
can be vectorized, because a	1
can be disabled in the	1
can be ruled out or	1
can be reused elsewhere. In	1
can be bypassed when the	1
can be annoyingly high for	1
can be defined. The cost	1
can be obtained. If a	1
can be predicted. The target	1
can be fed directly to	1
can be shared. Any writable	1
can be left out if	1
can be wrapped into a	1
can be fetched from the	1
can be broken up. The	1
can be arranged in regular	1
can be cross- compiled on	1
can be combined. For example:	1
can be improved. 3.2 Use	1
can be programmed in a	1
can be reduced. This may	1
can be omitted, of course,	1
can be speeded up significantly	1
can be used: // Example	1
can be made) then it	1
can be ameliorated by using	1
can be wired for a	1
can be accomplished by doing	1
can be overridden in Linux	1
can be propagated through a	1
can be accessed. Pointer arithmetic	1
can not only improve the	1
can not do. The following	1
can you assume that model	1
can have one addition every	1
can have no other values	1
can have any brand name	1
can have eight numbers of	1
can have quite dramatic consequences.	1
can use the same register	2
can use the same space	1
can use the same induction	1
can use the same principle	1
can use the header file	1
can use the GetTickCount or	1
can use a lot of	1
can use a linear list	1
can use for recovering or	1
can use it for improving	1
can use this function to	1
can use this library with	2
can use vector operations automatically	1
can use only compilers and	1
can use 64-bit integers with	1
can use any of the	1
can use standard user interface	1
can then be placed in	1
can then use this information	1
can then run on its	1
can make a Boolean NOT	1
can make function calls faster	1
can make an update when	1
can make an approximate comparison	1
can make this reordering easier	1
can make use of the	1
can make two different implementations	1
can make sure that a	1
can make dynamic link libraries	1
can make arrays of different	1
can make certain kinds of	1
can make thread-local storage of	1
can only be applied to	2
can only have four numbers	1
can only hope that such	1
can only hope that future	1
can set multiple bits in	1
can set up and enable	1
can do the job fast	1
can do is to mix	1
can do a lot of	2
can do to make the	1
can do to take maximum	1
can do and what it	1
can do with bitwise operators	1
can do this by invoking	1
can do this every time	1
can do because it comes	1
can do simple algebraic reductions	1
can do while waiting for	1
can do calculations while another	1
can do calculations while simultaneously	1
can do four additions in	1
can do another addition to	1
can do mathematical calculations. It	1
can do whole program optimization.	1
can do out-of-order execution. This	1
can do arithmetic operations with	1
can double the speed by	1
can also be a type.	1
can also be used for	2
can also be used with	1
can also be used as	1
can also be advantageous to	1
can also be predicted quite	1
can also be vectorized if	1
can also be convenient for	1
can also be eliminated if	1
can also be huge). Far	1
can also use vector operations	1
can also find more examples	1
can also eliminate i and	1
can return with an error	1
can call the polymorphic member	1
can call all code branches	1
can call C1::f directly without	1
can take the absolute value	1
can take more than a	1
can take several seconds to	1
can take several minutes to	1
can take advantage of this	2
can take advantage of vector	1
can take advantage of 64-bit	2
can take advantage of these	1
can take quite a long	2
can take care of the	1
can take care of communication	1
can often be optimized by	1
can often be made smaller	1
can often be executed faster	1
can often optimize the code	1
can often happen that a	1
can often reveal things that	1
can test or manipulate all	1
can even be used on	1
can access internal variables and	1
can avoid the problem that	1
can avoid the conversions and	1
can avoid the inefficient virtual	1
can avoid this by using	1
can avoid this error by	1
can avoid virtual functions then	1
can avoid it. Global variables	1
can avoid hyperthreading by using	1
can cause the memory to	1
can cause other variables to	1
can cause all kinds of	1
can cause cache contentions if	1
can cause branch mispredictions if	1
can cause problems if the	1
can cause caching problems because	1
can cause contentions in the	1
can cause errors if the	1
can cause overflow. For example,	1
can cause unpredictable errors elsewhere	1
can cause complications with member	1
can cause severe delays if	1
can cause holes of unused	1
can therefore be advantageous to	1
can therefore be advantageous when	1
can therefore suffer from mispredictions.	1
can therefore conclude that most	1
can get the exact time	1
can get very expensive cache	1
can get answers to your	1
can check the order of	1
can check the final result	1
can check if a floating	1
can run in both 16-bit,	1
can run only if AVX	1
can run eight threads simultaneously.	1
can run optimally on any	1
can calculate the address of	1
can calculate a vector just	1
can calculate that the number	1
can calculate which set of	1
can calculate each address by	1
can calculate how much memory	1
can store the values in	1
can optimize away the extra	1
can optimize specifically for the	1
can replace a function call	1
can replace an integer constant	1
can replace all occurrences of	1
can replace j * 32	1
can automatically replace a branch	1
can automatically generate multiple versions	1
can automatically detect opportunities for	1
can see the delay. But	1
can see that the addresses	1
can see that the rows	1
can never be sure that	1
can never be negative so	1
can block the execution of	1
can read about in my	1
can give some indication of	1
can look like and how	1
can actually reduce speed if	1
can assume that the type	1
can assume that there is	1
can assume that there are	1
can assume that these integer	1
can improve the performance by	1
can improve the performance dramatically	1
can improve the speed of	1
can improve this by writing:	1
can improve performance in some	1
can improve optimizations in some	1
can improve search times 24	1
can reduce the performance because	1
can reduce the problem by	1
can reduce other types of	1
can reduce any expression, but	1
can reduce some types of	1
can reduce simple algebraic expressions	1
can reduce them all. In	1
can start a new addition	1
can go more than two	1
can change the sign of	1
can change the value. The	1
can change the behavior of	1
can change their clock frequency	1
can change what a pointer	1
can become a serious legal	1
can become very big. In	1
can become imprecise or simply	1
can turn on and off.	1
can rely on only the	1
can rely on automatic prefetching	1
can produce no other value	1
can sometimes be replaced by	1
can sometimes be avoided by	1
can sometimes be obtained by	1
can sometimes be eliminated completely.	1
can sometimes take more time	1
can still be used if	1
can still be vectorized, but	1
can still run on a	1
can still give a considerable	1
can prevent the compiler from	1
can shift out the sign	1
can save a lot of	1
can save cache space or	1
can save several clock cycles.	1
can tell it this by	1
can tell how many times	1
can divide by 2n by	1
can clear or mask out	1
can predict the loop control	1
can predict where the obstacles	1
can possibly be compiled as	1
can possibly be obtained in	1
can possibly block the execution	1
can possibly improve the code.	1
can possibly throw an exception	1
can execute the loop control	1
can execute a code one	1
can execute instructions out of	1
can convert an integer in	1
can convert example 15.1a to	1
can handle eight elements at	1
can occur in the multiplication	1
can occur if a program	1
can occur at random times	1
can insert nontemporal writes automatically	1
can align the arrays as	1
can expect a particular compiler	1
can expect 64-bit programs to	1
can modify x *const_cast<int*>(&x) +=	1
can modify x, while other	1
can not. Static cast The	1
can happen in the code	1
can happen that (b*c) overflows,	1
can happen if the size	1
can happen with the loops	1
can define in this way	1
can contain either sixteen integers	1
can help the compiler optimize	1
can multiply a nonzero floating	1
can multiply by a power	1
can share the same code	1
can share the same register	1
can share the same dynamic	1
can now be vectorized as	1
can easily be organized into	1
can easily optimize away a	1
can easily become fragmented when	1
can easily justify a possible	1
can spend a lot of	1
can generally assume that the	2
can hold many renamed instances	1
can hold 8 double's of	1
can hold four double precision	1
can hold e.g. four numbers,	1
can eliminate this jump by	1
can eliminate one division by	1
can eliminate common subexpressions that	1
can eliminate branches, as explained	1
can increase the time slices	1
can detect that the value	1
can prefetch the data. The	1
can benefit from its many	1
can benefit from setting the	1
can consume a lot of	2
can lead to a better	1
can lead to a dramatic	1
can lead to a complete	1
can overlap the iterations and	1
can obtain most of the	1
can obtain much more by	1
can move out loop-invariant code	1
can move outside the loop.	1
can disable exception handling for	2
can begin the calculation of	1
can force a member function	1
can run. Some implementations of	1
can skip large expressions when	1
can probably be improved by	1
can open the possibility for	1
can bypass the virtual table	1
can bypass the check for	1
can compute a / b	1
can proceed unattended. Uninstallation should	1
can emulate a 256-bit vector	1
can throw. In fact, the	1
can occur, but the calculation	1
can influence the performance of	1
can add, remove or modify	1
can see, it is possible	1
can be, for example, to	1
can subtract this value from	1
can roughly estimate that the	1
can build code for the	1
can steal the user's time.	1
can incur a large delay	1
can surely rely on is	1
can toggle multiple bits with	1
can handle. Waiting for user	1
can learn from this is	1
can safely assume that the	1
can overwrite the return address	1
can exceed 2 Gbytes. This	1
// of function pointers if	2
// The child classes implement	1
// The purpose of the	1
// or from example 16.1	1
// function to transpose and	2
// function to transpose matrix	1
// function prototypes for each	1
// if above doesn't work	1
// if above line doesn't	1
// This is the function	1
// This is the code	1
// This is used only	1
// This is slow //	2
// This function stores a	1
// This function adds the	1
// This triangle is handled	1
// this function can modify	1
// will give -2.0 55	1
// It will look different	1
// Example 13.1 // CPU	1
// Example 16.2 #include <stdio.h>	1
// Example 14.9 struct S1	1
// Example 14.8 const int	1
// Example 16.1 #include <intrin.h>	1
// Example 9.3 #include <malloc.h>	1
// Example 8.26a void Func(int	1
// Example 12.2 __declspec(align(16)) struct	1
// Example 14.6 float list[16];	1
// Example 14.28 union {	1
// Example 14.30 const int	1
// Example 7.2 a =	1
// Example 7.1 float SomeFunction	1
// Example 7.8 if (handle	1
// Example 14.10 int a,	1
// Example 14.11 int a,	1
// Example 8.4 double a	1
// Example 8.7 int SomeFunction	1
// Example 7.21 int i;	1
// Example 9.6b. #include "xmmintrin.h"	1
// Example 9.5a const int	1
// Example 7.7 unsigned int	1
// Example 7.11 bool a;	1
// Example 7.12 void FuncA	1
// Example 11.3 const int	1
// Example 7.22 short int	1
// Example 7.23 int i;	1
// Example 7.20 int i;	1
// Example 7.27 float x;	1
// Example 7.24 float a;	1
// Example 7.25 unsigned int	1
// Example 7.28 class c1	1
// Example 9.4 const int	1
// Example 7.14 class c1;	1
// Example 7.16 float list[100];	1
// Example 7.17 const int	1
// Example 7.13 struct abc	1
// Example 7.19 int i;	1
// Example 7.18 int FuncRow(int);	1
// Example 12.5. Aligned arrays	1
// Example 8.26b void Func(int	1
// Example 14.12b int list[300];	1
// Example 14.14b double a,	1
// Example 15.1c. Calculate integer	1
// Example 14.14a double a,	1
// Example 8.15a struct S1	1
// Example 14.13b int list[300];	1
// Example 9.6a const int	1
// Example 12.1a. Automatic vectorization	1
// Example 14.19 static inline	1
// Example 14.1c void CriticalInnerFunction	1
// Example 14.23b union {	1
// Example 11.2b const int	1
// Example 11.1a float a,	1
// Example 11.1b float a,	1
// Example 7.15b SafeArray <float,	1
// Example 15.1b. Calculate integer	1
// Example 14.26 union {	1
// Example 14.27 union {	1
// Example 14.23 union {	1
// Example 8.21 void Func1	1
// Example 14.5b if ((unsigned	1
// Example 14.5a const int	1
// Example 7.6. Set flush-to-zero	1
// Example 9.5b void transpose(double	1
// Example 13.2. CPU dispatching	1
// Example 7.40a struct Bitfield	1
// Example 7.40b union Bitfield	1
// Example 7.40c x.abc =	1
// Example 14.3a int n;	1
// Example 14.3b int n;	1
// Example 11.2a const int	1
// Example 12.4a. Loop with	1
// Example 8.9b int SomeFunction	1
// Example 8.9a int SomeFunction	1
// Example 8.23b. Calculate polynomial	1
// Example 14.1b int factorial	1
// Example 14.1a int factorial	1
// Example 8.3a float parabola	1
// Example 12.4c. Same example,	1
// Example 12.6. Function with	1
// Example 7.29b floata; boolb=0;	1
// Example 7.29a float a;	1
// Example 7.34a. Use macro	1
// Example 14.13c int list[301];	1
// Example 14.13a int list[300];	1
// Example 8.15b struct S1	1
// Example 7.10b char a	1
// Example 7.10a bool a,	1
// Example 12.4e. Same example,	1
// Example 8.5b a +=	1
// Example 8.5a void Plus2	1
// Example 7.31b char string[100],	1
// Example 7.31a char string[100],	1
// Example 7.43b. Compile-time polymorphism	1
// Example 14.4b if ((unsigned	1
// Example 15.1a. Calculate x	1
// Example 8.13a int i,	1
// Example 8.13b int i,	1
// Example 14.15b if (a	1
// Example 9.1a int Func(int);	1
// Example 9.1b int Func(int);	1
// Example 7.33b const int	1
// Example 8.11b int SomeFunction	1
// Example 8.11a int SomeFunction	1
// Example 7.38b. Alternative to	1
// Example 8.1b float parabola	1
// Example 8.1a float square	1
// Example 12.9b. Taylor series,	1
// Example 8.16 float a,	1
// Example 8.17 char a	1
// Example 8.18 float a	1
// Example 7.42 int Multiply	1
// Example 7.45 // Portability	1
// Example 7.44 class C1	1
// Example 7.4. Signed and	1
// Example 12.8a. Sum of	1
// Example 7.35b struct S1	1
// Example 7.35a struct S1	1
// Example 8.23a. Loop to	1
// Example 12.8b. Sum of	1
// Example 14.18c double a,	1
// Example 8.2a double a,	1
// Example 8.2b a =	1
// Example 14.7b. Testing multiple	1
// Example 7.9b char a	1
// Example 7.9a bool a,	1
// Example 8.25 void Func	1
// Example 8.20 module1.cpp int	1
// Example 8.22 #ifdef __GNUC__	1
// Example 12.9a. Taylor series	1
// Example 8.3b a =	1
// Example 7.38a. Multiple inheritance	1
// Example 7.43a. Runtime polymorphism	1
// Example 14.21. // Only	1
// Example 7.32a double x,	1
// Example 14.22b unsigned int	1
// Example 14.22a unsigned int	1
// Example 15.1d. Integer power	1
// Example 14.18a float a,	1
// Example 14.18b float a,	1
// Example 9.2b void F3(bool	1
// Example 9.2a void F1(int	1
// Example 8.24. Integer constant	1
// Example 7.32b double x,	1
// Example 8.6a int a,	1
// Example 8.6b int a,	1
// Example 7.15a. Array with	1
// Example 7.5. Set flush-to-zero	1
// Example 14.17b double a1,	1
// Example 14.7a. Testing multiple	1
// Example 14.16a double y,	1
// Example 7.26b float a[100];	1
// Example 7.26a float a[100];	1
// Example 8.19. Devirtualization class	1
// Example 8.10b a =	1
// Example 8.10a if (true)	1
// Example 7.30b int i;	1
// Example 7.30a int i;	1
// Example 7.3. Explain volatile	1
// Example 7.39 union {	1
// Example 7.37 class S3	1
// Example 7.36 class S2	1
// Example 12.1b. Vectorization with	1
// Example 8.12a int i,	1
// Example 8.12b int a[2];	1
// Example 12.4b. Vectorized with	1
// Example 12.4d. Same example,	1
// Example 14.12a int list[300];	1
// Example 8.14b int i,	1
// Example 8.14a int i,	1
// Example 7.33a const int	1
// Example 8.8b double x,	1
// Example 8.8a double x,	1
// Example 12.7. Vector class	1
// Example 7.34b. Replace macro	1
// Example 14.16b double y,	1
// Example 14.17a double a1,	1
// Example 14.15a if (a	1
// Example 14.2a float a;	1
// Example 14.2b float a;	1
// Example 14.29 union {	1
// Example 14.24 union {	1
// Example 14.25 union {	1
// Example 14.20 double d	1
// Example 14.4a const int	1
// Example 7.41a class vector	1
// Example 7.41b a.x =	1
// vector class library #include	1
// make dispatcher in only	1
// CPU dispatching on first	1
// loop for // multiply	1
// loop through rows for	1
// loop through rows //	1
// loop columns below diagonal	2
// If Microsoft compiler #define	1
// used for multiplication }	1
// set a to zero	2
// set sign bit of	1
// set sign bit to	1
// do nothing while seconds	1
// number of rows and	2
// number of rows/columns in	1
// C++ casting operator These	1
// return 0 if out	1
// return y = pow(x,n)	1
// return x^10 // loop	1
// 2 unused bytes S1	1
// 2 bytes. first //	1
// 2 bytes. first byte	1
// You may insert any	1
// table of 1/n! 1.,	1
// 32-bit Windows, Intel/MASM syntax:	1
// 32-bit Linux, Gnu/AT&T syntax:	1
// makes intermediate object for	1
// 4 unused bytes byte	1
// 4 bytes. first //	1
// 4 bytes. first byte	2
// call polymorphic child function:	1
// call transpose function swapd(a[r][c],	1
// 8 bytes. first //	1
// 8 bytes. first byte	1
// For unused returns //	1
// test bits 0 -	1
// test sign bit //	1
// always 1 if nonzero	1
// SSE2 // SSE4.1 //	1
// SSE2 version int CriticalFunction_SSE2(int	2
// SSE2 supported return &CriticalFunction_SSE2;	1
// SSE2 supported CriticalFunction =	1
// constant data // constructor	1
// Gnu compiler, etc. #define	1
// Windows syntax or See	1
// result = b >	2
// Use template to get	1
// Use signed when converting	1
// Use mask to choose	1
// Use ReadTSC() from library	1
// specific version of the	1
// Linux syntax 90 Gives	1
// AVX version int CriticalFunction_AVX(int	1
// AVX version 127 int	1
// AVX supported return &CriticalFunction_AVX;	1
// AVX supported CriticalFunction =	1
// get next each bit	1
// check if nonzero u.i	1
// Function to store aligned	1
// Function to store unaligned	3
// Function to load aligned	1
// Function to load unaligned	3
// Function pointer initially points	1
// Function pointer serves as	1
// Function template for x	1
// Function prototype CriticalFunctionType CriticalFunction_Dispatch;	1
// add the four sums	1
// add 2 to x	1
// add elements }; vector()	1
// add n to exponent	1
// sign bit }; The	1
// copy a to b	2
// ... for (int i	1
// ... } } }	1
// next four x^n }	1
// n factorial } return	1
// Make the dispatcher function.	1
// Make a vector of	6
// Make all instances of	1
// Make array of 100	1
// Make dynamic array of	1
// Make three aligned arrays	1
// Table of factorials: static	1
// Table of factorials: const	1
// Table // Loop counter	2
// Table lookup } else	1
// Floating point overflow has	1
// AVX2 // specific version	1
// constructor // sum operator	1
// constructor initializes x to	1
// go to dispatched version	1
// Loop to print out	1
// Loop with branch void	1
// Loop through array cout	1
// Loop counter // Calculate	1
// Loop counter //=2*A //=A*x*x+B*x+C	1
// Loop r1 and c1	1
// Loop r2 and c2	1
// No cache contentions. Use	1
// No error return a[i];	1
// sum operator // add	1
// exponent + 0x3FF unsigned	1
// exponent + 0x3FFF unsigned	1
// exponent + 0x7F unsigned	1
// Define function type with	1
// Define function name depending	1
// Define vector objects Vec8s	1
// Define vector classes //	1
// Define vector classes void	1
// Define vector classes (Intel)	1
// Define size of squares:	1
// Define SSE2 intrinsic functions	1
// Define vectors of four	1
// Define macro to swap	1
// Define macro for aligning	1
// Define biggest possible vector	1
// square x // get	1
// Any function that needs	1
// align by cache line	1
// align table by 16	1
// SSE4.1 // AVX2 //	1
// header for intrinsic functions	1
// swap elements // align	1
// swap elements } }	1
// Store the result vector	4
// Store result // Update	1
// f is zero }	1
// f is nonzero }	1
// define a macro to	1
// define function type typedef	1
// define matrix // call	1
// define fprintf // define	1
// Load eight consecutive elements	8
// multiply // square x	1
// 6 unused bytes //	1
// default constructor // constructor	1
// Time // Serialize //	1
// Time before test //	1
// Time difference for each	1
// everything is double There	1
// everything is float 140	1
// parent class. The child	1
// Virtual function // Call	1
// Virtual call to C1::f	1
// Template for pow(x,N) where	1
// Cache contentions expected. Use	1
// Now call the chosen	1
// Now 1.0 <= u.f	1
// Add 2 to each	2
// Number of times to	1
// SSE3 required // This	1
// Set function pointer if	1
// Set pointer to the	2
// Set sign bit of	1
// INSTRSET == 2 12.6	1
// Roll out loop by	5
// Critical function to test	1
// Critical innermost loop: for	1
// AND each element in	2
// SIZE must be divisible	1
// OR the results of	1
// Array of 100 doubles:	1
// Array with N elements	1
// Array size Alignd (	1
// Calculate polynomial The calculation	1
// Only for SSE2 or	1
// Division by a constant	1
// n! // Table of	1
// n! int i, f	1
// s += x^n/n! xxn	1
// Writes "Hello 2" The	1
// Writes "Hello 2" Here	1
// Writes "Hello 1" //	2
// x^4 // Define vectors	1
// x^4 // x^8 //	1
// x^4 F32vec4 s(0.f, 0.f,	1
// Multiply b and c	2
// u.f > v.f if	1
// Header file for InstructionSet()	2
// C-style type casting //	1
// Bounds checking (see page	1
// Same as example 13.1,	1
// MOVNTQ _mm_empty(); // EMMS	1
// Still faster if unsigned	4
// Faster if divisor is	2
// After first call it	2
// Return the size of	1
// Return a null reference	1
// Return reference to a[i]	1
// fractional part unsigned int	2
// fractional part 142 unsigned	1
// Index out of range.	1
// At the diagonal there	1
// Get supported instruction set,	2
// Get upper 32 bits	1
// sum, initialize to x^0/0!	1
// Check that index is	1
// Check if level-2 cache	1
// Call to virtual function	1
// Call critical function a	1
// Call critical function through	1
// Structure of 4 floats	1
// 400 bytes. first byte	1
// x^2 // x^4 //	1
// x^2 float x4 =	1
// Full template specialization for	2
// (N & N-1)==0 if	1
// Enable exception for floating	1
// Lowest version int CriticalFunction_386(int	2
// Initialize to zero //	1
// Initialize loop counter outside	1
// x^n // sum, initialize	1
// (time after) - (time	1
// Volatile to prevent optimizing	1
// x^10 // return x^10	1
// _controlfp(0, _EM_OVERFLOW); // if	2
// Polynomial coefficients // Table	1
// Polynomial coefficients double Table[100];	1
// Increment loop counter and	1
// Overflow may occur in	1
// General case, N is	1
// ipow faster than pow	1
// (This is faster than	1
// Returns a pointer to	1
// Returns time stamp counter	1
// Portability note: This example	1
// Catch floating point overflow	1
// Catch exceptions in this	1
// Update induction variable Y	1
// Update induction variable Z	1
// Mixing float and double	1
// Or #include <ia32intrin.h> etc.	1
// EMMS } const int	1
// Approximate exp(x) for small	2
// initialize sum for(inti=0;i<16;i+=4){ //Loopby4	1
// Remove right-most 1-bit in	1
// Compare each element in	2
// flip sign bit of	1
// incremented every second by	1
// Repeat NumberOfTests times //	1
// Prevent optimizing away cpuid	1
// Dispatcher void SelectAddMul_dispatch(short int	1
// Re-do the calculation in	1
// x^8 // x^10 //	1
// Non-polymorphic functions go here	1
// Error: lowest instruction set	1
// Safe [] array index	1
// Output array element }	1
// Generic version CriticalFunction =	1
// polynomial(x) = 2.5*x^2 -	1
// u.d is negative or	1
// Called directly // Writes	1
// Round to nearest integer	1
// versions: class CChild1 :	1
// Entry to dispatched function	1
// Truncation is slow. Value	1
// Implicit type conversion //	1
// Constructor // Initialize to	1
// Modulo by a constant	1
// Branch/loop function vectorized: void	1
// Detect supported instruction set	1
// Place non-polymorphic functions in	1
// Print heading You can	1
// x,y coordinates // default	1
// Reset floating point status:	1
// x^1, x^2, x^3, x^4	1
// Serialize // Prevent optimizing	1
// Convert to unsigned for	1
// Find numerically largest element	1
// Faster, but risk of	1
// continue in dispatched version	1
// erroneously called with IsPowerOf2	1
// Read time You can	1
// Dispatcher. Will be called	1
// Constructor-style type casting //	1
// 2-dimensional vector 56 public:	1
// Partial template specialization for	1
// instrset_detect function // Function	1
// Rounding is fast. Value	1
// Prototype for the common	1
// abs(u.f) > abs(v.f) }	1
// Main loop for calculations:	1
// (Some compilers use the	1
// Default version return &CriticalFunction_386;	1
= a a && false	1
= a a | -1	1
= a a ^ -1	1
= a - n.a. -	2
= a - n.a. x	1
= a - n.a. a-a	1
= a - n.a. a*0	1
= a - n.a. (-a)*(-b)	1
= a - a-a =	1
= a - a*0 =	1
= a - 0/a =	1
= a - a/1 =	1
= a x - x	1
= a + b +	4
= a + 2 thenaandbcannot	1
= a + 1; x[1]	1
= a + 1.0f; The	1
= a * 2; }	2
= a * 2; return	2
= a * 3; }	2
= a * 3; return	2
= a * 2.5; //	1
= a & b; will	1
= a & b; d	1
= a ; parameter 2:	1
= a && b; d	1
= a | b; Here,	1
= a || b; This	1
= a ? b :	2
= a ^ b ---xx----	1
= a ^ 1; You	1
= a XOR b Bit	1
= int 4 AVX2 _mm256_i32gather_epi32	1
= int 8 AVX2 _mm_i64gather_epi32	1
= x * x; //	1
= x > y &&	1
= x *x; double x4	1
= { // table of	1
= { "Alpha", "Beta", "Gamma",	1
= A + A; double	1
= A + B; for	1
= A | (B <<	1
= point to end of	1
= double 2 AVX2 _mm256_i64gather_pd	1
= double 4 AVX2 Table	1
= b + c +	1
= b + 1 is	1
= b + 1; return	1
= b + 2.0 /	1
= b + 0.666666666666666666667; This	1
= b * b +	2
= b * 5 /	1
= b * 2.5 may	1
= b * 3.5; c	1
= b * 1.2; //	2
= b * (1. /	1
= b * 1.2f; //	1
= b / c; a	1
= b / 10; a	1
= b / 16; a	1
= b / 1.2345; Change	1
= b > 0 ?	2
= b % c; a	1
= b % 10; a	1
= b % 16; a	1
= b ? 1.5f :	1
= i = 0 that	1
= i * 9 +	1
= i % 3; }	1
= float or int 4	1
= float or int 8	1
= float 4 AVX2 _mm256_i32gather_ps	1
= float 8 AVX2 _mm_i64gather_pd	1
= 2 * 5; to	1
= 4 rows. Let's look	1
= 0; for (i =	1
= 0; for (int i	1
= 0; for (i=0; i<100;	1
= 0; // Initialize loop	1
= 0; int i; for	2
= 0; int i, largest_index	1
= 0; x < 100;	2
= 0; } if (a	1
= 0; } else {	1
= 0; i < 100;	11
= 0; i < 2;	1
= 0; i < size;	11
= 0; i < n;	1
= 0; i < 256;	6
= 0; i < 1000;	1
= 0; i < 20;	2
= 0; i < rows;	2
= 0; i < NumberOfTests;	2
= 0; i < ArraySize;	1
= 0; i < list.Size();	1
= 0; while (seconds <	1
= 0; c < SIZE;	2
= 0; c < r;	2
= 0; r < SIZE;	2
= 0; row < NUMROWS;	1
= 0; j < columns;	1
= 0; column < NUMCOLUMNS;	1
= 0; c1 < r1;	1
= 0; 14.6 Floating point	1
= 0; list[i+1] = 1;	1
= 0; r1 < SIZE;	1
= 8 * 4 =	1
= 64 kb. This corresponds	1
= 16 is actually hidden	1
= 0 a & -1	1
= 0 a ^ ~a	1
= 0 that r points	1
= 0 // This is	1
= 0 - n.a. -	2
= 0 - n.a. x	1
= 0 - n.a. a*1	1
= 0 - n.a. a+0	1
= 0 - Divide by	1
= 0 - a*1 =	1
= 0 - a+0 =	1
= 0 because this would	1
= 0 a+0=a a*0=0 a*1=a	1
= & obj1; p->f(); //	1
= c + b +	1
= i; } } Example	1
= i; } Here, the	1
= a, a & 0	1
= a, a | a	1
= a, a | 0	1
= a, a || false	1
= a, but they are	1
= b; A branch can	1
= b; } else {	1
= b; c = b	1
= 1; for (i =	1
= 1; } This is	1
= 1; } else {	1
= 1; n <= 16;	1
= 1; r < SIZE;	2
= 1; list[i+2] = 2;	2
= 1; a[1] = 2;	1
= 256 times and the	1
= y + 1.; }	2
= y + 1.; Eliminate	1
= c; } Can be	1
= char 16 SSSE3 _mm_perm_epi8	1
= char 16 XOP, AMD	1
= x; float sum =	1
= 100; // Array of	1
= 100; int i; float	1
= 100; int matrix[NUMROWS][NUMCOLUMNS]; int	1
= 100; float list[size], sum	1
= 100; float list[size], sum1	1
= 100; float list[ARRAYSIZE]; if	1
= 100; S1 list[size]; int	1
= r + 2; }	1
= r + i/2; }	1
= r ebx, eax ebx,	1
= 0, b = 0,	1
= 0, b; b =	1
= 0, c, d; c	1
= 0, sum2 = 0;	1
= 0, s3 = 0,	1
= 0, s2 = 0,	1
= 0, sum; for (int	1
= 0, (a&b) | (~a&c)	1
= 0, s1 = 0,	1
= 2; } The loop	1
= 2; } list[300] =	1
= 2; i <= n;	1
= 2; Unfortunately, some compilers	1
= a[i] + b[i]; c[i]	1
= a; b = a	1
= a; y = b;}	1
= p + i; Here,	1
= 1. This ends the	1
= 1. / (b1 *	1
= temp * temp; c	1
= temp * temp; 104	1
= temp / 4; Register	1
= shift and add Divide	1
= d + 3.5; Here,	1
= d + e +	1
= divide by 2 ;	1
= 2, Tuesday = 4,	1
= true a && a	1
= true a && true	1
= temp; } 70 Induction	1
= temp; temp += 9;	1
= u; If you are	1
= row + column; Do	1
= 3; for (i =	1
= multiply and shift Floating	1
= multiply by - reciprocal	1
= multiply by xx-xx--x- reciprocal	1
= *p + 2; }	2
= *p + 2;} int	1
= false where it should	1
= 4, we have: //	1
= 4, Wednesday = 8,	1
= -1 - n.a. -	1
= -1 x - -	1
= -1 (a&~b)|(~a&b)=a^b --------- ~a	1
= 8, Thursday = 0x10,	1
= (unsigned int)b / 10;	1
= (unsigned int)b / 16;	1
= (unsigned int)b % 10;	1
= (unsigned int)b % 16;	1
= (unsigned int)a / 10;	1
= 10; int i; long	1
= 10; Templates are instantiated	1
= 1, Monday = 2,	1
= 256; // Array size	1
= (a + b) +	1
= (a >= b) -	1
= Induction ; edx =	1
= int64_t 2 AVX2 _mm256_i64gather_epi32	1
= int64_t 4 AVX2 _mm_i32gather_ps	1
= log (b[i] * c[i]);	1
= 16; int i; float	1
= x- x- x (x)	1
= (float *)alloca(n * sizeof(float));	1
= 1.0; for (x =	1
= 1.0; int i; for	1
= 1.0; while (n !=	1
= 1.0; list[i].b = 2.0;	1
= 1.0; temp->b = 2.0;	1
= 250 s on a	1
= a[i]; It is often	1
= ~a a ^a =	1
= b[i] + 2; }	1
= C; double Z =	1
= C; Assuming that the	1
= 1000; int i; float	1
= 1000; int List[ArraySize]; ...	1
= 1000; float a[size], b[size];	1
= 1000; unsigned int dummy;	1
= parabola (2.0f); b =	1
= 2.0; x <= n;	1
= 2.0; } The factor	1
= 2.0; } In order	1
= 2.0; i >= 0;	1
= s; An integer is	1
= 0x2710 and (set) =	1
= (n & 0x7FFFFF) |	1
= (b == 0) ?	1
= Induction; ; parameter $B1$1:	1
= Induction; ; a[i+1] =	1
= Induction; a[i+1] = Induction;	1
= Induction; Induction++; } }	1
= 100, c = 100,	1
= 100, y; y =	1
= 100, max = 110;	1
= 100, NUMCOLUMNS = 100;	1
= LoadVector(cc + i); //	3
= LoadVector(bb + i); //	3
= r; for (i =	1
= 100. Now, according to	1
= x2 * x2; //	1
= 28. This means that	1
= 28. We take the	1
= b;} vector operator +	1
= 8; // SIZE must	1
= 8; float matrix[rows][columns]; int	1
= (number of sets) (line	1
= false, a || true	1
= false, a || !a	1
= 1024; int a[size], b[size];	1
= 1024; int a[size], b[size],	1
= 1024; struct Sab {int	1
= r1; c2 < r2;	1
= r1; r2 < r1+TILESIZE;	1
= a*b - n.a. !(a	1
= ReadTSC() - time1; //	1
= *(p++) is more efficient	1
= 0x1C. Reading or writing	1
= _mm_set1_epi16(2); // Roll out	2
= a2 * b1 *	1
= a2 / b2; This	1
= a1 * b2 *	1
= a1 / b1; y2	1
= ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x = ((x2)	1
= (a+b)+(c+d) a*b+a*c=a*(b+c) a*x*x*x +	2
= cos(x); } z =	1
= cos(x); z = y	1
= a+(b+c) - n.a. a*b+a*c	1
= a+(b+c) - a*b+a*c =	1
= N&(N-1) gives the value	1
= 3.3; // Polynomial coefficients	1
= 3.3; double Table[100]; int	1
= 2.0f; x.i |= 0x80000000;	1
= {1, 1, 2, 6,	2
= StringLength; i > 0;	1
= 32. This is a	1
= string; int i, StringLength;	1
= string; while (*p !=	1
= &Object1; p1->Hello(); CChild2 *	1
= &Object1; p->NotPolymorphic(); p->Hello(); p	1
= a*(b+c) - n.a. x*x*x*x*x*x*x*x	1
= a*(b+c) - -(-a) =	1
= (bb[i] > 0) ?	1
= order(i); matrix[j][0] = i;	1
= order(i); list[j].a = list[j].b	1
= 2048 bytes = 4	1
= InstructionSet(); // Set pointer	2
= ((x2) 2) 2 -	1
= ((x2) 2) 2 a+a+a+a=a*4	1
= 512; // number of	2
= 20, columns = 32;	1
= 20, columns = 50;	1
= bb[i] + 2; }	1
= (memory address) / (line	1
= log(b[i]) + log(c[i]); //	1
= log(b[i]) + log(c[i]);. This	1
= _mm_set1_epi16(0); // Make a	2
= a&&(b||c) !a && !b	1
= a&&(b||c) (a&&!b) || (!a&&b)	1
= (a&b) | (~a&c) a&b&c&d	1
= 8192 bytes, 4 ways,	1
= _mm_cmpgt_epi16(b, zero); // Use	1
= _mm_cmpgt_epi16(b, zero); // AND	1
= (double)(signed int)u; // Faster,	1
= (double)(signed int)u; 14.9 Using	1
= &CriticalFunction_386; } // Now	1
= select(b > 0, c	2
= sin(x); } 68 else	1
= sin(x); z = y	1
= 1.f; for (int n	1
= 1.f; float nfac =	1
= A; x.b = B;	1
= _mm_add_epi16(c, two); // Multiply	2
= 2.2, C = 3.3;	2
= &CriticalFunction_SSE2; } else {	1
= 1.23456. But we will	1
= 1.1, B = 2.2,	2
= &Object2; p->Hello(); } //	1
= &Object2; p2->Hello(); // Writes	1
= 80. The difference lies	1
= c1; c2 < c1+TILESIZE;	1
= 0x40 }; Weekdays Day;	1
= !(a || b) a	1
= _mm_mullo_epi16 (b, c); //	2
= (a<b && b<c) Multiply	1
= B; x.c = C;	1
= 1.0f + b *	1
= b*a - n.a. (a+b)+c	1
= b*a (a+b)+c=a+(b+c) a+b+c=c+b+a a+b+c+d	1
= &CriticalFunction_AVX; } else if	1
= (a+1) * (a+1); c	1
= (a+1) / 4; The	1
= a&(b|c) - n.a. -	1
= a&(b|c) x-xxxx--x (a|b)&(a|c) =	1
= 10, columns = 8;	1
= b+a a*b = b*a	1
= x8*x2; return x10; }	1
= 128. These lines are	1
= i+1; The compiler may	1
= -abs(x);. There are a	1
= b.y + c.y +	1
= sin(0.8); The sin function	1
= xxn-1, and each value	1
= 6.0f; Constant folding and	1
= a1/b1 + a2/b2; Here	1
= &SelectAddMul_AVX2; (iset >= 5)	1
= 64; // number of	1
= list[j].b + list[j].c; }	1
= 1.23456, y; y =	1
= x2*x2; double x8 =	1
= -100, b = 100,	1
= {2.6f, 1.5f}; a =	1
= (int)n - 2, x	1
= a[i].u[1] * 2; //	1
= 110; int i; ...	1
= lookup[b]; If a bool	1
= pow(x,n) As we can	1
= 2.5*x^2 - 8*x +	1
= a<<(b+c) - n.a. -	1
= {1.1, 0.3, -2.0, 4.4,	1
= A*x*x + B*x +	1
= 1.0E8, c = 1.23456,	1
= (short int)i; This conversion	1
= (s0+s1)+(s2+s3); Now s0, s1,	1
= &SelectAddMul_dispatch; // Dispatcher void	1
= (a&b)&(c&d) a ^0 =	1
= n(n-1)!. If we want	1
= (total cache size) /	1
= _mm_or_si128(c2, bc); // Store	1
= (a1*b2 + a2*b1) /	1
= OneOrTwo5[b!=0]; will also work,	1
= b[r][c]; } } }	1
= *(++p) because in the	1
= array[++i] because in the	1
= (10000 / 64) %	1
= {1.0f, 2.5f}; a =	1
= (int)d; // Truncation is	1
= absvalue; largest_index = i;	1
= _mm_andnot_si128(mask, bc); // OR	1
= 0x20, Saturday = 0x40	1
= instrset_detect(); 116 // Set	1
= (b*c)/d, it can happen	1
= Y; Y += Z;	1
= Func1(2); ... } If	1
= &list[0]; temp < &list[100];	1
= a|(b&c) x-xxxx--x ~a&~b=~(a|b) --xxxx---	1
= 32; float matrix[rows][columns]; int	1
= WhateverFunction(i); // ... }	1
= array[i++] is more efficient	1
= 100000001.23456. The float type	1
= Func(a[i]); } The data	1
= -1.0E8, b = 1.0E8,	1
= 0x10, Friday = 0x20,	1
= y.d + 4.; };	1
= y.a + 1.; x.b	1
= y.b + 2.; x.c	1
= y.c + 3.; x.d	1
= (float)i; f = float(i);	1
= 0.0; // copy a	1
= &CriticalFunction_Dispatch; // Lowest version	1
= 5.0f; b = 6.0f;	1
= lrint(d); // Rounding is	1
= 123; are equally efficient	1
= OneOrTwo5[b & 1]; Here,	1
= MAX(f(x), g(x)); In this	1
= Func(ab[i].a); } There will	1
= log(2.0); ... } Here,	1
= 50; float matrix[rows][columns]; int	1
= (int)(&list[0]) + 100*16, and	1
= MultiplyBy<8>(10); a and b	1
= &SelectAddMul_SSE2; // Error: lowest	1
= b+a, a*b = b*a	1
= _mm_blendv_epi8(bc, c2, mask); //	1
= CriticalFunction(b, c); ... return	1
= _mm_hadd_ps(x, x); s =	1
= r1+1; r2 < r1+TILESIZE;	1
= 10000, then we have	1
= (A & 0x0F) |	1
= !a; can be optimized	1
= __rdtsc(); return clock; }	1
= b++; will make the	1
= a*4 - n.a. -(-a)	1
= float(i); f = static_cast<float>(i);	1
= ++b; the compiler will	1
= (*CriticalFunction)(b, c); ... return	1
= Multiply(10,8); b = MultiplyBy<8>(10);	1
= b.x + c.x +	1
= select_gt(b, zero, c +	1
= (0x2710 / 0x40) %	1
= x4*x4; double x10 =	1
= _mm_hadd_ps(s, s); return _mm_cvtss_f32(s);	1
= ((x2)2)2 a+a+a+a=a*4 -(-a)=a -	1
= ReadTSC(); CriticalFunction(); timediff[i] =	1
= FactorialTable[b]; ... } }	1
= static_cast<float>(i); // Implicit type	1
= a&&b (a&&b) || (a&&c)	1
= 18, then the &	1
= 1.6; int a, b;	1
= &SelectAddMul_SSE41; (iset >= 2)	1
= _mm_and_si128(c2, mask); 110 //	1
= dummy[0]; clock = __rdtsc();	1
= a+1; b = temp	1
or the function could be	1
or the other with a	1
or the loop unroll factor.	1
or the number of objects	1
or the user is far	1
or the error code may	1
or the specific literature for	1
or the negative effects of	1
or the series of statements	1
or the __assume_aligned directive to	1
or a function library. 78	1
or a make utility. It	1
or a CPU with multiple	1
or a static library. A	1
or a member function such	1
or a simple variable. Using	1
or a few arrays of	1
or a few machine instructions.	1
or a few places. Constant	1
or a separate module then	1
or a binary tree. Is	1
or a pointer. A variable	1
or a smart pointer. But	1
or a similar utility for	1
or a hash map is	1
or a hash map. Do	1
or a reasonable upper limit	1
or a nearby address again	1
or a not-too-big upper limit	1
or a non-const reference, a	1
or to an output file.	1
or to exit the loop.	1
or in the programming manuals	1
or in a separate function.	1
or in a register. If	1
or in a high-priority thread	1
or for the sake of	1
or for issuing an error	1
or for combining multiple .cpp	1
or function call (other than	1
or function libraries is more	1
or function calls. The consequence	1
or if the first operand	1
or if the new version	1
or if the type T	1
or if the calculation time	1
or if the prediction turns	1
or if the 7 program	1
or if it is called	2
or if it is correlated	1
or if it opens the	1
or if this is obvious,	1
or if different versions have	1
or if one is 0	1
or if there is nothing	1
or if pointers are type-casted	1
or if they are sure	1
or if they come from	1
or if its body is	1
or by an executable file	1
or by memory access. The	1
or by using a compiler	1
or by making a and	1
or by type-casting i to	1
or by turning the frame	1
or by extending with zero-bits	1
or by keys within a	1
or with the functions malloc	1
or with an index of	1
or with compile-time polymorphism. It	1
or code lines. The 17	1
or as a function return	1
or not in a particular	1
or not at all on	1
or an integer can be	1
or an assembly listing. Use	1
or an input file. The	1
or an anonymous object. The	1
or an over- loaded type	1
or int 4 AVX _mm256_permutevar_ps	1
or int 8 AVX2 _mm_i32gather_epi32	1
or you may use the	1
or use the CPU detection	1
or use objconv or a	1
or more of the above	1
or more then the offset	1
or more integer units, one	1
or more performance monitor counters	2
or more template instances will	1
or more dynamic libraries are	1
or more versions of the	2
or more threads writing to	1
or more iterations back. The	1
or more complex integer expressions.	1
or more jobs simultaneously or	1
or more cores, and it	1
or more constants. For example,	1
or when the SSE2 instruction	3
or when code caching is	1
or when accessing an object	1
or from example 16.1 const	1
or from knowing that the	1
or memory pool. Alignment? Some	1
or at run time. Therefore,	1
or data used in the	1
or data exceeds 64 kbytes.	1
or program size, while high-level	1
or vector classes is just	1
or vector classes than by	1
or make files smaller. It	1
or because the programmer hasn't	1
or CPU cores, we need	1
or other data structure then	1
or other error condition. Things	1
or other hardware often requires	1
or other hardware conditions. A	1
or other resources. There are	1
or other device should preferably	1
or one clock cycle. In	1
or cache access rather than	1
or no other branches. A	1
or no overhead while other	1
or no offset at all.	1
or no idea how a	1
or class is less than	1
or class is 128 bytes	1
or class is responsible for	1
or class for containing thread-specific	1
or class that is used	1
or class with members of	1
or class should be aligned	1
or class into an anonymous	1
or class declaration and the	1
or class separately in software	1
or class elements. The size	1
or class objects. The size	1
or floating point numbers. Therefore,	1
or each of its members	1
or do more than one	1
or do other input/output than	1
or double to int in	1
or double to integer can	1
or double to integer takes	1
or double because all the	1
or double takes 4 -	1
or double plus 6 integer,	1
or double precision, and intermediate	1
or double precision, but there	1
or Intel compiler. Use CPUs	1
or pointer to the object	1
or library has an initialization	1
or library files. Use 64-bit	1
or multiple times in the	1
or multiple configurations with the	1
or multiple elements? If the	1
or two floating point multiplication	1
or two floating point addition	1
or two integers of 64	1
or two 128- bit vector	1
or object is accessed in	1
or object that is allocated	1
or object as if it	1
or object through a pointer	1
or static or by using	1
or static storage Variables that	1
or 64-bit integers in 32-bit	1
or 64-bit mode. Much of	1
or 64-bit systems). 28 Dynamic	1
or C++ code. Compilers and	1
or C++ file and compiled	1
or C++ based on what	1
or array coincides with the	1
or variable is accessed from	1
or variable having the same	1
or any other cleanup that	1
or any higher instruction set,	1
or any particularly slow instruction	1
or performance problems. Avoid nested	1
or long dependency chains then	1
or between different parts of	1
or member function because this	1
or member functions. A static	1
or const reference cannot change	1
or cannot be calculated at	1
or See page 95 and	1
or critical parts of the	1
or less each time. An	1
or unsigned 2 2 int,	1
or unsigned 4 4 64-bit	1
or unsigned 8 8 pointer	1
or unsigned 1 1 short	1
or first in an ||	1
or libraries that come with	1
or pointers to data through	1
or they may be swapped	1
or without the sign bit.	1
or even a linear search,	1
or even a thousand times	1
or even swapped to disk.	1
or even telling the user	1
or method should be longer	1
or always false: // Example	1
or 16 8 or 16	1
or 16 bits of the	1
or 16 Table 7.2. Alignment	1
or SSE2 instruction set, as	1
or out of order. See	1
or 32 bits (rarely 64).	1
or 32 bytes). This has	1
or dynamic link libraries, also	2
or error prone. All these	1
or Gnu compilers without problems	1
or accessed in a non-sequential	1
or does so in a	1
or assembly language and the	1
or assembly language. It is	1
or threads simultaneously. If the	1
or specific models then you	1
or common names. Use fastcall	1
or thread are smaller. The	1
or thread does not necessarily	1
or small sequences of code.	1
or line separately through multiple	1
or optimized away. It is	1
or four single precision variables	1
or four float's when the	1
or another error has occurred	1
or get ReadTSC as a	1
or container is too big	1
or container without dynamic memory	1
or eight single precision variables	1
or structure is a good	1
or structure is simply a	1
or structure is created. There	1
or structure are stored consecutively	1
or structure object takes no	1
or every code line. Time-based	1
or 1 and that the	1
or 1 by XOR'ing it	1
or 1 (see page 135).	1
or add an extra dummy	1
or simply zero. Execution time	1
or addresses that need relocation.	1
or shared objects), resource files,	1
or write it in one	1
or write less than a	1
or replace it with the	1
or operator that transfers ownership	1
or Mac operating system running	1
or cache. Most compilers will	1
or 256 bytes) on future	1
or model the best possible	1
or mathematical functions such as	1
or Microsoft compiler for Windows	1
or what a function pointer	1
or reference is valid only	1
or reference to the class	1
or reference to the object.	1
or reference to a static	1
or reference to a variable	1
or reference to a structure.	1
or reference to such an	1
or reference to it. Therefore,	1
or reference to anything it	1
or reference can be eliminated	1
or reference may be just	1
or reference parameters). The this	1
or three levels of cache	1
or too long. If the	1
or transferred from one function	1
or after the last member.	1
or give it a pointer	1
or graphics accelerator card. Some	1
or assume that it doesn't	1
or later // Header file	1
or later with code compiled	1
or later instruction set is	4
or later instruction set if	1
or later instruction set. 120	1
or higher instruction set. More	1
or goes into sleep mode.	1
or union can use any	1
or require a lot of	1
or require more resources, even	1
or require runtime type identification	1
or #define makes no difference	1
or switch statement leads to	1
or modules with a well-defined	1
or references then tell the	1
or VIA processor and a	1
or global arrays require a	1
or global variables. (See thread-local	1
or 1. The AND operator	1
or 1. This makes operations	1
or 1. See page 34.	1
or 1. Writing a =	1
or turn off requirements for	1
or size. Today, it is	1
or network resources. This time	1
or #pragma optimize("a",on). Specifies that	1
or #pragma novector to tell	1
or hot spot but also	1
or comes from a reliable	1
or limited in scope. A	1
or class. The transfer of	1
or class. This makes data	1
or database is heavily loaded.	1
or strings of different lengths	1
or writing a variable from	1
or writing a file on	1
or writing a small bit	1
or writing to a variable	1
or writing big blocks is	1
or writing small bits in	1
or accessing databases, network and	1
or until the computer is	1
or full speed. A simple	1
or overloaded operator is as	1
or models that were unknown	1
or fail completely because of	1
or compiling the intermediate code.	1
or structures are accessed through	1
or logical processors available in	1
or logical processors usually share	1
or subexpression containing only constants	1
or reading disk files. See	1
or resource files from disk.	1
or enable the SSE2 instruction	1
or PathScale compiler for Unix	1
or references. It is OK,	1
or come from unknown sources.	1
or modify the ones that	1
or modify objects simultaneously. In	1
or setting an array to	1
or input data. A missing	1
or not. The loop can	1
or not. The Intel compiler	1
or not. The following example	1
or not. The advise of	1
or not. There are various	1
or not. See page 107	1
or not. I will conclude	1
or approximately so. It may	1
or easy linking to assembly	1
or writes a file can	1
or writes to any other	1
or non-static member functions. A	1
or false (0); and the	1
or 8, but not any	1
or __restrict or #pragma optimize("a",on).	1
or 1, but operators that	1
or update automatically when the	1
or int64_t MS compiler: __int64	1
or log off the computer	1
or compile-time generation of identifier	1
or remove any objects if	1
or constant. If the loop	1
or reads to the same	1
or reference, the compiler may	1
or reference, or the function	1
or reference, 64-bit mode 8	1
or reference, 32-bit mode 4	1
or compilation before it can	1
or completely absent in a	1
or structure. The situation is	1
or structure. This is equally	1
or loss of precision, especially	1
or multidimensional array is less	1
or multidimensional array should be	1
or lists of specific CPU	1
or created it will generate	1
or key in the container	1
or key press. 19 Avoid	1
or malloc is typically aligned	1
or malloc and free are:	1
or malloc and free. This	1
or division. The compiler will	1
or __asm ("int 3"); or	1
or two. Often, it is	1
or sixteen vector registers (XMM	1
or estimate of the final	1
or mouse input. It is	1
or mouse move. It is	1
or *.so). The program has	1
or *.so). The installation program	1
or video should also be	1
or unsigned. The following table	1
or another. Therefore, micro- processors	1
or mask out multiple bits	1
or structures. Accessing a data	1
or otherwise optimize across the	1
or uint64_t MS compiler: unsigned	1
or API function which then	1
or multi-core CPUs, as described	1
or manipulate all the bits	1
or bypassing syntax checks. These	1
or C++. Critical device drivers	1
or (requires no specific option)	1
or moving the mouse. The	1
or moving the mouse. This	1
or infinity or NAN (not	1
or reference. Registers are a	1
or micro-op cache. The Core2	1
or moved with a single	1
or bypass the CPU detection	1
or typedef instead of a	1
or inline. This will enable	1
or modified. This can be	1
or modified. This can cause	1
or 3-dimensional vectors RGB image	1
or 3-dimensional vectors ....................................................... 120	1
or post-increment. The effect is	1
or interpretation on the device	1
or send data from a	1
or ten years old. The	1
or four, depending on the	1
or NAN (not a number).	1
or NAN (Not A Number)	1
or -0 } It is	1
or namespaces. Therefore, you should	1
or microseconds as a time	1
or re- allocating when a	1
or column. The access is	1
or integrated in the CPU	1
or -Ofast /O3 -O3 Interprocedural	1
or Friday is set in	1
or x64 141 #include <emmintrin.h>	1
or 0x40 bytes from address	1
or later. Example: // Example	1
or better, make your own	1
or circumvent operating system standards.	1
or CString uses new and	1
or she is busy concentrating	1
or .a), but not dynamic	1
or more. Many software applications	1
or QueryPerformanceCounter functions for millisecond	1
or decrementing a pointer does	1
or __debugbreak();. If you run	1
or "frame pointer". The standard	1
or -axAVX. This will make	1
or bitmap than to draw	1
or double) /arch:SSE2 -msse2 /arch:SSE2	1
or network. Various development tools	1
or clearing arrays It may	1
or PSDK). Supports the OpenMP	1
or friend function or operator	1
or g(x) is calculated twice	1
or seemingly simultaneously. If the	1
or remotely. If frequent updates	1
or -fno-strict-overflow. You may deviate	1
or while-loop is also a	1
or animation. It is possible	1
or Espresso) that can reduce	1
or "__attribute__((visibility ("hidden")))". A more	1
or inttypes.h is available then	1
or __attribute__((fastcall)). The fastcall modifier	1
or C1::f. But an optimizing	1
or C2::Disp() is done at	1
or hide them for the	1
or p->member is equally fast	1
or /Ox -O3 or -Ofast	1
or intranet for automatic updates,	1
or PathScale. 2. Use the	1
or 2016. The same coding	1
or NAN. Avoiding the cost	1
or tiling. This technique is	1
or *.so) that belong to	1
or modifies many strings. In	1
or __attribute__((aligned(16))). Specifies alignment of	1
or bottleneck, it is likely	1
or memory-intensive functions such as	1
or CString. This is safe	1
or "how many elements are	1
or removable media such as	1
or glitches in the output	1
or (5) make the overflow	1
or First-In-Last-Out access, sort and	1
or aliasing, but the compiler	1
or void. Returning objects of	1
or references: If the Intel	1
or /Fa for assembly output.	1
or Verilog. Common devices are	1
or sizes? It is possible	1
or iterative in nature, it	1
or malloc. Handles to windows,	1
or malloc) is necessarily accessed	1
or __restrict__, if supported by	1
or vice versa. But most	1
or C2, then we can	1
or .so). There is no	1
or YMM) which can be	1
or -fsource-asm). This option makes	1
or makefile. You can check	1
or __declspec(thread). Such variables have	1
or malloc/free should be avoided	1
it the first time. This	1
it is the responsibility of	1
it is the "best case"	1
it is the responsi- bility	1
it is a register variable.	1
it is a valid 63	1
it is a staircase function	1
it is to choose a	1
it is and interpreted line	1
it is on a PC	1
it is not the best	1
it is not in the	1
it is not in use.	1
it is not possible to	3
it is not accessed by	1
it is not necessary to	1
it is not advantageous to	2
it is not optimal to	1
it is not clear whether	1
it is not needed. Obviously,	1
it is not portable to	1
it is not necessary. A	1
it is not cached. See	1
it is not unusual for	1
it is not uncommon for	2
it is not human readable	1
it is an integer). All	1
it is more efficient to	3
it is more complicated to	1
it is more relevant to	1
it is only called once.	1
it is only calculated once,	1
it is used and this	1
it is used and popped	1
it is also likely to	1
it is also recommended to	1
it is also discussed which	1
it is possible to use	1
it is possible to make	1
it is possible to do	1
it is possible to get	1
it is possible to calculate	1
it is possible to replace	2
it is possible to give	1
it is possible to start	1
it is possible to implement	1
it is possible to obtain	1
it is possible to utilize	1
it is possible to construct	1
it is very important to	1
it is very likely that	1
it is very inefficient. Linear	1
it is long does not	1
it is faster to access	1
it is stored in memory,	1
it is stored on the	1
it is stored at a	1
it is called from only	1
it is called only from	1
it is less advantageous to	1
it is often possible to	1
it is often necessary to	1
it is even more important	1
it is sure to be	1
it is short in duration	1
it is available from www.agner.org/optimize/testp.zip.	1
it is important to have	1
it is important to make	1
it is important to do	1
it is important to consider	1
it is important to economize	1
it is important to focus	1
it is important to decide	1
it is important to remember	1
it is important to realize	1
it is accessed by several	1
it is accessed much faster.	1
it is accessed through a	1
it is accessed quite fast.	1
it is necessary to do	1
it is necessary to first	1
it is necessary to test	1
it is necessary to look	1
it is necessary to allocate	1
it is necessary to compromise	1
it is necessary to reload	1
it is necessary to query	1
it is necessary here to	1
it is much more efficient	1
it is small or if	1
it is good for the	2
it is done in connection	1
it is done only once.	1
it is inside a loop	1
it is advantageous to use	3
it is advantageous to do	1
it is advantageous to replace	1
it is advantageous to roll	1
it is known with certainty	1
it is known at compile-time	1
it is known which version	1
it is likely to be	1
it is likely that the	1
it is likely that memory	1
it is doing two iterations	1
it is certain that a	1
it is quite certain that	1
it is recommended to use	3
it is recommended to calculate	1
it is recommended to specify	1
it is recommended to wrap	1
it is recommended to place	1
it is optimal to use	1
it is optimal to inline	1
it is never used. Whenever	1
it is running on, while	1
it is running on. Replace	1
it is too late. You	1
it is difficult for the	1
it is usually faster to	1
it is relevant for the	1
it is intended to be	1
it is intended for. Some	1
it is inefficient to use	2
it is outside the critical	1
it is still the fastest	1
it is safe to use	1
it is clear that static	1
it is clear that p	1
it is possible. A compiler	1
it is true that some	1
it is initialized or comes	1
it is initialized only the	1
it is discussed which of	1
it is rarely necessary to	1
it is slightly more efficient	1
it is independent of the	1
it is executed. An example	1
it is almost certain that	1
it is preferred to use	1
it is poorly predictable then	1
it is hardly worth the	1
it is convenient to make	1
it is deallocated when the	1
it is safer to calculate	1
it is preferable to allocate	1
it is finished using the	1
it is run. Examples include	1
it is filled up, which	1
it is certainly more convenient	1
it is certainly something that	1
it is sufficient to have	1
it is sufficient to make	1
it is evicted before we	1
it is impossible to work	1
it is compiled. This is	1
it is worthwhile to invest	1
it is profitable to use	1
it is compiling. This prevents	1
it is correlated with preceding	1
it is advisable to make	1
it is unrealistic that you	1
it is servicing. A command	1
it is cached, but several	1
it is unlikely that the	1
it a pointer or reference	1
it a template: // Example	1
it to the exception handler	1
it to the tolerance may	1
it to a branch tree.	1
it to any other number.	1
it to signed before converting	1
it to do. It is	1
it to begin calculating a	1
it and create a new	1
it in the form of	1
it in a temporary variable	1
it in one operation rather	1
it in order to make	1
it for lists that are	1
it for improving the code.	1
it can be a good	1
it can be an advantage	1
it can be useful to	1
it can be useful in	1
it can be done as	1
it can be advantageous to	1
it can be implemented as	1
it can be difficult to	1
it can be predicted perfectly	1
it can be initialized to	1
it can be expected that	1
it can be said that	1
it can be represented as	1
it can be disabled in	1
it can not do. The	1
it can have no other	1
it can use the same	2
it can do another addition	1
it can also be used	1
it can call C1::f directly	1
it can take more than	1
it can often happen that	1
it can cause errors if	1
it can calculate each address	1
it can start a new	1
it can save cache space	1
it can happen that (b*c)	1
it can multiply by a	1
it can move out loop-invariant	1
it can move outside the	1
it can run. Some implementations	1
it can handle. Waiting for	1
it can overwrite the return	1
it by a table lookup:	1
it by 100 so that	1
it with the calculated value.	1
it with many decimals. It	1
it with 1: // Example	1
it with 2n -1. The	1
it as a subexpression. For	1
it may be a better	1
it may be more efficient	1
it may be possible to	1
it may be useful to	3
it may be necessary to	1
it may be quite a	1
it may be optimal to	1
it may be optimal in	1
it may be better to	2
it may be difficult to	2
it may be smaller as	1
it may be preferred to	1
it may be convenient to	1
it may be preferable to	1
it may be freed before	1
it may not be necessary	1
it may not be worth	1
it may take only 5	1
it may take 3 -	1
it may cause a loss	1
it may cause cache contentions.	1
it may go through multiple	1
it may detect the misprediction	1
it may involve the loading	1
it this by making i	1
it more clear to the	1
it will be compatible with	1
it will not be negative.	1
it will not have the	1
it will not use GOT	1
it will point to the	1
it will often take several	1
it will run the advanced	1
it will run an inferior	1
it will run faster than	1
it will generate a new	1
it will generate relocations in	1
it will still take 10	1
it will break at the	1
it will recognize that 10	1
it from a project built	1
it from making optimizations across	1
it from fully utilizing its	1
it at the diagonal. Each	1
it at compile time. Some	1
it has the disadvantage that	1
it has the correct child	1
it has to assume the	1
it has not been given	1
it has an instruction set	1
it has i instead of	1
it has many advanced optimizing	1
it has allocated with alloca,	1
it has been called before.	1
it has been deallocated. The	1
it has been deallocated. Failure	1
it has been brutally interrupted.	1
it has done by fetching,	1
it has calculated in advance	1
it has chosen the wrong	1
it has finished the calculations	1
it has finished the calculation	1
it has incomplete information about	1
it only once. Example: //	1
it point to the right	1
it used to be. The	1
it should be true. template<>	1
it should save one unit	1
it into multiple threads, but	1
it also makes the code	1
it possible to use the	1
it possible to use vector	1
it possible to do operations	1
it possible to compile for	1
it possible to store intermediate	1
it possible to see which	1
it possible to come from	1
it possible for the CPU	1
it takes to make a	1
it takes to make support	1
it takes to do two	1
it takes to do calculations	1
it takes to call the	1
it takes to call a	2
it takes to calculate the	3
it takes to add i	1
it takes to load the	1
it takes to start and	1
it takes to execute the	1
it takes to execute CriticalFunction	1
it takes to transpose a	1
it takes to install a	2
it takes to recover from	1
it takes to reload the	2
it takes to develop and	2
it takes to refresh the	1
it takes more time to	1
it takes only a few	1
it takes before the application	1
it takes too much space	1
it takes six times as	1
it takes 40% more time	1
it takes hours to install	1
it some heavy work to	1
it so that it can	1
it makes it possible to	1
it makes program development more	1
it makes no difference whether	1
it makes floating point code	1
it makes sure the variable	1
it makes dispatching on every	1
it makes sense to dispatch	1
it cannot be known at	1
it cannot be shared. You	1
it cannot access any non-static	1
it cannot inline the function	1
it cannot rule out aliasing	1
it less efficient. The performance	1
it often contains writeable data.	1
it often gives more reliable	1
it does not spend time	1
it does have some disadvantages	1
it does some funny things	1
it does not, and therefore	1
it does incredibly stupid things.	1
it must return to its	1
it work cannot be ignored	1
it Use a "move constructor"	1
it doesn't have the line	1
it doesn't have to save	1
it doesn't have to push	1
it doesn't need the 'this'	1
it doesn't need a 'this'	1
it doesn't work with member	1
it doesn't work well on	1
it doesn't generate any extra	1
it doesn't matter if the	1
it doesn't depend on system-specific	1
it doesn't occur. In the	1
it necessary to load several	1
it works well on non-Intel	1
it inside {} brackets. However,	1
it uses more clock cycles	1
it would be even faster	1
it would be obvious to	1
it count up to some	1
it was executed. It is	1
it was programmed. But if	1
it was programmed. Therefore, it	1
it was assigned previously in	1
it allows the compiler to	1
it allows larger floating point	1
it needs to load the	1
it needs to switch to	1
it needs to follow the	1
it needs an extra jump	1
it needs only calculate element	1
it becomes invalid as soon	1
it becomes full. This may	1
it requires the loading of	1
it requires that the background	1
it requires an extra register	1
it actually is. This above	1
it goes the other way.	1
it goes another way than	1
it goes automatically when the	1
it points to the selected	1
it points to is deleted	1
it points to. A const	1
it off and use alternative	1
it gives more reliable and	1
it comes to optimization, it	1
it comes before the compiler	1
it still uses a GOT.	1
it prevents the compiler from	1
it prevents the use of	1
it prevents certain optimizations. Do	1
it calls. The best performance	1
it calls. 48 Use macros	1
it rarely justifies the relatively	1
it easier for the compiler	2
it might be possible to	1
it might not be able	1
it checks which instruction set	1
it checks whether the original	1
it returns. But what if	1
it writes only, then the	1
it to. It is safer	1
it could free the memory	1
it involves the risk of	1
it involves allocation of memory	1
it involves pure function calls.	1
it had a different type	1
it is. It is important	1
it fits into a single	1
it follows a simple periodic	1
it defines electrical connections rather	1
it adds an extra level	1
it gets from the dispatcher	1
it jumps to. Example: //	1
it avoids the branch inside	1
it is, and is compiled	1
it is, but must go	1
it appears to be an	1
it opens the possibility for	1
it takes. The version that	1
it takes. Debugging. The profiler	1
it explicitly. In example 8.21,	1
it optimizes the code. Sometimes	1
it occurs, but this is	1
it occurs, (2) use unsigned	1
it allocates the required amount	1
it unusual that a user	1
it took several minutes to	1
it expects a GOT entry.	1
it locally in the thread	1
it increases the amount of	1
it handles eight elements at	1
it obviously takes time to	1
it decides whether to repeat	1
it attempts to set seconds	1
it sees a relative reference	1
it compares the array pointer	1
it exits. For example, if	1
it unwise to use it.	1
it uses. There are also	1
it fills up the loop	1
it twice. You can avoid	1
it lacks the self-explaining menus	1
it (&ArraySize) is taken. A	1
it feeds a branch into	1
it matters: Division by a	1
it says. A code that	1
it changes. A branch that	1
it understands only the simplest	1
it has. Assuming that processor	1
it supports. An inferior version	1
it directly. The reason for	1
function is a function that	3
function is a few clock	1
function is by a const	1
function is as fast as	1
function is not accessed by	1
function is not resolved when	1
function is not allowed to	1
function is not referenced from	1
function is time consuming because	1
function is also called from	1
function is also available in	1
function is so important and	1
function is faster than the	1
function is faster than a	1
function is called a leaf	1
function is called and the	1
function is called and how	2
function is called for the	1
function is called on an	1
function is called through a	1
function is less than the	1
function is always inlined even	1
function is available in the	1
function is compiled in multiple	1
function is big and is	1
function is small or if	1
function is advantageous if the	1
function is doing multiple logically	1
function is never called. This	1
function is never called. Unfortunately,	1
function is usually called before	1
function is usually inlined if	1
function is called. The values	1
function is called. This is	1
function is called. This has	1
function is called. If virtual	1
function is called. You may	1
function is called. I have	1
function is called. Example: //	1
function is called. Lazy binding	1
function is called. 118 12.7	1
function is replaced by the	1
function is intended for 32-bit	1
function is given in example	1
function is OS independent and	1
function is needed. Example: //	1
function is defined in a	2
function is pure if the	1
function is pure __attribute(( const))	1
function is called, a dispatch	1
function is called, it can	1
function is called, it allocates	1
function is called, while the	1
function is simpler than a	1
function is inlined. An alternative	1
function is big. The compiler	1
function is pure. Virtual functions	1
function is inserted in the	1
function is InstructionSet().The following example	1
function is 83 called faster	1
function is expanded like a	1
function a = CriticalFunction(b, c);	1
function a different name for	1
function a member of the	2
function a constructor for the	1
function of the loop index.	1
function of the Intel compiler.	1
function of the absolute value	1
function of a loop counter	2
function of i which can	1
function of 2 double Intel	1
function of 4 floats exp	1
function to be inlined by	1
function to be pure. This	1
function to use and returns	1
function to test // (time	1
function to work with any	1
function to measure the clock	1
function to transpose and copy	2
function to transpose matrix //	1
function to another. These costs	1
function and the function is	1
function and to optimize across	1
function and you want to	1
function and branch is executed.	1
function and these two functions	1
function and calculate it at	1
function and later deleted by	1
function and replaces the PLT	1
function in the main executable	1
function in a library other	1
function in a dynamic library	2
function in a shared object	1
function in a shared object,	1
function in a DLL goes	1
function in which the array	1
function in which they are	2
function in which alloca was	1
function in Intel function libraries	1
function in system code or	1
function in case of an	1
function in case F2 actually	1
function in terms of speed.	1
function in isolation have been	1
function for the next step.	1
function for the sake of	1
function for a particular purpose.	1
function for this purpose, or	1
function for different Intel CPUs.	1
function for each different value	1
function for register storage. The	1
function for CPUs with slow	1
function that is used only	1
function that is member of	1
function that is called from	1
function that is longer than	1
function that has no side-effects	1
function that I have supplied	1
function that does the same	1
function that calls at least	1
function that calls other functions	1
function that doesn't call any	2
function that doesn't add or	1
function that simply prints an	1
function that needs to call	1
function that needs them. Pure	1
function that reads or writes	1
function that allocates memory on	1
function that draws a whole	1
function that detects an error	1
function are stored on the	2
function are called global variables.	1
function are simply treated as	1
function can be calculated by	1
function can be turned into	1
function can be inlined. (In	1
function can use for recovering	1
function can modify x *const_cast<int*>(&x)	1
function can modify x, while	1
function can throw. In fact,	1
function // Function pointer initially	1
function // Call to virtual	1
function or in a separate	1
function or by turning the	1
function or class is responsible	1
function or class that is	1
function or class into an	1
function or class separately in	1
function or variable is accessed	1
function or variable having the	1
function or method should be	1
function or every code line.	1
function or operator that transfers	1
function or hot spot but	1
function or otherwise optimize across	1
function or friend function or	1
function if the inlining causes	1
function if it is small	1
function by inlining all the	2
function by adding throw() to	1
function with the same name.	1
function with the same arguments	1
function with a pointer or	1
function with a lookup table	1
function on a thousand numbers.	1
function on CPUs with a	1
function code is not copied	1
function as described below. The	1
function may be the one	1
function may be called from	1
function may return an error	1
function when the exponent is	2
function will be called, or	1
function will most likely be	1
function will return the result	1
function will wait until seconds	1
function } }; // Called	1
function then the dispatch branch	1
function from the library is	1
function from www.agner.org/optimize/asmlib.zip. // Example	1
function at runtime. Polymorphism is	1
function has only a limited	1
function has only one instance.	1
function because the compiler knows	1
function because the stack unwinding	1
function because it doesn't need	2
function because this may improve	1
function which in turn calls	1
function which then calls a	1
function which we assume is	1
function which cannot be inlined	1
function which returns a reference	1
function which transposes a quadratic	1
function but outside the innermost	1
function should also be considered.	1
function should preferably be a	1
function should never use static	1
function should never return any	1
function using assembly language. See	1
function pointer is the same	1
function pointer is simply the	1
function pointer a = (*CriticalFunction)(b,	1
function pointer to the best	1
function pointer to the right	1
function pointer and makes it	1
function pointer if else if	1
function pointer has changed then	1
function pointer has changed. 7.8	1
function pointer which initially points	1
function pointer typically takes a	1
function pointer points to. Therefore,	1
function pointer follows a simple	1
function into a leaf function	1
function into multiple smaller functions	1
function library and the vector	1
function library and you cannot	1
function library for a few	1
function library that has a	1
function library that takes care	1
function library that works well	1
function library or a separate	1
function library with a different	1
function library with a well-defined	1
function library with CPU dispatching.	1
function library then make sure	1
function library at www.agner.org/optimize/asmlib.zip. The	1
function library at www.agner.org/optimize/asmlib.zip contains	1
function library made for demonstration	1
function library asmlib, which is	1
function also has something to	1
function such as ReadB needs	1
function In some cases, there	1
function where you want vectorization	1
function many times with a	1
function version // Get supported	1
function version CriticalFunctionType * CriticalFunction	1
function we want to measure	1
function so that it is	1
function return a pointer or	1
function return addresses (i.e. where	1
function return value. The copy	1
function cannot be called from	1
function cannot access any non-static	1
function cannot rely on anything	1
function cannot modify data members.	1
function called only from same	2
function address in the procedure	1
function call is translated to	1
function call to a graphics	1
function call to count how	1
function call if it is	1
function call by the body	1
function call with a table	1
function call so that you	1
function call makes the microprocessor	1
function call inline void SelectAddMul(short	1
function call statement always calls	1
function call statement occupies a	1
function call (other than log)	1
function libraries is more difficult.	1
function libraries and drivers differ	1
function libraries and compiler-generated code	1
function libraries in this format.	1
function libraries for many standard	1
function libraries for computing mathematical	1
function libraries that are used	1
function libraries that are intended	1
function libraries are not fully	1
function libraries are useful for	1
function libraries are available in	1
function libraries are discussed below.	1
function libraries are highly optimized	1
function libraries are highly optimized,	1
function libraries with internal multi-threading,	1
function libraries have CPU dispatching	1
function libraries have features for	1
function libraries do not use	1
function libraries available use excessive	1
function libraries Some applications spend	1
function libraries available. The most	1
function libraries distributed as object	1
function libraries Test Processor memcpy	1
function libraries published by Intel	1
function template because partial template	1
function pointers if there are	2
function pointers It is rarely	1
function they are used in	1
function type and its parameters.	1
function type with desired parameters	1
function type typedef void FuncType(short	1
function does not throw exceptions	1
function must then check for	1
function must check if it	1
function calls is the same	1
function calls to check for	1
function calls and it can	1
function calls and it needs	1
function calls in the most	1
function calls in the critical	2
function calls in the innermost	1
function calls are saved in	1
function calls can be mispredicted	1
function calls may run slightly	1
function calls more efficient. The	1
function calls because the CPU	1
function calls faster and makes	1
function calls faster in 32-bit	1
function calls another dispatched function	1
function through a function pointer	1
function through a pointer or	1
function through function pointer a	1
function uses by looking at	1
function uses logarithms in the	1
function parameters to be transferred	1
function parameters are transferred on	1
function parameters because of alignment	1
function was called from), function	1
function name is not allowed	1
function name ; start of	1
function name depending on instruction	1
function name Instruction set Prefetch	1
function name ;startofFunc ; a	1
function parameter is that the	1
function parameter and a template	1
function means that it cannot	1
function instead of a macro.	1
function dispatch mechanism is rarely	1
function dispatch process. This can	1
function calling more efficient in	1
function calling method in 32-bit	1
function calling conventions are different.	1
function calling conventions. FreeBSD and	1
function goes in the //	1
function feature is used in	1
function just because it is	1
function #define MAX(a,b) (a >	1
function go to the desired	1
function relative to the beginning	1
function inlining is that the	1
function inlining is done at	1
function inlining and constant propagation	1
function inlining are: The overhead	1
function #pragma optimize(...) Fastcall function	1
function calls. The Gnu compiler	1
function calls. The calculation of	1
function calls. The principle of	1
function calls. The consequence of	1
function calls. It is recommended	1
function calls. If the bottleneck	1
function calls. There are three	1
function calls. Example: // Example	1
function calls. Unfortunately, the compiler	1
function calls. Internal references to	1
function library. The radical solution	1
function library. If the application	1
function library. 78 Therefore, it	1
function libraries. C++ is an	1
function libraries. Use Gnu or	1
function libraries. Several special purpose	1
function libraries. Numbers in the	1
function names and code addresses.	1
function names and variable names	1
function names and variable names.	1
function names in the SVML	1
function names are not compatible	1
function directly if the target	1
function modify an existing object	1
function F1 is supposed to	1
function returns. The next time	1
function returns. The preferred method	1
function returns. This is because	1
function returns. There is no	1
function returns. Make the function	1
function returns. Alternatively, you may	1
function returns. alloca may not	1
function returns. Global or static	1
function returns. Every time a	1
function writes to matrix a	1
function stores the thousand results	1
function stores a double without	1
function could be a member	1
function parameter. But it may	1
function body inside the class	1
function call. Load library at	1
function call. Algebraic reduction Most	1
function call. (2) find the	1
function __fastcall __attribute(( fastcall)) __fastcall	1
function names. But a highly	1
function 250 times with four	1
function library, but this is	1
function adds the elements of	1
function returns even though it	1
function _mm256_zeroupper() before any transition	1
function opens a file in	1
function parameters, local variables, and	1
function parameters, pointers, references, 'this'	1
function libraries, but who would	1
function parameter, or as a	1
function looks like this: //	1
function scans a string of	1
function definition. This tells the	1
function longjmp is used for	1
function ReadTSC listed below in	1
function F2 that can possibly	1
function argument to be an	1
function implicitly when copying a	1
function Size of each table	1
function inline. This may enable	1
function inline. Replacing a function	1
function ten times and stores	1
function construct an object with	1
function prototype to tell the	1
function declaration. This is the	1
function decides which function to	1
function swapd(a[r][c], a[c][r]); void test	1
function body. A function is	1
function libraries........................................................................................ 12 2.7 Choice	1
function local: 1. Add the	1
function __intel_cpu_features_init_x() does the same	1
function calls, if there are	1
function inlining, common subexpression elimination,	1
function prototype: void F1() throw();	1
function billions of times before	1
function rounds a floating point	1
function F1. However, if F1	1
function add_horizontal) static inline float	1
function prototypes for each version	1
function bodies above, it is	1
function (n!) as an example.	1
function __intel_cpu_features_init() sets the variable	1
function vectorized: void SelectAddMul(short int	1
function inlining. Reducible expressions also	1
function tables. The static data	1
function scanf. Violation of array	1
function calling. __fastcall or __attribute__((fastcall)).	1
if the function is small	1
if the function is defined	1
if the function is inlined.	1
if the function has only	1
if the code is fragmented	1
if the code is indeed	1
if the code is repetitive.	1
if the code can be	1
if the code contains natural	1
if the code involves multiplication	1
if the compiler does what	1
if the compiler doesn't know	1
if the time slices allocated	1
if the data are stored	2
if the data are aligned	1
if the data fit nicely	1
if the program is never	1
if the program is actually	1
if the program uses a	1
if the program uses more	1
if the program had read	1
if the program runs satisfactorily	1
if the same operation is	1
if the CPU clock frequency	1
if the loop is long	1
if the loop is inside	1
if the loop counter is	1
if the loop count is	2
if the loop control branch	1
if the loop body is	1
if the integer is signed,	1
if the class of the	1
if the most time-consuming part	1
if the size is a	1
if the size of a	1
if the size of program	1
if the size parameter is	2
if the library is very	1
if the object is treated	1
if the object can be	1
if the object doesn't need	1
if the number of elements	2
if the number of threads	1
if the number of iterations	1
if the array or container	1
if the array element is	1
if the clock frequency is	1
if the value of the	3
if the value of A	1
if the value of b	1
if the objects are accessed	1
if the objects stored are	1
if the variable is only	1
if the table is cached.	1
if the software contains a	1
if the branch is poorly	1
if the member function is	1
if the elements are accessed	1
if the elements matrix[r][c] below	1
if the address can be	1
if the critical part of	1
if the critical innermost loop	1
if the first operand of	1
if the first operand determines	1
if the template parameters are	1
if the new version causes	1
if the user has a	1
if the user has to	1
if the user never uses	1
if the SSE2 instruction set	2
if the following conditions are	1
if the type T is	1
if the case labels follow	1
if the constant is a	1
if the processor is not	1
if the processor is compatible	1
if the processor has hyperthreading.	1
if the threads are competing	1
if the threads use different	1
if the threads write to	1
if the threads share the	1
if the necessary library files	1
if the AVX instruction set	1
if the AVX 32 instruction	1
if the calculation time is	1
if the uses of a	1
if the problem is likely	1
if the list is large	1
if the inline keyword is	1
if the branches are poorly	1
if the application can make	1
if the application has a	1
if the expression contains a	1
if the conversion to signed	1
if the parameter has a	1
if the source is an	1
if the cost of this	1
if the programmer has defined	1
if the results are combined	1
if the operands are variables	1
if the operands are comparisons,	1
if the operands have other	1
if the index is out	1
if the inlining causes technical	1
if the network is unstable	1
if the network or database	1
if the constants Sunday, Monday,	1
if the destructor causes another	1
if the repeat count is	2
if the offset of the	1
if the full generality and	1
if the RAM size is	1
if the rows are accessed	1
if the rows are indexed	1
if the handle is invalid.	1
if the target address can	1
if the target pointed to	1
if the subexpression c+b can	1
if the condition is known	1
if the condition can be	1
if the SSE4.1 instruction set	1
if the sequence of calculations	1
if the length of the	1
if the current version satisfies	1
if the typical repeat count	1
if the prediction turns out	1
if the inputs have any	1
if the changes of the	1
if the dispatched function is	1
if the 7 program can	1
if the bottleneck is file	1
if the image base is	1
if the distance between rows	1
if the dividend is unsigned	1
if the dividend is unsigned.	1
if the goal of 18	1
if the unsafe code is	1
if the time-critical part of	1
if the evaluation of the	1
if the bias of the	1
if is resolved at runtime.	1
if a is true. The	1
if a is false. Likewise,	1
if a and b are	1
if a and b have	2
if a and b take	1
if a program has two	1
if a program has many	1
if a program creates or	1
if a loop repeats a	1
if a floating point number	1
if a simple algorithm can	1
if a large fraction of	1
if a thread jumps between	1
if a matrix is so	1
if a certain modification is	1
if a was zero or	1
if a lot of data	1
if a high degree of	1
if a parameter is part	1
if a piece of software	1
if a reasonable estimate can	1
if and compile-time while loops,	1
if it is a register	1
if it is a valid	1
if it is not in	1
if it is not necessary.	1
if it is not cached.	1
if it is an integer).	1
if it is only called	1
if it is possible to	1
if it is stored in	1
if it is stored at	1
if it is called from	1
if it is called only	1
if it is short in	1
if it is accessed by	1
if it is small or	1
if it is good for	2
if it is done in	1
if it is inside a	1
if it is known with	1
if it is known which	1
if it is certain that	1
if it is independent of	1
if it is correlated with	1
if it is cached, but	1
if it can save cache	1
if it has the correct	1
if it has an instruction	1
if it has been called	1
if it has incomplete information	1
if it cannot be known	1
if it involves allocation of	1
if it had a different	1
if it is. It is	1
if it follows a simple	1
if it opens the possibility	1
if an int uses more	1
if an array index is	1
if an exception occurs in	1
if an exception occurs somewhere	1
if an overflow or another	1
if you are not sure	1
if you are using functions	1
if you are sure the	1
if you are sure that	2
if you are sure you	1
if you are making programs	1
if you are doing a	1
if you are satisfied with	1
if you can use a	1
if you can take advantage	1
if you can avoid it.	1
if you have big data	1
if you have big arrays	1
if you cannot find the	1
if you take into account	1
if you want to make	1
if you want to call	1
if you want to optimize	1
if you want to see	1
if you want to flip	1
if you avoid the large	1
if you write a 64-bit	1
if you don't want this	1
if you don't understand it.	1
if you look at the	1
if you change pre-increment to	1
if you expect the table	1
if you had used intrinsic	1
if you declare an int,	1
if you follow the guidelines	1
if you forget to delete	1
if this is possible in	1
if this is obvious, then	1
if this can eliminate branches,	1
if this prevents a faster	1
if this appears to be	1
if time intervals are short.	1
if memory access is a	1
if data are scattered randomly	1
if data access can be	1
if different versions have to	1
if because #if is resolved	1
if functions that are used	1
if functions have more than	1
if only you make sure	1
if other nearby parts of	1
if instruction sets are mutually	1
if all the additions are	1
if all the inputs to	1
if all the factors are	1
if all of the following	1
if all functions called by	1
if all bits except the	1
if one is 0 and	1
if no other threads have	1
if no other modules call	1
if no exception ever happens.	1
if each bit of a	1
if each addition depends on	1
if pointer arithmetic calculations go	1
if b is an integer	1
if b is an expression	2
if b and c are	1
if i < 100. pop	1
if multiple threads are sharing	1
if multiple threads can add,	1
if static linking is used.	1
if there is a pointer	1
if there is a try	1
if there is more than	1
if there is only one	1
if there is other work	1
if there is no graphics	1
if there is no risk	2
if there is no loop-carried	1
if there is something that	1
if there is nothing to	1
if there are no copy	1
if there are many function	1
if there are many functions	1
if there are many allocations	1
if there are many branches):	2
if there are specific advantages	1
if there are allocated resources	1
if there are wrapper classes	1
if such a response is	1
if such dependency chains can	1
if possible and by changing	1
if any of the bits	1
if any objects declared in	1
if we use hexadecimal numbers	1
if we want to read	1
if we want to generate	1
if we change the order	1
if we specify the options	1
if branch is eliminated. Loop	1
if branch in example 15.1b	1
if elements have a natural	1
if elements have no specific	1
if unsigned The same rules	1
if unsigned // Faster if	2
if unsigned You can take	1
if pointers are type-casted to	1
if they are often mispredicted.	1
if they are sure to	1
if they are members of	1
if they are never used	1
if they are predicted most	1
if they are uninitialized or	1
if they are uninitialized, if	1
if they don't need any	1
if they come from operators	1
if they otherwise would be	1
if SSE2 is available: //	1
if out of range }	1
if dynamic linking is used,	1
if I write that something	1
if its address is taken,	1
if its body is defined	1
if speed is important. Some	1
if c < 0. The	1
if a, b, c and	1
if AVX is supported by	1
if implemented on other platforms	1
if (i < 0 ||	1
if (i < ARRAYSIZE &&	1
if (i >= min &&	1
if (i >= N) {	1
if (i % 2 ==	1
if supported by the CPU	1
if supported by the compiler.	1
if certain options are set	1
if certain conditions are satisfied.	1
if intermediate calculations can cause	1
if above doesn't work //	1
if above line doesn't work	1
if both are negative or	1
if both positive } Example	1
if else if else if	1
if else if else {	1
if else { (iset >=	1
if their live-ranges do not	1
if your optimization effort is	1
if your modifications actually increase	1
if XMM registers are supported	1
if XMM registers are used.	1
if statement and all the	1
if statement in this example	1
if level-2 cache contentions will	1
if possible. The AVX instructions	1
if possible. This also makes	1
if possible. See page 141.	1
if possible. SSE2 is always	1
if possible. Use inline functions	1
if possible. Don't rely on	1
if possible. Smaller microprocessors have	1
if true ; unused label	1
if N is a power	1
if condition can be calculated	1
if statements (called static if),	1
if F1 has saved all	1
if F1 calls another function	1
if alternative implementations are less	1
if organized as follows: //	1
if available. See page 81	1
if required for performance reasons.	1
if (b) { a =	4
if (b) { return a	1
if (b) { y =	2
if exceptions can be ruled	1
if (a * c >	1
if (a > b /	1
if (a == 0) {	1
if (a != 0) {	1
if possible, and make sure	1
if possible, and avoid dynamic	1
if possible, and replaced by	1
if possible, or the error	1
if possible, so that the	1
if portability is important. This	1
if protection against overflow is	1
if ((unsigned int)i < 10)	1
if ((unsigned int)i >= (unsigned	1
if ((unsigned int)n < 4)	1
if ((unsigned int)n < 13)	1
if ((unsigned int)(i - min)	1
if nonzero and normal unsigned	1
if nonzero u.i += n	1
if pieces of data that	1
if b[i] and c[i] are	1
if divisor is a power	2
if (u.i * 2 >	1
if (u.i & 0x7FFFFFFF) {	2
if (u.i > v.i) {	1
if powN is // erroneously	1
if unsigned. This typically takes	1
if (n & 1) y	1
if (n > 0) {	1
if (b == 0) {	1
if (b != 0) {	1
if (level >= 4) {	2
if (level >= 11) {	2
if necessary, to fit the	1
if necessary, by using the	1
if necessary, each compiled for	1
if (Day & (Tuesday |	1
if (Day == Tuesday ||	1
if (y) { int a[1000];	1
if (y) { F1(a); }	1
if appropriate. 8. Avoid branches	1
if any, is usually called	1
if any, must be called	1
if (handle != INVALID_HANDLE_VALUE &&	1
if (true) { a =	1
if (absvalue > largest_abs) {	1
if (u.i[1] < 0) {	1
if (SIZE > 256 &&	1
if our estimate is correct	1
by the function body. A	1
by the code inside square:	1
by the compiler to the	1
by the compiler in the	1
by the compiler you will	1
by the compiler have been	1
by the use of two	1
by the use of assembly	1
by the use of <<	1
by the memory page size	1
by the program logic. Some	1
by the vector size for	1
by the vector size then	1
by the vector size (16	1
by the same constant. Example:	1
by the CPU and the	2
by the loop control branch.	1
by the cache line size	1
by the cache line size,	1
by the floating point code	1
by the size of the	2
by the size (in bytes)	1
by the Intel and PathScale	1
by the number of elements	1
by the number of times	1
by the clock period and	1
by the value 1000. The	1
by the branch prediction mechanism.	1
by the critical code so	1
by the operating system which	1
by the operating system rather	1
by the operating system. It	1
by the operating system, not	1
by the test program is	1
by the following example: //	1
by the Gnu utilities in	1
by the processor and the	1
by the calculated result. Example:	1
by the program. The advantage	1
by the microprocessor and the	1
by the application program. The	1
by the methods described on	1
by the constructor itself. Constructors	1
by the compiler. We can	1
by the compiler. On the	1
by the unroll factor. If	1
by the unroll factor. For	1
by the unroll factor. Loop	1
by the processing power. Connecting	1
by the heap manager for	1
by the program, and one	1
by the program, one for	1
by the compiler, you will	1
by the user. Feature bloat.	1
by the Gnu, Clang, Intel,	1
by the body of the	1
by the linker to a	1
by the linker and the	1
by the throughput of the	1
by the requirements of the	1
by the requirements of compatibility	1
by the rest of the	1
by the latency of the	1
by the latency or by	1
by the 107 number of	1
by the loader to a	1
by the programmer. 79 Floating	1
by the caller through a	1
by the formula: (set) =	1
by the application, while dynamic	1
by the series: ex xn	1
by is (columns * sizeof(float))	1
by a float variable. Example:	1
by a multiple of the	2
by a variable because optimizing	1
by a variable until the	1
by a table with two	1
by a table lookup. For	1
by a table lookup: //	2
by a const reference. A	1
by a system call (e.g.	1
by a constant is faster	6
by a constant can be	1
by a constant with a	1
by a constant should be	1
by a single & operation,	1
by a single comparison: //	1
by a power of 2	3
by a list should preferably	1
by a second induction variable	1
by a shift operation which	1
by a variable. Make sure	1
by a factor of 1,	1
by a factor 4 in	1
by a macro, but the	1
by a blend instruction if	1
by a key? If the	1
by a conditional move, depending	1
by a plain old data	1
by a unique key. Do	1
by a constant: Unsigned is	1
by // Example 8.5b a	1
by // Example 14.15b if	1
by // Example 8.2b a	1
by // Example 8.3b a	1
by // Example 8.6b int	1
by // Example 8.8b double	1
by not using position-independent code	1
by - reciprocal n.a. -	1
by an induction variable because	1
by an induction variable. The	1
by an executable file stub.	1
by an interrupt should preferably	1
by an EMMS instruction before	1
by compiler There are several	1
by compiler ....................................................................... 77 8.4	1
by more than 33% when	1
by more efficient container class	1
by memory access. The execution	1
by at least the cache	1
by vector size. Unpredictable branches	1
by only 50% or less	1
by CPU Modern CPUs can	1
by CPU brand. The version	1
by other constants because it	1
by all other processes running	1
by all means avoid powers	1
by all modern CPUs. The	1
by one function and later	1
by one makes the code	1
by cache line size //	1
by each thread. Pointers to	1
by most CPUs and operating	1
by using the keyword __restrict	1
by using the keyword far	1
by using the keyword __thread	1
by using the | operator	1
by using the so-called time	1
by using the so-called intrinsic	1
by using the bitwise OR	1
by using the declaration "static"	1
by using the smallest integer	1
by using the directive __declspec(cpu_dispatch(...)).	1
by using a compiler that	1
by using a different function	1
by using a 64-bit integer	1
by using a constant divisor	1
by using a particular code	1
by using a lookup table:	1
by using a shift operation.	1
by using a pipeline where	1
by using function inlining, common	1
by using an inline function	1
by using vector operations when	1
by using different types of	1
by using only the even-numbered	1
by using one or more	1
by using static linking and	1
by using short int instead	1
by using assembly language because	1
by using intrinsic functions or	1
by using vectors if the	1
by using references instead of	1
by using nontemporal writes. If	1
by using rounding instead of	1
by using indexes, working with	1
by using memset: // Example	1
by Intel have similar CPU	1
by Intel but is currently	1
by multiple threads should rely	1
by multiple threads Parallelization by	1
by two and making an	1
by two then there is	1
by two gives: // Example	1
by many users in many	1
by value in most cases.	1
by any of these methods	1
by any other form of	1
by any other modules. This	2
by some very good compilers	1
by some formula into a	1
by 2 in example 14.28	1
by 2 ; add what	1
by 2 (See page 137).	1
by 4 float a[100]; float	1
by 4 ; mangled function	1
by 8 in order to	1
by 8 rather than by	1
by template template <typename T>	1
by pointers or references. It	1
by 16 is required. The	1
by 16 to fit the	1
by 16 for SSE2, preferably	1
by 16 float Exp(float x)	1
by 16 (see below). The	1
by 16 __declspec( align(16)) __attribute((	1
by 32 and the 512-bit	1
by constant = shift and	1
by constant = multiply and	1
by constant = multiply by	2
by making the code size	1
by making the data more	1
by making the most critical	1
by making the constant single	1
by making the full declaration	1
by making a and b	1
by making a common denominator:	1
by making an additional floating	1
by making i an unsigned	1
by making objects inside the	1
by making critical functions inline	1
by making sure that functions	1
by making another function with	1
by making longer time slices.	1
by making them static if	1
by its value at compile	1
by calls to memset and	1
by element 0 in this	1
by several different functions and	1
by exception handlers for cleaning	1
by line when it is	1
by another function and these	1
by another thread void DelayFiveSeconds()	1
by another thread. This prevents	1
by another thread. If seconds	1
by eight to fit the	4
by doing the heavy background	1
by optimizing the first algorithm	1
by optimizing database access. 3.10	1
by both the CPU and	1
by preferably using powers of	1
by their address and attempts	1
by their values before compilation.	1
by their index or key	1
by their actual values before	1
by n and reorganize the	1
by n additions and no	1
by better standardization of programming	1
by means of #include directives	1
by means of #include directives.	1
by calling the intrinsic function	1
by calling vector::reserve with a	1
by calling WritePrivateProfileString, which opens	1
by piece in a function	1
by r is re-loaded from	1
by storage on the stack	1
by my comments, in green.	1
by columns in this case	1
by p is identical to	1
by consecutive indices or by	1
by inlining the frame function	1
by inlining the latter function,	1
by inlining all the functions	2
by 2. The compiler has	1
by 2. The instruction add	1
by 2. (See page 71).	1
by including the library libmmt.lib	1
by checking if b[i] and	1
by testing and analyzing program	1
by testing all bits except	1
by 100 so that it	1
by copying the code that	1
by copying the return statement:	1
by copying the entire list	1
by copying all data members.	1
by copying them into a	1
by adding the length of	1
by adding a constant to	2
by adding an integer counter	1
by adding one more integer	1
by adding n to the	1
by adding throw() to the	1
by compiling the module with,	1
by compiling in two steps.	1
by unrolling the loop and	1
by unrolling the loop in	1
by F1 also have an	1
by setting the sign bit	1
by setting the fraction bits:	1
by setting a thread affinity	1
by setting pointers to zero	1
by setting these variables to	1
by default in 64-bit mode.	1
by default unless there is	1
by default anyway in 64-bit	1
by *p or p->member is	1
by Microsoft, Intel, PathScale and	1
by OpenMP directives 32 bit	1
by multiplying with the reciprocal:	1
by random events that are	1
by executing instructions out of	1
by storing the elements consecutively	1
by storing intermediate results as	1
by 16. This is a	1
by 16. In example 12.1a,	1
by 16. You can generally	1
by 16. Library versions tested	1
by 16. Alignment of data	1
by giving it some heavy	1
by Agner Fog. Public distribution	1
by Agner Fog The present	1
by specifying the type and	1
by comparing bits 32-62. This	1
by comparing them as integers:	1
by avoiding the virtual function	1
by avoiding pointer arithmetics and	1
by avoiding any public variables.	1
by type-casting i to unsigned	1
by type-casting its 'this' pointer	1
by type-casting its address: //	1
by physical factors. The way	1
by unacceptably long response times,	1
by increasing the thread priority	1
by 16, i.e. stored at	2
by 8. The size should	1
by 8. The number of	1
by 8. There are also	1
by 8. 71 The compilers	1
by itself. But a solution	1
by turning the frame function	1
by turning off the exception	1
by turning off the position-independent	1
by one, into an STL	1
by declaring the function body	1
by declaring the table inside	1
by declaring it inside {}	1
by defining a container class	1
by defining _mm_malloc and _mm_free.	1
by choosing the best algorithm	1
by choosing a programming language	1
by modifications of the source	1
by transferring 'this' in a	1
by default, which makes it	1
by default, so 1.2 in	1
by default, even when shared	1
by default, conform to the	1
by 2n by adding n	1
by 2n by subtracting n	1
by individual installation tools. Automatic	1
by unit-testing is unfortunately very	1
by me manually, but if	1
by changing the dividend to	1
by changing this to: //	1
by considerations such as price,	1
by reordering the data members.	1
by well-tested container classes. The	1
by step. In most systems,	1
by 64, but the alignment	1
by bypassing the so-called CPU-dispatcher	1
by F2 and call the	1
by organizing the data as	1
by measuring the time it	1
by returning a null reference.	1
by joining the operations: //	1
by joining a and b	1
by joining identical pieces of	1
by modifying only half of	1
by four, we will have	1
by rolling out the loop	2
by invoking the compiler from	1
by putting the smallest members	1
by TILESIZE // Loop r1	1
by S. Goedecker and A.	1
by __fastcall. The implicit 'this'	1
by looking at a link	1
by default. This is less	1
by default. Position-independent code is	1
by consistent modularity and reusable	1
by performing an illegal operation	1
by extending the sign-bit if	1
by extending with zero-bits if	1
by subtracting n from the	1
by 3, 5 and 9.	1
by replacing a function call	1
by replacing an integer variable	1
by removing the call to	1
by assigning a new physical	1
by writing: 103 // Example	1
by writing: __declspec(align(64)) int BigArray[1024];	1
by ignoring the higher bits.	1
by (partial) template specialization. This	1
by x<<3, which is faster.	1
by assignment, as a function	1
by assignment. shared_ptr allows multiple	1
by u[0]. 14.10 Mathematical functions	1
by requesting a map file	1
by emulating the so-called Java	1
by controlling the order in	1
by inverting the sign bit:	1
by initializing pointers to zero,	1
by dropping the graphical user	1
by keys within a limited	1
by commas. There should be	1
by hand and insert the	1
by constructing the object on	1
by wrapping the vectors into	1
by summing up the factors	1
by selecting optimize performance for	1
by fetching, decoding and perhaps	1
by causing return addresses to	1
by XOR'ing it with 1:	1
by semicolons, while multiple statements	1
by AND'ing it with 2n	1
by CPU.............................................................................81 8.5 Compiler optimization	1
by xx-xx--x- reciprocal Boolean algebra	1
by allowing two data members	1
by 5-10% for some CPU-intensive	1
by thousands of people. I	1
with the function ReadTSC listed	1
with the time it takes	1
with the time stamp counter	1
with the use of integer	1
with the use of Intel	1
with the same precision as	1
with the same source code.	1
with the same priority is	1
with the same priority than	1
with the same name. In	1
with the same arguments are	1
with the same template. 57	1
with the same divisor. In	1
with the functions malloc and	1
with the functions lrintf and	1
with the other compilers). The	1
with the double precision constant	1
with the Intel C++ compiler.	1
with the pointer it gets	1
with the static modifier will	1
with the static keyword, for	1
with the C++ language relates	1
with the value 0 for	1
with the performance of this	1
with the way a profiler	1
with the operating system or	1
with the & operator; and	1
with the constant 2.5, which	1
with the Gnu compiler for	1
with the Gnu compiler. Not	1
with the best compiler and	1
with the option -fpic according	1
with the option -fno-pic and	1
with the option -fpie instead	1
with the option -mveclibabi=acml. Agner's	1
with the option -ftrapv, but	1
with the option -read_only_relocs suppress.	1
with the option -mveclibabi=svml. This	1
with the calculated value. The	1
with the four R value	1
with the operators new and	1
with the sign bit of	1
with the problems of the	1
with the last index changing	1
with the appropriate instruction set	1
with the SSE and SSE2	1
with the loops if the	1
with the compiler, and the	1
with the beginning of a	1
with the current instruction set.	1
with the Gnu, Clang and	1
with the Borland C++ builder.	1
with the expected real-time speed.	1
with the application. The availability	1
with the ^ operator. The	1
with the requirements of optimizing	1
with the ever bigger software	1
with the bit-mask: c2 =	1
with the highest instruction set	1
with the resolution of the	1
with the correct result because	1
with the AVX-512 instruction set	1
with the inverted bit-mask: bc	1
with the inverted mask. The	1
with the LLVM is a	1
with the sizeof operator. The	1
with the rightmost 1-bit removed.	1
with the reciprocal: // Example	1
with a different compiler by	1
with a different compiler. Object	1
with a pointer or reference	1
with a table lookup if	1
with a very large number	1
with a very low repeat	1
with a 32-bit (signed) address.	1
with a branch inside the	1
with a 64 64 matrix	1
with a & b if	1
with a simple index. A	1
with a constant (see page	1
with a single call to	1
with a small and fixed	1
with a line size of	2
with a well optimized software	1
with a lot of added	1
with a high repeat count	1
with a better version of	1
with a lookup table is	1
with a | b if	1
with a graphics coprocessor or	1
with a higher instruction set.	1
with a higher number is	1
with a relative difference less	1
with a profiler which determines	1
with a slow bit scan	1
with a slow CPU, an	1
with a special trick which	1
with a shift operation, which	1
with a destructor that makes	1
with a total offset bigger	1
with a square brackets index,	1
with a little more syntax	1
with a default constructor that	1
with a fully compiled code.	1
with a prediction or estimate	1
with a suitable set of	1
with a suitable choice of	1
with a constant. The compilers	1
with a remote database, and	1
with a realistic set of	2
with a well-defined interface to	1
with a well-defined functionality and	1
with a combination of additions	1
with a micro-op cache (e.g.	1
with a debugger. You may	1
with a decimal point in	1
with a top-of-stack index. Are	1
with a wealth of advanced	1
with a 50-50 chance of	1
with a password. The log	1
with a lineage of software	1
with a non-recursing template specialization,	1
with and without AVX using	1
with and without AVX support.	1
with in a particular CPU	1
with in assembly language. Here	1
with that branch. The common	1
with or without the sign	1
with code compiled without AVX,	1
with an error code which	1
with an inline assembly instruction	1
with an intermediate code and	1
with an Intel, AMD or	1
with an index of memory	1
with an offset that is	1
with an example. My example	1
with an extended number of	1
with this code is that	1
with this instruction set?". A	1
with this problem: 1. Relocation.	1
with this rule. Splitting up	1
with this mask, and bb[i]*cc[i]	1
with more RAM than end	1
with more heuristic guidelines. Most	1
with memory access. 12 Using	1
with vector integer operations, and	1
with vector operations when alignment	1
with vector classes Agner's vector	1
with vector parameters Vec4f polynomial	1
with vector access. 12.9 Aligning	1
with vector operands: minimum, maximum,	1
with different set values then	1
with different compilers then it	1
with different versions of the	1
with different matrix sizes. The	1
with different compilers. Dispatch at	1
with different brands of CPUs,	1
with different strides. Therefore, you	1
with different priorities then the	1
with only the SSE2 instruction	1
with only one CPU core,	1
with only one logical processor	1
with only four multiplications. How	1
with CPU dispatching. Add to	1
with CPU dispatching, then it	1
with other compilers or function	1
with other compilers at the	1
with other objects on the	1
with other calculations to save	1
with other compilers. This includes	1
with other local variables and	1
with other microprocessors. Many of	1
with other subtasks is necessary.	1
with all the relevant optimization	1
with all the R values	1
with all CPUs that support	1
with all compilers. Use automatic	1
with all x86 platforms. This	1
with all x86 platforms. Works	1
with all relevant optimization options	3
with all 0's gives zero.	1
with all 1's is unchanged,	1
with integer parameters. Floating point	1
with floating point code. If	1
with floating point multiplication, to	1
with floating point numbers: //	1
with each their smart pointer	1
with each instance of the	1
with compilers and development tools.	1
with most modern C++ compilers.	1
with most distributions of Linux,	1
with Intel C++ compiler, which	1
with Intel processors. A non-Intel	1
with multiple memory blocks makes	1
with multiple CPU cores is	1
with multiple CPUs or a	1
with multiple overloaded operators will	1
with multiple cores are advantageous	1
with multiple cores. 3.15 Dependency	1
with multiple counters, as in	1
with two decimals, for example,	1
with two entries. This may	1
with many of the same	1
with many function calls may	1
with many function calls. If	1
with many different factors as	1
with many such programs installed	1
with many branches and function	1
with many Boolean expressions. Whether	1
with many instances makes the	1
with many features, but also	1
with many labels that have	1
with many decimals. It is	1
with any function or variable	1
with any type of parameters	1
with some of the best	1
with some changes for each	1
with some legacy software. It	1
with long double precision. Conversions	1
with long latencies. 8.5 Compiler	1
with branch // Loop with	1
with branch void SelectAddMul(short int	1
with member pointers and virtual	1
with member functions, where static	1
with unsigned integers is ambiguous	1
with unsigned integers (see page	1
with 64 bits, but 32-bit	1
with template metaprogramming. Don't panic	1
with template metaprogramming, but this	1
with pointers that are impossible	1
with new and return a	1
with new and delete (or	1
with new and delete, and	1
with new and delete, or	1
with new or malloc is	1
with new or malloc. Handles	1
with SSE2 #include <emmintrin.h> //	1
with system calls (e.g. IsProcessorFeaturePresent	1
with dynamic memory allocation. Container	1
with short or common names.	1
with making software in a	1
with its value. However, the	1
with its limit, etc. In	1
with CPUs that are up	1
with large data sets. Covers	1
with execution units same size	1
with execution units smaller than	1
with element matrix[c][r] at its	1
with element matrix[c][r]. // Example	1
with single or double precision,	1
with virtual functions class CHello	1
with virtual member functions. The	1
with option -fpie because the	1
with option -fwrapv or -fno-strict-overflow.	1
with option -Wstrict-overflow=2, or (5)	1
with AVX support and another	1
with AVX support calls a	1
with line 29. Each cache	1
with four numbers at a	1
with four cores can run	1
with another vector register containing	1
with another dynamic library requiring	1
with another thread will always	1
with another compiler. 2.6 Choice	1
with few or no other	1
with 1 for the sake	1
with sign bit set). We	1
with both static and dynamic	1
with programs written in Java,	1
with sets rather than loops,	1
with members of mixed sizes.	1
with Boolean variables as input	1
with intrinsic functions for the	1
with signed than with unsigned	1
with Microsoft or Gnu compilers	1
with Microsoft compiler. Some functions	1
with automatic CPU dispatching #include	1
with automatic CPU dispatching. The	1
with automatic CPU dispatching. Unfortunately,	1
with automatic vectorization. The Gnu	1
with induction variables const double	1
with induction variables. It is	1
with end of array ;	1
with old CPUs is not	1
with old microprocessors that do	1
with old microprocessors without any	1
with old CPUs. The Pentium	1
with just two additions by	1
with #define is certain to	1
with C or C++ code.	1
with C functions such as	1
with Windows, Linux, BSD and	1
with network access to virus	1
with slow bit scan instructions.	1
with desired parameters typedef int	1
with out-of-order capabilities are very	1
with out-of-order capabilities can overlap	1
with out-of-order capabilities (see page	1
with limited resources. Most of	1
with preceding branches and the	1
with non-Intel CPUs. Includes many	1
with alignment problem void AddTwo(int	1
with 100 and jumps back	1
with 100 in the loop	1
with reduced speed or not	1
with accessing 32 bits of	1
with 16-bit programs. It is	1
with full debugging support which	1
with N elements of type	1
with little or no overhead	1
with bitwise operators using integers	1
with bounds checking and various	1
with bounds checking template <typename	1
with bounds checking, as illustrated	1
with reading the value from	1
with references. You can change	1
with SSE4.1 // Function to	1
with templates // Place non-polymorphic	1
with templates instead of virtual	1
with invalid pointers can be	1
with destructors to take care	1
with low power consumption are	1
with low priority. In many	1
with Microsoft, Intel and Gnu	1
with lower priority than the	1
with lower priority. If the	1
with heavy traffic and a	1
with profiling support. Then you	1
with j << 5. If	1
with fixed size to avoid	1
with fixed size, not as	1
with fixed strides. Uncached memory	1
with non-sequential access and you	1
with -fpic and it will	1
with hardly any loss of	1
with profilers are: Coarse time	1
with compile-time polymorphism. It is	1
with Intel's compilers and invoked	1
with normal writes or reads	1
with column 28 above the	1
with embedded microcontrollers. I am	1
with internal multi-threading, e.g. Intel	1
with CISC instruction sets have	1
with contiguous memory. See the	1
with macros is that the	1
with older microprocessors is lost.	1
with 1: // Example 7.10a	1
with structured exception handling. See	1
with pointers. The advantages of	1
with 2n -1. The bitwise	1
with existing systems and a	1
with sequential labels is simply	1
with fine-grained parallelism because communication	1
with earlier CPUs. The sequence	1
with big-endian storage. Example 14.23b	1
with big-endian storage. All x86	1
with big-endian storage. Optimizing file	1
with character arrays. Strings can	1
with external libraries. www.agner.org/optimize/#vectorclass All	1
with 14.14b automatically but only	1
with suffixes such as e.g.	1
with coarse-grained parallelism than with	1
with debugging. A debugger can	1
with millisecond resolution and the	1
with alloca. This is a	1
with Gnu. It is expected	1
with lots of data. Use	1
with legacy code, specific preferences	1
with certainty that the operands	1
with certainty which version of	1
with interpretation. The program code	1
with x87 style floating point	1
with -mcmodel=large, but this will	1
with C++0x support. Make a	1
with segmented memory, such as	1
with _mm. These functions are	1
with real time applications. Remember	1
with zero-bits if unsigned. This	1
with enum, const, or #define	1
with First-In-First-Out or First-In-Last-Out access,	1
with profiling, but it often	1
with carry) instructions where the	1
with full-size execution units. The	1
with alloca: // Example 9.3	1
with alloca, because it is	1
with #) are costless in	1
with _finite()) and redo the	1
with nagging pop-up messages saying	1
with double's. It is almost	1
with u.i[1] ^= 0x80000000; because	1
with widely different priority in	1
with IsPowerOf2 = false where	1
with massively parallel vector processing	1
with truncation, and % means	1
with these. The CodeGear, Codeplay	1
on the compiler to do	1
on the compiler bypassing the	1
on the time consuming parts	1
on the same machine. The	1
on the same computer, including	1
on the CPU family number,	1
on the other hand, does	1
on the size and type	1
on the Intel compiler for	1
on the object file level,	1
on the number of elements	1
on the value that is	1
on the way the programming	1
on the first sub-vector. A	1
on the user interface than	1
on the type of CPU	1
on the processors that were	1
on the available instruction set.	1
on the stack and are	1
on the stack and reading	1
on the stack in 32-bit	2
on the stack for all	1
on the stack at address	1
on the stack before it	1
on the stack rather than	1
on the stack always belong	1
on the stack (see above,	1
on the stack Variables and	1
on the stack (three parameters	1
on the work load. The	1
on the calculations inside the	1
on the execution time because	1
on the result of the	3
on the processor and the	1
on the option for "function	1
on the standard PC platform	1
on the hardware platform and	1
on the values of its	1
on the intermediate expression b	1
on the microprocessor hardware for	1
on the next generation of	1
on the Mac platform, but	1
on the data. This is	1
on the second sub-vector before	1
on the x86 family of	1
on the old Pentium 4,	1
on the compiler. Some compilers	1
on the advanced principles of	1
on the costs of software	1
on the preceding value of	1
on the Pentium 4 processor.	1
on the efficiency of the	1
on the variable. This can	1
on the total execution time	1
on the stack. This can	1
on the stack. This makes	1
on the stack. A static	1
on the stack. Each thread	1
on the stack. String constants	1
on the PathScale and Intel	1
on the previous one. It	1
on the CPU. Unrolling a	1
on the device itself is	1
on the hard disk. A	1
on the system, as explained	1
on the CPUID information about	1
on the processor. This is	1
on the processor. Nested loops	2
on the newest CPU of	1
on the newest CPU model,	1
on the newest processors. Supports	1
on the strict aliasing rule	1
on the actual processor. However,	1
on the assumption that the	1
on the stack, which is	1
on the stack, which makes	1
on the stack, except for	1
on the Internet where you	1
on the specified instruction set.	1
on the microprocessor. Integer division	1
on the microprocessor. Multiplication takes	1
on the past history of	1
on the context. The keyword	1
on the screen. However, such	1
on the market. But the	1
on the market. Such a	1
on the processor). Integer division	1
on the processor). Optimizing compilers	1
on the stack). ecx now	1
on the processor) when the	1
on the essential task of	1
on is the feature information,	1
on a program saying that	1
on a CPU with a	1
on a variable which is	1
on a 2 GHz CPU.	1
on a system with only	1
on a Linux compiler, or	1
on a store operation doesn't	1
on a particular processor model.	1
on a particular subtask before	1
on a graphics card or	1
on a graphics accelerator card	1
on a platform with a	1
on a modern CPU. But	1
on a network with heavy	1
on a Pentium 4 with	1
on a Pentium 4 computer	1
on a Pentium 4 computer.	1
on a Pentium 4. The	1
on a non-Intel CPU. If	1
on a sequence of consecutive	1
on a hard disk because	1
on a hard disk often	1
on a typical set of	1
on a PC and then	1
on a PC platform. However,	1
on a thousand numbers. With	1
on a complex framework requiring	1
on a computer. Security software	1
on a command line or	1
on a unit-test without taking	1
on a First-In-Last- Out (FILO)	1
on a First-In-First- Out (FIFO)	1
on and off. It is	1
on that particular part. It	1
on that variable. The different	1
on function calls in the	1
on with a password. The	1
on code optimization Intel: "Intel	1
on an Intel CPU. See	1
on an Intel processor. The	1
on an object of known	1
on an interpreter which interprets	1
on compiler optimization than to	1
on compiler optimization. en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC	1
on x so we can	1
on this part of the	1
on this option. This requires	1
on this option. 8.4 Obstacles	1
on this topic, see my	1
on when objects can be	1
on program performance. The positive	1
on different test examples. You	1
on different processors. In a	1
on different platforms, different screen	1
on only the most simple	1
on CPU dispatching and discovered	1
on CPU efficiency then it	1
on other platforms with big-endian	1
on instruction set #if INSTRSET	1
on which a code version	1
on which it is not	1
on which this code version	1
on which instruction sets the	1
on which imprecisions should be	1
on all the compilers I	1
on all data in large	1
on all 64-bit CPUs and	1
on all C++ compilers The	1
on all elements of a	1
on all compilers. Some compilers	1
on all relevant options. Many	1
on all platforms and the	1
on all sizes of matrices.	1
on all newer models that	1
on all non-static member functions.	1
on all brands of CPUs.	1
on all major platforms. However,	1
on one computer is not	1
on integer code. It is	1
on integer expressions than on	1
on integer expressions (except for	1
on integer variables. 31 7.3	1
on page 8 below. This	1
on page 16. If you	1
on page 134 and 135	1
on page 146 below. Position-independent	1
on page 146 below. 3.7	1
on page 164 below. Those	1
on page 136 and 137,	1
on page 15. C++ is	1
on page 39 shows how	1
on page 105. Floating point	1
on page 93. Avoid the	1
on page 93. 7.10 Arrays	1
on page 26. Avoid global	1
on page 122. The code	1
on page 58 shows an	1
on page 72. It is	1
on page 72. You have	1
on page 22. Avoid long	1
on page 153. A profiler	1
on page 107. A disadvantage	1
on page 60. In the	1
on page 62. If the	1
on page 96. 14.5 Integer	1
on page 44. The dispatching	1
on page 134. The table	1
on page 132. Unfortunately, table	1
on page 87. This will	1
on page 130. It is	1
on page 158. This manual	1
on page 27. An array	1
on floating point code and	1
on floating point expressions. It	1
on floating point expressions. Most	1
on compilers that rely on	1
on most other microprocessors. Integer	1
on most processors (when vector	1
on most newer processors. The	1
on most microprocessors. Multiplication and	1
on using the optimization features	1
on using the instructions listed	1
on using alloca. 9.7 Container	1
on Intel compiler versions 7	1
on Intel processors. The performance	1
on Intel processors. Details about	1
on Intel CPUs: use the	1
on Intel CPUs. Another function	1
on Intel Atom processors, but	1
on b can be omitted,	1
on multiple data elements and	1
on static or global variables.	1
on C++ Performance for further	1
on C++ Performance". www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf.	1
on such systems than it	1
on such processors requires a	1
on such small devices if	1
on such small devices, as	1
on any brand of CPU.	1
on some processors that have	1
on some systems. If the	1
on some processors. On many	1
on some microprocessors when an	1
on variables in memory or	1
on table lookup or require	1
on very small loops (less	1
on software that is slow,	1
on branch predictions in the	1
on first call // Header	1
on first call method using	1
on first call. The function	1
on optimization of C++ and	3
on how to test a	1
on how they are declared	1
on how well the microprocessor	1
on how predictable the branch	1
on test theory. Advice on	1
on these data. It is	1
on instructions that use the	1
on processors that were unknown	2
on processors with a micro-op	1
on processors with this instruction	1
on stack ; ecx =	1
on its own CPU core.	1
on its final destination, but	1
on its family and model	1
on important work. The updating	1
on CPUs with a slow	1
on CPUs with full-size execution	1
on CPUs without the FMA4	1
on large data sets where	1
on Windows platforms. The Microsoft	1
on calculations inside the loop	1
on processor X?" rather than	1
on big runtime frameworks, intermediate	1
on several different CPUs if	1
on AMD and VIA processors.	3
on AMD CPUs (See manual	1
on AMD CPUs. The Gnu	1
on AMD processors, but not	1
on exception handling. 8.6 Optimization	1
on small devices with limited	1
on overflow and underflow. The	1
on Linux platforms, and in	1
on another computer. The Pentium	1
on whether CriticalFunction is called	1
on every call of the	1
on every call method. When	1
on every call. A branch	1
on hardware identification. Such schemes	1
on certain Intel CPUs, but	1
on intermediate code is needed	1
on intermediate code and just-in-time	1
on Mac platform. Intel The	1
on complicated criteria or lists	1
on signed and unsigned variables.	1
on mathematical applications with large	1
on what is most appropriate	1
on what instruction sets and	1
on what fits best into	2
on automatic vectorization. The compiler	1
on automatic prefetching so this	1
on n here because the	1
on runtime dispatch to virtual	1
on compilers. Several other programming	1
on bigger systems. The smaller	1
on vectors of two double	1
on vectors and matrixes. Algorithms	1
on process is known to	1
on process may take more	1
on old operating systems that	1
on advanced C++ programming, how	1
on my own research, not	1
on my study of how	1
on network resources and servers	1
on network resources are not	1
on Pentium 4 processors, and	1
on non-Intel processors can be	1
on non-Intel processors (see page	1
on non-Intel CPUs was more	1
on non-Intel CPUs unless you	2
on non-Intel processors, as explained	1
on non-Intel machines? Possible solutions	1
on non-Intel processors). It has	1
on it. Instead of returning	1
on alignment and the resultant	1
on until you turn them	1
on performance. 7.18 Class data	1
on access. Sequential forward access	1
on access. Run multiple processes	1
on bounds checking). An error	1
on reading and writing data	1
on future processors. There are	1
on future CPUs. Half size	1
on future processors, and choose	1
on newer processors. Many processors	1
on input data is a	1
on current Intel CPUs can	1
on PC platforms. Graphics accelerators	1
on just-in-time compilation of an	1
on algorithms and data structures	1
on lazy binding leads to	1
on executing library functions. Time-	1
on executing instructions are less	1
on registers, not on variables	1
on CodeGear compiler). Fastcall functions	1
on CodeGear compiler) integer parameters	1
on deciding which version to	1
on completely independent divisions. Example:	1
on anything else being initialized.	1
on seven different compilers. The	1
on seven different brands of	1
on remote or removable media	1
on BSD, but the compiler	1
on n, including the while	1
on older processors and on	1
on structured exception handling and	1
on mixing code compiled for	1
on multi-core CPUs, but event-counters	1
on contemporary processors. The cache	1
on contemporary 106 CPUs if	1
on longjmp in time-critical code.	1
on improving performance. Stefan Goedecker	1
on x. It is a	1
on hacks that violate or	1
on non- standardized details in	1
on servers that run many	1
on usability, but I think	1
on publicly available information. They	1
on system-specific graphical interface calls.	1
on arranging data in order	1
on Intel/x86-compatible microprocessors. The function	1
on redesigning a program may	1
on correction for the "FDIV	1
code the offset as a	1
code is the same. This	1
code is a risk factor	1
code is that the user	1
code is that it is	1
code is that it adds	1
code is that if the	1
code is not copied because	1
code is not optimal. Use	1
code is not optimized. Jumps	1
code is not separated from	1
code is more difficult for	1
code is used in shared	1
code is so high that	2
code is very inefficient because	1
code is critical when there	1
code is compiled and distributed	1
code is compiled for a	1
code is compiled for old	1
code is compiled into an	1
code is optimized is to	1
code is implemented as a	1
code is likely to run	1
code is likely to execute	1
code is fast anyway and	1
code is running in the	1
code is running on an	1
code is needed for other	1
code is later ported to	1
code is smaller because relative	1
code is intended for. In	1
code is limited to well-tested	1
code is inlined - no	1
code is chosen only when	1
code is executed. Optimizes very	1
code is included in a	1
code is fragmented and scattered	1
code is fastest because you	1
code is exactly identical for	1
code is distributed and stored	1
code is distributed as it	1
code is distributed between multiple	1
code is compact and takes	1
code is inefficient, especially in	1
code is __asm int 3;	1
code is serial in the	1
code is serial because each	1
code is selected if the	1
code is translated into machine	1
code is indeed vectorized as	1
code is repetitive. The simplest	1
code of the next function.	1
code to the device. Any	1
code to a specific CPU	1
code to be able to	1
code to call the version	1
code to test in the	1
code to access these instructions.	1
code to check that thrown	1
code to support different CPUs.	1
code to see which solution	1
code to give the variable	1
code to tell the compiler	1
code to non-AVX code because	1
code to non-AVX code. This	1
code to test. disable power-save	1
code and for fast and	1
code and can be linked	1
code and you can rely	1
code and data are not	1
code and data are cached	1
code and data can exceed	1
code and data A cache	1
code and data memory used	1
code and data ......................................................................................... 87	1
code and table lookup is	1
code and how the microprocessor	1
code and doesn't take any	1
code and compile them separately	1
code and intermediate code for	1
code and put the different	1
code and divide it into	1
code and just-in-time compilation may	1
code and just-in-time compilation. Some	1
code and lazy binding by	2
code and main() are compiled	1
code and read-only data. The	1
code in the above example	1
code in the disassembly window	1
code in a way that	1
code in a separate module,	1
code in a typical software	1
code in this example should	1
code in which the variable	1
code in example 16.2 calls	1
code in example 15.1c is	1
code in example 14.8 and	1
code in example 14.14a with	1
code in example 11.1a to	1
code in example 14.21 is	1
code in multiple versions for	3
code in multiple versions, each	1
code in order to improve	1
code in addition to the	1
code in either case. Intrinsic	1
code in details. The funny	1
code in general. Assume that	1
code for the common language	1
code for the three functions.	1
code for the Microsoft, Intel,	1
code for the .NET framework	1
code for this instruction set	1
code for Intel CPUs. New	1
code for making the structure	1
code for AMD CPUs. New	1
code for actually making a	1
code for vectorization Not all	1
code for accessing a data	1
code for vectorization............................................................. 117 12.7	1
code that the compiler generates	1
code that is not part	1
code that is compiled as	1
code that is difficult to	1
code that is ported to	1
code that is distributed. The	1
code that a compiler generates	1
code that are used by	1
code that can be moved	1
code that can benefit from	1
code that it jumps to.	1
code that you see in	1
code that use only a	1
code that makes code. For	1
code that does floating point	1
code that works for any	1
code that uses the cache	1
code that uses pointers because	1
code that contains integer division:	1
code that allows you to	1
code that current compilers may	1
code that produces a string	1
code that copies the table	1
code that accesses data members	1
code that accesses b through	1
code that matters rather than	1
code are compiled with different	1
code are relative to the	1
code are uncached or even	1
code are modified, if necessary,	1
code can be optimized if	1
code can be implemented in	1
code can be made more	1
code can be further tested	1
code can be improved in	1
code can be applied to	1
code can be completely contained	1
code can be vectorized, because	1
code can then be placed	1
code can therefore suffer from	1
code can become very big.	1
code can possibly be compiled	1
code can now be vectorized	1
code can probably be improved	1
code or in a high-priority	1
code or use objconv or	1
code or not. I will	1
code if no other modules	1
code if we specify the	1
code if possible, or the	1
code by making another function	1
code by default. This is	1
code by emulating the so-called	1
code with a 64 64	1
code with an inline assembly	1
code with CPU dispatching, then	1
code with automatic CPU dispatching	1
code with automatic CPU dispatching.	1
code as example 12.4b, rewritten	1
code may be stored in	1
code may run with reduced	1
code you are testing contains	1
code you want to 155	1
code have been reordered, inlined,	1
code more efficient in some	1
code more efficient when arrays	1
code more complicated and error-prone.	1
code more efficient. 64 bit	1
code more compact so that	1
code more efficient, and sometimes	1
code more complex, but not	1
code when the #pragma vector	1
code when you compile with	1
code will be efficient whether	1
code will be very efficient	1
code will be less efficient	1
code will not be portable	1
code will work only on	1
code will run faster because	1
code will read four elements	1
code will load the structure	1
code will fail if an	1
code will catch an exception	1
code then it is important	1
code then you can get	1
code then you may of	1
code from example 8.26a (32-bit	1
code from example 8.26b: ;	1
code from example 9.5a: 98	1
code at each function call	1
code at all. This method	1
code has a branch that	1
code has a branch (e.g.	1
code has a parallel structure	1
code has a jump from	1
code has to obey certain	1
code has no pointer aliasing.	1
code because of a change	1
code because it doesn't have	1
code because they fail to	1
code which the calling function	1
code one line at a	1
code cache is used more	1
code cache and the data	1
code cache and it fills	1
code cache and data cache	1
code cache or micro-op cache.	1
code cache if there are	1
code cache use and data	1
code cache works most efficiently	1
code cache works less efficiently	1
code should be written in	1
code should have #if directives	1
code should therefore preferably be	1
code size or data used	1
code size have got low	1
code size has higher priority	1
code into multiple threads. The	1
code where speed is important.	1
code version is implemented in	2
code version on, then it	1
code version performs well. The	1
code version performs poorly. It	1
code takes no extra time.	1
code so that you don't	1
code so that each value	1
code performance is to use	1
code branch to use for	1
code branch for a low	1
code branch for test purposes.	1
code faster because testing a	1
code makes caching more efficient	1
code makes caching less efficient.	1
code cannot be executed as	1
code address and back again.	1
code less clear and more	1
code 64 bit code Static	1
code often contains a lot	1
code rather than by the	1
code rather than using a	1
code optimization Intel: "Intel 64	1
code 16 will not only	1
code up to 5 times	1
code must compute (FuncRow(i)*columns +	1
code versions for different CPUs.	1
code versions work correctly. The	1
code compiled for AVX or	1
code compiled with and without	1
code compiled with AVX support	1
code compiled without AVX, as	1
code big and uses more	1
code works only for compilers	1
code inside square: // Example	1
code uses an unfortunate method	1
code Function libraries can be	1
code contains only simple standard	1
code contains natural parallelism. The	1
code memory. The functions are	1
code branches works correctly. A	1
code branches separately and test	1
code automatically in simple cases	1
code automatically or does so	1
code caching is critical. The	1
code caching is critical. Optimizing	1
code caching and data caching	1
code caching for the following	1
code implementation works particularly bad	1
code like the one that	1
code cache. The register stack	1
code cache. The subsequent sections	1
code examples in these manuals	1
code examples for these methods.	1
code difficult to read. If	1
code instead of the most	1
code becomes the same as	1
code becomes more efficient when	1
code becomes more readable when	1
code becomes bigger if there	1
code becomes smaller if there	1
code becomes simpler because it	1
code becomes contiguous. The code	1
code becomes bulky and difficult	1
code together near each other	1
code goes through the following	1
code smaller and more efficient.	1
code section is always position-independent	1
code section and read-only data	1
code section can be loaded	1
code section will be different	1
code section so that it	1
code section contains no absolute	1
code section needs one instance	1
code section position-independent, makes a	1
code gives an 9 extra	1
code size. In fact, the	1
code still needs careful optimization.	1
code prevent the CPU from	1
code further by using function	1
code Assume that a function	1
code optimization. See www.agner.org/optimize and	1
code execute faster than other	1
code execute faster. The most	1
code containing pure function calls.	1
code version. 2. Check that	1
code to: // Example 8.15b	1
code could benefit from using	1
code involves multiplication or division.	1
code once the hot spots	1
code explicitly by using the	1
code line. Time-based sampling: The	1
code itself is a very	1
code Shared objects in Linux,	1
code automatically. It is also	1
code Static linking (multithreaded) /arch:AVX	1
code generated by the compiler	1
code generated by the compiler,	1
code relies on structured exception	1
code addresses. The names of	1
code itself. Another disadvantage of	1
code flag in the compiler.	1
code lines. The 17 debug	1
code incompatible with old CPUs.	1
code cache, branch target buffer,	1
code only. This can be	1
code motion A calculation may	1
code motion Induction variables for	1
code motion manually when it	1
code explicitly. There are various	1
code looks like this: //	1
code caching. This problem can	1
code took 50 clock cycles	1
code carefully to make sure	1
code ....................................................... 20 3.7 File	1
code everywhere by default. Position-independent	1
code (option -fno-pic). 64 bit	1
code generality. The most important	1
code bloat and complexity (en.wikipedia.org/wiki/Standard_Template_Library).	1
code mixes float and double	1
code (release version) in the	1
code slower, especially when the	1
code optimization", Coriolis group books	1
code (byte code). The source	1
code motion. See page 78.	1
code section, but it will	1
as the function returns. Make	1
as the compiler itself is.	1
as the other thread increments	1
as the example below shows.	1
as the size of data	1
as the number of machine	1
as the error doesn't occur,	1
as the standard PC processors	1
as the Microsoft compiler. Supports	1
as the difference between the	1
as the binary digits. The	1
as the Microsoft, Intel, Gnu	1
as the Gnu, Clang and	1
as the latency of a	1
as the "Intel Math Kernel	1
as the C-style type-casting. It	1
as the basis for this	1
as the operands. The advantages	1
as the .exe file, is	1
as is often seen, is	1
as is commonly the case	1
as a function in a	1
as a function library or	1
as a function return value.	1
as a function call to	1
as a function parameter, or	1
as a time measure. This	1
as a memory pointer. This	1
as a vector of eight	1
as a vector of vectors,	1
as a make utility. The	1
as a pointer in assembly	1
as a library function from	1
as a * (2n /	1
as a table of jump	1
as a very large positive	1
as a 32-bit number (the	1
as a 32-bit number. If	1
as a member function which	1
as a member function. Do	1
as a member function. 7.12	1
as a register variable in	1
as a register stack. These	1
as a template parameter. There	1
as a template parameter: template	1
as a dynamic link library	1
as a large positive number	1
as a result of other	1
as a result of macro	1
as a single bit which	1
as a virtual member function.	1
as a structure or class.	1
as a Boolean vector. For	1
as a parameter to the	1
as a runtime DLL or	1
as a means of making	1
as a linked list. Each	1
as a linked list. Do	1
as a linked list. 94	1
as a global variable in	1
as a shift operation. For	1
as a so-called soft processor.	1
as a temporary register for	1
as a normal array. The	1
as a base address plus	1
as a circular buffer with	2
as a circular buffer than	1
as a subexpression. For example,	1
as a biased binary integer,	1
as a plug-in to Microsoft	1
as a valuable source of	1
as a learning process where	1
as a stand alone compiler	1
as a scalar (Scalar means	1
as a subset, giving access	1
as to the AVX instructions.	1
as to make pointers efficient,	1
as in example 13.1 page	1
as in example 16.2 above,	1
as in example 14.23 page	1
as in example 7.32b. A	1
as in example 7.22. //	1
as in Linux kernel version	1
as in Linux. 32-bit Mac	1
as for switch statements, as	1
as for (i=0; i<n; ++i).	1
as it is and interpreted	1
as it is done only	1
as it is, and is	1
as it is, but must	1
as function parameters because of	1
as function parameter. But it	1
as function inlining. Reducible expressions	1
as if it had a	1
as if you had used	1
as an integer if it	1
as an example in the	1
as an object of a	1
as an array of structures:	1
as an array index then	1
as an array index. The	1
as an unsigned integer and	1
as an integer. The compiler	1
as an integer. But the	1
as an integer. 158 Integer	1
as an example. The only	1
as an appendix to this	1
as an implicit parameter to	1
as an 8-bit signed number.	1
as an 8-bit signed number,	1
as you are not doing	1
as you can read about	1
as you have even a	1
as you will see shortly.	1
as you avoid an excessive	1
as you don't need conversions	1
as this is not the	1
as when contentions do not	1
as memory leak. An even	1
as memory leaks. It is	1
as vector operations. 105 The	1
as vector register. Factors that	1
as different functions. There is	1
as loop counter when the	1
as cache and execution units.	1
as integer arithmetic operations. When	1
as floating point. Use 64-bit	1
as example 7.15b below shows.	1
as example 12.4b, rewritten with	1
as example 13.1, Requires binutils	1
as most sorting algorithms, are	1
as using a function that	1
as i modulo 16. This	1
as multiple inheritance where a	1
as two 32-bit integers, which	1
as two 128-bit vectors. The	1
as object or library files.	1
as static arrays in the	1
as static link libraries (*.lib,	2
as C++ for doing some	1
as C++ compilers. 2.5 Choice	1
as efficient as a member	2
as efficient as a virtual	1
as efficient as using a	1
as efficient as any other	1
as efficient as integers. 7.5	1
as efficient functions for string	1
as many encryption algorithms, cannot	1
as possible for usability reasons.	1
as possible or when code	1
as possible at compile time.	1
as possible into the data	1
as any other member functions.	1
as very time-consuming tasks because	1
as long as the error	1
as long as it is	1
as long as you are	1
as long as you avoid	1
as long as you don't	1
as long as this is	1
as long as their uses	1
as long time to transpose	1
as 32-bit integer multiplication prior	1
as code. Metaprogramming can be	1
as template parameters then the	1
as template parameter. In other	1
as template parameters, as example	1
as pointers and references. Arrays	1
as pointers unless they are	1
as 32 sets 4 ways.	1
as part of the instruction	1
as simple variables, loop counters,	1
as constant references accept expressions	1
as error handling in the	1
as important usability problems that	1
as much as possible at	1
as much data as possible	1
as single precision. And who	1
as common subexpression elimination, constant	1
as AMD and VIA. The	1
as small as possible or	1
as good as the compiler	1
as good as the Microsoft,	1
as good as possible. The	1
as good as expected. I	1
as explained in the next	2
as explained in the previous	1
as explained in the chapter	1
as explained in example 7.35	1
as explained in chapter 9.10,	1
as explained on page 16.	1
as explained on page 105.	1
as explained on page 93.	1
as explained on page 72.	1
as explained on page 22.	1
as explained on page 107.	1
as explained on page 96.	1
as explained on page 44.	1
as explained on page 132.	1
as explained on page 87.	1
as explained on page 130.	1
as explained on page 27.	1
as explained at page 150.	1
as explained below. The disadvantage	1
as explained below. There are	1
as explained below. Shared objects	2
as explained above, so that	1
as explained above. Examples are	1
as parameters to a class	1
as supported instruction sets and	1
as few branches as possible,	1
as inline function #define MAX(a,b)	1
as well as the size	1
as well as in Linux	1
as well as efficient functions	1
as well as pointers and	1
as well as important usability	1
as well as writing data.	1
as well as directly compiled	1
as well as Intel-based Mac	1
as well use a #define,	1
as well specify the alignment	1
as well developed as C++	1
as fast as a scalar	1
as fast as integer arithmetic	1
as fast as single precision.	1
as fast as calling a	1
as fast as accessing it	1
as fast as additions. When	1
as their uses (live ranges)	1
as Boolean vectors, and these	1
as string or CString. This	1
as three branches. They can	1
as last time the statement	1
as last time it was	1
as calling a simple function	1
as bigger than it actually	1
as binary executable code. Most	1
as p and r in	1
as intended (see page 84).	1
as dynamically allocated memory, windows,	1
as index then the compiler	1
as described in the subsequent	1
as described in this chapter.	1
as described in chapter 12.	1
as described in chapter 11.	1
as described below. The program	1
as position-independent has the following	1
as given in the following	1
as output can produce no	1
as task switches and garbage	1
as writing data. Multidimensional arrays	1
as copying an array or	1
as accessing it directly. The	1
as possible. The first count	1
as possible. However, there are	1
as possible. Typically it should	1
as little work as possible.	1
as discussed on page 158.	1
as directly compiled code. (Compile	1
as e.g. .R. for AVX.	1
as well. The conversion from	1
as well. This is the	1
as input less efficient than	1
as input check if the	1
as integers. 7.5 Booleans The	1
as mentioned above. The generality	1
as addition, subtraction, comparison, bit	1
as standardized as possible for	1
as heavy mathematical calculations, should	1
as Gnu, Clang, Intel or	1
as listed in the table.	1
as xn = xxn-1, and	1
as follows: // Example 9.1b	1
as follows: struct Sfloat {	1
as follows: Instruction set Header	1
as follows: Instruction set Important	1
as follows: Type of elements	1
as follows: Matrix size Time	1
as follows: floatvalue ( 1)sign	1
as machine code to the	1
as powers of 2: //	1
as possible, and the dispatching	1
as follows in 64-bit mode	1
as follows (using Intel vector	1
as soon as the function	1
as int, float, double, bool,	1
as list, set and map	1
as -(-a) = a, but	1
as n! = n(n-1)!. If	1
as true, if any of	1
as macros are sometimes more	1
as well, but the examples	1
as Taylor expansions and Newton-Raphson	1
as alternatives to the standard	1
as illustrated in this example:	1
as 8-bit integers with the	1
as entry point. // After	1
as Intel-based Mac OS and	1
as character arrays. Note that	1
as expected. I believe that	1
as DOS and 16-bit Windows,	1
as logarithms and trigonometric functions.	1
as C#, Visual Basic .NET	1
as pivot in a Gauss	1
as memcpy, memmove, memset, or	1
as shown in the above	1
as shown in example 9.6b.	1
as semaphores, mutexes and message	1
as floppy disks and USB	1
as arguments while pointers and	1
as price, compatibility, second source,	1
as pragmas in the code	1
as _mm_empty() as shown in	1
as logarithms, exponential functions, trigonometric	2
as additions. When used simply	1
as additions. Divisions take longer	1
as command-line versions without an	1
as Java, use dynamic memory	1
as 0/a = 0 because	1
as accurate and reproducible as	1
as sorting and searching, or	1
as coprocessors to take care	1
as sqrt and pow at	1
as b*(2.0/3.0) unless you put	1
as C- style type-casting with	1
as 2eee 1.fffff, where is	1
as (int)&matrix[0][0] + j *	1
as eliminating the if-branch in	1
as buffers for storing text	1
as spell-checking and repagination are	1
as GetPrivateProfileString and WritePrivateProfileString to	1
as sorting, searching, and mathematical	1
as strcpy, strcat, strlen, sprintf,	1
as x4xn-4. There is no	1
as (critical stride) = (number	1
as VHDL or Verilog. Common	1
as recursive templates. The powN	1
as versatile. Fortran is also	1
as flush and fence instructions,	1
as pow, log, exp, sin,	1
as email and web browsing	1
as required, but in example	1
as <. The result of	1
as (b*2.0)/3.0 rather than as	1
as ((a+b)+c)+d. This is a	1
as replacements for switch statements	1
as integers: // Example 14.27	1
as ReadB needs to code	1
as gates, flip-flops, multiplexers, arithmetic	1
as 'this'. We can therefore	1
as OneOrTwo5[(b!=0) ? 1 :	1
as follows. The first generation	1
as reflecting it at the	1
as AQtime, Intel VTune and	1
as intended, while the Borland	1
not the more complicated functions	1
not the case we may	1
not the compiled code. In	1
not the best optimizer. Borland/CodeGear/Embarcadero	1
not the optimized version because	1
not the columns. Every fourth	1
not a good idea to	1
not a power of 2:	1
not a manual on usability,	1
not a problem since we	1
not a safe programming practice,	1
not a profiler. It is	1
not a vector). The first	1
not a textbook on test	1
not to mix signed and	1
not to vectorize. The pragmas	1
not in the same thread	1
not in the cache. The	1
not in a shared object	1
not in a particular application.	1
not in some very old	1
not in memory. The renaming	1
not in use. The installation	1
not for other brands of	1
not be necessary to optimize	1
not be advantageous if a	1
not be able to do	1
not be able to optimize	1
not be able to find	1
not be able to completely	1
not be optimal to use	1
not be too worried about	1
not be compatible with old	1
not be compatible with structured	1
not be safe to make	1
not be safe if there	1
not be evaluated if a	2
not be worth the effort.	2
not be portable to platforms	1
not be cached. This can	1
not be visible at all	1
not be negative. The method	1
not be optimally aligned. See	1
not be passed as parameters	1
not if the loop counter	1
not if it is a	1
not if b is an	1
not if static linking is	1
not by the application program.	1
not with a branch inside	1
not with earlier CPUs. The	1
not on Intel processors. Details	1
not on variables in memory	1
not on AMD CPUs (See	1
not on publicly available information.	1
not as a linked list.	1
not not _WIN32 n.a. MS	1
not an advantage if the	1
not an optimal solution because	1
not an Intel, even if	1
not an issue because an	1
not have the disadvantages mentioned	1
not have the selected instruction	1
not have to unroll a	1
not have to worry much	1
not have this problem. Vectors	1
not have such a feature	1
not have its own IDE.	1
not have inherent support for	1
not use the same memory	1
not use the best possible	1
not use the source annotation	1
not use a stack frame	1
not use a linked list	1
not use one container for	1
not use lookup tables if	1
not use runtime type identification	1
not use STL containers. See	1
not use GOT and PLT	1
not use branches, provided that	1
not at all on AMD	1
not make the program more	1
not make a destructor if	1
not make this kind of	1
not make variables global if	1
not make induction variables for	1
not only the time spent	1
not only a single function	1
not only be a waste	2
not only when called from	1
not only improve the performance,	1
not all libraries have the	1
not used for internal references.	2
not do such obvious reductions	1
not do so unless you	1
not using position-independent code (option	1
not i but i*12, because	1
not possible to do two	1
not possible to add unused	1
not possible to contain all	1
not possible to distribute function	1
not possible if the expression	1
not possible when parts of	1
not any other factor. If	1
not very good at optimizing	1
not long enough to be	1
not stored contiguously in the	1
not call WriteFile if the	1
not less than ARRAYSIZE. Another	1
not take the hint, but	1
not need the updates if	1
not need to be initialized	1
not need any patch. 131	1
not need updating in the	1
not need relocation at load	1
not even compatible with different	1
not even temporarily. This is	1
not sure you need it.	1
not always for application-specific code.	1
not always as good as	1
not always possible to access	1
not always work well on	1
not always able to predict	1
not always apply to arrays	1
not always fully optimized. Library	1
not always avoiding this. The	1
not always true. The program	1
not always work. Data alignment.	1
not always accurate, however, and	1
not always comparable to a	1
not always sequential, and you	1
not always optimal, though. In	1
not out of range printf(Greek[n]);	1
not dynamic libraries (.dll or	1
not part of a shared	1
not up to date. Mac	1
not making any specific recommendation	1
not accessed by any other	2
not work in example 9.6b.	1
not work on compilers that	1
not necessary to have many	1
not necessary to unroll a	1
not necessary for your application	1
not necessary if you can	1
not necessary when no attempt	1
not necessary because the factorials	1
not thread safe if multiple	1
not good to have two	1
not been a power of	1
not been tested in Mac	1
not been given a name.	1
not been updated since 2004.	1
not been updated lately. Vector	1
not optimized for 16-bit mode	1
not get the same result	1
not get any answer. Beginners	1
not check for overflow and	1
not check if XMM registers	1
not advantageous to use the	1
not advantageous to use a	1
not advantageous to split the	1
not advantageous by itself. But	1
not advantageous then it is	1
not known at compile time	1
not known at compile time.	4
not known at compile time,	1
not support the SSE and	1
not support static linking. A	1
not support SSE. Several function	1
not supported at all. Can	1
not supported fprintf(stderr, "\nError: Instruction	1
not doing divisions. It is	1
not add to the total	1
not well documented. The examples	1
not able to do more	1
not able to see this.	1
not certain to be divisible	1
not shared between multiple processes	1
not quite as versatile. Fortran	1
not used. The method currently	1
not recommended to use the	1
not recommended to make 16-bit	1
not recommended to modify a	1
not recommended for critical applications	1
not recommended if portability is	1
not optimize as good as	1
not optimize well. Open Watcom	1
not optimal to do so	1
not optimal from a technological	1
not optimal because it takes	1
not optimal because it prevents	1
not cost anything here because	1
not efficient. If the compiler	1
not needed in 64-bit mode	2
not needed for the calculation	1
not needed if the object	2
not read or write less	1
not give the full information	1
not look at CPU brand	1
not load all the modules	1
not declared volatile then an	1
not improve the execution speed	1
not divisible by the vector	1
not divisible by the unroll	1
not know that double precision	1
not appropriate here. It reveals	1
not require a multiplication but	1
not negative by AND'ing it	1
not predicted well. A switch	1
not compatible with the other	1
not compatible with other compilers	1
not compatible across compilers. Fastcall	1
not intended for finding hot	1
not turn on correction for	1
not produce any extra code	1
not produce any extra code.	2
not safe unless the length	1
not clear whether r is	1
not mix single and double	1
not fit into a vector	1
not needed. You may write	1
not needed. Obviously, the best	1
not needed. Even better, you	1
not copied because the same	1
not allow vector objects as	1
not expect to 99 read	1
not swap the order of	1
not significant as long as	1
not enough registers then the	1
not apply to floating point	1
not apply to very big	1
not allocate more space than	1
not critical. It is possible	1
not vectorize automatically. The code	1
not include any part of	1
not fully optimized yet. Supports	1
not standardized across platforms. See	1
not included in the representation,	1
not easily ported to systems	1
not resolved when the program	1
not allowed to change the	1
not allowed in C++ so	1
not suitable for example 9.5	1
not spend time on deciding	1
not free the memory used	1
not do. The following sections	1
not evaluated at all because	1
not edx but the variable	1
not permissible to assume that	1
not permissible for reasons of	2
not overlap. If c =	1
not overlap. You can save	1
not overlap. See page 89	1
not overlap. 27 The number	1
not backwards compatible with 16-bit	1
not portable to systems with	1
not _WIN64 not _WIN64 64	1
not _WIN64 64 bit platform	1
not necessarily stored sequentially in	1
not necessarily done by the	1
not necessarily stay in the	1
not necessarily newer. The CPU	1
not divided into threads with	1
not seen in the unit-	1
not wrap around on overflow	1
not necessary. A virtual destructor	1
not all. Fortunately, there are	1
not doubled. A thread that	1
not present in the old	1
not overlap or if they	1
not optimal. There are certain	1
not optimal. Use 12 option	1
not guaranteed to be less	1
not expensive. You may use	1
not going to recommend any	1
not __INTEL_COMPILER __INTEL_COMPILER 161 32	1
not cached. The subsequent counts	1
not cached. See page 26	1
not optimized. Jumps between CPU	1
not normally use this principle	1
not satisfied with the way	1
not alias any elements in	1
not alias anything by using	1
not separated from the application	1
not cover graphics processors. 5	1
not unusual for the installation	1
not unusual for the reinstallation	1
not solve all the problems	1
not occur. The reason why	1
not occur. See page 78	1
not _WIN32 n.a. MS compiler	1
not throw exceptions throw() throw()	1
not modified. Unlike a pointer	1
not overlapping or aliasing, but	1
not computationally intensive may very	1
not vacant then the DLL	1
not suited for vector operations.	1
not supported. The calculation of	1
not visible in the scope	1
not allowed. Non-public distribution to	1
not testing. Trying to read	1
not uncommon for software teachers	1
not uncommon for virus scanners	1
not 123 correspond to any	1
not accessible from other modules.	1
not noticed that i can	1
not recognized in 64-bit mode.	1
not human readable and not	1
not yet as well developed	1
not referenced from any other	1
not selected. Compiler has insufficient	1
not evaluated, because the result	1
not detected until 10 -	1
not supported"); return; } //	1
not safe, of course. It	1
not standardized. It is not	1
not affected by __fastcall. The	1
not aliased #pragma optimize("a", on)	1
not backwards. Copying or clearing	1
not traditionally considered a software	1
not used). You may use	1
not satisfactory. The following considerations	1
not met then it is	1
not alias, if appropriate. 8.	1
not reproducible. Such events as	1
This is the function we	1
This is the code from	1
This is the time it	1
This is the variable 85	1
This is the first in	1
This is the case if	1
This is the best way	1
This is the reason why	4
This is the simplest method,	1
This is a function that	1
This is a very efficient	1
This is a very user	1
This is a useful way	1
This is a simple solution,	1
This is a common way	1
This is a common programming	1
This is a power of	1
This is a problem with	1
This is a counter that	1
This is a dependency chain	1
This is a linear function	1
This is a frequent source	1
This is a cheap compiler	1
This is of course inefficient.	1
This is of course far	1
This is not a manual	1
This is not an optimal	1
This is data decomposition. It	1
This is because the critical	1
This is because the register	1
This is because the file	1
This is because it can	1
This is because we forgot	1
This is because modern CPUs	1
This is because algebraic manipulations	1
This is because computers have	1
This is only an advantage	1
This is only possible if	1
This is only safe if	1
This is all done in	1
This is used only for	1
This is one of the	2
This is no problem if	1
This is also called Single-Instruction-Multiple-Data	1
This is efficient for simple	1
This is very problematic because	1
This is faster if a	1
This is faster than calculating	1
This is called the branch	1
This is called CPU dispatching.	1
This is called register renaming.	1
This is called stack unwinding.	1
This is called name mangling.	1
This is called square blocking	1
This is called garbage collection.	1
This is less efficient than	1
This is often the case	1
This is often a disadvantage	1
This is how the if	1
This is useful in situations	1
This is useful on servers	1
This is useful when the	1
This is sure to work	1
This is necessary if the	1
This is small enough to	1
This is done by copying	1
This is done by declaring	1
This is advantageous in cases	1
This is advantageous because registers	1
This is quite inefficient. The	1
This is optimal in most	1
This is typically implemented by	1
This is actually quite convenient.	1
This is usually done in	1
This is just an arbitrary	1
This is intended for variables	1
This is slow // Division	1
This is slow // Modulo	1
This is inefficient because of	1
This is safe and flexible,	1
This is approximately three times	1
This is equally efficient. Simple	1
This is efficient, but risky.	1
This is inefficient, of course,	1
This is coded as _mm_empty()	1
This is unfortunate because truncation	1
This is annoying to the	1
This is supplied with Intel's	1
This can be a very	1
This can be an advantage	1
This can be useful in	3
This can be useful for	1
This can be useful when	1
This can be necessary in	1
This can be done by	1
This can be done with	2
This can be quite inefficient	1
This can be replaced with:	2
This can be avoided in	1
This can be avoided by	2
This can be changed to:	1
This can be improved by	2
This can be permissible if	1
This can be ameliorated by	1
This can be accomplished by	1
This can have quite dramatic	1
This can cause the memory	1
This can cause all kinds	1
This can cause cache contentions	1
This can cause severe delays	1
This can actually reduce speed	1
This can improve the speed	1
This can save several clock	1
This can lead to a	1
This function is so important	1
This function is intended for	1
This function is OS independent	1
This function writes to matrix	1
This function stores a double	1
This function adds the elements	1
This code will work only	1
This code has a jump	1
This code works only for	1
This code took 50 clock	1
This compiler is a good	1
This compiler does not have	1
This may be because the	1
This may be faster despite	1
This may be useful if	1
This may be advantageous if	1
This may take up to	1
This may cause the software	1
This may cause a lot	1
This may typically look like	1
This may improve the performance	1
This may require that a	1
This may enable the compiler	1
This time is included in	1
This will be very helpful	1
This will make all dynamic	1
This will make multiple versions	1
This will make any call	1
This will make applications run	1
This will generate relative addresses	1
This will prevent the compiler	1
This will enable the compiler	1
This will allow the compiler	1
This will happen if the	1
This will provoke an error	1
This memory space is freed	1
This data conversion and shuffling	1
This has the advantage that	2
This has the disadvantage that	2
This has a very dramatic	1
This has a long dependency	1
This has a significant effect	1
This has three advantages: The	1
This has hardly any effect	1
This has influence on the	1
This instruction set is supported	1
This instruction set is maintained	1
This instruction set was originally	1
This loop repeats 20 times	1
This loop calculates four consecutive	1
This should be taken into	1
This example is specific to	1
This pointer is 4 bytes	1
This library has a CPU	1
This library has reduced performance	3
This library contains many useful	1
This also makes testing and	1
This also applies to the	1
This makes the code more	1
This makes the use of	1
This makes a critical dependency	1
This makes it possible to	2
This makes it easier for	1
This makes function calls more	1
This makes code caching and	1
This makes data caching more	2
This makes data caching less	3
This makes data caching inefficient.	2
This makes sure that the	3
This makes operations with Boolean	1
This makes inlining more efficient	1
This makes position- independent code	1
This new insight can lead	1
This method is faster because	1
This method is useful for	2
This method is useful if	1
This method is explained on	1
This method is advantageous if	1
This method is described in	1
This method is described below.	1
This method is inefficient, however,	1
This method is illustrated in	1
This method can be used	1
This method can be extended	1
This method may be faster	1
This method also involves the	1
This method works with all	1
This method requires that you	1
This method requires OS support	1
This extra check on b	1
This extra cost is seen	1
This does not fit into	1
This does not solve all	1
This large memory model is	1
This processor has four physical	1
This option makes the code	1
This option makes the assembly	1
This works in the following	1
This works in the main	1
This works by compiling in	1
This manual is for advanced	1
This manual is based on	1
This manual is based mainly	1
This manual does not cover	1
This manual discusses how to	1
This calculation requires n-1 multiplications,	1
This check makes dynamic_cast more	1
This problem can be solved	1
This problem has been alleviated	1
This solution is clearly better.	1
This solution can incur a	1
This advantage comes automatically. There	1
This would not only be	1
This would double the number	1
This would require two floating	1
This structure or class should	1
This standard is used in	1
This information is contained in	1
This above code will fail	1
This typically takes one clock	1
This typically happens if the	1
This allows the compiler to	2
This allows it to begin	1
This allows common subexpression elimination	1
This expression is calculated as	1
This implementation uses a lookup	1
This needs a little explanation.	1
This conversion takes no extra	1
This cost is minimized if	1
This mechanism is also used	1
This means that the value	1
This means that a must	1
This means that a particular	1
This means that it is	1
This means that if a	1
This means that if each	1
This means that all the	1
This requires a compiler with	1
This requires that you analyze	1
This requires no modification of	1
This framework typically uses much	1
This results in meaningless event	1
This feature is intended for	1
This feature uses an ordinary	1
This section discusses how to	1
This index must be multiplied	1
This gives a measure that	1
This operation will then be	1
This task must have a	1
This prevents the compiler from	2
This prevents the CPU from	2
This prevents it from making	1
This alignment can cause holes	1
This effect can be illustrated	1
This so-called virtual table is	1
This so-called symbol interposition is	1
This includes the libraries named	1
This includes static variables, floating	1
This includes pointers and references,	1
This includes languages such as	1
This delay is just long	1
This chapter is aiming at	1
This garbage collection may start	1
This penalty should be avoided	1
This gain in performance can	1
This series of five manuals	1
This applies to reading as	1
This applies to default constructors,	1
This tool is not a	1
This tool can make two	1
This principle is useful whenever	1
This happens when a task	1
This tells the compiler that	1
This enables the compiler to	2
This enables interprocedural optimizations. The	1
This non-inlined copy is dead	1
This unit-testing is necessary for	1
This normally belongs to the	1
This reordering has made the	1
This removed the contentions and	1
This wasteful behavior can be	1
This reflects the order in	1
This reduces the code to:	1
This safety problem can be	1
This worked sufficiently fast on	1
This technique is illustrated in	1
This dilemma can be solved	1
This fragmentation of the code	1
This ends the recursion template<>	1
This corresponds to 16 lines	1
This closely follows the mathematical	1
This behaviour is implementation dependent.	1
This requires, of course, that	1
This triangle is handled separately:	1
This '1' is not included	1
- a & a =	1
- a & -1 =	1
- a & ~a =	1
- a & 0= 0	1
- a | -1 =	1
- a ^a = 0	1
- to make a piece	1
- in terms of development,	1
- - - - -	28
- - - - x	12
- - - - n.a.	5
- - - - x-xx----x	1
- - - x -	7
- - - x x	6
- - - x 74	1
- - - n.a. n.a.	5
- - - xxxxxxxxx --	1
- - - x-xx----x x-xxxxxx-	1
- - - 76 Boolean	1
- - x - -	10
- - x - x	5
- - x x -	3
- - x x x	7
- - x x Loop	1
- - x 74 x	1
- - n.a. n.a. -	29
- - n.a. n.a. x	3
- - Integer XMM (vector)	1
- - xxxxxxxxx -- -	1
- - x-xx----x x-xxxxxx- x-xxxx-x-	1
- - 76 Boolean XMM	1
- x - - -	10
- x - - x	5
- x - - n.a.	4
- x - x -	4
- x - x x	4
- x x - -	5
- x x - x	7
- x x x -	3
- x x x x	20
- x x x x-	1
- x x Loop invariant	1
- x 74 x x	1
- no need to link	1
- n.a. - - -	5
- n.a. - x -	3
- n.a. - n.a. -	2
- n.a. - n.a. x	2
- n.a. x x -	2
- n.a. x n.a. -	1
- n.a. x n.a. x	1
- n.a. n.a. - a	6
- n.a. n.a. - -	21
- n.a. n.a. - Table	1
- n.a. n.a. - (a&b)|(a&c)	1
- n.a. n.a. - a<<b<<c	1
- n.a. n.a. - a+b+c	1
- n.a. n.a. - andnot(a,a)	1
- n.a. n.a. x -	3
- n.a. Floating point XMM	1
- n.a. -(-a) = a	1
- n.a. a-a = 0	1
- n.a. x*x*x*x*x*x*x*x = ((x2)	1
- n.a. a+b = b+a,	1
- n.a. a*0 = 0	1
- n.a. a*1 = a	1
- n.a. a+0 = a	1
- n.a. a*b+a*c = a*(b+c)	1
- n.a. !(a < b)	1
- n.a. (-a)*(-b) = a*b	1
- n.a. (a+b)+c = a+(b+c)	1
- n.a. a+a+a+a = a*4	1
- there is no difference	1
- 2 clock cycles in	1
- 4 clock cycles on	1
- 8 clock cycles. Division	1
- 64 Kbytes and a	1
- they are guaranteed to	1
- 16 clock cycles, depending	1
- Integer XMM (vector) reductions:	1
- preferably isolated into a	1
- 1; } } The	1
- 1; } } Loop	1
- Table 8.1. Comparison of	1
- 10 clock cycles, depending	1
- 5 clock cycles to	1
- 100 clock cycles. The	1
- 2, x = 2.0;	1
- 20 clock cycles later	1
- 20 clock cycles. The	1
- 6 clock cycles, depending	1
- reciprocal n.a. - n.a.	1
- x-xxxx--x x-xxxx--x x-xx----- x--x-----	1
- 80 clock cycles for	1
- 80 clock cycles, depending	1
- xxxxxxxxx -- - xx	1
- -(-a) = a -	1
- 5. www.amd.com. 163 Internet	1
- 45 clock cycles. Floating	1
- 45 clock cycles). Floating	1
- a-a = 0 -	1
- Divide by constant =	1
- 30 // f is	1
- ----- x---- x---- -----	1
- 25 clock cycles, depending	1
- a*0 = 0 -	1
- a*1 = a -	1
- time1; // This is	1
- a+0 = a -	1
- (time before) } printf("\nResults:");	1
- vectorclass www.agner.org/optimize/#vectorclass. The Intel	1
- a*b+a*c = a*(b+c) -	1
- 0/a = 0 -	1
- (a&b)|(a&c) = a&(b|c) -	1
- masm=intel /FA -S Generate	1
- a<<b<<c = a<<(b+c) -	1
- x-xxx - xx(-)x- -	1
- min) <= (unsigned int)(max	1
- a/1 = a -	1
- a+b+c = a+(b+c) -	1
- xx x x- x	1
- x-xx----x x-xxxxxx- x-xxxx-x- x-xxxxxxx	1
- andnot(a,a) = 0 -	1
- xx(-)x- - x-xxxx--x x-xxxx--x	1
- 2014. Last updated 2014-08-07.	1
- 8*x + 2 return	1
- 76 Boolean XMM (vector)	1
- min)) { ... There	1
- 8.0f) * x +	1
an int is 32 bits,	1
an int is 4. So	1
an int uses more bits	1
an instruction that the CPU	1
an instruction set that is	1
an integer is within a	1
an integer is added to	1
an integer of a specific	1
an integer to a smaller	1
an integer to zero is	1
an integer in the interval	1
an integer in one operation.	1
an integer in disguise. Enums	1
an integer that holds a	1
an integer can be converted	1
an integer if the length	1
an integer if it is	1
an integer with a constant	1
an integer because the integer-to-float	1
an integer size that is	1
an integer takes a very	1
an integer variable by a	1
an integer constant with its	1
an integer known at compile	1
an integer counter and using	1
an integer addition, a floating	1
an integer variable, it makes	1
an integer comparison, which is	1
an integer constant, unless the	1
an example of how to	3
an example in the "Macro	1
an Intel function library then	1
an Intel before it checks	1
an Intel Pentium 4. Even	1
an Intel compiler, then make	1
an Intel CPU. See page	1
an Intel processor. The CPU	1
an object is copied by	1
an object is moved, which	1
an object of the class.	1
an object of the derived	2
an object of a simple	1
an object of a derived	1
an object of class C1,	1
an object of known type,	1
an object to a function	1
an object that behaves like	1
an object by *p or	1
an object with new and	1
an object It is possible	1
an object file disassembler. Note	1
an object must be dynamically	1
an object through a smart	1
an object after it has	1
an object oriented programming style	1
an efficient way of keeping	1
an efficient solution. Is searching	1
an efficient solution. Sort the	1
an array of structure or	1
an array of thousand numbers	1
an array of structures: //	1
an array to all zeroes.	1
an array to zero. The	1
an array and for more	1
an array can cause other	1
an array or the number	1
an array or setting an	1
an array with bounds checking,	1
an array element if the	1
an array index is out	1
an array index than when	1
an array index then it	1
an array element. In some	1
an array index. The data	1
an array grows during program	1
an address divisible by the	1
an address divisible by 8	1
an address divisible by 16.	1
an address divisible by 8.	2
an address below 2 GB,	1
an operating system this is	1
an operating system. The best	1
an unsigned int or by	1
an unsigned integer and this	1
an unsigned integer takes longer	1
an unsigned variable produces a	1
an even faster way to	1
an error can return with	1
an error if the index	1
an error code if possible,	1
an error code which the	1
an error then there is	1
an error simply by performing	1
an error message and stop	1
an error message in a	1
an error message in this	1
an error message if it	1
an error message when it	1
an error condition terminates the	1
an error handler calls exit(),	1
an error message. It is	1
an important part of the	1
an important distinction between the	1
an extra cache for the	1
an extra register to hold	1
an extra register available for	1
an extra cost whenever a	1
an extra framework can consume	1
an extra iteration that has	1
an extra level of abstraction	1
an extra jump through a	1
an extra dummy element to	1
an extra layer of a	1
an assembly language output, which	1
an assembly output option then	1
an assembly listing. Use the	1
an execution unit. For example,	1
an element in list, the	1
an exception in case of	2
an exception or other error	1
an exception then F1 has	1
an exception without using the	1
an exception occurs in the	1
an exception occurs somewhere in	1
an overflow and give the	1
an overflow or another error	1
an overflow check. There are	1
an option for source annotation	1
an option for whole program	1
an option for assuming no	1
an option for RTTI then	1
an option for "standard stack	1
an option that allows less	1
an option (Windows: /Gy, Linux:	1
an optimized function, but unfortunately	1
an advantage to using hyperthreading,	1
an advantage to unroll a	1
an advantage in the select	1
an advantage in applications that	1
an advantage if the threads	1
an advantage because integer operations	1
an inline function instead of	1
an inline assembly instruction for	1
an optimizing compiler can replace	1
an optimizing compiler can see	1
an optimizing compiler will see	1
an optimizing compiler will change	1
an optimizing compiler would assume	1
an intermediate code is that	2
an intermediate code and just-in-time	1
an intermediate code like the	1
an intermediate code (byte code).	1
an intermediate code. The reason	1
an intermediate file format instead	1
an intermediate code, which is	1
an optimal solution because the	1
an application to a different	1
an application program without invoking	1
an expression that should not	2
an expression or an anonymous	1
an induction variable because it	1
an induction variable unless the	1
an induction variable. The compiler	1
an && expression, or first	1
an addition to sum1 from	1
an addition with another vector	1
an || expression. Assume, for	1
an Intel, even if the	1
an Intel, AMD or VIA	1
an old computer with a	1
an appropriate error message and	1
an advanced and complicated algorithm	1
an advanced high-level language with	1
an unused copy of an	1
an unused fourth value to	1
an STL vector turned up	1
an STL container are allowed	1
an index of memory blocks.	1
an index multiplied by a	1
an inefficient way. See page	1
an instance of the class	1
an output file. A console	1
an inlined function. The static	1
an inlined 15.1b and the	1
an algorithm of sequential instructions,	1
an offset that is coded	1
an operand is infinity or	1
an unknown CPU based on	1
an overloaded function are simply	1
an overloaded operator is exactly	1
an overloaded assignment operator, or	1
an entire cache line to	1
an executable file stub. If	1
an input file. The output	1
an explanation of this option.	1
an explanation of return prediction).	1
an explanation of branch prediction.	2
an explanation of register stack	1
an explanation and possible workaround.	1
an integer, and this pointer	1
an integer, or an integer	1
an integer, then you can	1
an integer, so that the	1
an integer, usually 32. In	1
an interrupt should preferably be	1
an interrupt occurs in each	1
an arithmetic expression. The size	1
an array. The values are	1
an update when the next	1
an integer. The compiler does	1
an integer. If a loop	1
an integer. But the &	1
an integer. 158 Integer variables	1
an equal amount of work	1
an 9 extra overhead which	1
an int, without specifying the	1
an obvious thing to do.	1
an excessive number of function	1
an excessive number of separate	1
an excessive number of DLLs,	1
an increasing number of purposes	1
an increasing number of devices	1
an explanation. Note that these	1
an explanation. (The Microsoft compiler	1
an explanation. Please skip the	1
an exception. The costs of	1
an exception. A frame function	1
an exception. Therefore, you should	1
an additional integer counter. Example:	1
an additional floating point variable:	1
an example. The only allowed	1
an example. A union can	1
an example. My example is	1
an appendix to this manual	2
an empty throw() statement can	1
an empty throw() specification. The	1
an IDE. Does not optimize	1
an IDE. Free trial versions	1
an extended number of bits.	1
an underflow and give the	1
an assumption is that the	1
an uncached read because the	1
an existing object rather than	1
an existing program. Weighing the	1
an explicit CPU dispatching in	1
an explicit induction variable. (This	1
an implicit parameter to the	1
an implicit 'this' pointer which	1
an 8-bit signed number. If	1
an 8-bit signed number, or	1
an inferior version on the	1
an arbitrary memory address and	1
an arbitrary cache line. Only	1
an arbitrary name that the	1
an FPGA in the same	1
an FPGA as a so-called	1
an error. // You may	1
an addition. If the size	1
an addition. Comparing two pointers	1
an unfortunate method that delays	1
an approximate comparison of doubles	1
an annoying time consumer to	1
an up-to-date function library that	1
an up-to-date version. The CPU	1
an initialization routine that is	1
an initialization routine that loads	1
an issue because an optimizing	1
an odd number then we	1
an insufficient amount of RAM,	1
an import table and possibly	1
an import table or a	1
an anonymous object. The compiler	1
an anonymous namespace. 3. The	1
an infinite loop. The effect	1
an immediate response to pressing	1
an array, or approximately so.	1
an interpreter for Basic. A	1
an interpreter which interprets the	1
an EMMS instruction before any	1
an obstacle to vectorization. The	1
an IDE with many of	1
an update, or update automatically	1
an acceptable limit, then you	1
an over- loaded type casting	1
an integral number of vectors.	1
an MFC application. The development	1
an attribute which can be	1
an imported pointer, but this	1
an ordinary procedure linkage table	1
an if-else structure), the microprocessor	1
an estimated calculation time of	1
an illegal operation that crashes	1
an hour. Neither is it	1
an unrecoverable error without using	1
an antivirus program that scans	1
an n'th degree polynomial of	1
an integer). All intermediate results	1
an interrupt, e.g. every millisecond.	1
an error; and make appropriate	1
int is 16 bits wide,	1
int is 32 bits, so	1
int is 4. So the	1
int a = Func1(2); ...	1
int in the critical part	1
int in one vector, while	1
int in 16-bit systems: int	1
int in 16-bit systems: long	1
int in 16-bit systems: unsigned	2
int or by type-casting i	1
int if (i >= N)	1
int int 256 unsigned 256	1
int x = 2 *	1
int x = 10; Templates	1
int one : 1; //	1
int size = 100; //	1
int size = 100; int	1
int size = 100; float	2
int size = 100; S1	1
int size = 256; //	1
int size = 16; int	1
int size = 1000; int	1
int size = 1000; float	1
int size = 1024; int	2
int size = 1024; struct	1
int i = 0; //	1
int * p) { int	1
int * __restrict bb) {	1
int before dividing by 2	1
int 4 AVX _mm256_permutevar_ps 4	1
int 4 AVX2 _mm256_i32gather_epi32 unlimited	1
int 8 AVX2 _mm_i32gather_epi32 unlimited	1
int 8 AVX2 _mm_i64gather_epi32 unlimited	1
int unsigned int 64 Is32vec2	1
int unsigned char 8 0	1
int 64 0 264-1 uint64_t	1
int 64 Is32vec2 32 64	1
int 64 Is16vec4 16 4	1
int 64 Iu16vec4 32 2	1
int 16 4 64 MMX	1
int 16 8 128 SSE2	1
int 16 16 256 AVX2	1
int 16 0 65535 uint16_t	1
int 16 -32768 32767 int16_t	1
int 32 2 64 MMX	1
int 32 4 128 SSE2	1
int 32 8 256 AVX2	1
int 32 16 512 AVX512	1
int 32 -231 231-1 int32_t	1
int & r) { int	2
int i; for (i =	6
int i; if ((unsigned int)i	1
int i; int Induction =	1
int i; } x; x.f	1
int i; } u; if	1
int i; } u; int	2
int i; } u; u.i	2
int i; } u, v;	2
int i; float x; for	1
int i; float f; f=i;	1
int i; float a[size], b[size];	1
int i; float a[size], b[size],	1
int i; float list[size]; ...	1
int i; float i2; for(i=0,i2=0;	1
int i; long long time1;	1
int i; const int ARRAYSIZE	1
int i; short int s;	2
int i; ... for (i	1
int i; ... if (i	1
int i; ... list[i &	1
int i; p = p	1
int i; for(i=0; i<300; i++){	2
int i; for(i=0; i<300; i+=3){	1
int i; for(i=0; i<100; i++)a[i]=2*i;	1
int i; for(i=0; i<301; i+=3){	1
int i; 45 for (i	1
int i; 84 for (i	1
int a, b; a =	2
int a, b; double c;	1
int a, b, c; a	2
int a, b, c; b	1
int a, b, c; ...	2
int a, b, c, temp;	1
int 128 Is16vec8 Vec8s 16	1
int 128 Iu32vec4 Vec4ui 64	1
int 128 Is32vec4 Vec4i 32	1
int 128 Iu16vec8 Vec8us 32	1
int uses more bits than	1
int b; a = (b	1
int b; // 4 bytes.	1
int b; int c; int	1
int b; int c;}; abc	1
int b; int Sum1() {return	1
int b; static const float	1
int sign : 1; //	1
int sign :1;//signbit }; struct	2
int 256 unsigned 256 int	1
int c; int UnusedFiller; };	1
int c; }; Replace with:	1
int c; }; 7.23 Constructors	1
int instead of int. A	1
int x; for (x =	1
int x; const double A2	1
int x; public: c1() :	1
int b, c; x[0] =	1
int i, a, b; //	1
int i, sum = 0;	1
int i, f = 1;	1
int i, a[100]; for (i	1
int i, i_div_3; for(i=i_div_3=0; i<300;	1
int i, j; int order(int	1
int i, j; float x;	1
int i, j; ... for	1
int i, a[100], b; for	1
int i, a[100], b, temp;	1
int i, a[100], temp; temp	1
int i, StringLength; for (i	1
int i, a[2]; for (i	1
int i, largest_index = 0;	1
int a; // 2 bytes.	1
int a; int b; int	2
int a; double b; int	1
int a; Plus2 (&a); The	1
int d; // 2 bytes.	1
int d; // 4 bytes.	1
int exponent : 8; //	1
int exponent : 15; //	1
int exponent : 11; //	1
int rows = 20, columns	2
int rows = 10, columns	1
int level = InstructionSet(); //	2
int u; double d; d	3
int CriticalFunction (); __asm__ (".type	1
int fraction : 23; //	1
int fraction : 52; //	1
int fraction : 63; //	1
int declaration may in some	1
int 3; or __asm ("int	1
int n; static char const	1
int n; switch (n) {	1
int n; #if defined(__unix__) ||	1
int n; u.i = (n	1
int n; 143 if (u.i	1
int factorial (int n) {	2
int bb[], short int cc[])	8
int bb[], short int cc[]);	1
int aa[], short int bb[],	9
int cc[]) { for (int	1
int cc[]) { // Make	3
int cc[]) { // go	1
int cc[]) { // Define	1
int cc[]) { // Detect	1
int cc[]) { Vec16s a,	1
int a[100]; // 400 bytes.	1
int a[100]; int i, sum	1
int Induction = r; for	1
int parm2) { // Get	1
int parm2) {...} // SSE2	2
int parm2) {...} // AVX	2
int parm2) {...} // Dispatcher.	1
int parm2) {...} // Prototype	1
int int64_t 256 uint64_t 256	1
int SomeFunction (int a, int	1
int SomeFunction (int a, bool	4
int SIZE = 512; //	2
int SIZE = 64; //	1
int a[size], b[size]; // ...	1
int a[size], b[size], i; ...	1
int list[300]; int i; for(i=0;	3
int list[300]; int i, i_div_3;	1
int Multiply (int x, int	1
int n) { double y	1
int s; s = (short	1
int s; 40 i =	1
int lrint (double const x)	2
int N> class powN {	1
int N> class SafeArray {	1
int r, c; for (r	2
int r, c; double temp;	2
int b;}; Sab ab[size]; int	1
int main() { int a,	2
int list[100]; Func1(list, &list[8]); }	1
int A, B, C; x.abc	1
int A, B, C; x.a	1
int (16 bits), unless the	1
int CriticalFunction_386(int parm1, int parm2)	2
int a[2]; a[0] = 1;	1
int b:2; int c:2; };	2
int MultiplyBy (int x) {	1
int c:2; }; char abc;	1
int c:2; }; Bitfield x;	1
int TILESIZE = 8; //	1
int Func(int); const int size	2
int a[1000]; float b[1000]; };	1
int a[1000]; F1(a); } else	1
int CriticalFunction_SSE2(int parm1, int parm2)	2
int lrintf (float const x)	1
int ArraySize = 1000; int	1
int ABC = 123; are	1
int parm2); // Function prototype	1
int NumberOfTests = 10; int	1
int min = 100, max	1
int Func2() { int a	1
int order(int x); const int	1
int order(int x); 136 ...	1
int a:4; int b:2; int	2
int ARRAYSIZE = 100; float	1
int FactorialTable[13] = {1, 1,	2
int CriticalFunction_AVX(int parm1, int parm2)	2
int matrix[NUMROWS][NUMCOLUMNS]; int row, column;	1
int CriticalFunctionType(int parm1, int parm2);	1
int Sum2(S3 * p) {return	1
int c;}; abc * p;	1
int dummy; double a[arraysize], b[arraysize],	1
int row, column; for (row	1
int Sum3(S3 & r) {return	1
int r1, r2, c1, c2;	1
int BigArray[1024] __attribute__((aligned(64))); // Linux	1
int FuncRow(int); int FuncCol(int); const	1
int bb[size] ); Alignd (	1
int NUMROWS = 100, NUMCOLUMNS	1
int UnusedFiller; }; int order(int	1
int List[ArraySize]; ... for (int	1
int Func1(int x) { return	1
int absvalue, largest_abs = 0;	1
int BigArray[1024]; // Windows syntax	1
int cc[size] ); // Function	1
int u[2]} a[size]; unsigned int	1
int m) { return x	1
int arraysize = 1000; unsigned	1
int CriticalFunction_Dispatch(int parm1, int parm2)	1
int x[]) { int b,	1
int DontSkip; long long clock;	1
int list[301]; int i; for(i=0;	1
int c1::*MemberPointer; Here, the compiler	1
int Size() { return N;	1
int ReadB() {return b;} };	1
int iset = instrset_detect(); 116	1
int aa[size] ); // Make	1
int 832 256 16 16	1
int Sum1() {return a +	1
int i[2]; } u; if	1
int dummy[4]; volatile int DontSkip;	1
int FuncCol(int); const int rows	1
int seconds; // incremented every	1
int cc[]); // function prototypes	1
than the function add_horizontal) static	1
than the code itself. Another	1
than the time it takes	3
than the time you would	1
than the program itself when	1
than the vector register size.	1
than the CPU supports then	1
than the other then put	1
than the one it is	1
than the cache then you	1
than the cache size. When	1
than the cache size. Alternatively,	1
than the library that comes	1
than the number of CPU	1
than the number of cores	1
than the variable m. The	1
than the table lookup. Lookup	1
than the 32-bit version. The	1
than the user interface. It	1
than the simple function because	1
than the Gnu compiler mechanism	1
than the speed of RAM	1
than the specific event it	1
than the hardware implementation in	2
than the programs they are	1
than the application itself and	1
than the complicated address calculation	1
than the Boolean operators because	1
than the intrinsic hardware functions.	1
than the runtime polymorphism that	1
than the parts of the	1
than the main memory and	1
than the level-2 cache and	1
than the level-1 data cache	1
than the alternative version. The	1
than the subsequent times because	1
than the subsequent counts. This	1
than the throughput (see p.	1
than the largest available register	1
than the actual calculations. This	1
than the equivalent if(!(a ||	1
than the C-style type-casting without	1
than the product makes sure	1
than the external clock. This	1
than the heap. The space	1
than the destination array. But	1
than the ones mentioned in	1
than the other, then put	1
than a function template because	1
than a function parameter is	1
than a program where the	1
than a floating point comparison.	1
than a static library, except	1
than a simple type casting,	1
than a thread that runs	1
than a small piece at	1
than a few lines should	1
than a few lines. A	1
than a few kilobytes at	1
than a hardware implementation of	1
than a certain tolerance. The	1
than a frame function because	1
than a linear array for	1
than a non-static member function	2
than a hundred clock cycles	1
than a dedicated test server.	1
than a dedicated microprocessor and	1
than a float. (Both use	1
than a polymorphous class? This	1
than a minute if the	1
than to use this complicated	1
than to access it the	1
than to type in the	1
than to calculate the value	1
than to store each object	1
than to write the members	1
than to write _mm_add_epi16(a,b). Two	1
than to execute it. The	1
than to allocate a small	1
than to delete it and	1
than to draw each pixel	1
than to temporarily lock a	1
than in the big registration	1
than in a static link	1
than in a register and	1
than in a microprocessor because	1
than in a register. The	1
than in a PC. Nevertheless,	1
than in other programming languages,	1
than in 64-bit Windows (See	1
than in 64-bit Windows. The	1
than in 64-bit Windows. In	1
than in 32-bit mode, and	1
than in 32 bit mode.	1
than in optimizing application-specific code.	1
than in memory. Function parameters	1
than for double precision. But	1
than for level-1 cache contentions	1
than for auto_ptr. Smart pointers	1
than it is on a	1
than it is intended for.	1
than it can handle. Waiting	1
than it used to be.	1
than it takes to call	1
than it actually is. This	1
than it says. A code	1
than if the data are	1
than if the operands are	1
than if because #if is	1
than by the loop control	1
than by the processing power.	1
than by the latency or	1
than by a macro, but	1
than by using assembly language	1
than by pointers or references.	1
than by optimizing the first	1
than by 16. This is	1
than by individual installation tools.	1
than with unsigned integers (see	1
than with fine-grained parallelism because	1
than on the stack (three	1
than on the stack. This	2
than on the stack. A	1
than on the stack). ecx	1
than on the essential task	1
than on floating point expressions.	1
than code generality. The most	1
than as a linked list.	1
than as b*(2.0/3.0) unless you	1
than an uncached read because	1
than an MFC application. The	1
than an hour. Neither is	1
than x = -abs(x);. There	1
than x = *(++p) because	1
than x = array[++i] because	1
than when a fixed-size array	1
than when compiled with -fpic	1
than when n is a	1
than from the loop counter.	1
than from floating point to	1
than memory access and cache	1
than at runtime if all	1
than at runtime. Example 7.43	1
than CPU time. Another disadvantage	1
than other CPUs for executing	1
than other methods of rounding,	1
than other languages that do	1
than other kinds of storage.	1
than other CPUs, but it	1
than one variable if their	1
than one way in the	1
than one call to the	1
than one line at a	1
than one instance of the	1
than one thing at the	1
than integer comparisons. The solution	1
than floating point operations. You	1
than floating point expressions, even	1
than each time the function	2
than example 12.4a, depending on	1
than most other libraries when	1
than using a ready-made profiler.	1
than double if the code	1
than double precision when the	1
than two 32-bit integers to	1
than two ways. Switch statements	1
than static memory. If you	1
than static link libraries. These	1
than 64-bit Windows if functions	1
than there are objects in	1
than there is, in order	1
than any non-vector library. 119	1
than 2 gigabytes of data.	1
than 2 GB. When considering	1
than 32-bit programs if there	1
than pointers to objects) are	1
than pointers because in most	1
than pointers are: The syntax	1
than 16 bytes should be	1
than 32 bits. This makes	1
than dynamic linking are: Static	1
than 0 and 1. The	1
than 0 and 1. Note	1
than 0 or 1 (see	1
than 0 or 1. The	1
than 0 or 1. This	1
than 0 or 1. See	1
than 0 or 1, but	1
than type casting of pointers	1
than short int (16 bits),	1
than making a new one.	1
than making a separate thread	1
than making it count up	1
than its name at the	1
than its brand, family and	1
than its reputation. The compactness	1
than processor features. The programmer	1
than single precision. When the	1
than done to choose the	1
than 128 because the offset	1
than four parameters. There is	1
than functions. See page 49	1
than doing arithmetic operations. The	1
than standard PCs. The clock	1
than optimizing CPU use in	1
than Boolean expressions. There are	1
than signed when you divide	1
than signed integers. It is	1
than division by a variable	1
than division by a variable.	1
than end users have. The	1
than addition and subtraction (3	1
than needed in order to	1
than last time. Newer processors	1
than linked lists in most	1
than calling the function directly	1
than references are: When you	1
than C if you follow	1
than intended because of a	1
than frame functions for reasons	1
than accessing a member of	1
than accessing a simple variable.	1
than processing the data in	1
than needed. This makes data	1
than mov eax,0. The loop	1
than reading or writing a	1
than reading or writing small	1
than calculating the logarithm again,	1
than future processors. Consider the	1
than seconds or microseconds as	1
than 65 bytes of code).	1
than finding the most efficient	1
than addition, subtraction and multiplication	2
than once then the compiler	1
than 8, 16, 32 and	1
than multiplying by other constants	1
than random access. Reading or	1
than rounding unless the SSE2	1
than 127 bytes is slightly	1
than speed. This includes languages	1
than normal on some microprocessors	1
than half the single-thread speed.	1
than half speed because of	1
than comparing it to any	1
than comparing i with 100	1
than truncation when the SSE2	1
than anything else on a	1
than third party security software.	1
than pow The method used	1
than 250 ms. If the	1
than necessary. Take the example:	1
than two. Some compilers will	1
than 2n and not negative	1
than another. Therefore, it can	1
than RISC in situations where	1
than moving each object separately	1
than allocating more space 91	1
than allocating piecewise or re-	1
than "what works best on	1
than post-increment. For example, in	1
than Sum2 and Sum3 in	1
than generating denormal numbers in	1
than rounding. This is unfortunate	1
than PCs. Therefore, it is	1
than loops, etc. Optimizing database	1
than 1.23456. The conclusion to	1
than 99% of the time	1
than normal. This happens when	1
than normal. 157 17 Optimization	1
than relocation, especially in 32-bit	1
than sequences of operations. A	1
than non-virtual functions. Avoid virtual	1
than 231. This extra cost	1
than 1/50 of the time	1
than 2-20, but this is	1
than ARRAYSIZE. Another example: //	1
than 1% goes to actually	1
than 20. The fact that	1
than investing in a big	1
than nine, even though it	1
than 200. Next, we are	1
than rendering graphics on the	1
than looping through a linear	1
than log) inside the critical	1
than others. While some of	1
than -156. Surprisingly, we end	1
than 33% when the CPUID	1
than non-object oriented programs. If	1
than 15.1b, and in this	1
than isolating a single function.	1
than self-styled hacks and direct	1
than normally. There are various	1
than doubled for this task	1
compiler is a very good	1
compiler is a good choice	3
compiler is that the compiled	1
compiler is not always able	1
compiler is more likely to	1
compiler is less efficient than	1
compiler is available for many	1
compiler is available for free	1
compiler is likely to use	1
compiler is able to do	1
compiler is able to inline	1
compiler is usually not able	1
compiler is used, then use	1
compiler is prevented from assuming	1
compiler is unable to predict	1
compiler is unable to vectorize	1
compiler is mostly compatible with	1
compiler is capable of making	1
compiler to the value 0x2C	1
compiler to be able to	1
compiler to make more efficient	1
compiler to make register variables	1
compiler to do and which	1
compiler to do more reductions	1
compiler to do any algebraic	1
compiler to do interprocedural optimizations	1
compiler to do cross-module optimizations	1
compiler to always behave according	1
compiler to work on a	1
compiler to inline the function	1
compiler to store x in	1
compiler to optimize code that	1
compiler to optimize register allocation	1
compiler to optimize away the	1
compiler to optimize away an	1
compiler to assume that F1	1
compiler to assume no pointer	1
compiler to reduce example 12.1b	1
compiler to reduce complicated algebraic	1
compiler to predict with certainty	1
compiler to evaluate whether it	1
compiler to ignore overflow or	1
compiler to vectorize, or #pragma	1
compiler and the Intel compiler	1
compiler and it understands only	1
compiler and call it from	1
compiler in the following way:	1
compiler in many respects and	1
compiler in favor of Intel	1
compiler for 32-bit Windows, including	1
compiler for 32-bit Windows. Does	1
compiler for 32-bit Windows. Integrates	1
compiler for Windows and the	1
compiler for Windows applications. The	1
compiler for Linux have an	1
compiler for Mac OS X	1
compiler for Windows, while most	1
compiler for 32- and 64-bit	2
compiler for Basic soon became	1
compiler for restrictions on using	1
compiler for Unix applications and	1
compiler that the function cannot	1
compiler that the arrays are	1
compiler that a specific pointer	1
compiler that can do whole	1
compiler that you want this	1
compiler that this is a	1
compiler that automatically reduces example	1
compiler that supports automatic vectorization,	1
compiler can use the same	2
compiler can use this library	2
compiler can then use this	1
compiler can make this reordering	1
compiler can do and what	1
compiler can also use vector	1
compiler can often optimize the	1
compiler can optimize away the	1
compiler can optimize specifically for	1
compiler can replace a function	1
compiler can replace an integer	1
compiler can replace all occurrences	1
compiler can replace j *	1
compiler can automatically replace a	1
compiler can automatically generate multiple	1
compiler can see that the	2
compiler can look like and	1
compiler can insert nontemporal writes	1
compiler can align the arrays	1
compiler can easily optimize away	1
compiler can eliminate this jump	1
compiler can eliminate common subexpressions	1
compiler can bypass the virtual	1
compiler can safely assume that	1
compiler // Same as example	1
compiler if the uses of	1
compiler by including the library	1
compiler with the application. The	1
compiler with other compilers or	1
compiler with many features, but	1
compiler with C++0x support. Make	1
compiler on the Mac platform,	1
compiler not to vectorize. The	1
compiler may in some cases	2
compiler may be able to	1
compiler may not be able	3
compiler may not take the	1
compiler may avoid the multiplication	1
compiler may calculate it only	1
compiler may replace the call	1
compiler may replace this by	4
compiler may actually add extra	1
compiler may reduce this to:	2
compiler may change the expression	1
compiler may change this to:	1
compiler may try to do	1
compiler may reorder instructions for	1
compiler may report that memset	1
compiler may interleave the two	1
compiler you are using and	1
compiler you will notice that	1
compiler have been replaced by	1
compiler when called from a	1
compiler A feature called "Gnu	1
compiler will make only one	1
compiler will do the best	1
compiler will always select the	1
compiler will calculate (1./1.2345) at	1
compiler will store the table	1
compiler will optimize this loop	1
compiler will replace this by	1
compiler will see that p	1
compiler will choose the variables	1
compiler will change the code	1
compiler will produce the optimal	1
compiler will convert example 15.1b	1
compiler will convert example 12.8a	1
compiler will convert these types	1
compiler will vectorize the code	1
compiler will vectorize a loop	1
compiler will recognize that the	1
compiler from the command line	1
compiler from making a non-inlined	1
compiler from making an induction	1
compiler from making an unused	1
compiler from making optimizations that	1
compiler from doing the optimizations	1
compiler from doing optimizations on	1
compiler from aligning the data	1
compiler at compile time. No	1
compiler has to use the	1
compiler has to make a	1
compiler has to take extra	1
compiler has not noticed that	1
compiler has an option for	2
compiler has no information about	1
compiler has some support for	1
compiler has replaced i by	1
compiler has chosen for the	1
compiler has solved this problem	1
compiler because it has many	1
compiler which is similar to	1
compiler should produce the same	1
compiler Intel compiler Windows Linux	1
compiler Intel compilers have a	1
compiler There are several different	1
compiler There are several factors	1
compiler takes the hint about	1
compiler takes care of this	1
compiler makes a distinction between	1
compiler cannot make floating point	1
compiler cannot know for sure	1
compiler cannot know that a	1
compiler cannot rule out the	2
compiler often inserts built-in code	1
compiler optimization than to use	1
compiler I have ever seen	1
compiler does not have its	1
compiler does not produce any	1
compiler does not allow vector	1
compiler does It can be	1
compiler does some things very	1
compiler does quite ingenious things	1
compiler does what you want	1
compiler does ............................................................................. 84 9	1
compiler must calculate its address.	1
compiler must convert it to	1
compiler (see page 103), but	1
compiler Windows Intel compiler Linux	2
compiler Windows Gnu compiler Linux	3
compiler Windows Linux __INTEL_COMPILER __INTEL_COMPILER	1
compiler versions were tested: Microsoft	1
compiler versions 7 through 14,	1
compiler doesn't have the necessary	1
compiler doesn't have to obey	1
compiler doesn't have an assembly	1
compiler doesn't have information about	1
compiler doesn't make such an	1
compiler doesn't need induction variables	1
compiler doesn't know the value	1
compiler doesn't know what class	1
compiler doesn't provide the best	1
compiler option for all modules	1
compiler option for assembly language	1
compiler option -fno-pic when compiling	1
compiler option -fno-pic apparently has	1
compiler option "assume no pointer	1
compiler Linux Intel compiler Intel	1
compiler Linux Intel compiler Windows	2
compiler Linux Align by 16	1
compiler Linux Optimize for speed	1
compiler works only for Intel	1
compiler manual for details. Use	1
compiler manual or in the	1
compiler uses a different implementation	1
compiler uses position-independent code and	1
compiler would be able do	1
compiler would assume that seconds	1
compiler optimize example 8.26a by	1
compiler allows you to use	1
compiler allows "__attribute__((visibility("hidden")))". Use whole	1
compiler needs to make a	1
compiler needs to look up	1
compiler mechanism because it makes	1
compiler optimizations that it is	1
compiler options to enable the	1
compiler options Table 18.1. Command	1
compiler #define Alignd(X) __declspec(align(16)) X	1
compiler supports this option only	1
compiler supports vector intrinsics, automatic	1
compiler supports CPU dispatching to	1
compiler supports intrinsic functions, but	1
compiler comes with some of	1
compiler output can often reveal	1
compiler sometimes uses 32-bit absolute	1
compiler reduced 15.1b to 15.1c,	1
compiler reduced 15.1a to an	1
compiler optimization. en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC TR	1
compiler includes standard function libraries.	1
compiler e.g. how often a	1
compiler might store the floating	1
compiler explicitly that pointers do	1
compiler itself is. The 64-bit	1
compiler generates the following assembly	2
compiler generates is to use	1
compiler generates to see how	1
compiler manual. This option makes	1
compiler .......................................................................................... 66 8.1 How	1
compiler combined with the LLVM	1
compiler additional information about a	1
compiler 8.1 How compilers optimize	1
compiler documentation for the size	1
compiler documentation for detailed instructions.	1
compiler inserts extra code at	1
compiler optimizes a piece of	1
compiler bypassing the dispatch mechanism	1
compiler packages include a profiler	1
compiler ......................................................................... 128 13.7 CPU	1
compiler ......................................................................... 130 14 Specific	1
compiler became available. It should	1
compiler .................................................................................................... 10 2.6 Choice	1
compiler warning for such optimizations	1
compiler sees the constant 8	1
compiler treat a variable or	1
compiler interpret the bits of	1
compiler recognizes it as a	1
compiler technology, and microprocessor microarchitecture.	1
compiler price GNU General Public	1
compiler puts the programmer in	1
compiler options....................................................................................... 160 19 Literature	1
compiler (parallel composer) This compiler	1
compiler ....................................................................... 77 8.4 Obstacles	1
compiler knows that it can	1
compiler makers assume that floating	1
compiler makers. 4. Instruction tables:	1
x is treated as an	1
x is type-casted to a	1
x to the power of	3
x to 0 // this	1
x and y?" then you	1
x in memory rather than	1
x The syntax may seem	1
x for approximately two clock	1
x can be read before	1
x // get next each	1
x // align table by	1
x // x^n // sum,	1
x = a + b	1
x = 2 * 5;	1
x = 10; Templates are	1
x = 2.0; i >=	1
x = *(p++) is more	1
x = -abs(x);. There are	1
x = *(++p) because in	1
x = array[++i] because in	1
x = array[i++] is more	1
x by using the |	1
x as an integer. The	1
x - - - -	11
x - - - x	2
x - - - xxxxxxxxx	1
x - - - 76	1
x - - x -	7
x - - x x	5
x - - n.a. n.a.	6
x - - Integer XMM	1
x - x - -	6
x - x - x	3
x - x x -	9
x - x x x	17
x - n.a. n.a. -	3
x - 8.0f) * x	1
x x - - -	4
x x - - x	7
x x - - n.a.	2
x x - - Integer	1
x x - x -	5
x x - x x	19
x x x - -	7
x x x - x	16
x x x x -	19
x x x x x	61
x x x x (x)	1
x x x x ((a*x+b)*x+c)*x+d	1
x x x x- x	3
x x x (x) x	1
x x x ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x	1
x x x -- -	1
x x Loop invariant code	1
x x x- x x	3
x x (x) x x	1
x x ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x =	1
x x -- - -	1
x when it returns. But	1
x + 1.0f;} The advantages	1
x + 1.0f;} 66 float	1
x + 2.0f; } 115	1
x n.a. - - -	1
x n.a. - n.a. -	1
x n.a. x x x	1
x n.a. x n.a. -	1
x n.a. Constant folding -	1
x * x + 1.0f;}	2
x * x; // x^2	1
x * m;} int a,	1
x * m;} template <int	1
x so we can store	1
x < 100; x++) {	2
x must wait until a	1
x > y && z	1
x Loop invariant code motion	1
x *= x; n >>=	1
x <= n; x++) factorial	1
x x- x x x	3
x x- x ----- -	1
x 43 speculatively executing instructions	1
x x-- x x-- x	1
x x-- x --- -	1
x ----- - x-xxx -	1
x (x) x x -	1
x (x) x (x) x-xx--xx-	1
x (x) x-xx--xx- x--x----- --xx-----	1
x ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x = ((x2)2)2	1
x 74 x x x	1
x -- - - -	1
x *const_cast<int*>(&x) += 2;} //	1
x *x; double x4 =	1
x --- - ----- x----	1
may of course make the	1
may in some cases be	2
may in some cases take	1
may in some cases ignore	1
may in fact be less	1
may be the one that	1
may be a better solution	1
may be a difference in	1
may be a binary tree	1
may be a hundred or	1
may be a viable compromise	1
may be a slight degradation	1
may be of some help	1
may be more efficient to	2
may be more convenient to	1
may be at a disadvantage	1
may be because the non-reduced	1
may be only one free	1
may be used for vectorized	1
may be used for reducing	1
may be used for metaprogramming,	1
may be used if elements	1
may be used as a	1
may be used as alternatives	1
may be used when a	1
may be no certain limit	1
may be two or three	1
may be possible to replace	1
may be possible to improve	1
may be so many unknown	1
may be so high that	1
may be faster than making	1
may be faster despite the	1
may be stored in a	1
may be called from another	1
may be called whenever an	1
may be useful to make	2
may be useful to copy	1
may be useful to roll	1
may be useful to isolate	1
may be useful for making	1
may be useful if the	1
may be cases where a	1
may be cases where it	1
may be necessary to replace	1
may be necessary to modify	1
may be advantageous to put	1
may be advantageous if the	1
may be able to do	1
may be able to avoid	1
may be able to predict	1
may be quite a good	1
may be fast in a	1
may be both cheaper and	1
may be optimal to mirror	1
may be optimal in special	1
may be three or four,	1
may be better to do	1
may be better to join	1
may be needed for communication	1
may be difficult to get	1
may be difficult to measure	1
may be bigger than the	1
may be just as fast	1
may be smaller as well.	1
may be replaced by more	1
may be loaded only when	1
may be given a false	1
may be inlined for improved	1
may be changed to a	1
may be enough to identify	1
may be situations where a	1
may be scattered around at	1
may be preferred to use	1
may be convenient to have	1
may be poor because it	1
may be completely unrolled to	1
may be obvious to the	1
may be swapped to the	1
may be necessary. If F1	1
may be preferable to keep	1
may be needed, however, if	1
may be selected during the	1
may be modified by the	2
may be removed after debugging	1
may be considered a container	1
may be moved out of	1
may be sufficient for less	1
may be freed before the	1
may be justified in case	1
may be worthwhile to unroll	1
may be undesired. Example: //	1
may be mitigated by making	1
may be caused by random	1
may as well use a	1
may as well specify the	1
may not be necessary to	1
may not be advantageous if	1
may not be able to	3
may not be optimal to	1
may not be compatible with	1
may not be safe to	1
may not be safe if	1
may not be worth the	2
may not be cached. This	1
may not be visible at	1
may not be optimally aligned.	1
may not take the hint,	1
may not need the updates	1
may not work on compilers	1
may not load all the	1
may not vectorize automatically. The	1
may have a function for	1
may have a reduced number	1
may have a larger memory	1
may have to be renewed.	1
may have to do a	1
may have to test several	1
may have to fix the	1
may have big endian storage	1
may have undesired effects. This	1
may use the Intel math	1
may use the upper 32	1
may use the _mm_clflush intrinsic	1
may use a sorted list	1
may use an object oriented	1
may use more resources than	1
may use double precision without	1
may use 64-bit integers if	1
may use single precision if	1
may make multiple versions of	1
may make some tests with	1
may make member functions faster	1
may make separate executables for	1
may also be a level-3	1
may also be an efficient	1
may also see emulated processors	1
may also look at the	1
may some day be implemented	1
may return an error code	1
may very well spend more	1
may call the CPUID instruction	1
may take a long time	1
may take more than a	1
may take more time than	1
may take only 5 s	1
may take up to 4	1
may take 3 - 5	1
may need to be cleaned	1
may need to be resized	1
may need to lock a	1
may need extra overhead to	1
may need assembly language. C++	1
may need modification to compensate	1
may need metaprogramming. The next	1
may even be a million	1
may even have a false	1
may even add dummy elements	1
may want to use the	1
may want to make one	1
may work with both static	1
may avoid the multiplication by	1
may avoid this method if	1
may avoid multiple inheritance by	1
may cause the software to	1
may cause a lot of	1
may cause a waste of	1
may cause a loss of	1
may cause cache contentions. See	1
may cause slight imprecision in	1
may therefore fail to see	1
may get a better result	1
may get a misprediction penalty	1
may run with reduced speed	1
may run at less than	1
may run slightly faster in	1
may calculate it only once.	1
may add the static keyword	1
may add counter variables that	1
may store the information in	1
may store all strings in	1
may write your own container	1
may write FatalAppExitA(0,"Array index out	1
may replace the call to	1
may replace this by //	4
may replace this line by	1
may typically look like this:	1
may preferably be a power	1
may preferably avoid global variables	1
may put the desired measurement	1
may read the time before	1
may give inconsistent results if	1
may look at the assembly	1
may look like this: //	2
may actually be better than	1
may actually add extra code	1
may improve the performance if	1
may improve the performance by	1
may improve the performance somewhat.	1
may improve the possibilities for	1
may improve efficiency by using	1
may reduce this to: //	2
may choose the compilers that	1
may choose the method that	1
may choose a newer instruction	1
may choose to make memory-hungry	1
may choose to align large	1
may choose one of the	1
may choose either C or	1
may require a very high	1
may require that a new	1
may start at unpredictable times	1
may go through multiple layers	1
may go undetected. The principle	1
may change the expression -(-a)	1
may change this to: //	1
may slow down the execution	1
may slow down a program	1
may produce undesired results. Integer	1
may save by avoiding the	1
may save RAM space, if	1
may possibly be more (128	1
may fail to distinguish elements	1
may fail in the event	1
may occur in multiplication here:	1
may occur as a result	1
may insert any other error	1
may consider the following alternatives:	1
may consider if the cost	1
may consider if it is	1
may consider whether it is	1
may consider whether others have	1
may enable the compiler to	1
may come unpredictably at inconvenient	1
may happen quite often. This	1
may apply to other platforms	2
may define a structure or	1
may contain pointers or addresses	1
may try to do as	1
may remove the memset line	1
may declare the function inline.	1
may detect the misprediction before	1
may prefer to use the	1
may prefer to write if(!a	1
may move the object in	1
may think that exception handling	1
may mirror the entire file	1
may behave differently on different	1
may catch programming errors that	1
may seem a little odd	1
may seem illogical that the	1
may ignore the problem and	1
may skip this section if	1
may decide to do some	1
may reorder instructions for the	1
may report that memset is	1
may interfere with real time	1
may involve the loading of	1
may reuse the same array	1
may sample more data than	1
may fill up the queue	1
may interleave the two formulas	1
may actively invalidate the cache.	1
may occasionally predict that the	1
may deviate from the above	1
may view the software development	1
may write: y = c	1
may neverthe- less be possible	1
may argue that it is	1
may supply such a framework	1
may vary dynamically and that	1
you to use the #pragma	1
you to define 64-bit integers,	1
you to manipulate the data	1
you to override the CPU	1
you to reserve the amount	1
you are in doubt how	1
you are not sure you	1
you are not doing divisions.	1
you are not satisfied with	1
you are not testing. Trying	1
you are using the same	1
you are using and turn	1
you are using an Intel	2
you are using vector classes	1
you are using functions such	1
you are using single precision	1
you are using __fastcall. Function	1
you are sure the code	1
you are sure that the	1
you are sure that it	1
you are sure you know	1
you are making a shared	1
you are making programs that	1
you are making branches that	1
you are doing a sequence	1
you are certain that u	1
you are including a header	1
you are testing contains debug	1
you are satisfied with more	1
you are overriding Intel's CPU	2
you are dealing with in	1
you are doing. See the	1
you are feeding an array	1
you are risking to insert	1
you can have one addition	1
you can have eight numbers	1
you can use the header	1
you can use the GetTickCount	1
you can use a linear	1
you can use it for	1
you can use only compilers	1
you can make a Boolean	1
you can make an update	1
you can make arrays of	1
you can only have four	1
you can set multiple bits	1
you can do is to	1
you can do to make	1
you can do with bitwise	1
you can do this by	1
you can do this every	1
you can do arithmetic operations	1
you can double the speed	1
you can also find more	1
you can take advantage of	1
you can avoid the problem	1
you can avoid virtual functions	1
you can avoid it. Global	1
you can avoid hyperthreading by	1
you can get the exact	1
you can get very expensive	1
you can get answers to	1
you can read about in	1
you can assume that there	1
you can assume that these	1
you can reduce the problem	1
you can turn on and	1
you can rely on only	1
you can rely on automatic	1
you can clear or mask	1
you can predict where the	1
you can expect a particular	1
you can expect 64-bit programs	1
you can generally assume that	1
you can increase the time	1
you can obtain most of	1
you can obtain much more	1
you can toggle multiple bits	1
you may of course make	1
you may as well use	1
you may as well specify	1
you may have to test	1
you may use the _mm_clflush	1
you may use a sorted	1
you may use 64-bit integers	1
you may make multiple versions	1
you may make some tests	1
you may also look at	1
you may call the CPUID	1
you may want to use	1
you may want to make	1
you may get a better	1
you may get a misprediction	1
you may store all strings	1
you may write FatalAppExitA(0,"Array index	1
you may put the desired	1
you may read the time	1
you may improve the performance	1
you may improve efficiency by	1
you may consider the following	1
you may consider if the	1
you may consider if it	1
you may consider whether it	1
you may consider whether others	1
you may define a structure	1
you may reuse the same	1
you may actively invalidate the	1
you may view the software	1
you have to do the	1
you have to do is	1
you have to do manually.	1
you have to call the	2
you have to avoid long	1
you have to store the	1
you have to replace u[1]	1
you have to execute _mm_empty()	1
you have to vectorize the	1
you have to identify the	1
you have this problem when	1
you have two different versions	1
you have even a single	1
you have big data structures.	1
you have big arrays and	1
you have special reasons to	1
you have ample resources. For	1
you use is a matter	1
you use pre-increment or post-increment.	1
you will be loading the	1
you will have only one	1
you will get one instance	1
you will get no warning	1
you will see shortly. The	1
you will never spend time	1
you will notice that the	1
you will notice that some	1
you will soon get a	1
you make a test run	1
you make sure it is	1
you make your own error	1
you only need a CPU	1
you should be aware that	1
you should be prepared for	1
you should by all means	1
you should not call WriteFile	1
you should test the response	1
you should avoid any use	1
you should avoid making any	1
you should avoid macros with	1
you should look at to	1
you should choose an up-to-date	1
you should apply the empty	1
you should apply CPU dispatching	1
you should multiply it by	1
you should disable it in	1
you do use the 64-bit	1
you cannot be sure that	1
you cannot make any assumption	1
you cannot always rely on	1
you cannot avoid conversions from	1
you cannot replace a ||	1
you cannot assume that model	1
you cannot find the answers	1
you cannot rely on a	1
you cannot expect the compiler	1
you cannot swap the order	2
you cannot increase the size	1
you take into account that	1
you need to use assembly	1
you need to do searches	1
you need to test on	1
you need to remove all	1
you need it. In C++	1
you access a variable in	1
you access to all of	1
you access part of a	1
you want the function to	1
you want the code to	1
you want the executable to	1
you want a number to	1
you want to be able	1
you want to make the	1
you want to make sure	2
you want to call the	1
you want to avoid the	1
you want to compile for.	1
you want to check whether	1
you want to calculate the	1
you want to optimize a	1
you want to optimize for	1
you want to see the	1
you want to improve speed	1
you want to know how	1
you want to find out	2
you want to prevent cache	1
you want to keep together	1
you want to compare the	1
you want to 155 test.	1
you want to flip the	1
you want to optimize, and	1
you want it to. It	1
you want as static arrays	1
you want this to be	1
you want when the program	1
you want vectorization then follow	1
you want them to apply	1
you must be careful when	1
you must make sure that	1
you must make your program	1
you must do the extra	1
you must consider if intermediate	1
you avoid the large graphics	1
you avoid an excessive number	1
you compile the program with	1
you compile the output of	1
you compile with the option	1
you optimized for is likely	1
you get four float additions	1
you would have spent fighting	1
you run the optimized code	1
you write a 64-bit double	1
you see in the debugger	1
you don't have to prefetch	1
you don't have to distribute	1
you don't have to reinvent	1
you don't need a smart	1
you don't need conversions between	1
you don't even have an	1
you don't want this initialization,	1
you don't care to calculate	1
you don't understand it. I	1
you put a parenthesis around	1
you read the value of	1
you look at the function	1
you look at the code	2
you assume that model N-1	1
you know that processor model	1
you know what you are	1
you choose to use intrinsic	1
you just want the program	1
you start to program. Many	1
you start to optimize anything,	1
you start to code, you	1
you change pre-increment to post-increment.	1
you turn them off or	1
you unroll by two then	1
you divide the data set	1
you divide an integer with	1
you consider making highly optimized	1
you expect the table to	1
you expect the && expression	1
you gain in speed by	1
you gain by testing and	1
you could calculate *p+2 and	1
you had used intrinsic functions.	1
you measure are much higher	1
you spend on redesigning a	1
you declare an int, without	1
you follow the guidelines below.	1
you specify an option that	1
you prefer is a matter	1
you forget to make the	1
you forget to delete the	1
you know). The code can	1
you discover that there are	1
you analyze all pointers and	1
you activate a particular part	1
{ a = a *	8
{ a = b; }	1
{ a = c; }	1
{ The effect of the	1
{ for (int i =	2
{ for (c = 0;	3
{ for (c2 = r1;	1
{ for (c2 = c1;	1
{ for (c1 = 0;	1
{ // function to transpose	1
{ // loop through rows	2
{ // loop columns below	1
{ // do nothing while	1
{ // table of 1/n!	1
{ // test bits 0	1
{ // test sign bit	1
{ // SSE2 supported return	1
{ // SSE2 supported CriticalFunction	1
{ // AVX supported return	1
{ // AVX supported CriticalFunction	1
{ // check if nonzero	1
{ // Make a vector	3
{ // Make dynamic array	1
{ // Table of factorials:	1
{ // Floating point overflow	1
{ // go to dispatched	1
{ // Loop to print	1
{ // Loop through array	1
{ // Loop r2 and	1
{ // No cache contentions.	1
{ // Define vector objects	1
{ // Define macro to	1
{ // f is zero	1
{ // Load eight consecutive	4
{ // Cache contentions expected.	1
{ // Array with N	1
{ // n! // Table	1
{ // n! int i,	1
{ // u.f > v.f	1
{ // Bounds checking (see	1
{ // Get supported instruction	1
{ // Get upper 32	1
{ // Check that index	1
{ // (N & N-1)==0	1
{ // Overflow may occur	1
{ // Returns a pointer	1
{ // Catch exceptions in	1
{ // Remove right-most 1-bit	1
{ // Safe [] array	1
{ // Generic version CriticalFunction	1
{ // polynomial(x) = 2.5*x^2	1
{ // Round to nearest	1
{ // Detect supported instruction	1
{ // 2-dimensional vector 56	1
{ // abs(u.f) > abs(v.f)	1
{ // Main loop for	1
{ if (i % 2	1
{ if (b) { a	4
{ if (n & 1)	1
{ if (n > 0)	1
{ if (b == 0)	1
{ if (b != 0)	1
{ if (y) { int	1
{ int a = Func1(2);	1
{ int i; for (i	1
{ int i; int Induction	1
{ int i; 84 for	1
{ int a, b, c;	2
{ int b, c; x[0]	1
{ int a; int b;	1
{ int r, c; for	2
{ int list[100]; Func1(list, &list[8]);	1
{ int a[1000]; F1(a); }	1
{ int a:4; int b:2;	2
{ int dummy[4]; volatile int	1
{ has the same name	1
{ double b; // 8	1
{ double y = 1.0;	1
{ double d; int i[2];	1
{ double x2 = x	1
{ float a, b, c,	1
{ float f; int i;	7
{ float f; unsigned int	1
{ float xn = x;	1
{ float b[1000]; F2(b); }	1
{ static float list[] =	1
{ static const double log2	1
{ return a - 1;	1
{ return a + 1;	1
{ return a * a;}	1
{ return a > b	1
{ return x * x	2
{ return x * m;}	2
{ return 0; // return	1
{ return x; } };	1
{ return 1.0; } };	1
{ return _mm_loadu_si128((__m128i const*)p); }	2
{ return _mm_loadu_si128((__m128i const*)p);} //	1
{ return Func1(x) * Func1(x)	1
{ return pow(x,10); } The	1
{ return IntegerPower<10>(x); } 152	1
{ return x*x + 1;	1
{ return ipow(x,10); // used	1
{ return powN<true,N/2>::p(x) * powN<true,N/2>::p(x);	1
{ return _mm_load_si128((__m128i const*)p); }	1
{ return square(x) + 1.0f;}	1
{ return _mm_cvtss_si32(_mm_load_ss(&x));} static inline	1
{ return N; } T	1
{ return vector(x + a.x,	1
{ return _mm_cvtsd_si32(_mm_load_sd(&x));} The code	1
{ const int x; public:	1
{ const int arraysize =	1
{ unsigned int fraction :	3
{ case 0: printf("Alpha"); break;	1
{ short int a; double	1
{ c = 1; }	1
{ ... a = FactorialTable[b];	1
{ ... can be changed	1
{ ... } } The	1
{ ... There is an	1
{ ... Here, you cannot	1
{ ... Here you cannot	1
{ ... Conversions between signed	1
{ y = cos(x); }	1
{ y = cos(x); z	1
{ y = sin(x); }	1
{ y = sin(x); z	1
{ public: int c; };	1
{ public: int a; int	1
{ public: int a[100]; //	1
{ public: static double p(double	4
{ public: void Disp() {	2
{ public: void Hello() {	1
{ public: void NotPolymorphic(); virtual	1
{ public: void NotPolymorphic(); };	1
{ public: virtual void Disp()	2
{ public: virtual void f();	2
{ public: ... ~C1(); };	1
{ public: B2 b2; int	1
{ r = r +	1
{ union { 89 int	1
{ a[i] = b *	1
{ a[i] = i *	1
{ a[i] = r +	1
{ a[i] = temp; }	1
{ a[i] = temp; temp	1
{ a[i] = *p +	1
{ a[i] = b[i] +	1
{ a[i] = Induction; a[i+1]	1
{ S1 x, y; ...	1
{ temp = a[i] +	1
{ d = 0; }	1
{ sum += xn /	1
{ struct { int a:4;	1
{ list[i] += 1.0f; }	2
{ cout << 1; }	2
{ cout << 2; }	2
{ cout << "Hello ";	2
{ cout << "Error: Index	2
{ seconds = 0; while	1
{ *p = *p +	2
{ try { F1(); }	1
{ j = order(i); matrix[j][0]	1
{ j = order(i); list[j].a	1
{ C1 x; ... }	1
{ C1 obj1; C0 *	1
{ C1 Object1; C2 Object2;	1
{ sum1 += list[i]; sum2	1
{ b[i] = Func(a[i]); }	1
{ __declspec(align(16)) static const float	1
{ CChild1 Object1; CChild2 Object2;	1
{ 89 int a[1000]; float	1
{ _mm_storeu_si128((__m128i *)d, x); }	2
{ _mm_storeu_si128((__m128i *)d, x);} void	1
{ Vec16s a, b, c;	1
{ (iset >= 8) SelectAddMul_pointer	1
{ __m128 s; s =	1
{ F2(b); } } Using	1
{ aa[i] = (bb[i] >	1
{ aa[i] = bb[i] +	1
{ FuncA(i); } else {	1
{ FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1);	1
{ s0 += a[i]; s1	1
{ F1(a); } else {	1
{ goto CFALSE; } }	1
{ goto DTRUE; } }	1
{ DoThisThreeTimesAWeek(); } 135 The	1
{ DoThisThreeTimesAWeek(); } By giving	1
{ list[i].a = 1.0; list[i].b	1
{ swapd(a[r2][c2],a[c2][r2]); } } }	2
{ memset(a, 0, sizeof(a)); }	1
{ Sunday, Monday, Tuesday, Wednesday,	1
{ largest_abs = absvalue; largest_index	1
{ Table[x] = A*x*x +	1
{ Table[x] = Y; Y	1
{ b.load(bb+i); c.load(cc+i); a =	1
{ Sunday = 1, Monday	1
{ time1 = ReadTSC(); CriticalFunction();	1
{ protected: T a[N]; public:	1
{ FuncB(i); } FuncC(i); }	1
{ CFALSE: c = 0;	1
{ DTRUE: d = 1;	1
{ "Alpha", "Beta", "Gamma", "Delta"	1
{ __declspec(__align(64)) double matrix[SIZE][SIZE]; transpose(matrix);	1
{ ab[i].b = Func(ab[i].a); }	1
{ _mm_store_si128((__m128i *)d, x); }	1
{ F1(); } catch (...)	1
{ StoreNTD(&a[c][r], b[r][c]); } }	1
{ temp->a = 1.0; temp->b	1
{ a[c][r] = b[r][c]; }	1
{ _mm_stream_pi((__m64*)dest, *(__m64*)&source); // MOVNTQ	1
{ 92 DynamicArray[i] = WhateverFunction(i);	1
have the time to answer	1
have the same value. This	1
have the member functions of	1
have the following disadvantages compared	1
have the best and most	1
have the necessary information about	1
have the line number information.	1
have the disadvantage of a	1
have the disadvantages mentioned above	1
have the selected instruction set.	1
have a = 0x2710 and	1
have a function for this	1
have a standard function library	1
have a high priority. Other	1
have a graphics processing unit,	1
have a feature for making	1
have a feature called whole	1
have a special loop predictor.	1
have a destructor to make	1
have a destructor that needs	1
have a reduced number of	1
have a 'this' pointer which	1
have a false vendor string.	1
have a strict formalism that	1
have a larger memory footprint	1
have a non-inlined copy Function	1
have a dedicated physics processor	1
have a natural order and	1
have a natural ordering? If	1
have a built-in test feature	1
have a physics processing unit	1
have a niche in scientific	1
have a balanced mix of	1
have a temp1 and temp2.	1
have a strategy for saving	1
have to be compiled with	1
have to be done at	1
have to be put into	1
have to be aligned by	1
have to be designed so	1
have to be restored before	1
have to be renewed. Context	1
have to make sure that	1
have to set the parentheses	1
have to do the necessary	1
have to do the divisions	1
have to do is to	1
have to do a lot	1
have to do manually. It	1
have to call the function	1
have to call the library	1
have to take into account	1
have to test several different	1
have to avoid long dependency	1
have to check if your	1
have to calculate each value	1
have to add the last	1
have to store the intermediate	1
have to replace u[1] by	1
have to save some information	1
have to save recovery information	1
have to unroll a loop	1
have to execute _mm_empty() after	1
have to vectorize the code	1
have to include the appropriate	1
have to care about the	1
have to wait for another	1
have to identify the critical	1
have to prefetch data explicitly	1
have to distinguish between recoverable	1
have to worry about loss	1
have to worry much about	1
have to push and pop	1
have to distribute all the	1
have to fix the thread	1
have to obey any specific	1
have to reinvent the wheel.	1
have to consult the general	1
have to adapt to the	1
have as few branches as	1
have not been tested in	1
have an operating system. The	1
have an extra cache for	1
have an assembly output option	1
have an option for whole	1
have an option for assuming	1
have an option for "standard	1
have an option (Windows: /Gy,	1
have an empty throw() specification.	1
have an up-to-date version. The	1
have an attribute which can	1
have an estimated calculation time	1
have this problem when the	1
have this problem. Vectors of	1
have more than four parameters.	1
have more references to relocate,	1
have more powerful computers with	1
have memory caches. Typically, there	1
have vector instructions that make	1
have functions for integer vector	1
have only one floating point	1
have only one addition every	1
have CPU dispatching 125 for	1
have other values if they	1
have other values than 0	2
have used the trick that	1
have used char (or int)	1
have one and only one	1
have one addition every clock	1
have one instance for each	1
have no more threads with	1
have no other value than	1
have no other values than	2
have no cache (see p.	1
have no branch prediction (see	1
have no specific order but	1
have no specific recommendation of	1
have no check for overflow	2
have no checking for array	1
have no out-of-order execution. There	1
have no explanation why this	1
have no native floating point	1
have floating point capabilities (except	1
have each their stack. This	1
have multiple // versions: class	1
have multiple versions. This method	1
have two or more threads	1
have two or more cores,	1
have two different versions of	1
have two different types of	1
have such a feature for	1
have such checks. But it	1
have efficient table-based methods with	1
have many different CPUs to	1
have many file input/output operations.	1
have many keywords and directives	1
have variable lengths that are	1
have any other value than	1
have any brand name and	1
have some disadvantages that make	1
have very different speeds. If	1
have very good performance and	1
have very few restrictions on	1
have long double precision (80	1
have less computing resources than	1
have even a single constant	1
have access to the container.	1
have its pointer set to	1
have its own IDE. It	1
have execution units, memory ports,	1
have big data structures with	1
have big data structures. For	1
have big arrays and want	1
have big endian storage (e.g.	1
have much less memory and	1
have several versions for different	1
have several advantages over 32	1
have been stored in the	1
have been replaced by my	1
have been tested only on	1
have been initialized to valid	1
have been defined in other	1
have been added and then	1
have been added? If search	2
have been lost at the	1
have been reordered, inlined, or	1
have been found, then it	1
have been unsatisfied with the	1
have been identified. My test	1
have done the job before	1
have done a good deal	1
have four numbers of type	1
have implemented a separate version	1
have implemented a collection of	1
have support for intrinsic functions	1
have support for whole program	1
have eight numbers of type	1
have values far from each	1
have information about functions in	1
have certain instructions that allow	1
have addresses divisible by 16.	1
have quite dramatic consequences. I	1
have fast ways of multiplying	1
have Boolean variables as input	1
have separate containers for each	1
have put the whole software	1
have various optimization options that	1
have various options to control	1
have three values per point.	1
have public variables in a	1
have made a series of	1
have just two branches: one	1
have tested the strlen function	1
have tested the capability to	1
have tested can convert example	1
have tested were able to	1
have tested implement OneOrTwo5[b!=0] as	1
have tested seem to do	1
have become more powerful. The	1
have become bigger and more	1
have inefficient code-based methods or	1
have described some of the	1
have particularly slow implementations of	1
have special reasons to use	1
have names that begin with	1
have names with suffixes such	1
have little or no idea	1
have similar CPU dispatch mechanisms,	1
have features for automatic CPU	1
have added a bounds check	1
have provided several examples of	1
have #if directives around it	1
have family number 6! The	1
have exactly the same effect.	1
have spent fighting with the	1
have powerful facilities that do	1
have mixed precision require precision	1
have mixed types or sizes?	1
have constructors and destructors. The	1
have unacceptably long response times	1
have seen many examples of	1
have AND'ed b with 1	1
have ever seen can reduce	1
have facilities for making a	1
have finished the time-consuming data	1
have (set) = (10000 /	1
have supplied in the library	1
have undesired effects. This effect	1
have discovered that there are	1
have developed a test tool	1
have extern "C" declaration and	1
have inherent support for 64-bit	1
have got low priority. Especially	1
have got RISC cores, vector	1
have inserted UnusedFiller in the	1
have difficulties making floating point	2
have worked well in tests	1
have Booleans as output can	1
have occurred. This makes it	1
have ample resources. For example,	1
have studied do not make	1
have confirmed this by measuring	1
have sent me corrections and	1
have little-endian storage, but other	1
have exploited. A good way	1
have gone to great lengths	1
have tested. The reason is	1
have tried. The Microsoft, Intel	1
this the time it takes	2
this the time before the	1
this is the most efficient	1
this is the case then	1
this is the job of	1
this is a pure function.	1
this is to make a	1
this is to help the	1
this is that the next	1
this is that all variables	1
this is not the case	1
this is not a problem	1
this is not a textbook	1
this is not an issue	1
this is not possible when	1
this is not always true.	1
this is not necessary because	1
this is only possible if	1
this is possible in Linux).	1
this is often faster than	1
this is likely to generate	1
this is permissible when it	1
this is sufficiently accurate for	1
this is extremely inefficient, (4)	1
this is obvious, then it	1
this to be the fastest	1
this to be a register	1
this to i and shifts	1
this in a protected operating	1
this in a pivot search:	1
this for testing single assembly	1
this can be implemented with	1
this can cause contentions in	1
this can eliminate branches, as	1
this or for the sake	1
this function is InstructionSet().The following	1
this function to measure the	1
this function and calculate it	1
this function can modify x	1
this function on CPUs with	1
this by // Example 8.5b	1
this by // Example 8.2b	1
this by // Example 8.3b	1
this by // Example 8.6b	1
this by // Example 8.8b	1
this by using an inline	1
this by making i an	1
this by preferably using powers	1
this by measuring the time	1
this by invoking the compiler	1
this by assigning a new	1
this by writing: 103 //	1
this with an example. My	1
this with induction variables. It	1
this code is that if	1
this code can be improved	1
this code with a 64	1
this code version performs poorly.	1
this may work with both	1
this may improve the possibilities	1
this time has been wasted.	1
this time lag. Thinking in	1
this will use full 64-bit	1
this will make the program	1
this will trigger the error	1
this memory block is re-allocated	1
this only happens rarely. The	1
this instruction set and insert	1
this instruction set or any	1
this instruction set?". A list	1
this loop by using vector	1
this loop will take approximately	1
this example is a double	1
this example is called with	1
this example can be accessed	1
this example can be avoided	1
this example has three conditions	1
this example only to show	1
this example should be compiled	1
this example so that a+b	1
this pointer is then de-referenced	1
this pointer in member functions	1
this library with the option	2
this number of iterations. The	1
this number we get 0	1
this value will propagate through	1
this value from the counts.	1
this table may be of	1
this way is equal to	1
this way includes the time	1
this makes the code incompatible	1
this address is not vacant	1
this example, the sign bit	1
this example, the conversion is	1
this example, the DelayFiveSeconds function	1
this example, we are using	1
this example, a, b and	1
this example, f(x) or g(x)	1
this bit scan instruction. Programmers	1
this first manual. The subsequent	1
this optimization automatically in simple	1
this optimization explicitly. Divisions can	1
this code. For example, many	1
this method is that the	1
this method is extremely complicated	1
this method is safer. Type	1
this method for all unknown	1
this method if memory access	1
this method only for big	1
this method doesn't work for	1
this method works only for	1
this part of the code	1
this part of the memory	1
this case is to divide	1
this case is faster when	1
this case it may be	1
this case it will recognize	1
this case it doesn't matter	1
this case you have to	1
this case there is an	1
this case we need to	1
this case so we don't	1
this error is easy to	1
this error by avoiding any	1
this important new update or	1
this extra element zero. It	1
this does not work in	1
this work on non-Intel processors).	1
this result in a[i]. Note	1
this language gained remarkably in	1
this option only in the	1
this line by any other	1
this works and suggests methods	1
this works only if it	1
this manual for reasons explained	1
this manual at www.agner.org/optimize/cppexamples.zip contains	1
this manual at www.agner.org/optimize/cppexamples.zip containing	1
this manual at www.agner.org/optimize/cppexamples.zip. 9.9	1
this calculation implemented with template	1
this problem is to use	2
this problem is to combine	1
this problem are the following:	1
this problem by defining _mm_malloc	1
this problem by bypassing the	1
this problem when the repeat	1
this solution is using one	1
this solution is too high.	1
this solution can still give	1
this would be invalid if	1
this would give annoyingly long	1
this every time a new	1
this information to optimize the	1
this multiplication will be faster	1
this complicated template method. 7.29	1
this requires static linking (e.g.	1
this feature is rarely needed	1
this feature is rarely needed.	1
this feature is seldom used.	1
this function, though not all	1
this range then the value	1
this section for some caveats.	1
this section if you are	1
this section by summing up	1
this example: 38 // Example	1
this statement so that it	1
this hot spot. Repeating the	1
this fact by replacing a	1
this task when the CPUID	1
this shift in software writing	1
this prevents a faster vectorized	1
this efficiency lies in the	1
this discussion that the choice	1
this alignment automatically. The alignment	1
this effect is so much	1
this time, any processor that	1
this optimization. 8.2 Comparison of	1
this address. Step (1) is	1
this might be a better	1
this problem. The most important	1
this problem. If a function	1
this problem. These instructions write	1
this problem. 7.11 Type conversions	1
this problem. Vectors of 256-bit	1
this series of manuals. 7.1	1
this to: // Example 14.14b	1
this to: // Example 8.13b	1
this to: // Example 8.11b	1
this to: // Example 8.12b	1
this to: // Example 8.14b	1
this brand was less popular	1
this involves the problems that	1
this unit is pipelined, as	1
this kind of instructions for	1
this kind of problems you	1
this kind of optimizations is	1
this jump by copying the	1
this case. The best solution	1
this case. A binary tree	1
this case. You cannot expect	1
this case. Loop unrolling should	1
this polynomial can be done	1
this principle for objects stored	1
this method. Your measurement code	1
this manual. You have to	1
this manual. 2.3 Choice of	1
this case, the performance is	1
this example. We might check	1
this option. This requires that	1
this option. Use the option	1
this option. 8.4 Obstacles to	1
this appears to be profitable	1
this unit-test may have a	1
this manually. This principle is	1
this format. Other compilers offer	1
this reordering easier for the	1
this distance the critical stride.	1
this wasteful copying of memory	1
this purpose. It just happened	1
this condition. In general, the	1
this bookkeeping depends very much	1
this argument is that the	1
this problem: 1. Relocation. All	1
this problem: (1) check for	1
this purpose, or you may	1
this column. Number 17 will	1
this "override" feature. All accesses	1
this initialization, or if the	1
this manual, but you should	1
this manual, I am using	1
this limitation). 14.11 Static versus	1
this interval, for example i	1
this did not improve the	1
this works, here's an explanation.	1
this topic, see my free	1
this rule. Splitting up a	1
this delaying process is used	1
this limitation and other flaws	1
this block: 62 __try {	1
this chapter. Using the out-of-order	1
this loop? Certainly not! 250	1
this reason. A program with	1
this reason, you can use	1
this mask, and bb[i]*cc[i] is	1
this place. This can be	1
this respect. 7.15 Function parameters	1
this capability: // Example 11.1a	1
this chapter, I have described	1
time the function is called	1
time the function is called.	6
time the function is called,	1
time the function pointer has	1
time the program is run.	1
time the program starts. The	1
time the variable pointed to	1
time the software was coded.	1
time the software was developed.	1
time the critical function is	1
time the computer starts up,	1
time the statement was executed.	1
time is so long that	1
time is typically between 5	1
time is needed for setting	1
time is actually more than	1
time is included in the	1
time is interpreted in the	1
time is determined by the	1
time is measured with millisecond	1
time is spent in the	1
time is spent on reading	1
time is doubled. The time	1
time is consistent for the	1
time is wasted on software	1
time is wasted on runtime	1
time a function is called,	2
time a new and better	1
time a new object of	1
time a new processor enters	1
time a string is created	2
time a thousand cache misses	1
time of programming will typically	1
time of 250 ms. This	1
time of programming. The CPU	1
time of programming. 13.3 Difficult	1
time to call a function	1
time to user input never	1
time to calculate when long	1
time to copy the entire	1
time to load a program	1
time to execute then the	1
time to e.g. a menu	1
time to share the same	1
time to eliminate everything that	1
time to transpose the matrix	1
time to transpose a matrix	1
time to evaluate and are	1
time to load. A light-weight	1
time to answer questions from	1
time to calculate. If there	1
time and it avoids the	1
time and b is true	1
time and compatibility problems into	1
time and insert the reciprocal	1
time and rarely the other	1
time and show the values	1
time and resolve any branch	1
time and afterwards a BSF	1
time and maintainability of C++	1
time in the unit-test but	1
time in most cases, but	1
time in library functions then	1
time in case of mispredictions	1
time in vectors of eight	1
time in thousand so the	1
time for the user. Time	1
time for the user. With	1
time for software users as	1
time for WTL applications can	1
time that is measured in	1
time that it takes to	1
time can be annoyingly high	1
time or a reasonable upper	1
time or a not-too-big upper	1
time it is used and	1
time it is filled up,	1
time it takes to make	2
time it takes to do	1
time it takes to call	2
time it takes to calculate	3
time it takes to add	1
time it takes to load	1
time it takes to start	1
time it takes to execute	2
time it takes to transpose	1
time it takes to install	2
time it takes to recover	1
time it takes to reload	2
time it takes to develop	2
time it takes to refresh	1
time it takes before the	1
time it was executed. It	1
time it was programmed. But	1
time it was programmed. Therefore,	1
time it takes. The version	1
time it takes. Debugging. The	1
time it uses. There are	1
time if and compile-time while	1
time if it is done	1
time on the user interface	1
time on processors that were	2
time on executing library functions.	1
time on deciding which version	1
time as the other thread	1
time as long as the	1
time an object is moved,	1
time int CriticalFunction_Dispatch(int parm1, int	1
time than the table lookup.	1
time than the actual calculations.	1
time than other kinds of	1
time than single precision. When	1
time than addition and subtraction	1
time than accessing a simple	1
time than processing the data	1
time than addition, subtraction and	2
time than rounding unless the	1
time than normal on some	1
time than anything else on	1
time than looping through a	1
time than normally. There are	1
time may be justified in	1
time you would have spent	1
time you spend on redesigning	1
time you activate a particular	1
time when the floating point	2
time when the CPUID instruction	1
time when code and data	1
time when performance is important	1
time then the sampling generates	1
time then there is a	1
time then there is no	1
time at unpredictable intervals which	1
time has been wasted. The	1
time because the memory bus	1
time because the cache miss	1
time because of the extra	1
time because it needs to	1
time because each call to	1
time which version of a	1
time but avoids the overflow.	1
time used for file input	1
time used by all other	1
time each part takes. See	1
time we are swapping column	1
time so that the compiler	1
time so that it may	1
time You can use this	1
time before the end user	1
time before and after each	1
time rather than at runtime	1
time rather than at runtime.	1
time they are used. Example:	1
time Some developers feel that	1
time while if is resolved	1
time doing the division. Some	1
time both during installation of	1
time unless the SSE2 or	1
time too small or too	1
time goes to cache misses,	1
time loading files or accessing	1
time delay that the end	1
time under worst-case conditions. Programs	1
time loops or compile-time generation	1
time unit is clock cycles	1
time applications. Remember that container	1
time stamp counter in the	1
time stamp counter can be	1
time stamp counter // For	1
time stamp counter before and	1
time stamp counter becomes invalid	1
time stamp counter. The test	1
time stamp counter. This is	1
time consuming because it may	2
time consuming parts only. Critical	1
time consuming updates may come	1
time T to T+5, then	1
time measurements to avoid this.	1
time measurements may require a	1
time waiting for user input	2
time spent in the program	1
time spent on function calls	1
time Func is executed. This	1
time Func is executed. Without	1
time here. It may be	1
time regardless of whether you	1
time consuming. A collection of	1
time consuming. Therefore, the data	1
time consuming. Therefore, you should	1
time consuming. Sometimes it takes	1
time searching for updates each	1
time consumption of different type	1
time consumption of each run	1
time consumption as the difference	1
time consumption was down to	1
time slices is determined by	1
time slices of typically 30	1
time slices to 120 ms	1
time slices allocated to each	1
time cleaning up spaces that	1
time compared to the time	1
time consumers ................................................................................ 16 3.1	1
time consumers 3.1 How much	1
time intervals are short. In	1
time MemberPointer is declared. Therefore,	1
time consumer to many hard	1
time consumer if it involves	1
time T+1 to T+6, and	1
time slices. This will make	1
time consumers. Choose the strongest	1
time consuming, especially if there	1
time intervals. Some programs search	1
time packed into a vector	1
time lag. Thinking in terms	1
time measurement. If time is	1
time slice are quite costly	1
time measure. This is because	1
time measurements: warm up the	1
use the same memory area	2
use the same member pointer.	1
use the same register for	2
use the same register because	1
use the same space for	1
use the same induction variable	1
use the same unit as	1
use the same register. Everything	1
use the same DLL at	1
use the same principle as	1
use the functions memset and	1
use the CPU detection function	1
use the most complicated implementation	1
use the Intel compiler because	1
use the Intel math function	1
use the static version if	1
use the 64-bit vectors then	1
use the value in edx	1
use the software implementation if	1
use the const keyword wherever	1
use the bit scan instruction	1
use the best possible instruction	1
use the AVX instructions. The	1
use the copy of the	1
use the well optimized Intel	1
use the name _alloca) for	1
use the high processing power	1
use the zero flag and	1
use the source annotation option	1
use the induction variable as	1
use the XMM registers for	1
use the vectors of 64	1
use the core clock cycle	1
use the #pragma vector always	1
use the local name for	1
use the safe formula a[i]	1
use the so-called position- independent	1
use the bitwise operators (&	1
use the header file timingtest.h	1
use the default integer size	1
use the memcpy function implicitly	1
use the Gnu, Clang, Intel	1
use the smallest data size	1
use the smallest integer size	2
use the newest instruction set.	1
use the upper 32 bits	1
use the lrint function: //	1
use the GetTickCount or QueryPerformanceCounter	1
use the _mm_clflush intrinsic function.	1
use is a matter of	1
use a function library, but	1
use a compiler option for	1
use a different operating systems	1
use a different kind of	1
use a loop for trivial	1
use a loop counter: //	1
use a set of test	1
use a set of special	1
use a version control tool.	1
use a table // of	2
use a new register size	1
use a constant reference instead:	1
use a stack frame unless	1
use a container that allows	1
use a container or memory	1
use a lot of computing	1
use a lookup table if	1
use a lookup table: //	1
use a linked list (see	1
use a negative list of	1
use a database for storing	1
use a smart pointer (see	1
use a linear array with	1
use a linear list with	1
use a hash table for	1
use a console mode program.	1
use a sorted list or	1
use a systematic and well	1
use a #define, const or	1
use a union, as in	1
use a queue. It is	1
use of the data cache.	1
use of the extra bits.	1
use of the micro-op cache.	1
use of vector operations is	1
use of integer operations. This	1
use of floating point expressions.	1
use of Intel vector classes:	1
use of two induction variables:	1
use of register variables. 9.5	1
use of assembly language for	1
use of arrays in C	1
use of threads is discussed	1
use of classes and member	1
use of intrinsic vectors requires	1
use of << and |	1
use of RAM memory. Big	1
use of structures (without member	1
use of templates makes the	1
use of software. For more	1
use of memset and memcpy	1
use of longjmp if possible.	1
use of coprocessors is beyond	1
use and data cache use	1
use and returns a pointer	1
use in system code. Dynamic	1
use in case the function	1
use in programs that have	1
use for a particular memory	1
use for each processor model	1
use for many programmers and	1
use for recovering or for	1
use that for a portable	1
use can be critical. The	1
use it for lists that	1
use it for improving the	1
use on such systems than	1
use as pivot in a	1
use an integer size that	1
use an object file disassembler.	1
use an object oriented programming	1
use an intermediate code (byte	1
use an advanced and complicated	1
use than pointers because in	1
use than others. While some	1
use this function to measure	1
use this library with the	2
use this number of iterations.	1
use this method only for	1
use this information to optimize	1
use this complicated template method.	1
use this principle for objects	1
use time searching for updates	1
use more time loading files	1
use more resources than the	1
use vector operations on contemporary	1
use vector operations where there	1
use vector operations automatically in	1
use vector instructions (see page	1
use vector operations. You may	1
use vector classes, as explained	1
use different memory spaces for	1
use different memory areas, and	1
use different execution units. For	1
use only the lower 8	1
use only a small fraction	1
use only compilers and function	1
use one container for each	1
use one 256-bit vector register	1
use integer operations for incrementing	1
use double precision without worrying	1
use Intel VTune, for AMD	1
use float rather than double	1
use multiple CPU cores is	1
use multiple CPUs or CPU	1
use multiple accumulators if there	1
use static variables. See chapter	1
use static linking, as explained	1
use 64-bit systems if the	1
use 64-bit integers if the	1
use 64-bit integers with hardly	1
use such methods only if	1
use any of the storage	1
use 32-bit integers in 16-bit	1
use unsigned integers - they	1
use 64 bits rather than	1
use rather than a dedicated	1
use pointers may be replaced	1
use these methods to improve	1
use 32 bits in x86	1
use dynamic memory allocation in	1
use dynamic memory allocation for	1
use dynamic memory allocation with	1
use dynamic memory allocation when	1
use dynamic memory allocation. There	1
use dynamic memory allocation. You	1
use assembly code or use	1
use assembly language. In fact,	1
use large amounts of memory	1
use big endian storage. If	1
use single precision if you	1
use single precision. Using double	1
use AMD CodeAnalyst. Unfortunately, profilers	1
use exception handling even in	1
use AVX only when AVX2	1
use inline assembly code to	1
use standard user interface elements	1
use standard API calls rather	1
use intrinsic functions or vector	1
use induction variables for calculating	1
use string classes, such as	1
use lookup tables if this	1
use runtime type identification (RTTI)	1
use linked lists. A linked	1
use later in the program	1
use binary search for finding	1
use depends on what fits	1
use STL containers. See page	1
use #pragma vector aligned or	1
use position-independent code by default.	1
use position-independent code everywhere by	1
use vectorized code or not.	1
use it. Complicated code is	1
use full 64-bit addresses for	1
use algebraic manipulations on integer	1
use situation where the network	1
use alternative implementations. 7.22 Inheritance	1
use standardized installation tools. It	1
use #if instead of if.	1
use just-in-time compilation of the	1
use just-in-time compilation. The program	1
use GOT and PLT for	1
use absolute references in 32	1
use truncation towards zero, rather	1
use excessive loop unrolling so	1
use pre-increment or post-increment. The	1
use hyperthreading or not in	1
use branches, provided that the	1
use relocation. The DLLs are	1
use internet or intranet for	1
use denormal numbers. You may,	1
use hexadecimal numbers because all	1
use ~ for NOT. Instead,	1
use thread-safe functions. A thread-safe	1
use objconv or a similar	1
use SafeArray: // Example 7.15b	1
use inappropriate CPU dispatch methods.	1
use segmentation of the memory	1
use try, catch, and throw.	1
more of the above methods	1
more and more important. 9.2	1
more by the loader to	1
more by choosing the best	1
more on this topic, see	1
more than the time it	1
more than the number of	1
more than a hundred clock	1
more than a minute if	1
more than it takes to	1
more than it says. A	1
more than an hour. Neither	1
more than one variable if	1
more than one way in	1
more than one call to	1
more than one line at	1
more than one instance of	1
more than one thing at	1
more than two ways. Switch	1
more than 2 gigabytes of	1
more than four parameters. There	1
more than calling the function	1
more than once then the	1
more than half the single-thread	1
more than 250 ms. If	1
more than 99% of the	1
more than 33% when the	1
more than doubled for this	1
more time to calculate when	1
more time to load a	1
more time to transpose the	1
more time to load. A	1
more time than the table	1
more time than the actual	1
more time than other kinds	1
more time than single precision.	1
more time than accessing a	1
more time than processing the	1
more time than normal on	1
more time than anything else	1
more time than looping through	1
more time but avoids the	1
more time loading files or	1
more then the offset has	1
more memory resources than a	1
more memory blocks than there	1
more data than it can	1
more vector instructions SSE4.2 string	1
more CPU time on the	1
more cache space. Excessive use	1
more integer to the structure.	1
more integer vector instructions SSE4.1	1
more integer units, one or	1
more efficient to have separate	1
more efficient to use a	2
more efficient to make a	2
more efficient to store many	1
more efficient to store application-specific	1
more efficient to convert unsigned	1
more efficient to allocate one	1
more efficient to define your	1
more efficient to implement a	1
more efficient to determine the	1
more efficient to re-use a	1
more efficient to pool all	1
more efficient and enables interprocedural	1
more efficient in 64-bit Linux	2
more efficient in 64-bit mode	1
more efficient in some cases	1
more efficient if it is	1
more efficient than the runtime	1
more efficient than a polymorphous	1
more efficient than if because	1
more efficient than x =	2
more efficient than when a	1
more efficient than 64-bit Windows	1
more efficient than functions. See	1
more efficient than frame functions	1
more efficient than mov eax,0.	1
more efficient than comparing it	1
more efficient than post-increment. For	1
more efficient than Sum2 and	1
more efficient than investing in	1
more efficient when there is	1
more efficient when arrays are	1
more efficient because relative references	1
more efficient way if the	1
more efficient solution that doesn't	1
more efficient container class templates,	1
more efficient code, but this	1
more efficient alternatives that can	1
more efficient today where cache	1
more clock cycles than other	1
more performance monitor counters in	1
more performance monitor counters instead	1
more time. Single precision division,	1
more template instances will be	1
more useful methods for exploiting	1
more dynamic libraries are loaded	1
more bits than a float.	1
more error prone. The vectorized	1
more error prone. A discussion	1
more important to economize the	1
more important it is to	1
more important than optimizing CPU	1
more important than speed. This	1
more versions of the same	1
more versions of the most	1
more threads with the same	1
more threads writing to the	1
more common to exchange data	1
more advantageous the smaller the	1
more advantageous if the operands	1
more likely to inline a	1
more information about mathematical functions.	1
more space in the code	1
more space than needed. This	1
more space 91 step by	1
more complicated to make CPU-	1
more complicated and time consuming.	1
more complicated and error-prone. The	1
more complicated in a large	1
more complicated if the number	1
more complicated because various corrections	1
more complicated functions like sin.	1
more complicated solution is to	1
more complicated implementation is needed.	1
more complicated mathematical tasks. Before	1
more complicated reductions. Algebraic reduction	1
more resources than the code	1
more resources than the program	1
more resources than the programs	1
more resources than C if	1
more resources than non-virtual functions.	1
more efficient. The size of	1
more efficient. The SSE2 instruction	1
more efficient. This instruction set	1
more efficient. 64-bit Windows allows	1
more efficient. You can disable	1
more efficient. 64 bit systems	1
more efficient. Variables that are	1
more examples of bad CPU	1
more difficult to debug and	1
more difficult for the programmer	1
more advanced data structures with	1
more relevant to test the	1
more reductions on integer expressions	1
more references to relocate, but	1
more syntax check. It does	1
more safe to do the	1
more safe than the C-style	1
more discussion of the increment	1
more clear to the reader	1
more clear and intelligible way	1
more clear and modular. The	1
more clear program structure in	1
more clear unless the function	1
more efficiently by better standardization	1
more efficiently with coarse-grained parallelism	1
more efficiently than static memory.	1
more efficiently from the previous	1
more details on branch predictions	1
more RAM than there is,	1
more RAM than end users	1
more time-consuming than a simple	1
more frequent if the time	1
more iterations back. The method	1
more fragmented when the code	1
more general method is to	1
more random than normal. 157	1
more important. 9.2 Cache organization	1
more serious when n is	1
more expensive and more error	1
more expensive than an uncached	1
more reliable and reproducible results.	1
more reliable than third party	1
more reliable results. If you	1
more predictable than the other,	1
more predictable than integer comparisons.	1
more compact and efficient if	1
more compact if the offset	1
more compact by joining identical	1
more compact than an MFC	1
more compact so that the	1
more complex and often inefficient.	1
more complex if the parameter	1
more complex integer expressions. See	1
more complex cases it might	1
more convenient to calculate the	1
more convenient to rely on	1
more efficient, and sometimes it	1
more powerful solution is the	1
more powerful computers to keep	1
more powerful computers with more	1
more popular and used for	1
more realistic goal is to	1
more jobs simultaneously or seemingly	1
more resources, even if the	1
more cores, and it can	1
more dramatic when contentions occur	1
more detailed explanation of the	1
more reproducible time measurements: warm	1
more constants. For example, a	1
more detail in manual 2:	1
more compact. Accessing a member	1
more (128 or 256 bytes)	1
more focus on the costs	1
more readable when you are	1
more readable but unfortunately it	1
more well-structured program that is	1
more difficult. The functions must	1
more difficult. On the other	1
more complex, that there is	1
more complex, but not the	1
more efforts in optimizing library	1
more efficiently. It is therefore	1
more distant future. 12.3 Automatic	1
more efficient: // Example 7.18	1
more primitive, but efficient, way	1
more complicated. If the total	1
more heuristic guidelines. Most caches	1
more manageable and easier to	1
more powerful. The high priority	1
when the function is called.	1
when the function or variable	1
when the function returns. The	1
when the function returns. There	1
when the function returns. Alternatively,	1
when the function returns. alloca	1
when the function longjmp is	1
when the code is compiled	2
when the code is fast	1
when the code is distributed	1
when the code mixes float	1
when the data are accessed	1
when the program is loaded	2
when the program is run.	1
when the program is loaded.	1
when the program is started.	1
when the program is loaded,	1
when the program is busy	1
when the program starts up.	1
when the program 153 spends	1
when the loop count is	1
when the floating point register	1
when the floating point stack	2
when the size of the	2
when the size of an	1
when the pointer is deleted.	1
when the library is loaded	1
when the object is no	1
when the object is copied	1
when the number of available	1
when the number of allocations	1
when the clock frequency is	1
when the optimization of performance	1
when the SSE2 or later	2
when the SSE2 instruction set	5
when the arrays are accessed	1
when the work load is	2
when the result of the	1
when the virtual function is	1
when the hardware is updated.	1
when the next new model	1
when the next higher instruction	1
when the XMM registers are	3
when the computer is restarted	1
when the #pragma vector nontemporal	1
when the repeat count is	1
when the exponent is a	1
when the exponent is an	1
when the final value of	1
when the amount of memory	1
when the total number of	1
when the heap has become	1
when the heap space has	1
when the row length is	1
when the CPUID is artificially	1
when the CPUID instruction was	1
when the CPUID was manipulated	1
when the factor is a	1
when the AVX512 instruction set	1
when the highest level of	1
when the original is destroyed.	1
when the 145 SSE2 instruction	1
when a is true, which	1
when a function is called	1
when a memory block turns	1
when a program has one	1
when a pointer to a	1
when a new instruction set	1
when a user is waiting	1
when a thread is terminated.	1
when a global variable in	1
when a task switch occurs	1
when a fixed-size array is	1
when a genuine compiler became	1
when in fact it does	1
when it is not in	1
when it is not optimal	1
when it is not needed.	1
when it is outside the	1
when it is executed. An	1
when it is run. Examples	1
when it has not been	1
when it would be obvious	1
when it goes the other	1
when it comes to optimization,	1
when it returns. But what	1
when it involves pure function	1
when it occurs, but this	1
when it sees a relative	1
when it exits. For example,	1
when it changes. A branch	1
when code and data are	2
when code caching is critical.	1
when not selected. Compiler has	1
when an operand is infinity	1
when you are not testing.	1
when you are using vector	1
when you are using __fastcall.	1
when you want to make	1
when you want to optimize	1
when you compile with the	1
when you divide an integer	1
when you discover that there	1
when data are accessed in	1
when data are accessed backwards	1
when CPU access and memory	1
when instruction sets are mutually	1
when all threads have finished	1
when used for defining constants.	1
when used as macros are	1
when no reasonable upper limit	1
when no attempt is made	1
when using references. References are	1
when Intel libraries are used	1
when b is a float	1
when b is a float,	1
when b is floating point.	1
when b is true, which	1
when i is not less	1
when i is interpreted as	1
when static linking is used.	1
when there is no operating	1
when there is no exception	1
when C++ is chosen for	1
when objects of different sizes	2
when objects can be returned	1
when we read from 0x4700.	1
when we roll out the	1
when performance is important to	1
when software uses CPU dispatching:	1
when long double precision is	1
when elements are accessed in	1
when called from the shared	1
when called from a command	1
when called from main, but	1
when they are no longer	1
when they are needed, or	1
when they are long. This	1
when they are disabled will	1
when I die. See www.gnu.org/copyleft/fdl.html.	1
when accessed from the shared	1
when arrays are accessed through	1
when compiled with -fpic and	1
when compiled without -fpic because	1
when speed is critical. The	1
when speed is important. An	1
when several applications use the	1
when doing calculations on large	1
when doing calculations, and then	1
when optimizing multithreaded applications: The	1
when shared objects are not	1
when their live ranges do	1
when running in 64-bit mode	1
when running on the newest	1
when running on an Intel	1
when running on non-Intel processors	1
when n is a loop	1
when n is an array	1
when parts of the code	1
when AVX2 is supported in	1
when r = 28. We	1
when just a single function	1
when contentions do not occur.	1
when contentions occur in the	2
when columns is a power	1
when efficiency is important. A	1
when testing which version of	1
when testing worst-case performance: The	1
when alignment by 16 is	1
when compatibility with old CPUs	1
when copying a large object,	1
when accessing an object of	1
when needed. The bitwise operators	1
when compiling for the AVX	1
when compiling for a lower	1
when compiling for 32-bit Mac	1
when compiling for Windows and	1
when compiling for Linux. It	1
when compiling for AVX2, or	1
when compiling module2.cpp. The simplest	1
when calculating the address of	1
when applied to a class	1
when applied to a global	1
when applied to a local	1
when applied to a non-member	1
when applied to 32-bit integers,	1
when converted to unsigned. //	1
when multiplying with a constant.	1
when portability and ease of	1
when converting to double In	1
when deciding whether to use	1
when deciding whether to store	1
when deciding whether to base	1
when deciding whether it is	2
when type-casting pointers: The trick	1
when swapping the order of	1
when running. Programs using such	1
when choosing a container for	1
when going from AVX code	1
when mixing code compiled with	1
when alloca is used. The	1
when interprocedural optimization is enabled.	1
when returning from the function	1
when none of the time-consumers	1
when CriticalInnerFunction is called. The	1
when false. The value of	1
when bb[i] > 0 is	1
when activated by the user.	1
when exiting the {} brackets	1
A is not needed for	1
A is finished. Obviously, this	1
A is slow, then the	1
A and then B, and	1
A = 1.1, B =	2
A function is usually inlined	1
A function that is used	1
A function that calls other	1
A function that reads or	1
A function library with a	1
A code that is compiled	1
A code that does floating	1
A code branch for a	1
A compiler for Basic soon	1
A compiler that automatically reduces	1
A compiler can eliminate common	1
A compiler may reorder instructions	1
A compiler has to use	1
A more efficient solution that	1
A more complicated solution is	1
A more general method is	1
A more realistic goal is	1
A more detailed explanation of	1
A more primitive, but efficient,	1
A program with many branches	1
A CPU dispatcher then sets	1
A CPU dispatch mechanism that	1
A loop with a small	1
A loop with a high	1
A loop counter should preferably	1
A cache is a proxy	1
A cache works most efficiently	1
A class member variable with	1
A class doesn't need a	1
A floating point constant always	1
A double is represented with	1
A pointer is in fact	1
A pointer can be converted	1
A pointer or reference can	1
A + A; double Y	1
A + B; for (x	1
A static member function is	2
A static member function cannot	1
A C++ implementation may look	1
A possible negative value of	1
A clock cycle on one	1
A variable is accessed most	1
A variable in a DLL	1
A variable that is shared	1
A variable can be fetched	1
A variable number of objects	1
A variable cannot be stored	1
A performance monitor counter is	1
A very time-consuming function in	1
A software developer may choose	1
A long dependency chain may	1
A branch that always goes	1
A branch that goes one	1
A branch that goes many	1
A branch that follows a	1
A branch can be eliminated	1
A branch can also be	1
A branch instruction takes typically	1
A branch tree or switch	1
A const pointer or const	1
A const member function cannot	1
A const reference makes sure	1
A critical innermost loop should	1
A call to a graphics	1
A call from the main	1
A register is a small	1
A template is similar to	1
A template with many instances	1
A template class can be	1
A template parameter can also	1
A template instance has its	1
A test setup may look	1
A user interface library may	1
A method with multiple memory	1
A dynamic library can be	3
A part of memory called	1
A short int is 16	1
A simple way of solving	1
A simple solution to this	1
A simple constructor may be	1
A simple alternative is to	1
A simple periodic pattern can	1
A constant can be propagated	1
A large array can be	1
A large block containing many	1
A big file containing numerical	1
A language based on intermediate	1
A much higher resolution can	1
A virtual processor may have	1
A virtual destructor is as	1
A common situation where the	1
A thread that shares the	1
A good compiler can optimize	1
A good compiler will optimize	1
A good compiler will convert	1
A good way to prevent	1
A good optimizing compiler should	1
A good implementation uses XMM	1
A matrix or multidimensional array	2
A calculation may be moved	1
A problem with macros is	1
A few files, preferably in	1
A few decades ago, the	1
A list of which code	1
A structure of four float's	1
A copy constructor is not	1
A copy constructor may be	1
A shared object has a	1
A shared object compiled without	1
A lot of code is	1
A lot of advanced mathematical	1
A microprocessor with out-of-order capabilities	2
A dependency chain is a	1
A model with a higher	1
A conversion from floating point	1
A disadvantage is that CParent::Hello()	1
A disadvantage of using the	1
A disadvantage of binary data	1
A reference is the same	1
A dispatcher function decides which	1
A better performing software product	1
A | (B << 4)	1
A runtime DLL takes more	1
A longer loop- carried dependency	1
A look in my crystal	1
A linked list is a	1
A linked list is less	1
A higher level of optimization	1
A process or thread does	1
A binary tree or a	1
A binary tree may be	1
A union is a structure	1
A union can be used	1
A union can also be	1
A feature called "Gnu indirect	1
A constructor is implemented internally	1
A switch statement with many	1
A switch statements is a	1
A negative integer will be	1
A negative list, on the	1
A positive overflow of a	1
A computer with many such	1
A profiler is most useful	1
A particularly useful performance monitor	1
A limited number of variables	1
A limited "express" edition is	1
A database can consume a	1
A frame function is a	1
A frame function can be	1
A destructor is as efficient	1
A Pentium M processor may	1
A further extension of vector	1
A discussion of different algorithms	1
A non-Intel processor makes the	1
A macro will interfere with	1
A macro declared with #define	1
A little math is required	1
A smart pointer is an	1
A smart pointer may be	1
A situation where a program	1
A similar method can be	1
A newer method of doing	1
A metaprogramming implementation analogous to	1
A default constructor is not	1
A typical implementation of the	1
A pure function is a	1
A graphical user interface can	1
A hash table can improve	1
A hash table increases the	1
A hash map can be	1
A hash map may also	1
A collection of a variable	1
A complex digital operation can	1
A debugger can execute a	1
A leaf function is a	1
A leaf function is simpler	1
A 32- bit version for	1
A mixed implementation can be	1
A considerable delay comes when	1
A popular user interface library	1
A context switch is a	1
A multidimensional array should be	1
A realistic performance test should	1
A console mode program is	2
A command received by an	1
A safer implementation would only	1
A commercial compiler for 32-bit	1
A queue should be implemented	1
A missing check for buffer	1
A redesign can not only	1
A competing product is Borland's	1
A complete redesign of a	1
A for-loop or while-loop is	1
A for-loop has three clauses:	1
A GNU Free Documentation License	1
A programmable logic device is	1
A WTL application is generally	1
A command-line version of the	1
A thread-safe function should never	1
A Number) if an overflow	1
A sourcebook for fast 32-bit	1
A little-known alternative to using	1
A light-weight alternative is the	1
A Pragmatic Look at Exception	1
will be an efficient solution.	1
will be different for each	1
will be used most. The	1
will be cache contentions if	1
will be no extra overhead	1
will be efficient whether the	1
will be 2 In 64-bit	1
will be very efficient because	1
will be very helpful for	1
will be faster when the	1
will be stored in static	2
will be stored with each	1
will be stored on the	1
will be less efficient because	1
will be allocated for an	1
will be calculated as (b*2.0)/3.0	1
will be advantageous or not.	1
will be 1 b =	1
will be able to define	1
will be able to evaluate	1
will be better because the	1
will be replaced by the	1
will be loaded anyway. If	1
will be compatible with all	1
will be 2. The result	1
will be improved by a	1
will be loading the entire	1
will be used, even when	1
will be mispredicted 50% of	1
will be interpreted as a	1
will be called, or what	1
will be unable to access	1
will be unable to respond	1
will be filled up if	1
will be infinity or NAN	1
will be joined into one	1
will be joined together in	1
will be evicted when we	1
will be misleading reports of	1
will be rounded to 100000000.	1
will be non-zero, and therefore	1
will be mainstream next year.	1
will not be compatible with	1
will not be portable to	1
will not be negative. The	1
will not have the disadvantages	1
will not use the same	1
will not use GOT and	1
will not only be a	1
will not do such obvious	1
will not do so unless	1
will not get the same	1
will not get any answer.	1
will have to calculate each	1
will have an extra cache	1
will have an up-to-date version.	1
will have more references to	1
will have only one addition	1
will have one and only	1
will use the copy of	1
will use the XMM registers	1
will use different memory spaces	1
will use one 256-bit vector	1
will use full 64-bit addresses	1
will then be repeated 1024/4	1
will make the program slower.	1
will make the value wrap	1
will make the values of	1
will make a few comments	1
will make only one call	1
will make all dynamic libraries	1
will make multiple versions even	1
will make any call to	1
will make 32 AND-operations in	1
will make applications run faster	1
will make temp a register	1
will make exactly identical code	1
will make two. Some other	1
will point to the appropriate	1
will do the best job	1
will do this optimization automatically	1
will do such optimizations automatically,	1
will most likely be called,	1
will also work, 133 although	1
will return the result in	1
will call this distance the	1
will take only 256 clock	1
will take approximately 500 clock	1
will take 1000 * 100	1
will take precedence, not only	1
will often be C or	1
will often take several years	1
will often replace integer multiplication	1
will always run slower than	1
will always select the most	1
will always compete for the	1
will work only on Intel/x86-compatible	1
will work better. If the	1
will cause the cache to	1
will cause the heap to	1
will cause the creation of	1
will cause a cache miss.	1
will therefore be a disadvantage	1
will therefore need modification if	1
will get the value -100+100+100	1
will get time slices of	1
will get one instance for	1
will get no warning from	1
will support the ADX instructions	1
will run the advanced version	1
will run an inferior version	1
will run at more than	1
will run faster than when	1
will run faster because we	1
will calculate xn as x4xn-4.	1
will calculate (1./1.2345) at compile	1
will store the table in	1
will optimize this loop by	1
will both get the value	1
will replace the code in	1
will replace this by //	1
will typically use integer operations	1
will typically get the generic	1
will automatically replace such loops	1
will automatically choose the most	1
will see that p always	1
will see shortly. The following	1
will never be negative. The	1
will never spend time doing	1
will never throw any exception	1
will read four elements of	1
will give you access to	1
will give -2.0 55 In	1
will look different in other	1
will load the structure y	1
will generate the value infinity,	1
will generate a new instance	1
will generate an error message	1
will generate an overflow and	1
will generate an underflow and	1
will generate relative addresses in	1
will generate relocations in the	1
will generate -128, and subtracting	1
will usually unroll a loop	1
will reduce int x =	1
will choose the variables that	1
will start to calculate (c+d)	1
will start garbage collection when	1
will go into eight different	1
will go based on the	1
will change the code in	1
will change during the loop.	1
will become available in the	1
will produce the optimal code	1
will still take 10 clock	1
will prevent the compiler from	1
will shift out the sign	1
will save temp in memory.	1
will unroll loops if a	1
will fail if the object	1
will fail if an int	1
will fail if both are	1
will convert example 15.1b to	1
will convert example 12.8a to	1
will convert these types to	1
will occur in this hot	1
will consider if there is	1
will delay the availability of	1
will enable the compiler to	1
will enable optimizations across modules	1
will align data members to	1
will align large static arrays	1
will allow the compiler to	1
will happen if the size	1
will vectorize the code automatically	1
will vectorize a loop or	1
will try to fix the	1
will wait until seconds has	1
will break at the interrupt	1
will notice that the code	1
will notice that some compilers	1
will detect an error if	1
will soon be obsolete. But	1
will soon get a lot	1
will benefit from the larger	1
will appear as a large	1
will prefer to run a	1
will recognize that the two	1
will recognize that the values	1
will recognize that 10 is	1
will catch an exception in	1
will evict the cache line	1
will evict number 1. Number	1
will evict number 2, etc.	1
will remain locked after the	1
will invalidate each other's caches	1
will conclude this section by	1
will crash the program. 16.2	1
will crash on old operating	1
will provoke an error message	1
will interfere with any function	1
will contend for the same	1
will crash. See page 122	1
will stay on until you	1
will dominate in the future.	1
will trigger the error condition.	1
will grow in the future.	1
will cut off the binary	1
will propagate through the calculations	1
will occur: if (SIZE >	1
} The function F1 is	1
} The code in example	1
} The compiler may avoid	1
} The compiler may replace	1
} The compiler may reduce	1
} The compiler may change	1
} The compiler generates the	1
} The data in this	1
} The same example using	1
} The loop in example	1
} The loop unrolling in	1
} The most efficient vector	1
} The Intel compiler generates	1
} The two comparisons i	1
} The execution times per	1
} The advantage of using	1
} The multiplication by 2	1
} The Microsoft compiler does	1
} The declaration of the	1
} The factor sizeof(S1) =	1
} The pow function uses	1
} The InstructionSet() function is	1
} The resulting code will	1
} The indirect function feature	1
} The FactorialTable in example	1
} // Use template to	1
} // Function to store	3
} // No error return	1
} // Now call the	1
} // At the diagonal	1
} // x^2 // x^4	1
} // ipow faster than	1
} // Catch floating point	1
} // Or #include <ia32intrin.h>	1
} // Approximate exp(x) for	1
} // Non-polymorphic functions go	1
} // Entry to dispatched	1
} // Branch/loop function vectorized:	1
} // continue in dispatched	1
} // Default version return	1
} if (b) { return	1
} if (a == 0)	1
} if (level >= 4)	1
} This is of course	1
} This can be replaced	2
} This can be improved	1
} This function writes to	1
} This code has a	1
} This code took 50	1
} This has three advantages:	1
} This loop repeats 20	1
} This loop calculates four	1
} This calculation requires n-1	1
} This implementation uses a	1
} int main() { int	2
} int Size() { return	1
} A possible negative value	1
} A branch can be	1
} A good compiler will	1
} A problem with macros	1
} } The function F1	1
} } The compiler may	1
} } The compiler generates	1
} } The same example	1
} } The most efficient	1
} } The Intel compiler	1
} } The execution times	1
} } The Microsoft compiler	1
} } The resulting code	1
} } The FactorialTable in	1
} } // At the	1
} } // Catch floating	1
} } This function writes	1
} } This code took	1
} } This implementation uses	1
} } A branch can	1
} } } The execution	1
} } } // At	1
} } } This function	1
} } } This code	1
} } } } This	1
} } } } else	1
} } } } Transposing	1
} } } else {	1
} } } Assume that	1
} } } Obviously, a	1
} } } Transposing a	1
} } Example 14.30 finds	1
} } In this example,	1
} } void Func2() {	1
} } else { //	1
} } else { DTRUE:	1
} } Using a union	1
} } Loop unrolling Some	1
} } Assume that the	1
} } Obviously, a function	1
} } Here it is	1
} } #if INSTRSET ==	1
} } Transposing a matrix	1
} } 34 else {	1
} It is not recommended	1
} It is possible to	1
} Example 14.30 finds the	1
} Example 14.26 does not	1
} Example 14.27 assumes that	1
} If Func1 and Func2	1
} double xpow10(double x) {	1
} In this example, the	1
} In this example, a,	1
} In order to access	1
} There will be no	1
} return a + 1;	1
} return y; } double	1
} return sum; } Here,	1
} return add_elements(s); // add	1
} You have to include	1
} const int SIZE =	1
} void SelectAddMul(short int aa[],	1
} void Func2() { int	1
} void FuncB (int &	1
} void F0() { try	1
} An array initialized by	1
} These two functions are	1
} }; // The child	1
} }; // Function template	1
} }; // Index out	1
} }; // Full template	2
} }; // Called directly	1
} }; // Partial template	1
} }; class CChild2 :	1
} }; class C2 :	1
} }; void test ()	2
} else if (level >=	1
} else { a =	5
} else { // No	1
} else { // f	1
} else { // Generic	1
} else { float b[1000];	1
} else { return a	1
} else { return 0;	1
} else { y =	1
} else { list[i] +=	2
} else { F2(b); }	1
} else { goto CFALSE;	1
} else { goto DTRUE;	1
} else { FuncB(i); }	1
} else { DTRUE: d	1
} Using a union is	1
} We can multiply a	1
} x; x.f = 2.0f;	1
} Here, the address of	1
} Here, the Gnu compiler	1
} Here, it is necessary	1
} Here, each value xn	1
} Here, we have inserted	1
} Here, log(2.0) is only	1
} Loop unrolling Some compilers	1
} Assume that the numbers	1
} sum = (s0+s1)+(s2+s3); Now	1
} u; if (u.i &	1
} u; if (u.i[1] <	1
} u; int n; u.i	1
} u; int n; 143	1
} u; u.i ^= 0x80000000;	1
} u; u.i &= 0x7FFFFFFF;	1
} Obviously, a function should	1
} Here it is possible	1
} #if INSTRSET == 2	1
} Induction variables are often	1
} T & operator[] (unsigned	1
} polynomial // Polynomial coefficients	1
} #endif // INSTRSET ==	1
} Can be reduced to:	1
} z = y +	1
} catch (...) { ...	1
} 135 The if statement	1
} 73 Without optimization, the	1
} Microprocessors with out-of-order capabilities	1
} FuncC(i); } This loop	1
} u, v; if (u.i	2
} By giving each constant	1
} 109 } It is	1
} Transposing a matrix is	1
} 34 else { CFALSE:	1
} module2.cpp int Func2() {	1
} 59 third generations classes	1
} printf("\nResults:"); for (i =	1
} 68 else { y	1
} 70 Induction variables An	1
} 152 If you want	1
} 138 A similar method	1
} 115 from bb into	1
} 111 } You have	1
} 112 Vectorized table lookup	1
} list[300] = 0; 14.6	1
then the code is likely	1
then the code can become	1
then the code can probably	1
then the code will not	1
then the compiler can see	1
then the compiler may calculate	1
then the compiler would be	1
then the CPU may occasionally	1
then the loop branch must	1
then the loop control branch	1
then the most efficient solution	1
then the pointer has to	1
then the version in main	1
then the value is already	1
then the critical part can	1
then the first result is	1
then the user might experience	1
then the even integer is	1
then the & operator (bitwise	1
then the error is not	1
then the exception handler needs	1
then the line that covered	1
then the line containing the	1
then the solution is to	1
then the solution is more	1
then the optimal version of	1
then the optimal solution is	1
then the microprocessor can begin	1
then the multiplication can be	1
then the multiplication would take	1
then the expression y =	1
then the dispatch branch of	1
then the second operand is	2
then the profiler may sample	1
then the instance in main	1
then the offset has to	1
then the effect of nontemporal	1
then the target address is	1
then the nontemporal write instructions	1
then the length of a	1
then the DLL is relocated	1
then the mirror elements matrix[c][r]	1
then the sampling generates too	1
then the transformation of example	1
then a simple array is	1
then a simple array can	1
then a linear array will	1
then a sorted list is	1
then be placed in a	1
then be repeated 1024/4 =	1
then it is the "best	1
then it is not possible	1
then it is not advantageous	1
then it is more efficient	1
then it is important to	3
then it is necessary to	2
then it is advantageous to	1
then it is likely that	1
then it is recommended to	3
then it is usually faster	1
then it is almost certain	1
then it is preferred to	1
then it is convenient to	1
then it is preferable to	1
then it is certainly more	1
then it is advisable to	1
then it can be advantageous	1
then it can do another	1
then it may be possible	1
then it may be useful	2
then it may be necessary	1
then it may be optimal	1
then it may be better	1
then it may be freed	1
then it may not be	1
then it may take only	1
then it will be compatible	1
then it will run the	1
then it will run an	1
then it will still take	1
then it will break at	1
then it must return to	1
then it becomes invalid as	1
then it obviously takes time	1
then an optimizing compiler would	1
then you are risking to	1
then you can have one	1
then you can set multiple	1
then you can avoid hyperthreading	1
then you can get the	1
then you can get very	1
then you can generally assume	1
then you can obtain most	1
then you may of course	1
then you may as well	1
then you may use a	1
then you may make some	1
then you may also look	1
then you may get a	1
then you may put the	1
then you may improve the	1
then you may improve efficiency	1
then you may consider if	2
then you may consider whether	1
then you have to call	1
then you have to store	1
then you have to execute	1
then you will have only	1
then you will get one	1
then you will soon get	1
then you should test the	1
then you should disable it	1
then you cannot be sure	1
then you cannot assume that	1
then you cannot rely on	1
then you need to remove	1
then you must do the	1
then you don't need a	1
then this can cause contentions	1
then this loop will take	1
then this might be a	1
then use a smart pointer	1
then use a linear array	1
then use a queue. It	1
then use an object file	1
then use this information to	1
then use only the lower	1
then use binary search for	1
then use #pragma vector aligned	1
then make it a template:	1
then make an additional integer	1
then make sure the startup	1
then make sure it works	1
then all the G values,	1
then all five values have	1
then each vector can hold	1
then each thread will run	1
then there is a pointer	1
then there is a risk	1
then there is a 90%	1
then there is an extra	1
then there is no need	1
then there is no advantage	1
then there is no reason	1
then there is no difference	1
then there is no guarantee	1
then there may be a	1
then many times the other	1
then we can avoid the	1
then we can roughly estimate	1
then we have an estimated	1
then we have (set) =	1
then we will consider if	1
then we need metaprogramming. None	1
then we would have to	1
then stored at address [ecx+eax*4].	1
then call _mm256_zeroupper() before calling	1
then call _mm256_zeroupper() before leaving	2
then call __intel_cpu_features_init_x(). In other	1
then its value is multiplied	1
then calls a device driver.	1
then calls exit. Calling exit	1
then c is added to	1
then check for the error	1
then run on its own	1
then add the keyword static	1
then add a few unused	1
then both can be accessed	1
then replace it by a	1
then sets a function pointer	1
then put the most often	1
then put the most predictable	1
then put the operand that	1
then transferred as machine code	1
then linked together in the	1
then become invalid. The heap	1
then turn it off and	1
then output after the test	1
then tell the compiler explicitly	1
then convert the result back	1
then convert it to signed	1
then handle its own block	1
then f is added to	1
then F1 has to check	1
then try to run two	1
then measurements can become imprecise	1
then follow the advice given	1
then think that you can	1
then B, and the calculation	1
then N&(N-1) is 0. The	1
then sizeof(S1) would be 8	1
then interpret that string as	1
then 0+1.23456 = 1.23456. But	1
then de-referenced in order to	1
then merge the multiple data	1
then FuncC. Unrolling the loop	1
then d+e, then c is	1
It is the responsibility of	6
It is a way of	1
It is not a good	1
It is not even compatible	1
It is not always possible	1
It is not necessary to	1
It is not good to	1
It is not advantageous to	1
It is not recommended to	3
It is not intended for	1
It is not permissible to	1
It is not unusual for	1
It is more efficient to	6
It is more common to	1
It is more safe to	1
It is used for storing	1
It is also possible to	2
It is also useful in	1
It is possible to make	4
It is possible to do	3
It is possible to avoid	1
It is possible to compile	1
It is possible to store	1
It is possible to write	1
It is possible to reduce	1
It is possible to insert	1
It is possible to implement	1
It is possible to vectorize	1
It is possible to express	1
It is possible in some	1
It is very important to	1
It is faster to first	1
It is faster to compose	1
It is faster than x	1
It is less efficient if	1
It is often more efficient	1
It is often possible to	1
It is often faster to	1
It is often useful to	1
It is often necessary to	1
It is often easier to	1
It is often easier said	1
It is often preferable to	1
It is useful to know	1
It is useful for the	1
It is important to economize	2
It is important to distinguish	1
It is important to study	1
It is important to note	1
It is important to weigh	1
It is important for the	1
It is important that the	2
It is important that all	1
It is accessed with a	1
It is best when the	1
It is necessary to use	1
It is necessary to adhere	1
It is common to make	2
It is common for software	1
It is common practice to	1
It is good to do	1
It is therefore a good	1
It is therefore not possible	1
It is therefore possible for	1
It is therefore important to	1
It is therefore necessary to	3
It is therefore certain to	1
It is therefore recommended to	1
It is therefore recommended that	1
It is therefore safer to	1
It is advantageous to use	1
It is simply a matter	2
It is quite difficult to	1
It is quite expensive -	1
It is recommended to use	5
It is recommended to make	1
It is recommended to return	1
It is recommended to put	1
It is recommended to turn	3
It is recommended to enable	2
It is recommended to try	1
It is difficult to predict	2
It is difficult for the	2
It is usually much faster	1
It is just easier to	1
It is intended for array	1
It is intended as a	1
It is sometimes possible to	1
It is discussed how to	2
It is rarely possible for	1
It is rarely worth the	1
It is easier to write	1
It is used, for example,	1
It is easy to make	1
It is easy to port	1
It is almost always advantageous	1
It is preferred to declare	1
It is free and open	1
It is measured simply by	1
It is expected to replace	1
It is safer to use	1
It is 102 also useful	1
It is unacceptable to the	1
It is assumed that the	1
It is OK, however, to	1
It is strongly recommended to	1
It is tempting to fine-	1
It can be very useful	1
It can be advantageous to	2
It can also be used	1
It can also be advantageous	1
It can also eliminate i	1
It can call the polymorphic	1
It can take several seconds	1
It can therefore be advantageous	1
It can contain either sixteen	1
It may in some cases	1
It may be more efficient	1
It may be more convenient	1
It may be possible to	1
It may be useful to	2
It may be necessary to	1
It may be advantageous to	1
It may be obvious to	1
It may be worthwhile to	1
It may not be advantageous	1
It may not be optimal	1
It may not be safe	1
It may even have a	1
It may fail to distinguish	1
It may catch programming errors	1
It may seem illogical that	1
It may neverthe- less be	1
It will not use the	1
It will look different in	1
It will fail if both	1
It will crash on old	1
It has the special feature	1
It has some syntax checking	1
It has excellent support for	1
It should be possible to	1
It should be clear from	1
It should therefore preferably be	1
It should never respond to	1
It also works on Intel	1
It also prevents the compiler	1
It takes some experience to	1
It takes between 2 and	1
It takes longer time to	1
It makes a runtime check	1
It does the same as	1
It does not produce any	1
It does this by assigning	1
It must be emphasized that	1
It doesn't prevent two threads	1
It works somewhat less efficiently	1
It uses the dispatch on	1
It uses ebx as a	1
It simply stores the lower	1
It requires support from both	1
It just happened to be	1
It supports 32-bit and 64-bit	1
It comes with most distributions	1
It might be possible to	1
It reveals a funda- mentally	1
It compares eax with 100	1
Example 13.1 // CPU dispatching	1
Example 16.2 #include <stdio.h> #include	1
Example 14.9 struct S1 {	1
Example 14.8 const int rows	1
Example 12.4b shows how this	1
Example 12.4b executes three to	1
Example 16.1 #include <intrin.h> long	1
Example 9.3 #include <malloc.h> void	1
Example 8.26a void Func(int a[],	1
Example 8.26a compiled to assembly:	1
Example 12.2 __declspec(align(16)) struct S1	1
Example 14.6 float list[16]; int	1
Example 14.28 union { float	1
Example 14.30 const int size	1
Example 14.30 finds the numerically	1
Example 7.2 a = b	1
Example 7.1 float SomeFunction (int	1
Example 7.8 if (handle !=	1
Example 14.10 int a, b,	1
Example 14.11 int a, b,	1
Example 8.4 double a =	1
Example 8.7 int SomeFunction (int	1
Example 7.21 int i; short	1
Example 9.6b. #include "xmmintrin.h" //	1
Example 9.5a const int SIZE	1
Example 7.7 unsigned int i;	1
Example 7.11 bool a; float	1
Example 7.12 void FuncA (int	1
Example 11.3 const int size	1
Example 7.22 short int a[100];	1
Example 7.23 int i; short	1
Example 7.20 int i; if	1
Example 7.27 float x; *(int*)&x	1
Example 7.24 float a; double	1
Example 7.25 unsigned int u;	1
Example 7.28 class c1 {	1
Example 9.4 const int NUMROWS	1
Example 7.14 class c1; int	1
Example 7.16 float list[100]; memset(list,	1
Example 7.17 const int rows	1
Example 7.13 struct abc {int	1
Example 7.19 int i; float	1
Example 7.18 int FuncRow(int); int	1
Example 12.5. Aligned arrays //	1
Example 8.26b void Func(int a[],	1
Example 8.26b compiled to assembly:	1
Example 14.12b int list[300]; int	1
Example 14.14b double a, b;	1
Example 15.1c. Calculate integer power,	1
Example 14.14a double a, b;	1
Example 8.15a struct S1 {double	1
Example 14.13b int list[300]; int	1
Example 9.6a const int SIZE	1
Example 9.6a Time per element	1
Example 12.1a. Automatic vectorization const	1
Example 14.19 static inline int	1
Example 14.1c void CriticalInnerFunction ()	1
Example 14.23b and 14.30 will	1
Example 14.23b union { double	1
Example 11.2b const int size	1
Example 11.1a float a, b,	1
Example 11.1b float a, b,	1
Example 7.15b SafeArray <float, 100>	1
Example 15.1b. Calculate integer power	1
Example 14.26 does not check	1
Example 14.26 union { float	1
Example 14.27 union { float	1
Example 14.27 assumes that we	1
Example 14.23 union { float	1
Example 8.21 is indeed a	1
Example 8.21 void Func1 (int	1
Example 14.5b if ((unsigned int)(i	1
Example 14.5a const int min	1
Example 7.6. Set flush-to-zero and	1
Example 9.5b void transpose(double a[SIZE][SIZE])	1
Example 13.2. CPU dispatching in	1
Example 7.40a struct Bitfield {	1
Example 7.40b union Bitfield {	1
Example 7.40c x.abc = (A	1
Example 14.3a int n; switch	1
Example 14.3b int n; static	1
Example 11.2a const int size	1
Example 12.4a. Loop with branch	1
Example 8.9b int SomeFunction (int	1
Example 8.9a int SomeFunction (int	1
Example 8.23b. Calculate polynomial with	1
Example 14.1b int factorial (int	1
Example 14.1a int factorial (int	1
Example 8.3a float parabola (float	1
Example 12.4c. Same example, vectorized	1
Example 12.6. Function with vector	1
Example 7.29b floata; boolb=0; static	1
Example 7.29a float a; bool	1
Example 7.34a. Use macro as	1
Example 14.13c int list[301]; int	1
Example 14.13a int list[300]; int	1
Example 8.15b struct S1 {double	1
Example 7.10b char a =	1
Example 7.10a bool a, b;	1
Example 12.4e. Same example, using	1
Example 8.5b a += 2;	1
Example 8.5a void Plus2 (int	1
Example 7.31b char string[100], *p	1
Example 7.31a char string[100], *p	1
Example 7.43b. Compile-time polymorphism with	1
Example 14.4b if ((unsigned int)i	1
Example 15.1a. Calculate x to	1
Example 8.13a int i, a[100],	1
Example 8.13b int i, a[100],	1
Example 14.15b if (a *	1
Example 9.1a int Func(int); const	1
Example 9.1b int Func(int); const	1
Example 7.33b const int size	1
Example 8.11b int SomeFunction (int	1
Example 8.11a int SomeFunction (int	1
Example 7.38b. Alternative to multiple	1
Example 8.1b float parabola (float	1
Example 8.1a float square (float	1
Example 12.9b. Taylor series, vectorized	1
Example 8.16 float a, b,	1
Example 8.17 char a =	1
Example 8.18 float a =	1
Example 7.43 on page 58	1
Example 7.42 int Multiply (int	1
Example 7.45 // Portability note:	1
Example 7.44 class C1 {	1
Example 7.4. Signed and unsigned	1
Example 12.8a. Sum of a	1
Example 7.35b struct S1 {	1
Example 7.35a struct S1 {	1
Example 9.6b 64 64 14.0	1
Example 8.23a. Loop to make	1
Example 12.8b. Sum of a	1
Example 14.18c double a, b;	1
Example 8.2a double a, b;	1
Example 8.2b a = b	1
Example 14.7b. Testing multiple conditions	1
Example 7.9b char a =	1
Example 7.9a bool a, b,	1
Example 8.25 void Func ()	1
Example 8.20 module1.cpp int Func1(int	1
Example 8.22 #ifdef __GNUC__ #define	1
Example 12.9a. Taylor series float	1
Example 8.3b a = 5.0f;	1
Example 7.38a. Multiple inheritance class	1
Example 7.43a. Runtime polymorphism with	1
Example 14.21. // Only for	1
Example 7.32a double x, n,	1
Example 14.22b unsigned int u;	1
Example 14.22a unsigned int u;	1
Example 15.1d. Integer power using	1
Example 14.18a float a, b;	1
Example 14.18b float a, b;	1
Example 9.2b void F3(bool y)	1
Example 9.2a void F1(int x[]);	1
Example 8.24. Integer constant const	1
Example 7.32b double x, n,	1
Example 8.6a int a, b,	1
Example 8.6b int a, b,	1
Example 7.15a. Array with bounds	1
Example 7.5. Set flush-to-zero mode	1
Example 14.17b double a1, a2,	1
Example 14.7a. Testing multiple conditions	1
Example 14.16a double y, a1,	1
Example 7.26b float a[100]; int	1
Example 7.26a float a[100]; int	1
Example 8.19. Devirtualization class C0	1
Example 8.10b a = b;	1
Example 8.10a if (true) {	1
Example 7.30b int i; 45	1
Example 7.30a int i; for	1
Example 7.3. Explain volatile volatile	1
Example 7.39 union { float	1
Example 7.37 class S3 {	1
Example 7.36 class S2 {	1
Example 12.1b. Vectorization with alignment	1
Example 8.12a int i, a[2];	1
Example 8.12b int a[2]; a[0]	1
Example 12.4b. Vectorized with SSE2	1
Example 12.4d. Same example, using	1
Example 14.12a int list[300]; int	1
Example 8.14b int i, a[100],	1
Example 8.14a int i, a[100];	1
Example 7.33a const int size	1
Example 8.8b double x, y;	1
Example 8.8a double x, y,	1
Example 12.7. Vector class code	1
Example 7.34b. Replace macro by	1
Example 14.16b double y, a1,	1
Example 14.17a double a1, a2,	1
Example 14.15a if (a >	1
Example 14.2a float a; int	1
Example 14.2b float a; int	1
Example 14.29 union { float	1
Example 14.24 union { float	1
Example 14.25 union { float	1
Example 14.20 double d =	1
Example 14.4a const int size	1
Example 7.41a class vector {	1
Example 7.41b a.x = b.x	1
from the function in which	1
from the compiler if the	1
from the same or a	1
from the same address so	1
from the same critical part	1
from the same few parameters.	1
from the same source code.	1
from the loop counter. Any	1
from the cache in just	1
from the cache between each	1
from the library is needed.	1
from the library file and	1
from the value that is	1
from the value that lies	1
from the stack before the	1
from the function. The function	1
from the function. The assembly	1
from the shared object. This	1
from the shared object. Likewise,	1
from the above example, then	1
from the above security advices	1
from the application code. An	1
from the dispatcher function. This	1
from the main executable to	1
from the level-2 cache because	1
from the exponent if there	1
from the message loop of	1
from the previous value as	2
from the previous value than	1
from the beginning rather than	1
from the command line with	1
from the larger address space	1
from the counts. It is	1
from the linker. The map	1
from the caller to the	1
from the server. These problems	1
from the IDE on some	1
from the leftmost column to	1
from a number of sources.	1
from a value that is	1
from a variable in memory,	1
from a table of constants	1
from a table in the	1
from a branch misprediction is	1
from a pointer. It has	1
from a previous branch. Example:	1
from a hard disk or	1
from a reliable source so	1
from a command line or	1
from a project built with	1
from a buffer. It should	1
from a technological point of	1
from a website. 5 Choosing	1
from a higher-priority thread running	1
from this is that all	1
from this discussion that the	1
from time T to T+5,	1
from time T+1 to T+6,	1
from memory a hundred times.	1
from memory each time it	1
from memory address a =	1
from memory plus the costs	1
from different compilers is generally	1
from different addresses with different	1
from same module static static	1
from same module __attribute__ ((visibility	1
from functions that require cleanup	1
from only one or a	1
from other applications such as	1
from other modules. You may	1
from other processes. The profiler	1
from one function to another.	1
from one object to another.	1
from one iteration to the	1
from one place in the	1
from one auto_ptr to another	1
from integer to floating point	1
from integer to floating point.	1
from set 0x1C. If the	1
from floating point to integer	2
from floating point to integer.	1
from floating point numbers to	1
from each other is inefficient	1
from example 15.1b to 15.1c	1
from example 15.1b to 15.1c?	1
from example 16.1 const int	1
from example 8.26a (32-bit mode):	1
from example 8.26b: ; Example	1
from example 9.5a: 98 int	1
from compilers that have support	1
from using registers for the	1
from Intel and one from	1
from Intel and Microsoft C++	1
from library asmlib.. // or	1
from float or double to	2
from multiple parent classes in	1
from static memory to the	2
from static memory to stack	2
from static libraries (.lib or	1
from 64-bit MMX to 128-bit	1
from array static inline __m128i	4
from many different places). Some	1
from any other module then	1
from any other module. The	1
from any function. Global variables	1
from address 0x2710 and later	1
from address 0x2710 will cause	2
from address 0x2700 to 0x273F	1
from register storage. Live range	1
from programming languages that do	1
from 0 to 12. Higher	1
from 0 to 15. If	1
from error conditions in a	1
from making a non-inlined copy	1
from making an induction variable	1
from making an unused copy	1
from making optimizations that rely	1
from making optimizations across function	1
from stack ; return ;	1
from its many optimization features	1
from single precision to double	1
from AVX code to non-AVX	2
from another module. The compiler	1
from another module. This non-inlined	1
from operators that produce Boolean	1
from doing the optimizations that	1
from doing multiple calculations simultaneously	1
from doing optimizations on that	1
from doing out-of-order execution, as	1
from addresses 0x2F00, 0x3700, 0x3F00	1
from both compiler, linker and	1
from string functions. A metaprogramming	1
from Intel, AMD and VIA	1
from main through an imported	1
from unknown sources. The above	1
from RAM memory can take	1
from RAM memory if it	1
from loading any cache lines	1
from 20 to 10 means	1
from setting the flush-to-zero mode	1
from within the same shared	1
from row 28 below the	1
from Microsoft, Intel and Gnu.	1
from fully utilizing its out-of-	1
from disk. Memory-hungry applications force	1
from Func 87 used cache	1
from poor branch prediction. Example:	1
from www.agner.org/optimize/asmlib.zip. // Example 16.1	1
from www.agner.org/optimize/asmlib.zip. Currently includes optimized	1
from mispredictions. 44 In some	1
from cc into vector c:	4
from optimal. The branches may	1
from seldom used functions, and	1
from Intel: "IA-32 Intel Architecture	1
from bb into vector b:	4
from errors. The following example	1
from errors. If you just	1
from aligning the data optimally,	1
from assuming that *p+2 is	1
from exceptions. See page 61.	1
from -128 to +127. An	1
from -128 generates 127. The	1
from cleaning up because it	1
from 0x2700 to 0x273F will	1
from 0x2700 to 0x273F would	1
from overlapping calculations. The loop	1
from 0x4700. Reading again from	1
from testing. Here, you should	1
from www.intel.com. (See also page	1
from www.intel.com. Manual on using	1
from me. My vector class	1
from www.agner.org/optimize. Copyright conditions are	1
from everybody. So please don't	1
from main, but also when	1
from attempting to write the	1
from Intel. See Intel Technology	1
from scratch. This would not	1
from www.agner.org/optimize/testp.zip. This tool is	1
from www.agner.org/optimize/testp.zip or get ReadTSC	1
from knowing that the objects	1
from a=a*2; to return a+1;.	1
memory is a multiple of	1
memory is also used for	1
memory is contiguous with other	1
memory is mirrored in the	1
memory a function uses by	1
memory a hundred times. This	1
memory to the stack is	1
memory to the stack when	1
memory to be fragmented and	1
memory to stack memory outside	1
memory to stack memory. Copying	1
memory to become fragmented and	1
memory to disk. Memory swapping	1
memory to disk. Provoke cache	1
memory and will have one	1
memory and we do not	1
memory and therefore it is	1
memory and string functions and	1
memory and string instructions. The	1
memory and disk space were	1
memory and insert a code	1
memory and computing power than	1
memory in a computer. The	1
memory in advance. The frequent	1
memory for a new object	1
memory for all the objects	1
memory that is organized in	1
memory can take quite a	1
memory can cause caching problems	1
memory or other resources. There	1
memory or accessed in a	1
memory or cache. Most compilers	1
memory if the size of	1
memory if it is not	1
memory if organized as follows:	1
memory by requesting a map	1
memory with new and delete	1
memory on the stack rather	1
memory may not be optimally	1
memory may even be a	1
memory when the program is	1
memory when exiting the {}	1
memory will be allocated for	1
memory will benefit from the	1
memory then there is a	1
memory at the start of	1
memory which is contiguous with	1
memory used by the test	1
memory used by a variable	1
memory page size (4096). This	1
memory each time it is	1
memory into a container class.	1
memory takes only 2-3 clock	1
memory takes much more time	1
memory called the heap is	1
memory address a = 10000,	1
memory address and shared between	1
memory address that is divisible	2
memory address by the formula:	1
memory address at which a	1
memory address which is divisible	1
memory address cannot be loaded	1
memory rather than in a	2
memory without loading a cache	1
memory even when just a	1
memory access is the biggest	1
memory access is a bottleneck.	1
memory access and cache size.	1
memory access are critical time	1
memory access ............................................................................................. 87 9.1	1
memory access 9.1 Caching of	1
memory inside the CPU used	1
memory store An uncached write	1
memory addresses is reused again	1
memory addresses divisible by the	1
memory used. You may avoid	1
memory allocation is done with	1
memory allocation is particularly risky	1
memory allocation is used, it	1
memory allocation is negligible when	1
memory allocation is unnecessarily wasteful	1
memory allocation in an inefficient	1
memory allocation for all objects.	1
memory allocation can be mentioned	1
memory allocation can therefore be	1
memory allocation with new and	1
memory allocation may be needed,	1
memory allocation when the size	1
memory allocation using new/delete or	1
memory allocation also tends to	1
memory allocation are: The process	1
memory allocation are: int BigArray[1024]	1
memory allocation Dynamic memory allocation	1
memory allocation Any array or	1
memory allocation Objects and arrays	1
memory allocation ...................................................................................... 90 9.7	1
memory allocation (new and delete).	1
memory space is used for	1
memory space is freed when	1
memory space is occupied throughout	1
memory space to store data	1
memory space can be given	1
memory space by allowing two	1
memory space where a #define	1
memory space never becomes fragmented	1
memory space becomes more fragmented	1
memory model is hardly ever	1
memory model used here. The	1
memory model where the combined	1
memory block is allocated and	1
memory block is re-allocated every	1
memory block and a pointer	1
memory block and copy the	1
memory block for every four	1
memory block that the object	1
memory block that has already	1
memory block than to store	1
memory block from one object	1
memory block should have its	1
memory block into the beginning	1
memory block every time a	2
memory block turns out to	1
memory resources than a static	1
memory needed in advance rather	1
memory pointer. This is the	1
memory outside the innermost loop.	1
memory access. The execution core	1
memory access. Assume that a	1
memory access. 12 Using vector	1
memory buffer and read or	1
memory address. Pointer arithmetic operations	1
memory allocation. This method also	1
memory allocation. There is no	1
memory allocation. You should avoid	1
memory allocation. See page 93	1
memory allocation. Some programming languages,	1
memory allocation. Dynamic memory allocation	1
memory allocation. Do not use	1
memory allocation. Container classes can	1
memory blocks is more efficient.	1
memory blocks than there are	1
memory blocks makes the access	1
memory block. This is inefficient,	1
memory block. This requires a	1
memory block. A large block	1
memory block. Do not use	1
memory required is not known	1
memory space. A floating point	1
memory space. A union can	1
memory Memory allocated with new	1
memory plus the costs to	1
memory swapping and other resource	1
memory addresses. If caching is	1
memory pool. See the examples	1
memory pool. See www.agner.org/optimize/cppexamples.zip. If	1
memory pool. 15 Integer overflow	1
memory pool. Alignment? Some applications	1
memory area for a and	1
memory area for different objects	1
memory blocks, for example: Use	1
memory blocks, or if the	1
memory blocks, either in the	1
memory space, even when it	1
memory caching. 3.14 Context switches	1
memory allocations of sizes 1,	1
memory heap. The heap manager	1
memory footprint is unreasonably large.	1
memory footprint than the alternative	1
memory area. The nontemporal write	1
memory area. Join identical branches	1
memory spaces for different arrays	1
memory management and garbage collection,	1
memory leaks and other common	1
memory leaks if you forget	1
memory leak. An even worse	1
memory blocks. A method with	1
memory areas. Data that are	1
memory areas, and there will	1
memory pool, as explained above.	1
memory re-allocation is needed. Objects	1
memory block, but this memory	1
memory economy and small code	1
memory fragmentation. Bounds checking is	1
memory economy, cache efficiency and	1
memory bus is saturated. This	1
memory footprint. If, for example,	1
memory ports, etc. of only	1
memory caches. Typically, there is	1
memory released when the object	1
memory pooling. It is more	1
memory leaks. It is the	1
memory requirement. Useful when no	1
at the function bodies above,	1
at the code generated by	2
at the compiler output can	1
at the time the software	2
at the time of programming	1
at the time of programming.	2
at the time it was	2
at the time we are	1
at the time MemberPointer is	1
at the vector element level	2
at the same time to	1
at the same time as	1
at the same time. The	1
at the same time. A	2
at the same time. There	1
at the same time. Example:	1
at the same time, except	1
at the CPU clock frequency	1
at the example of a	1
at the object file level.	1
at the possible alternatives to	1
at the assembly output listing	1
at the cost of longer	1
at the end of the	1
at the last cache level,	1
at the second step. The	1
at the start of the	1
at the start so that	1
at the diagonal remain unchanged.	1
at the label $B1$2:. This	1
at the interrupt 3 breakpoint	1
at the actual clock frequency	1
at the diagonal. Each element	1
at the "worst case" counts.	1
at a time and it	1
at a time and show	1
at a time and afterwards	1
at a time in vectors	1
at a time because each	1
at a time packed into	1
at a memory address that	2
at a memory address which	1
at a time. This is	1
at a time. A simple	1
at a time. You may	1
at a time. Do not	1
at a disadvantage if the	1
at a high price, and	1
at a higher address which	1
at a link map or	1
at a time, then the	1
at a lower priority level,	1
at to see if a	1
at an address divisible by	4
at an address below 2	1
at an arbitrary memory address	1
at this place. This can	1
at more than half the	1
at different memory addresses. If	1
at different places when the	1
at different times: Dispatch on	1
at CPU brand names and	1
at which a dynamic library	1
at all is for the	1
at all to the profiler.	1
at all on AMD and	1
at all because the 33	1
at page 150. Using templates	1
at each function call to	1
at each access. The compiler	1
at any time, then the	1
at address [ecx+eax*4]. This is	1
at address esp+8 and esp+12	1
at less than half speed	1
at its mirror position above	1
at specific places in the	1
at compile time to eliminate	1
at compile time and insert	1
at compile time or a	2
at compile time then there	1
at compile time because of	1
at compile time which version	1
at compile time so that	1
at compile time rather than	2
at compile time while if	1
at compile time here. It	1
at compile time. The function	1
at compile time. The storage	1
at compile time. // Example	1
at compile time. A variable	1
at compile time. A template	1
at compile time. For example,	1
at compile time. For example:	1
at compile time. Some compilers	1
at compile time. Integer division	1
at compile time. No memory	1
at compile time. Templates make	1
at compile time. Are objects	1
at compile time. Text strings	1
at compile time. Four typical	1
at compile time. (Of course	1
at compile time. (Examples can	1
at compile time, but the	1
at compile time? If the	1
at doing equivalent reductions at	1
at run time. Therefore, both	1
at every function or every	1
at every access. The code	1
at 1 byte at 8,	1
at optimizing away p and	1
at certain events, for example	1
at their own initiative whenever	1
at what happens inside the	1
at runtime if all the	1
at runtime from the caller	1
at runtime here if the	1
at load time. The program	1
at load time. Shared objects	1
at 0, last byte at	3
at installation time. Each code	1
at least the same instruction	1
at least the cache line	1
at least a large part	1
at least in some situations,	1
at least in simple cases.	1
at least at the last	1
at least one other function.	1
at least one virtual member	1
at least temporarily. Using the	1
at once The bitwise operators	1
at 8, last byte at	2
at random times and make	1
at 19 }; S1 ArrayOfStructures[100];	1
at vectorization. 3. Use appropriate	1
at compile-time whether the object	1
at 15 byte at 16,	1
at half speed or full	1
at 7 int d; //	1
at reducing integer expressions than	1
at www.agner.org/optimize/asmlib.zip. The following example	1
at www.agner.org/optimize/asmlib.zip. If you want	1
at 16, last byte at	1
at all. This makes the	1
at all. This method can	1
at all. Can only run	1
at 13 // 2 unused	1
at 11 short int a;	1
at initialization. The program or	1
at initialization. Each code version	1
at regular time intervals. Some	1
at round memory addresses divisible	1
at round addresses. Especially the	1
at inconvenient times when a	1
at inconvenient times. This can	1
at inconvenient times. A queue	1
at www.agner.org/optimize/cppexamples.zip for how to	1
at www.agner.org/optimize/cppexamples.zip contains examples of	1
at www.agner.org/optimize/cppexamples.zip containing container classes	1
at www.agner.org/optimize/cppexamples.zip. 9.9 Access data	1
at Exception Specifications, Dr Dobbs	1
at runtime. Example 7.43 on	1
at runtime. #define directives are	1
at runtime. Polymorphism is one	1
at unpredictable times and cause	1
at unpredictable intervals which may	1
at compile- time, but not	1
at 12, last byte at	1
at once................................... 135 14.4 Integer	1
at hand. Low-level languages are	1
at runtime). The following techniques	1
at 403 int ReadB() {return	1
at www.agner.org/optimize/asmlib.zip contains various functions	1
at Wikibooks. The following list	1
at explaining the relative efficiency	1
at 400, last byte at	1
at runtime, if only you	1
at 399 int b; //	1
data is a common error	1
data is to declare it	1
data is that it can	1
data is more compact and	1
data to the right format	1
data to optimize caching. Smaller	1
data and make one instance	1
data and resources should be	1
data and local variables in	1
data and measure how long	1
data in the old block	1
data in the file, especially	1
data in a program is	1
data in a static buffer	1
data in this example can	1
data in different ways. Example:	1
data in order to get	1
data in order to improve	1
data in large arrays. Array	1
data in Linux and BSD	1
data The prefetch instruction can	1
data for the other thread.	1
data for one segment then	1
data for regular access patterns	1
data for analysis. If the	1
data that are used together	1
data that are modified should	1
data that don't need the	1
data are not cached. The	1
data are used many times	1
data are stored in binary	1
data are stored in ASCII	1
data are stored can be	1
data are accessed in a	1
data are accessed backwards and	1
data are accessed sequentially. It	1
data are likely to be	1
data are aligned to an	1
data are aligned at round	1
data are scattered around in	1
data are scattered randomly around	1
data are cached as good	1
data can be overridden in	1
data can exceed 2 Gbytes.	1
data // constructor initializes x	1
data or pointers to data	1
data with all the R	1
data as an array of	1
data as possible into the	1
data than it can handle.	1
data have to be aligned	1
data have three values per	1
data more random than normal.	1
data more compact. Accessing a	1
data A cache is a	1
data A variable is accessed	1
data from a buffer. It	1
data from static memory to	1
data from RAM memory can	1
data memory used by the	1
data because the same range	1
data used in the innermost	1
data cache is 8 kb	1
data cache is optimized for	1
data cache of 8 -	1
data cache and accessed non-sequentially	1
data cache are critical resources.	1
data cache use can be	1
data cache (see page 87).	1
data should contain a typical	1
data set into sub-vectors that	1
data size that fits the	1
data into the right vector	1
data into a vector goes	1
data into multiple blocks in	1
data into classes or structures.	1
data into groups of four	1
data object in the GOT,	1
data object through this address.	1
data member is more compact	1
data member is unchanged across	1
data member of a class	1
data member or after the	1
data member pointer simply stores	1
data member relative to the	1
data elements and the program	1
data elements are. For example,	1
data without caching is advantageous	1
data access can be arranged	1
data file in simple cases.	1
data through function calls. Internal	1
data structure and then merge	1
data structure then you may	1
data files and databases with	1
data files while less than	1
data automatically thanks to out-of-order	1
data caching more efficient than	1
data caching more efficient. Variables	1
data caching very efficient. The	1
data caching less efficient. The	1
data caching less efficient. Dynamic	1
data caching less efficient. Do	1
data caching less efficient. Access	1
data caching less efficient. Extra	1
data caching inefficient. An allocated	1
data caching inefficient. Dynamic memory	1
data sets where the same	1
data members is added to	1
data members of a class	1
data members to round addresses	1
data members that are never	1
data members can be copied	1
data members or member functions.	1
data members or non-static member	1
data members with a total	1
data members come first. If	1
data members within the first	1
data members share the same	1
data members (properties) The data	1
data members (properties) ............................................................................ 51	1
data cache. The same can	1
data cache. If the number	1
data cache. These instructions are	1
data cache. 2.2 Choice of	1
data cache. Single precision is	1
data cache. Bit-fields of sizes	1
data block to copy that	1
data conversion and shuffling can	1
data instead of user input	1
data storage is that it	1
data storage and page 87	1
data section is not shared	1
data section may contain pointers	1
data section needs one instance	1
data fit into the vector.	1
data fit nicely into the	1
data structures to addresses divisible	1
data structures in the end	1
data structures for standard tasks	1
data structures that typically use	1
data structures with non-sequential access	1
data structures with First-In-First-Out or	1
data structures It is not	1
data structures ............................................................. 96 9.11	1
data sets. However, the Intel	1
data sets. Covers PC's, workstations	1
data within the DLL use	1
data explicitly if data access	1
data sections can be shared.	1
data members. This alignment can	1
data members. A simple constructor	1
data members. It is recommended	1
data members. If the class	1
data members. But each member	1
data base access, etc. The	1
data files. This can actually	1
data area is usually divided	1
data ...................................................................................................... 90 9.6 Dynamic	1
data ......................................................................................... 87 9.2 Cache	1
data structures. For example, if	1
data structures. On the contrary,	1
data cache, code cache, branch	1
data cache, where it is	1
data sequentially A cache works	1
data sequentially .......................................................................................... 96 9.10	1
data processing. Running multiple threads	1
data manipulation is required for	1
data flow and algorithms in	1
data types: long long, double.	1
data types: char, short int,	1
data shuffling, such as many	1
data compression and cryptography (www.intel.com).	1
data compression Most compilers include	1
data decomposition. It is important	1
data decomposition. Functional decomposition here	1
data exceeds 64 kbytes. This	1
data segment by using the	1
data together. Data members of	1
data #ifdef _MSC_VER // If	1
data (low numbers mean good	1
data optimally, or from knowing	1
data locally. Access to remote	1
data decomposition, we should preferably	1
data elements, as follows: Type	1
data bases, but there is	1
data object: (1) get its	1
data Loading data into a	1
data structure, data flow and	1
data conversion, shuffling, packing, unpacking	1
program is an important part	1
program is more manageable and	1
program is often reorganized in	1
program is useful for calling	1
program is compiled with AVX	1
program is compiled without AVX	1
program is exception safe if	1
program is likely to be	1
program is never used. A	1
program is actually used. No	1
program is bigger than the	1
program is loaded into memory.	1
program is loaded rather than	1
program is executed. Furthermore, you	1
program is running. The main	1
program is running. If there	1
program is run. The time	1
program is run. Both the	1
program is loaded. This method	1
program is compiled. #if directives	1
program is achieved when none	1
program is dividing repeatedly with	1
program is started. It takes	1
program is loaded, the loader	1
program is loaded, but waits	1
program is busy doing the	1
program is fast, compact, and	1
program is terminated and the	1
program is shut down and	1
program of occupying a cache	1
program to use a set	1
program to turn off the	1
program to measure how much	1
program to issue an error	1
program and whether there is	1
program and concentrate the optimization	1
program in a debugger and	1
program in multiple versions should	1
program in case of an	1
program for the following reasons:	1
program that is easier to	1
program that are very difficult	1
program that can call all	1
program that calls the critical	1
program that calls it. A	1
program that created a file	1
program that already works is	1
program that runs under the	1
program that produces another C++	1
program that scans all files	1
program that waits for user	1
program are in fact accessed	1
program are also stored near	1
program are often much more	1
program are typically specified on	1
program can take advantage of	1
program can check the final	1
program or data exceeds 64	1
program or because the programmer	1
program or library has an	1
program if there is a	1
program by their address and	1
program by turning off the	1
program with many branches and	1
program with profiling support. Then	1
program on the newest CPU	1
program code is distributed and	1
program code is distributed as	1
program code is translated into	1
program code for making the	1
program code are uncached or	1
program as long as you	1
program as well as the	1
program - preferably isolated into	1
program than to type in	1
program than to execute it.	1
program may in fact be	1
program may be selected during	1
program may have to do	1
program may need modification to	1
program you want to optimize,	1
program have been found, then	1
program more clear unless the	1
program when the program starts	1
program will be able to	1
program will be unable to	1
program will be joined together	1
program will not be compatible	1
program will crash. See page	1
program then it can be	1
program then you may consider	1
program has to keep pointers	1
program has an initialization routine	1
program has one or a	1
program has most cache misses,	1
program has two arrays, a	1
program has many calls and	1
program has many branches or	1
program has several large arrays	1
program has too much data	1
program should be tested with	1
program should automatically detect which	1
program should leave a background	1
program do the calculations. The	1
program where the dispatch branches	1
program takes too long time	1
program performance and studying the	1
program performance because they are	1
program makes a symbolic link	1
program before the file is	1
program before and after the	1
program less efficient. Splitting up	1
program optimization or for combining	1
program optimization cannot be used	1
program optimization Some compilers have	1
program optimization Integer algebra reductions:	1
program optimization /GL --combine -fwhole-	1
program without invoking the overhead	1
program must clean up everything	1
program execution may be caused	1
program execution then it is	1
program exception safe. In other	1
program uses a lot of	1
program uses a procedure linkage	1
program uses more than 2	1
program uses many small dynamically	1
program contains no calls to	1
program contains many variables and	1
program contains calls to frame	1
program contains automatic CPU dispatching	1
program structure in some cases.	1
program memory. This can be	1
program memory. If several functions	1
program their own graphical user	1
program development more expensive and	1
program errors in case the	1
program efficiency is reflected, first	1
program optimization. This works by	1
program optimization. 2.4 Choice of	1
program performance. The positive effects	1
program updates should be postponed	1
program loading can be a	1
program under test but also	1
program under test finishes in	1
program under test, but is	1
program happen to be spaced	1
program logic may need extra	1
program logic allows parallel calculations.	1
program logic allows it, it	1
program (or part of it).	1
program had read from different	1
program itself and recompile it.	1
program itself when running. Programs	1
program size, while high-level languages	1
program reads from address 0x2710	1
program structure. It is important	1
program development, and a release	1
program package is not traditionally	1
program relies on exception handling.	1
program itself. You may add	1
program appear to take longer	1
program runs satisfactorily on a	1
program repeats 1000 times and	1
program chooses between two or	1
program starts running and before	1
program starts up. Some modules	1
program execution, even if the	1
program optimization, which will enable	1
program 81 optimization is to	1
program 153 spends most of	1
program flow and the number	1
program flow at inconvenient times	1
program flow. However, this did	1
program flow. Failure to do	1
program afterwards reads or writes	1
program loads the library through	1
program slower. Another disadvantage is	1
program saying that it doesn't	1
program starts. The user may	1
program starts. The disadvantage is	1
program compactness, and execution time.	1
program executable: a debug version	1
program logic. Some guidelines are	1
program creates or modifies many	1
program /Qipo -ipo No exception	1
program dictates that an object	1
has the same name for	1
has the same name as	2
has the value it was	1
has the following features: The	1
has the advantage that the	1
has the advantage that it	1
has the disadvantage that the	3
has the feature that there	1
has the special feature that	1
has the SSE or SSE2	1
has the unfortunate consequence that	1
has the correct child class	1
has the complication that the	1
has a different meaning. 2.	1
has a different meaning for	1
has a CPU dispatcher that	1
has a pointer to a	1
has a table of pointers	1
has a very dramatic effect	1
has a long dependency chain.	1
has a branch that chooses	1
has a branch (e.g. an	1
has a good implementation of	1
has a good knowledge of	1
has a particular weakness or	1
has a particular meaning, then	1
has a smaller memory footprint.	1
has a parallel structure that	1
has a garbage collector which	1
has a significant effect on	1
has a graphical user interface.	1
has a jump from a=a*2;	1
has a composite type such	1
has a latency which is	1
has a virus scanner that	1
has to be done outside	1
has to be loaded from	1
has to be changed to	1
has to be expressed as	1
has to be reloaded eight	1
has to use the most	1
has to make a non-inlined	1
has to take extra precautions	1
has to check for exceptions	1
has to assume the worst	1
has to start at an	1
has to turn off or	1
has to keep pointers to	1
has to wait for the	2
has to wait for a	1
has to invest in ever	1
has to obey certain rules	1
has to reinstall a software	1
has not been given a	1
has not been updated lately.	1
has not noticed that i	1
has an instruction set that	1
has an option for source	1
has an option for RTTI	1
has an implicit 'this' pointer	1
has an initialization routine that	2
has at least one virtual	1
has only a limited number	1
has only one CPU core	1
has only one instance then	1
has only one instance. The	1
has one or a few	1
has one big problem. Whenever	1
has one operator less. Fortunately,	1
has no instruction for self-relative	1
has no pointer aliasing. See	1
has no virtual member the	1
has no AVX support, then	1
has no copy constructor and	1
has no information about the	1
has no cost because it	1
has no negative effect on	1
has no effect. GOT and	1
has no side-effects and its	1
has most cache misses, branch	1
has i instead of j	1
has multiple instances that take	1
has two loop-carried dependency chains,	1
has two arrays, a and	1
has many of the advantages	1
has many of the features	1
has many calls and branches.	1
has many branches or function	1
has many advantages when it	1
has many advanced optimizing features,	1
has many features, see http://www.agner.org/optimize/	1
has some support for intrinsic	1
has some syntax checking and	1
has const twice because both	1
has its parameters replaced by	1
has its own memory block	1
has its own set of	1
has its own stack. Alternatively,	1
has several different ways of	1
has several large arrays and	1
has several meanings depending on	1
has several flaws: The best	1
has allocated with alloca, because	1
has been called before. This	1
has been accessed recently than	1
has been allocated is also	1
has been reduced from 20	1
has been copied to the	1
has been increased from 64-bit	1
has been doubled. Thin clients	1
has been loaded. This makes	1
has been translated to the	1
has been deallocated. The program	1
has been deallocated. Failure to	1
has been incremented to 5	1
has been incremented, while in	1
has been alleviated in the	1
has been identified, then it	1
has been calculated. Therefore, it	1
has been introduced in Linux	1
has been criticized for code	1
has been brutally interrupted. Now	1
has been wasted. The consequence	1
has done by fetching, decoding	1
has calculated in advance and	1
has four physical processors but	1
has support for XMM registers;	1
has support for relative addressing	1
has hardware support for the	1
has hardware support for calculating	1
has hardware support for multiplying	1
has both positive and negative	1
has problems separating the flags	1
has high priority. The gain	1
has three conditions which are	1
has three clauses: initialization, condition,	1
has three advantages: The i<20	1
has too much data for	1
has higher priority than code	1
has advantages and disadvantages. The	1
has made the structure 8	1
has made the right prediction.	1
has replaced i by a	1
has become a serious legal	1
has become less important than	1
has become too fragmented. This	1
has become fragmented. This makes	1
has reduced performance on CPUs	1
has reduced performance on non-Intel	2
has full metaprogramming features, including	1
has changed then the target	1
has changed five times. Thread-local	1
has defined a constructor, an	1
has something to clean up	1
has enough bits for holding	1
has chosen the wrong branch.	1
has chosen for the label.	1
has hardly any effect on	1
has saved all information about	1
has already been allocated. If	1
has nothing between 8 bit	1
has finished the calculations on	1
has finished the calculation of	1
has solved this problem by	1
has insufficient information about pointer	1
has preprocessing directives that select	1
has disadvantages: The unrolled loop	1
has disadvantages: It is difficult	1
has hyperthreading. If so, then	1
has hyperthreading, then try to	1
has changed. 7.8 Member pointers	1
has influence on the efficiency	1
has occurred. // Reset floating	1
has side effects or if	1
has excellent support for inline	1
has occurred anywhere in the	1
has incomplete information about the	1
vector of two double. The	1
vector of four float. The	1
vector of eight 16-bit integers	1
vector of e.g. four floats.	1
vector of (0,0,0,0,0,0,0,0) __m128i zero	2
vector of (0,0,0,0,0,0,0,0) Is16vec8 zero(0,0,0,0,0,0,0,0);	1
vector of vectors, as is	1
vector of (2,2,2,2,2,2,2,2) __m128i two	2
vector of (2,2,2,2,2,2,2,2) Is16vec8 two(2,2,2,2,2,2,2,2);	1
vector in eight consecutive elements	4
vector can be 64 bits	1
vector can hold four double	1
vector or the loop unroll	1
vector function libraries. Use Gnu	1
vector as two 128-bit vectors.	1
vector { // 2-dimensional vector	1
vector from array static inline	4
vector functions have names that	1
vector integer operations, and to	1
vector class library can emulate	1
vector class library have functions	1
vector class library will use	1
vector class library has not	1
vector class library has many	1
vector class library makes it	1
vector class library #include <stdio.h>	1
vector class library exp exp	1
vector class library. Open source.	1
vector class library, SSE4.1 gives	1
vector class library). The D	1
vector size for the sake	1
vector size then add a	1
vector size often have execution	1
vector size (16 or 32	1
vector into array static inline	4
vector library is that if	1
vector objects // Roll out	1
vector objects as function parameters	1
vector objects Vec8s a, b,	1
vector so that we can	1
vector register is 128 bits	1
vector register for the class	1
vector register which can be	1
vector register size is handled	1
vector register size. Vectorized code	1
vector register containing (2,2,2,2), and	1
vector register sizes to 1024	1
vector libraries and short vector	1
vector registers in the CPU.	1
vector registers are available in	1
vector registers can hold e.g.	1
vector registers when compiling for	1
vector registers has been increased	1
vector registers are: It is	1
vector registers had in fact	1
vector registers (XMM or YMM)	1
vector method may be at	1
vector always to tell the	1
vector always #pragma vector always	1
vector always Optimize function #pragma	1
vector operations is more advantageous	1
vector operations of modern CPUs,	1
vector operations and before any	1
vector operations are not used).	1
vector operations on contemporary 106	1
vector operations use a set	1
vector operations when the SSE2	1
vector operations when alignment by	1
vector operations where there is	1
vector operations An integer may	1
vector operations automatically in cases	1
vector operations require that the	1
vector operations mentioned in chapter	1
vector operations (chapter 12) are	1
vector operations Today's microprocessors have	1
vector instructions that make it	1
vector instructions cannot multiply integers	1
vector instructions (see page 105).	1
vector instructions SSE4.1 some more	1
vector instructions SSE4.2 string search	1
vector processors are becoming increasingly	1
vector element level 9. Avoid	1
vector element level 108 You	1
vector c __m128i c2 =	2
vector a, b, c, d;	1
vector classes is just a	1
vector classes and overloaded operators.	1
vector classes are currently available,	1
vector classes // Function to	1
vector classes than by using	1
vector classes void SelectAddMul(short int	1
vector classes #include "vectorclass.h" //	1
vector classes Agner's vector class	1
vector classes Fortunately, it is	1
vector classes ............................................................................................. 113 12.6	1
vector classes looks like this:	1
vector classes Programming in the	1
vector classes (Intel) #include <pmmintrin.h>	1
vector classes 114 #include <dvec.h>	1
vector parameters Vec4f polynomial (Vec4f	1
vector operator + (vector const	1
vector implementation is optimal only	1
vector data. The data have	1
vector aligned or the __assume_aligned	1
vector aligned #pragma vector aligned	1
vector aligned Assume pointer not	1
vector processors. Henry S. Warren,	1
vector goes faster if the	1
vector just as fast as	1
vector depends on the size	1
vector size. There is a	1
vector size. Unpredictable branches that	1
vector size. Later models had	1
vector math library (SVML). This	1
vector math library (VML, MKL).	1
vector math libraries. The Gnu	1
vector math libraries: Intel vector	1
vector math libraries: Intel short	1
vector math libraries: long vector	1
vector registers. The vector class	1
vector registers. The maximum size	1
vector registers. It may not	1
vector operations. You may choose	1
vector operations. Algorithms that rely	1
vector operations. 7.6 Pointers and	1
vector operations. 105 The vector	1
vector processing capabilities still have	1
vector processing instructions, multiple cores,	1
vector libraries. To explain the	1
vector classes. Including the appropriate	1
vector containing integers. It can	1
vector access. 12.9 Aligning RGB	1
vector nontemporal is used. However,	1
vector nontemporal Table 18.3. Predefined	1
vector nontemporal #pragma vector nontemporal	1
vector stores all the objects	1
vector c2 with the bit-mask:	1
vector register. The library function	1
vector register. Factors that make	1
vector simultaneously. This is also	1
vector algebra reductions: x-- x	1
vector Type of elements Total	1
vector turned up to cause	1
vector bc with the inverted	1
vector library, you are feeding	1
vector library, you divide the	1
vector elements. 12.1 AVX instruction	1
vector division. 12.4 Using intrinsic	1
vector 56 public: float x,	1
vector c: CPU dispatching with	1
vector c: __m128i c =	2
vector c: Is16vec8 c =	1
vector b: from cc into	1
vector b: __m128i b =	2
vector b: Is16vec8 b =	1
vector operations, as explained on	1
vector operations, see page 105.	1
vector register, do an addition	1
vector register, add the constant	1
vector classes, as explained in	1
vector operations............................................................................................... 105 12.1 AVX	1
vector classes): // Example 12.9b.	1
vector operands: minimum, maximum, saturated	1
vector intrinsics and automatic vectorization	1
vector classes: // Example 12.4d.	1
vector (1,2,3,4), and store the	1
vector intrinsics, automatic vectorization (see	1
vector intrinsics. Digital Mars This	1
make the function a member	2
make the code more efficient	1
make the code more complicated	1
make the code more efficient,	1
make the code up to	1
make the code smaller and	1
make the compiler treat a	1
make the data fit into	1
make the program more clear	1
make the program do the	1
make the program slower. Another	1
make the functions that access	1
make the most critical modules	1
make the number of columns	1
make the array size a	1
make the value wrap around.	1
make the address calculation more	1
make the address calculation faster.	1
make the access non-sequential which	1
make the overflow behavior well-defined	1
make the matrix 512 520	1
make the values of a	1
make the next model work	1
make the division faster. Of	1
make the source code more	1
make the induction variable method	1
make the local object static	1
make the rows in the	1
make the measurements as accurate	1
make the scope of a	1
make the SelectAddMul example (12.4e)	1
make a function local: 1.	1
make a CPU dispatcher based	1
make a loop count down	1
make a pointer to a	1
make a variable global if	1
make a test program that	1
make a test run with	1
make a new branch only	1
make a new instance of	1
make a single call to	1
make a small test program	1
make a few comments about	1
make a multiplication and an	1
make a complicated implementation of	1
make a Boolean NOT on	1
make a piece of code	2
make a negative list of	1
make a positive list of	1
make a destructor if it	1
make a misprediction every time	1
make a DLL with the	1
make a reliable decision. 13.4	1
make a non-inlined copy of	1
make a round function using	1
make a variable-size array with	1
make a sensible balance between	1
make a lookup-table static. Example:	1
make a thread-like scheduling in	1
make a zip file of	1
make a destructor. A function	1
make a bit-mask which is	1
make and therefore more error	1
make it a template: //	1
make it in the form	1
make it possible to use	1
make it possible to do	1
make it possible for the	1
make it work cannot be	1
make function calls faster in	1
make function calling more efficient	1
make code that makes code.	1
make an update when the	1
make an additional integer counter.	1
make an approximate comparison of	1
make this extra element zero.	1
make this work on non-Intel	1
make this kind of optimizations	1
make this reordering easier for	1
make use of the extra	1
make more efficient code, but	1
make different objects share the	1
make only one call to	1
make all dynamic libraries contend	1
make one version that takes	1
make one instance for each	1
make floating point register variables.	1
make floating point register variables,	1
make floating point induction variables	1
make multiple code versions for	1
make multiple versions of the	1
make multiple versions even of	1
make two different implementations of	1
make two versions of a	1
make such an assumption is	1
make any call to the	1
make any assumption about an	1
make some tests with the	1
make variables global if you	1
make table of const double	1
make software that runs quite	1
make software packages faster and	1
make member functions static where	1
make member functions faster by	1
make member pointers less efficient.	1
make register variables because of	1
make pointers efficient, and that's	1
make sure the compiler recognizes	1
make sure the object is	1
make sure the arrays are	2
make sure the result is	1
make sure the information is	1
make sure the startup code	1
make sure that the code	1
make sure that the CPU	1
make sure that the most	1
make sure that the response	1
make sure that the declaration	1
make sure that a value	1
make sure that no object	1
make sure that no variable	1
make sure that they always	1
make sure that they are.	1
make sure that overflow never	1
make sure that certain calculations	1
make sure that everything that	1
make sure it is only	1
make sure it is initialized	1
make sure it works well	1
make sure you are using	1
make sure its size is	1
make sure allocated resources are	1
make sure everything that is	1
make 32 AND-operations in just	1
make dynamic link libraries slower	1
make up a program. Whole	1
make arrays of different types	1
make overflow checks where necessary	1
make overflow checks where necessary.	1
make container classes in the	1
make support for the exception	1
make certain kinds of code	1
make shared objects without position-independent	1
make files smaller. It is	1
make their software faster. It	1
make separate executables for 32-bit	1
make induction variables for floating	1
make dispatcher in only the	1
make better use of the	1
make applications run faster at	1
make parts of the program	1
make aligned arrays with vector	1
make your program exception safe.	1
make your own error handling	1
make your own error message	1
make appropriate error messages to	1
make position-independent code and lazy	1
make vectorization less favorable: Larger	1
make vectorization favorable: Small data	1
make temp a register variable	1
make special versions of the	1
make 16-bit programs, except for	1
make algebraic reductions on floating	1
make profiling feasible. Interference from	1
make exactly identical code for	1
make developers choose other programming	1
make measurements on this part	1
make two. Some other compilers	1
make explicit checks for such	1
make CPU- specific optimizations in	1
make thread-specific data is to	1
make Sum1 slightly more efficient	1
make utility. The conclusion is	1
make utility. It supports 32-bit	1
make thread-local storage of static	1
make log2 a global const	1
make memory-hungry software in two	1
different in other compilers. #include	1
different for different platforms as	1
different for each type of	1
different for each process. Obviously,	1
different function library. If the	1
different function libraries. Numbers in	1
different code address and back	1
different compiler by including the	1
different memory addresses. If caching	1
different memory spaces for different	1
different memory areas, and there	1
different functions and you want	1
different functions in the optimal	1
different CPU cores. You may	1
different instruction sets from the	1
different instruction sets Microprocessor producers	1
different instruction sets........................... 122 13.1	1
different cache lines in column	1
different integer types Unfortunately, the	1
different integer types available. declaration	1
different set values then the	1
different floating point precisions when	1
different compilers is generally possible	1
different compilers then it is	1
different compilers I have made	1
different compilers succeeded in applying	1
different size matrices, clock cycles	2
different Intel CPUs. It uses	1
different object file formats. Comments	1
different C++ compilers to choose	1
different C++ compilers and operating	6
different C++ compilers The tests	1
different C++ language elements in	1
different C++ constructs Most programmers	1
different C++ constructs........................................................................ 26 7.1	1
different value of the template	1
different objects even when their	1
different objects share the same	1
different so that they cannot	1
different way or bypassing syntax	1
different operating systems that allows	1
different libraries and see which	1
different test examples. You cannot	1
different user access rights. Software	1
different system color settings and	1
different type by type-casting its	1
different type conversions is discussed	1
different cases for different microprocessors,	1
different instructions sets. The different	1
different processors and instruction sets.	1
different processors are covered in	1
different CPUs to verify that	1
different CPUs if you want	1
different arrays even if they	1
different versions of the same	1
different versions of the critical	1
different versions of the virtual	1
different versions of the polymorphic	1
different versions of a critical	1
different versions of an overloaded	1
different versions of CriticalFunction in	1
different versions for different compilers.	1
different versions have to be	1
different versions alternatingly several times	1
different execution units. For example,	1
different execution units in the	1
different threads in a multithreaded	1
different threads are doing different	1
different threads need separate storage.	1
different matrix sizes were measured	1
different matrix sizes. The results	1
different functions. There is no	1
different addresses with different set	1
different implementation when b is	1
different intrinsic functions and it	1
different methods have exactly the	1
different name for each instruction	1
different source files for the	1
different parts of the floating	1
different parts of the software	1
different parts of the memory,	1
different parts of a big	1
different types of floating point	2
different types of graphics cards,	1
different types of variables. Move	1
different types or strings of	1
different types with the same	1
different types cannot point to	2
different compilers. The results are	1
different compilers. This function is	1
different compilers. Dispatch at load	1
different processors. In a C++	1
different platform is likely to	1
different ways of doing the	1
different ways of doing type	1
different ways of copying blocks	1
different CPUs. This is called	1
different CPUs. This method is	1
different CPUs. On the other	1
different CPUs. (See page 130	1
different compiler. Object files generated	1
different dynamically allocated objects are	1
different platforms as shown in	1
different platforms because it doesn't	1
different registers. You need to	1
different tasks in a multitasking	1
different tasks were not divided	1
different priority in the same	1
different thread. If you forget	1
different kinds of vector math	1
different kinds of variable storage	1
different kinds of operations in	1
different kinds of optimizations. The	1
different kinds of jobs. For	1
different purposes. The most commonly	1
different purposes. All these examples	1
different purposes. However, the STL	1
different cores is slow. If	1
different implementations of the same	1
different implementations of C++, directly	1
different sizes of the data	1
different sizes are allocated and	2
different way. There is no	1
different address. A call from	1
different module or a function	1
different brands of C++ compilers	1
different brands of CPUs unequally	1
different brands of CPUs, different	1
different purposes is beyond the	1
different kind of registers. There	1
different algorithms in order to	1
different algorithms for different purposes	1
different profiling methods: Instrumentation: The	1
different factors as template parameters	1
different array. // Example 9.6a	1
different applications. Therefore, it is	1
different places when the heap	1
different places making the dispatch	1
different ways. Example: // Example	1
different microprocessors. 7.13 Loops The	1
different modules. This may cause	1
different platforms, different screen resolutions,	2
different threads, but that's about	1
different type. Likewise, a pointer	1
different lengths in the same	1
different tasks. For example, in	1
different strides. Therefore, you don't	1
different screen resolutions, different system	1
different screen resolutions, etc. Accessibility	1
different priorities to different tasks.	1
different priorities then the user	1
different precisions take no extra	1
different executables. This method can	1
different meaning. 2. Put the	1
different alignments and different sizes	1
different targets is small. The	1
different speeds. If I write	1
different places). Some compilers have	1
different meaning for member functions.	1
different compilers............................................................................. 74 8.3 Obstacles	1
different browsers, different platforms, different	1
different types. A disadvantage is	1
different sizes, and they can	1
different times: Dispatch on every	1
different opinions on which imprecisions	1
different microprocessors, different alignments and	1
because the function calling conventions	1
because the code becomes contiguous.	1
because the compiler has to	1
because the compiler must convert	1
because the compiler doesn't have	1
because the compiler knows that	1
because the memory bus is	1
because the same code can	1
because the same range of	1
because the CPU can do	1
because the CPU has hardware	2
because the CPU has problems	1
because the cache lines follow	1
because the cache miss on	1
because the integer operations use	1
because the size of abc	1
because the two operating systems	1
because the static keyword has	1
because the 64-bit instruction set	1
because the value pointed to	1
because the critical stride is	1
because the register usage convention	1
because the template parameters are	1
because the template parameter is	1
because the file has been	1
because the stack unwinding information	1
because the result is known	1
because the threads will invalidate	1
because the speed here is	1
because the overflow and underflow	1
because the container may move	1
because the hardware can be	1
because the addresses are spaced	1
because the write causes an	1
because the microprocessor has hardware	1
because the expression list[i] is	1
because the block size grows	1
because the high level framework	1
because the programmer hasn't thought	1
because the response time to	1
because the response times for	1
because the out-of-order execution mechanism	1
because the offset can be	1
because the macro is referencing	1
because the total amount of	1
because the interpreted version of	1
because the debugging options prevent	1
because the body of a	1
because the linker makes an	1
because the x86-64 instruction set	1
because the consequence of n	1
because the 33 result is	1
because the contents of data	1
because the relocations in the	1
because the factorials don't depend	1
because the insertion of a	1
because the integer-to-float conversion takes	1
because the non-reduced expression better	1
because a float uses 32	1
because a good compiler can	1
because a fixed address might	1
because a typo in a	1
because of the way the	1
because of the extra work	1
because of the large overhead	1
because of the needs of	1
because of the costs of	1
because of a very obscure	1
because of a store forwarding	1
because of a change in	1
because of cache evictions and	1
because of its simplicity. But	1
because of their superior performance/price	1
because of alignment problems. It	1
because of disk caching, but	1
because of lazy loading of	1
because of technical problems. Some	1
because in the latter case	1
because in the latter case,	1
because in most cases they	1
because it is a staircase	1
because it is long does	1
because it is sure to	1
because it is important to	1
because it is accessed through	1
because it is deallocated when	1
because it is evicted before	1
because it can be done	1
because it can be implemented	1
because it can cause errors	1
because it may cause cache	1
because it may go through	1
because it may involve the	1
because it has many advanced	1
because it has been brutally	1
because it takes too much	1
because it makes floating point	1
because it makes dispatching on	1
because it cannot rule out	1
because it often contains writeable	1
because it doesn't have the	1
because it doesn't need the	1
because it doesn't need a	1
because it doesn't depend on	1
because it needs to load	1
because it needs an extra	1
because it needs only calculate	1
because it requires the loading	1
because it goes automatically when	1
because it gives more reliable	1
because it comes before the	1
because it prevents the use	1
because it involves the risk	1
because it defines electrical connections	1
because it handles eight elements	1
because it lacks the self-explaining	1
because an optimizing compiler can	1
because you can avoid the	1
because you will get no	1
because you should not call	1
because this is the most	1
because this is likely to	1
because this may improve the	1
because this method is safer.	1
because this would be invalid	1
because this would give annoyingly	1
because this brand was less	1
because all the compilers I	1
because all the numbers are	1
because all caches have to	1
because integer operations are faster	1
because each value of sum	1
because each call to a	1
because b has to start	1
because static data are likely	1
because there is no try	1
because there are different opinions	1
because there may be no	1
because we are reading and	1
because we are relying on	1
because we can access internal	1
because we forgot to tell	1
because registers is a scarce	1
because these are incompatible with	1
because these time consuming updates	1
because they are in fact	1
because they are resolved before	1
because they can block the	1
because they do not use	1
because they cannot be mixed	1
because they must be inside	1
because they fail to eliminate	1
because optimizing compilers can compute	1
because both the pointers and	1
because their live ranges do	2
because their live ranges now	1
because various corrections for sign	1
because switch statements often suffer	1
because relative addresses are often	1
because relative references do not	1
because modern CPUs can change	1
because testing a condition is	1
because algebraic manipulations of floating	1
because #if is resolved at	1
because serious errors can happen	1
because computers have very different	1
because truncation takes much longer	1
because communication and synchronization between	1
because nothing inside the loop	1
because partial template specialization is	1
same in a more clear	1
same in both cases. This	1
same for simple variables, arrays	1
same can be expected for	1
same can happen in the	1
same or a nearby address	1
same function or class is	1
same function on a thousand	1
same function may be called	1
same function calling conventions. FreeBSD	1
same code and read-only data.	1
same code in either case.	1
same code can be applied	1
same code as example 12.4b,	1
same as the latency of	1
same as the C-style type-casting.	1
same as a pointer in	1
same as for switch statements,	1
same as for (i=0; i<n;	1
same as if you had	1
same as i modulo 16.	1
same as last time the	1
same as C- style type-casting	1
same as reflecting it at	1
same compiler option for all	1
same time to share the	1
same time to evaluate and	1
same time that it takes	1
same time as the other	1
same time regardless of whether	1
same memory space. A union	1
same memory pool. See www.agner.org/optimize/cppexamples.zip.	1
same memory area for a	1
same memory area for different	1
same memory area. The nontemporal	1
same memory area. Join identical	1
same memory areas. Data that	1
same memory block, but this	1
same data in different ways.	1
same instruction set. Neither can	1
same cache is that communication	1
same cache line. The cache	1
same cache line. But these	1
same cache lines. The critical	1
same cache lines. This makes	1
same cache line, because the	1
same set in the cache.	1
same class and store the	1
same class will be stored	1
same example using Agner's vector	1
same size as vector register.	1
same object (except for char	1
same array for multiple purposes.	1
same version of the virtual	1
same member pointer. 7.9 Smart	1
same way is predicted well,	1
same way as in Linux.	1
same way as an object	1
same way as last time	1
same address so a cache	1
same critical part of the	1
same register for more than	1
same register for both, while	1
same register can be used	1
same register because their live	2
same time. The code in	1
same time. A code that	1
same time. A user interface	1
same time. There are three	1
same time. Example: // Example	1
same without discriminating between CPU	1
same method can be used	1
same dynamic library can change	1
same dynamic libraries without the	1
same part of the program	2
same part of the code.	1
same bits in a different	1
same bits differently. A negative	1
same type to avoid this.	1
same result if we change	1
same processor core on multi-core	1
same processor core. Unfortunately, contemporary	1
same processor core. Two threads	1
same processor core. Try to	1
same thread as very time-consuming	1
same precision in all operands	1
same precision as the operands.	1
same few parameters. Or it	1
same structure or class. This	1
same inline assembly syntax in	1
same shared object. Obviously, all	1
same space for the parameters	1
same cache. Multithreaded programs must	1
same name for the child	1
same name as a function	1
same name as a global	1
same source code. The library	1
same source code. #if is	1
same source file. Keep often	1
same induction variable for accessing	1
same reason that they cannot	1
same after this statement so	1
same piece of code in	1
same piece of memory. See	1
same function, each optimized for	1
same compiler. It is therefore	1
same range of memory addresses	1
same core will always compete	1
same errors can happen with	1
same variables. In these examples	1
same operation is performed on	2
same level-1 cache. The advantage	1
same resources. But it can	1
same class. The static keyword	1
same object. There is no	1
same time, except for some	1
same priority is no more	1
same priority than the number	1
same thing and the CPUID	1
same thing and if you	1
same thing and they are	1
same thing as p and	1
same logical register. This advantage	1
same subexpression occurs more than	1
same resource then it may	1
same generation can cause complications	1
same address. There are two	1
same module then the compiler	1
same module static static static	1
same module (i.e. the current	1
same module __attribute__ ((visibility ("internal")))	1
same features as the Microsoft	1
same applies to an array	1
same applies to 3-dimensional geometry	1
same value. This is useful	1
same unit as additions. Divisions	1
same register. Everything that is	1
same DLL at the same	1
same object, except for char	1
same core. It is the	1
same rules apply to modulo	1
same constant. Example: // Example	1
same principle as in example	1
same regardless of precision on	1
same result. A compiler can	1
same advice applies to arrays	1
same resources, such as cache	1
same cache, at least at	1
same brand. Future processors will	1
same way, the first processors	1
same argument does not apply	1
same chip can be a	1
same name. In the Windows	1
same arguments are sure to	1
same executable. SSE2 is the	1
same machine. The virtual processor	1
same thing. Example: // Example	1
same thing. An expression with	1
same template. 57 Templates are	1
same chip. Such hybrid solutions	1
same effect. Which method you	1
same class). If the same	1
same computer, including the profiler	1
same name, regardless of scope	1
same coding rules apply as	1
same algorithm, then you need	1
same directory as the .exe	1
same divisor. In this case	1
same queue, list, database, or	1
functions is not expensive. You	1
functions is also treated like	1
functions is called a frame	1
functions is higher for single	1
functions of a parent class	1
functions of parent and child	1
functions of parent class and	1
functions and a GOT for	1
functions and it can be	1
functions and function pointers It	1
functions and you want to	1
functions and data in Linux	1
functions and some other functions	1
functions and simply put 80	1
functions and public data can	1
functions and public variables go	1
functions and hot spots. The	1
functions and frame functions. A	1
functions in the optimal order.	1
functions in the grandparent class:	1
functions in a single step	1
functions in a module by	1
functions in memory by requesting	1
functions in other modules than	1
functions in C++ take more	1
functions The different versions of	1
functions The most common mathematical	1
functions The keyword __fastcall changes	1
functions for the SSE2 instruction	1
functions for integer vector division.	1
functions for these calculations. Division	1
functions for common mathematical calculations	1
functions for string searching and	1
functions for vectors There are	1
functions for vectorized table lookup	1
functions for reasons explained on	1
functions for audio and video	1
functions for millisecond resolution. A	1
functions for statistics, signal processing	1
functions for vectors........................................................................ 119 12.8	1
functions for distinguishing between the	1
functions that are not critical.	1
functions that are not accessible	1
functions that are used in	2
functions that are used near	1
functions that are needed from	1
functions that are difficult to	1
functions that are called. A	1
functions that are particularly critical.	1
functions that it calls. The	1
functions that it calls. 48	1
functions that have multiple //	1
functions that have multiple versions.	1
functions that need to call	1
functions that access the saved	1
functions that require cleanup before	1
functions that 150 you want	1
functions are not compatible across	1
functions are more efficient than	1
functions are used in a	1
functions are used for implementing	1
functions are less efficient (see	1
functions are often inlined automatically	1
functions are optimized well, others	1
functions are calculated faster than	1
functions are supported by the	1
functions are doing the same	1
functions are typically small pieces	1
functions are never called. The	1
functions are actually called in	1
functions are usually stored in	1
functions are included in the	1
functions are listed in the	1
functions are highly optimized for	1
functions are missing in many	1
functions are kept in different	1
functions are supplied in Intel's	1
functions are primitive operations in	1
functions are unrelated to each	1
functions can be implemented as	1
functions can be quite tedious	1
functions can not. Static cast	1
functions // This function stores	1
functions // Function to load	1
functions or code lines. The	1
functions or when accessing an	1
functions or vector classes is	1
functions or vector classes than	1
functions if the class of	1
functions if possible. Smaller microprocessors	1
functions by using the directive	1
functions with integer parameters. Floating	1
functions as well as efficient	1
functions than in optimizing application-specific	1
functions may not be visible	1
functions have a 'this' pointer	1
functions have a non-inlined copy	1
functions have to save some	1
functions have more than four	1
functions have no check for	2
functions have several versions for	1
functions have names that begin	1
functions have names with suffixes	1
functions A macro declared with	1
functions A pure function is	1
functions then the code can	1
functions then it may not	1
functions then you can obtain	1
functions then there is a	1
functions It is difficult to	1
functions because the static keyword	1
functions only makes the program	1
functions which are called near	1
functions should work efficiently on	1
functions class CHello { public:	1
functions static or inline. This	1
functions static where appropriate. Compiler-specific	1
functions such as logarithms and	1
functions such as memcpy, memmove,	1
functions such as logarithms, exponential	2
functions such as sqrt and	1
functions such as GetPrivateProfileString and	1
functions such as strcpy, strcat,	1
functions such as pow, log,	1
functions You have to make	1
functions faster by making them	1
functions called by the critical	1
functions called by F1 also	1
functions take more time to	1
functions take most time. Uses	1
functions take microseconds to execute	1
functions often belong to one	1
functions without CPU dispatching. Test	1
functions Some programming textbooks recommend	1
functions must have extern "C"	1
functions must use a function	1
functions An inline function is	1
functions Use predefined vector classes	1
functions inline or static or	1
functions like sin. Pointer elimination	1
functions like sqrt, pow and	1
functions separate from seldom used	1
functions look clumsy and tedious.	1
functions linked from static libraries	1
functions go here // Virtual	1
functions local A function that	1
functions (e.g. GetLogicalProcessorInformation in Windows)	1
functions counts a one parameter.	1
functions scattered around in program	1
functions Virtual functions are used	1
functions (i.e. Microsoft, Intel and	1
functions memset and memcpy: //	1
functions consume a significant amount	1
functions malloc and free. These	1
functions .............................................................................................. 56 7.27 Overloaded	1
functions ....................................................................................... 145 14.11 Static	1
functions lrintf and lrint. Unfortunately,	1
functions ........................................................................................ 53 7.21 Runtime	1
functions ........................................................................................ 109 12.5 Using	1
functions (methods) Each time a	1
functions /Gr Function level linking	1
functions Sum1, Sum2 and Sum3	1
functions directly: Library exp function	1
functions Encryption, decryption, data compression	1
functions (methods)......................................................................... 53 7.20 Virtual	1
only the code section and	1
only the time spent in	1
only the most simple reductions	1
only the first time the	1
only the SSE2 instruction set,	1
only the SSE2 version of	1
only the part of the	1
only the Gnu compiler will	1
only the innermost loop is	1
only the simplest expressions and	1
only the lower 8 or	1
only the lowest of the	1
only the even-numbered logical processors	1
only a single function or	1
only a single element. The	1
only a small fraction of	1
only a few clock cycles	1
only a limited number of	1
only a negligible contribution to	1
only a hint and the	1
only a minimal difference between	1
only to the most critical	1
only to show how tortuous	1
only in the second generation	1
only in the simplest cases.	1
only in the Professional and	1
only for compilers that support	1
only for Intel CPUs, not	1
only for objects stored in	1
only for very large libraries.	1
only for big objects that	1
only for positive n. You	1
only for classes. The splitting	1
only for powers of 2	1
only for avoiding infinite loop	1
only for speed-critical functions by	1
only be a waste of	2
only be used if there	1
only be applied to integers.	2
only if the program is	1
only if the loop count	1
only if the programmer has	1
only if it is certain	1
only if it cannot be	1
only if you are sure	1
only if all functions called	1
only if AVX is supported	1
only if certain options are	1
only with Intel processors. A	1
only on the values of	1
only on some processors that	1
only on some processors. On	1
only on CPUs with full-size	1
only on PC platforms. Graphics	1
only on registers, not on	1
only on n, including the	1
only on Intel/x86-compatible microprocessors. The	1
only an integer comparison, which	1
only an advantage in applications	1
only an addition. Comparing two	1
only you make sure it	1
only have four numbers of	1
only when the next higher	1
only when a new instruction	1
only when it goes the	1
only when it exits. For	1
only when it changes. A	1
only when instruction sets are	1
only when b is true,	1
only when elements are accessed	1
only when called from main,	1
only when they are needed,	1
only when running on an	1
only when AVX2 is supported	1
only when needed. The bitwise	1
only when activated by the	1
only from same module static	1
only from same module __attribute__	1
only from one place in	1
only used in a small	1
only one of the compilers	1
only one that works on	1
only one or a few	1
only one time in thousand	1
only one CPU core then	1
only one CPU core, but	1
only one floating point addition	1
only one clock cycle on	1
only one clock cycle. The	1
only one call to the	1
only one call to Func1,	1
only one constant needs to	1
only one element then use	1
only one addition every three	1
only one statement in the	1
only one instance then you	1
only one logical processor is	1
only one free register left	1
only one instance. The function	1
only one instance. Non-static members	1
only compilers and function libraries	1
only 64-bit execution units. Each	1
only possible if the value	1
only possible if F1 has	1
only 32-bit Windows. Gnu Comes	1
only 32-bit Windows. Does not	1
only way to make sure	2
only makes the program less	1
only called once. The reasons	1
only first time int CriticalFunction_Dispatch(int	1
only need a CPU with	1
only simple standard operations. All	1
only available if supported by	1
only available with vector operands:	1
only calculated the first time	1
only calculated once, rather than	1
only four function parameters to	1
only four cache lines in	1
only four multiplications. How was	1
only known processors. Other brands	1
only supported on AMD CPUs.	1
only few of the functions	1
only run on Mac platform.	1
only calculate element addresses for	1
only 256 clock cycles. Calculations	1
only after all objects have	1
only after they have put	1
only read the value of	1
only read this first manual.	1
only improve the performance, it	1
only 5 s on the	1
only constants will be replaced	1
only safe if it has	1
only until the next time	1
only situation where they are	1
only within the same module	1
only slightly more time. Single	1
only slightly more resources than	1
only slightly less efficient. In	1
only once for each function	1
only allowed inputs are the	1
only CPUID information that we	1
only show a discrete icon	1
only half the size of	1
only half a square. //	1
only half of it, for	1
only occurs because the addresses	1
only happens rarely. The above	1
only six instructions rather than	1
only one, auto_ptr that owns	1
only 50% or less each	1
only reasonable solution is to	1
only once. Example: // Example	1
only once. One may argue	1
only if, a level-2 cache	1
only once, while the runtime	1
only hope that such feature	1
only hope that future compilers	1
only self- relative addresses. Therefore,	1
only 10% of the time.	1
only 2-3 clock cycles if	1
only SSE). The YMM registers	1
only _mm_permutevar_ps 4 4 bytes	1
CPU is limited by physical	1
CPU is designed for a	1
CPU of a particular brand	1
CPU of unknown brand or	1
CPU to generate interrupts at	1
CPU to start calculations on	1
CPU to increment the loop	1
CPU to overlap the calculations	1
CPU and the operating system	3
CPU and the operating system.	1
CPU and prevent it from	1
CPU that each particular branch	1
CPU can do calculations while	1
CPU can hold many renamed	1
CPU or other hardware conditions.	1
CPU it is running on,	1
CPU by giving it some	1
CPU with the highest instruction	1
CPU with a higher instruction	1
CPU with multiple cores. 3.15	1
CPU than the main memory	1
CPU may occasionally predict that	1
CPU time on the user	1
CPU time then there is	1
CPU use in programs that	1
CPU will start to calculate	1
CPU from doing multiple calculations	1
CPU from doing out-of-order execution,	1
CPU from overlapping calculations. The	1
CPU has hardware support for	2
CPU has problems separating the	1
CPU which can be set	1
CPU used for temporary storage.	1
CPU cache (en.wikipedia.org/wiki/L2_cache). The details	1
CPU clock by using the	1
CPU clock cycles rather than	1
CPU clock frequency is doubled.	1
CPU clock frequency (in Windows:	1
CPU time. But this solution	1
CPU time. Another disadvantage of	1
CPU access and memory access	1
CPU doesn't support, and the	1
CPU doing multiple calculations in	1
CPU was started. The length	1
CPU dispatching to make multiple	1
CPU dispatching and is used	1
CPU dispatching and run any	1
CPU dispatching and discovered that	1
CPU dispatching in the code	1
CPU dispatching in Intel compiler	2
CPU dispatching in Gnu compiler	3
CPU dispatching or memory-intensive functions	1
CPU dispatching with vector classes	1
CPU dispatching on first call	1
CPU dispatching then call _mm256_zeroupper()	1
CPU dispatching only to the	1
CPU dispatching works only with	1
CPU dispatching #include "vectorclass.h" //	1
CPU dispatching are: Optimizing for	1
CPU dispatching explicitly as in	1
CPU dispatching 125 for this	1
CPU model is likely to	1
CPU model is over. Virtualization	1
CPU model and then think	1
CPU model has its own	1
CPU dispatcher to know whether	1
CPU dispatcher in the MKL	1
CPU dispatcher that doesn't handle	1
CPU dispatcher then sets a	1
CPU dispatcher should not look	1
CPU dispatcher should have as	1
CPU dispatcher should give a	1
CPU dispatcher does not check	1
CPU dispatcher based on complicated	1
CPU dispatcher checks whether the	1
CPU dispatcher treats non-Intel CPUs	1
CPU dispatcher updated. It is	1
CPU dispatch mechanism in the	2
CPU dispatch mechanism that treats	1
CPU dispatch mechanism can be	1
CPU dispatch Automatic vectorization Automatic	1
CPU dispatch methods. The most	1
CPU dispatch strategies........................................................................................ 122 13.2	1
CPU dispatch strategies It is	1
CPU dispatch mechanisms, and some	1
CPU based on its family	1
CPU feature on Intel CPUs.	1
CPU core is running at,	1
CPU core by setting a	1
CPU core then it is	1
CPU core during time measurements	1
CPU supports the corresponding instruction	1
CPU supports this kind of	1
CPU supports then you are	1
CPU efficiency then it is	1
CPU (See manual 3: "The	2
CPU time, RAM and disk	1
CPU models if the problem	1
CPU cores is to divide	2
CPU cores and leave them	1
CPU cores or logical processors	1
CPU dispatching. The code in	1
CPU dispatching. This function is	1
CPU dispatching. For example, the	1
CPU dispatching. For example, you	1
CPU dispatching. Many Intel library	1
CPU dispatching. Unfortunately, the CPU	1
CPU dispatching. Obviously, you should	1
CPU dispatching. Add to this	1
CPU dispatching. Test if the	1
CPU dispatching. Underestimating the cost	1
CPU Modern CPUs can do	1
CPU brands and similarly sets	1
CPU brands or specific models	1
CPU brand check is bypassed	1
CPU brand simply by setting	1
CPU brand names and model	1
CPU detection function of the	1
CPU detection function in Intel	1
CPU detection function that I	1
CPU detection function as described	1
CPU detection function In some	1
CPU detection mechanism in Intel	1
CPU detection function, one that	1
CPU detection mechanism. The CPU	1
CPU family and model numbers	1
CPU family number, which is	1
CPU core. There are four	1
CPU cores. A process or	1
CPU cores. You may have	1
CPU cores. You may need	1
CPU cores. 60 The cost	1
CPU development, each new generation	1
CPU cores, we need to	1
CPU dispatcher. See page 131.	2
CPU brand. The version that	1
CPU brand. Critical parts of	1
CPU market is developing so	1
CPU dispatchers are designed to	1
CPU dispatchers up to date.	1
CPU chip. Such units can	1
CPU only) -O3 or (requires	1
CPU only) (Intel CPU only)	1
CPU core). The counters will	1
CPU dispatching: 1. How much	1
CPU dispatching, then it is	1
CPU core, but it requires	1
CPU models. However, we must	1
CPU brands, and one that	1
CPU hardware. Porting such an	1
CPU vendors are offering profiling	1
CPU model, which quite likely	1
CPU cores: Define multiple threads	1
CPU supports, rather than its	1
other is inefficient because the	1
other is -0 (zero with	1
other in the code memory.	1
other in the same source	1
other in order to get	1
other in memory. Variables and	1
other are also stored near	2
other function is called a	1
other with a 50-50 chance	1
other code that uses the	1
other than the library that	1
other than short int (16	1
other than its name at	1
other than 8, 16, 32	1
other then put the operand	1
other data structure then you	1
other data structures that typically	1
other functions is called a	1
other functions that are difficult	1
other functions can not. Static	1
other cache control instructions than	1
other integer expressions Induction variables	1
other compilers can reduce other	1
other compilers or function libraries	1
other compilers have inefficient code-based	1
other compilers will make two.	1
other compilers at the object	1
other compilers (Microsoft, Intel) know	1
other possible ways of handling	1
other value than 0 or	3
other objects on the stack,	1
other variable in the code.	1
other variables to be overwritten,	1
other member functions. This applies	1
other way is mispredicted only	2
other way three times. Then	1
other address in this range	1
other less well-known languages. My	1
other libraries when running on	1
other systems may have big	1
other access patterns. This can	1
other programming languages are implemented	1
other programming languages can be	1
other programming languages, but also	1
other programming languages. This section	1
other bits to zero. 14.3	1
other error condition. Things that	1
other error reporting here: return	1
other CPUs for executing the	1
other function. A leaf function	2
other extra software layers and	1
other work that the processor	1
other calculations to save time.	1
other compiled programming languages as	1
other big objects come last	1
other threads with lower priority.	1
other threads have access to	1
other virtual processors on the	1
other common programming errors associated	1
other thread increments seconds. A	1
other allocated resource. The C++	1
other container class libraries use	1
other hardware often requires that	1
other hardware conditions. A dispatcher	1
other values if they are	1
other values than 0 and	2
other values than 0 or	2
other cases, it is possible	1
other methods of rounding, but	1
other resources than doing arithmetic	1
other resources locally or remotely.	1
other applications such as a	1
other parts of the program	1
other parts of the code.	1
other types of expressions, but	1
other compilers. This includes the	1
other compilers. #include <excpt.h> #include	1
other optimizations such as function	1
other optimizations possible because the	1
other advantages that may improve	1
other ways than by a	1
other modules than the one	1
other modules call the function.	1
other things very stupid. Some	1
other languages in Microsoft's .NET	1
other languages that do have	1
other STL containers do not	1
other platforms and other compiled	1
other platforms with big-endian storage.	1
other platforms as well, but	1
other resources. There are various	1
other local variables and therefore	1
other constants because it can	1
other tasks that are running	1
other thread. However, in most	1
other kinds of storage. See	1
other details that make function	1
other purposes. The use of	1
other purposes. This is advantageous	1
other resource problems that cause	1
other resource conflicts. But if	1
other way. A branch that	1
other module then add the	1
other processors, only the innermost	1
other features it has. Assuming	1
other device should preferably be	1
other brands of CPUs such	1
other purposes than it is	1
other purposes than rendering graphics	1
other CPUs, but it uses	1
other optimizations. In most cases	1
other number. Therefore, it is	1
other form of error reporting.	1
other protection means are among	1
other branches. A simple periodic	1
other cleanup that may be	1
other processes running on the	1
other hand, the compiler may	1
other hand, a just-in-time compiler	1
other hand, it is not	1
other hand, if your optimization	1
other hand, does not need	1
other factor. If a and	1
other microprocessors. Integer division takes	1
other microprocessors. Many of the	1
other modules. This makes inlining	1
other modules. This enables interprocedural	1
other modules. You may add	1
other words, the program must	1
other words, it is inefficient	1
other words, you need to	1
other words, you must make	1
other languages. But the C++	1
other module. The static declaration	1
other programs, 99% of the	1
other input/output than the specific	1
other way, etc. The worst	1
other nearby parts of the	1
other nearby branches. The algorithms	1
other (not member of the	1
other resource, such as dynamically	1
other exceptions: __except (GetExceptionCode() ==	1
other ways, as explained in	1
other complications that make member	1
other compilers). The best performance	1
other processes. The profiler measures	1
other reasons, but part of	1
other hardware-related details depend on	1
other situations: The stack unwinding	1
other optimizations, as explained below.	1
other constructors. A class doesn't	1
other system- specific parts of	1
other flaws in the CPU	1
other odd-sized vector data. The	1
other subtasks is necessary. 101	1
other abuse is extremely costly	1
other volumes in this series	1
instruction is executed only once	1
instruction to localize the first	1
instruction and have implemented a	1
instruction and expect this to	1
instruction for interrupt 3. The	1
instruction for self-relative addressing of	1
instruction that the CPU doesn't	1
instruction that you are dealing	1
instruction can be used for	1
instruction if the SSE4.1 instruction	1
instruction set is the vector	1
instruction set is the scarcity	1
instruction set is that the	1
instruction set is that it	1
instruction set is not always	1
instruction set is available then	1
instruction set is supported in	1
instruction set is supported by	5
instruction set is supported on	1
instruction set is used. It	1
instruction set is better than	1
instruction set is particularly interesting	1
instruction set is enabled. The	2
instruction set is enabled. There	1
instruction set is enabled. Conversion	1
instruction set is enabled. Conversions	1
instruction set is enabled. Typically,	1
instruction set is enabled. Few	1
instruction set is available. The	3
instruction set is available, 256	1
instruction set is enabled there	1
instruction set is enabled (single	1
instruction set is supported. For	1
instruction set is specified. The	1
instruction set is available: //	1
instruction set is enabled: //	1
instruction set is maintained for	1
instruction set and one that	1
instruction set and insert only	1
instruction set and YMM registers	2
instruction set and ZMM registers	2
instruction set in order to	1
instruction set for the vector	1
instruction set for the appropriate	1
instruction set that is compatible	1
instruction set that you want	1
instruction set are expected to	1
instruction set can run only	1
instruction set can still run	1
instruction set or any higher	1
instruction set it supports. An	1
instruction set if possible. The	1
instruction set if possible. SSE2	1
instruction set not supported fprintf(stderr,	1
instruction set int iset =	1
instruction set than the CPU	1
instruction set may actually be	1
instruction set when running on	1
instruction set when compatibility with	1
instruction set then it will	1
instruction set has no instruction	1
instruction set has support for	1
instruction set has nothing between	1
instruction set also allows 256-bit	1
instruction set where the number	1
instruction set makes floating point	2
instruction set SSE2 or later.	1
instruction set was originally designed	1
instruction set supports self-relative addressing	1
instruction set supports self-relative addressing.	1
instruction set gives the advantage	1
instruction set (or higher) is	1
instruction set #if INSTRSET ==	1
instruction set available, e.g. AVX,	1
instruction set opens the possibility	1
instruction set (requires a microprocessor	1
instruction set (128 bit float	1
instruction set (128 vectors of	1
instruction set specified. Insert an	1
instruction set (called x86) of	1
instruction set Suppl. SSE3 instr.	1
instruction set extensions. If a	1
instruction set (/arch:SSE2, /arch:AVX etc.	1
instruction takes typically 0 -	1
instruction cannot be used in	1
instruction before any floating point	1
instruction code. You can assume	1
instruction must be followed by	1
instruction doesn't give the 124	1
instruction add ebx, DWORD PTR	1
instruction add eax,1 is the	1
instruction was certain to truly	1
instruction sets the CPU supports,	1
instruction sets is as follows:	1
instruction sets is provided in	1
instruction sets and other features	1
instruction sets and cache sizes.	1
instruction sets are mutually incompatible.	2
instruction sets can be determined	1
instruction sets have certain instructions	1
instruction sets have got RISC	1
instruction sets from the same	1
instruction sets enable the compiler	1
instruction sets include a few	1
instruction sets Microprocessor producers keep	1
instruction set. The most compatible	1
instruction set. The following example	1
instruction set. The examples on	1
instruction set. The main advantage	1
instruction set. The newer instruction	1
instruction set. The preprocessing macro	1
instruction set. This instruction set	1
instruction set. A CPU dispatcher	1
instruction set. It is rarely	1
instruction set. If the CPU	1
instruction set. If you are	1
instruction set. These new instructions	1
instruction set. Therefore, you only	1
instruction set. Make two or	1
instruction set. Do not use	1
instruction set. 120 However, there	1
instruction set. Aligning data Loading	1
instruction set. 13.6 CPU dispatching	1
instruction set. More complicated cases	1
instruction set. Neither can you	1
instruction set. High precision math.	1
instruction prevents the level-2 cache	1
instruction mov DWORD PTR [ecx+eax*4],ebx	1
instruction sets. The program should	1
instruction sets. Most compilers will	1
instruction sets. Supports only 32-bit	1
instruction sets. Vector operations are	1
instruction sets. Likewise, the compiler	1
instruction sets. Does not optimize	1
instruction set, and a generic	1
instruction set, as listed in	1
instruction set, then you cannot	1
instruction set, but it may	1
instruction set, but possibly not	1
instruction set, one for SSE4.1	1
instruction set, using asmlib library	2
instruction set, another version for	1
instruction set, e.g. /arch:SSE2. The	1
instruction xor eax,eax. This is	1
instruction sets, cache size, etc.	1
instruction sets........................... 122 13.1 CPU	1
instruction latencies are listed in	1
instruction latencies, throughputs and micro-operation	1
instruction set: // Example 12.4b.	1
instruction timing, assembly language programming,	1
instruction set?". A list of	1
instruction directly, or use the	1
point is that the compiler	1
point is faster with signed	1
point is faster than from	1
point is 1. This '1'	1
point of view. This instruction	1
point of attack for hackers.	1
point to the same object	1
point to the same object,	1
point to the appropriate function	1
point to the right version	1
point to a valid address.	1
point to are constant. 14.2	1
point to integer without SSE2	1
point to integer According to	1
point to end of a	1
point to become invalid, and	1
point to integer. The conversion	1
point to a[i+2] ; compare	1
point and integer representations in	1
point in your program, you	1
point if the conversion to	1
point code and you can	1
point code more efficient in	1
point code rather than by	1
point code slower, especially when	1
point library which is very	1
point number is zero by	1
point number to the nearest	1
point number to an integer	1
point number in the interval	1
point number by 2n by	1
point number simply by inverting	1
point where it is less	1
point value written as 2eee	1
point variable as an integer	1
point variables is so large	1
point variables and operators Modern	1
point variables and operators ......................................................................	1
point variables in order to	1
point variables use a different	1
point variables do not wrap	1
point variables Floating point numbers	1
point variables ......................... 142 14.10	1
point register variables is eight	1
point register variables in 32-bit	2
point register stack is used.	1
point register variables. Vector operations	1
point register variables, but will	1
point code. The bigger vectors	1
point code. The 128-bit XMM	1
point code. If you do	1
point registers and correspondingly two	1
point registers are used, there	1
point registers available in 32-bit	1
point registers organized as a	1
point operations and choose the	1
point operations are done with	1
point operations without reducing the	1
point operations involves eight or	1
point operations involves eight floating	1
point operations (addition, multiplication, etc.)	1
point constant always takes memory	1
point stack registers are available	1
point stack registers are used.	2
point calculations and the loop	1
point calculations or turn off	1
point calculations as long as	1
point calculations will typically use	1
point calculations should therefore preferably	1
point calculations inside the loop	1
point calculations unless the strictness	1
point calculations usually take the	1
point calculations whenever they are	1
point execution units. Any floating	1
point overflow has occurred. //	1
point overflow but no other	1
point precision (see page 73).	1
point precision conversion Conversions between	1
point parameters are not affected	1
point parameters are transferred in	1
point counter then make an	1
point multiplication at the same	1
point multiplication units. This means	1
point division to be slower.	1
point division by a constant	1
point division takes much longer	1
point division Floating point division	1
point division ........................................................................................... 139 14.7	1
point induction variables for the	1
point induction variables Compilers cannot	1
point addition and multiplication may	1
point addition with floating point	1
point addition on a modern	1
point addition takes 5 clock	1
point addition takes 3 -	1
point addition every clock cycle.	1
point addition units, and 22	1
point addition unit, but this	1
point expressions or more complex	1
point expressions may have undesired	1
point expressions (see page 72).	1
point numbers is less efficient	1
point numbers is inefficient. Division,	1
point numbers to integers use	1
point numbers and integers Conversion	1
point numbers and integers ...................................	1
point numbers are stored in	1
point numbers can be calculated	1
point numbers simply by comparing	1
point XMM (vector) reductions: a+b=b+a,	1
point operands cannot be changed	1
point operation on such processors	1
point operation takes 5 clock	1
point constants are double precision	1
point constants are stored in	1
point library. If you want	1
point calculations. Even with all	1
point operations. You should use	1
point precision. The following compiler	1
point instructions. This is coded	1
point instructions. Each type has	1
point expressions. It is therefore	1
point expressions. For example, a	1
point expressions. Most reductions involving	1
point expressions. Floating point variables	1
point addition, and a floating	1
point variables, if possible. See	1
point Conversion of integers to	1
point vectors. There are also	1
point algebra reductions: a+b=b+a a*b=b*a	1
point rounding mode has to	1
point capabilities (except in device	1
point representation directly with the	1
point number. We can convert	1
point comparisons are more predictable	1
point comparisons are slow unless	1
point comparisons are inefficient when	1
point comparisons more efficient. This	1
point numbers. It can also	1
point numbers. Therefore, 64-bit Linux	1
point division. Correction for the	1
point underflow in XMM registers	1
point constants, string constants, and	1
point constants, string constants, array	1
point format is standardized allows	1
point addition. This is small	1
point multiplication, to mix simple	1
point numbers: // Example 8.18	1
point comparisons, which are relatively	1
point overflow: _controlfp_s(&dummy, 0, _EM_OVERFLOW);	1
point expressions, even though the	1
point extern "C" int CriticalFunction	1
point precisions when the code	1
point status: _fpreset(); _controlfp_s(&dummy, 0,	1
point comparison. On big endian	1
point variable: // Example 7.26b	1
point multiply-and-add Table 13.1. Instruction	1
point -ffast-math /fp:fast /fp:fast=2 -fp-model	1
point exceptions, etc. Event-based sampling	1
loop is to resume after	1
loop is in mathematical iterations	1
loop is long because the	1
loop is inside another loop	1
loop is predicted well. A	1
loop is interpreted again and	1
loop is rolled out by	1
loop of a program contains	2
loop of a graphical user	1
loop of ADC (add with	1
loop and have a temp1	1
loop and use multiple accumulators	1
loop and without the static	1
loop and splitting the dependency	1
loop and reorganize: // Example	1
loop in the main program.	1
loop in a program repeats	1
loop in this case. Loop	1
loop in example 9.5a goes	1
loop in example 11.3 is	1
loop in example 12.4a so	1
loop in example 15.1b. Branches	1
loop in example 8.23b has	1
loop in example 8.24 can	1
loop for // multiply //	1
loop for calculations: for (	1
loop for trivial tasks such	1
loop that also repeats 1000	1
loop that does floating point	1
loop that contains several branches	1
loop that includes the critical	1
loop are finished. This method	1
loop can be implemented in	1
loop can change the value.	1
loop can still be vectorized,	1
loop or the series of	1
loop or add an extra	1
loop or not. The following	1
loop if the same operation	1
loop if the results are	1
loop if it is independent	1
loop if you are sure	1
loop if this can eliminate	1
loop if all the factors	1
loop if true ; unused	1
loop if powN is //	1
loop by the same constant.	1
loop by using vector operations	1
loop by two and making	1
loop by two gives: //	1
loop by 16 to fit	1
loop by eight to fit	4
loop by n and reorganize	1
loop by storing intermediate results	1
loop by four, we will	1
loop with a small and	1
loop with a high repeat	1
loop with multiple counters, as	1
loop with few or no	1
loop A function that calls	1
loop will use the copy	1
loop will take only 256	1
loop will take approximately 500	1
loop will take 1000 *	1
loop then you cannot rely	1
loop because nothing inside the	1
loop should preferably be kept	1
loop double ipow (double x,	1
loop where each iteration needs	1
loop where almost the entire	1
loop takes up more space	1
loop branch should be predicted.	1
loop branch must rely on	1
loop without checking all the	1
loop does not cost anything	1
loop ; a[i] = Induction;	1
loop ; unused label ;	1
loop ; compute i/2 in	1
loop through rows for (c	1
loop through rows // loop	1
loop contains floating point calculations	1
loop would be while (0	1
loop doing mathematical calculations. In	1
loop counter is an integer,	1
loop counter is used as	1
loop counter and go back	1
loop counter can be calculated	3
loop counter by a constant	1
loop counter with its limit,	1
loop counter when the final	1
loop counter should preferably be	1
loop counter i is stored	1
loop counter outside both loops	1
loop counter ahead of time	1
loop count is small and	1
loop count is too big.	1
loop count is divisible by	2
loop count that can be	2
loop count should preferably be	1
loop count down to zero	1
loop count (ArraySize) is constant	1
loop automatically if this appears	1
loop needs a floating point	1
loop becomes a little more	1
loop control it compares the	1
loop control branch is mispredicted	1
loop control branch is executed	1
loop control branch depends on	2
loop control branch ahead of	1
loop control statement several iterations	1
loop control condition is a	1
loop control condition The most	1
loop control branch. There is	1
loop control branch. See the	1
loop control condition: // Example	1
loop bigger than the cache	1
loop depends on how well	1
loop columns below diagonal //	1
loop columns below diagonal swapd(a[r][c],	1
loop further if the loop	1
loop unroll option in the	1
loop unroll factor. A little	1
loop condition i < 100.	1
loop buffer that some microprocessors	1
loop unrolling is not optimal	1
loop unrolling in example 14.12b	1
loop unrolling so that the	1
loop iterations are: No loop-carried	1
loop body is very small	1
loop body now contains only	1
loop body begins at the	1
loop is. The type __m128i	1
loop counter. Example: // Example	1
loop counter. Any expression that	1
loop increment i++. cmp eax,	1
loop repeats a thousand times	1
loop repeats 20 times and	1
loop index. The integer division	1
loop counters, function parameters, pointers,	1
loop counters, etc. In large	1
loop manually unless there is	1
loop unrolled double xpow10(double x)	1
loop calculates four consecutive terms	1
loop counter, which is calculated	1
loop counter, comparing the loop	1
loop count. The method of	1
loop predictor. On other processors,	1
loop exits, when in fact	1
loop counter: // Example 7.31b	1
loop overhead. Example: // Example	1
loop initialisation i=0; has been	1
If the code is compiled	1
If the code is implemented	1
If the code in example	1
If the compiler is able	1
If the compiler has an	1
If the compiler doesn't have	1
If the program takes too	1
If the program under test	1
If the program logic allows	1
If the program afterwards reads	1
If the vector registers can	1
If the different tasks were	1
If the same function or	1
If the same subexpression occurs	1
If the CPU brand check	1
If the loop count is	1
If the cache always chooses	1
If the cache contentions can	1
If the class has at	1
If the size of abc	1
If the Intel compiler is	1
If the object is large	1
If the number of objects	1
If the number of elements	2
If the number of points	1
If the number of columns	1
If the number and types	1
If the version changes then	1
If the value of the	1
If the variable is stored	1
If the software contains a	1
If the member functions of	1
If the critical innermost loop	1
If the first operand of	1
If the template parameters differ	1
If the arrays or structures	1
If the AVX instruction set	1
If the problem is too	1
If the container is to	1
If the standard header file	1
If the microprocessor is doing	1
If the microprocessor has hyperthreading,	1
If the application uses most	1
If the computer has only	1
If the response time is	1
If the repeat count is	1
If the offset relative to	1
If the final size cannot	1
If the total number of	2
If the length of the	1
If the latter function also	1
If the carry bit is	1
If the key values are	1
If the combined size of	1
If the bottleneck is elsewhere	1
If the wrong branch is	1
If the word static is	1
If the granularity is too	1
If a and b in	1
If a and b are	1
If a function is not	1
If a function is compiled	1
If a function in the	1
If a program has too	1
If a program uses many	1
If a program contains many	1
If a loop contains floating	1
If a loop needs a	1
If a floating point addition	1
If a template has only	1
If a piece of code	1
If a bool is used	1
If a future version of	1
If a profiling (see page	1
If a dispatched function calls	1
If it is not possible	1
If it is known at	1
If it is poorly predictable	1
If an error handler calls	1
If you are in doubt	1
If you are not satisfied	1
If you are using an	2
If you are making branches	1
If you are certain that	1
If you are including a	1
If you can avoid virtual	1
If you make your own	1
If you do use the	1
If you cannot avoid conversions	1
If you need to do	1
If you access a variable	1
If you access part of	1
If you want the function	1
If you want a number	1
If you want to improve	1
If you want to know	1
If you want to compare	1
If you run the optimized	1
If you don't care to	1
If you read the value	1
If you look at the	1
If you know that processor	1
If you just want the	1
If you consider making highly	1
If you forget to make	1
If this is the case	1
If this address is not	1
If time is measured with	1
If different versions of the	1
If one operand is more	1
If one operand is faster	1
If each floating point operation	1
If i is outside this	1
If two threads are often	1
If two integers are equally	1
If there is a way	1
If there is a hot	1
If there are not enough	1
If there are no big	1
If there are floating point-to-integer	1
If objects are accessed on	2
If objects are identified by	1
If any of the shared	1
If any of these conditions	1
If we want to roll	1
If we compile the shared	1
If we assume that b	1
If we modify example 9.5	1
If part of a program	1
If I write that something	1
If arrays are accessed through	1
If c = b +	1
If virtual functions are used	1
If several functions that are	1
If exception handling is not	1
If caching is a problem	1
If Microsoft compiler #define Alignd(X)	1
If n = 4, we	1
If your optimization effort is	1
If columns had not been	1
If N is a power	1
If seconds was not declared	1
If F1 calls another function	1
If search facilities are needed,	2
If frequent updates are necessary	1
If not, then it may	1
If not, then you must	1
If hyperthreading is not advantageous	1
If Func1 and Func2 were	1
If MultiplyBy in this example	1
If so, then you can	1
which the array is defined.	1
which the variable is used.	1
which the variable is declared.	1
which the elements are stored	1
which the calling function can	1
which the modules are linked	1
which the modules appear in	1
which is the code that	1
which is the same as	1
which is the one that	1
which is a total waste	1
which is more efficient than	1
which is only 10% of	1
which is all 1's when	1
which is used in the	1
which is used during program	1
which is very time consuming.	1
which is very likely to	1
which is very fast. The	1
which is called by the	1
which is less efficient. You	1
which is useful for checking	1
which is 0 for positive	1
which is available in different	1
which is available from www.intel.com.	1
which is much faster. In	1
which is much faster. Division	1
which is calculated fast if	1
which is implemented with an	1
which is known to be	1
which is likely to consume	1
which is quite inefficient, and	1
which is typically 64 bytes.	1
which is typically loaded at	1
which is difficult to implement	1
which is transferred as an	1
which is divisible by the	1
which is slow unless the	1
which is similar to the	1
which is faster. In the	1
which is fast. Calculating the	1
which is 15 on the	1
which is contiguous with other	1
which is double. Here we	1
which is 50% of the	1
which a code version performs	1
which a dynamic library is	1
which of the two branches	1
which of the advanced programming	1
which in turn calls another	1
which are used for giving	1
which are called near each	1
which are 64 bits wide,	1
which are useful for finding	1
which are implemented as three	1
which are relatively costly because	1
which are cheap, in relation	1
which can be used for	1
which can be set up	1
which can be stored in	1
which can be calculated by	1
which can be quite time-consuming	1
which can be applied to	1
which can be fed directly	1
which can only be applied	1
which can take quite a	1
which it is not advantageous	1
which it has calculated in	1
which function to use and	1
which code branch to use	1
which compiler will do the	1
which may be undesired. Example:	1
which may cause slight imprecision	1
which may happen quite often.	1
which may interfere with real	1
which this code version performs	1
which will generate an underflow	1
which will change during the	1
which will delay the availability	1
which will enable optimizations across	1
which then calls a device	1
which data are stored can	1
which functions take most time.	1
which instruction set is supported	1
which instruction set it supports.	1
which instruction sets the CPU	1
which one is best. 3.11	1
which one is fastest. The	1
which one works best. Some	1
which set of cache lines	1
which version of the virtual	1
which version of a virtual	1
which version of a piece	1
which version of a polymorphic	1
which version to use in	1
which we assume is optimized.	1
which variables will be used	1
which software development process and	1
which way a branch will	1
which makes the data caching	1
which makes it less efficient.	1
which makes data caching very	1
which makes detailed optimization more	1
which cannot be inlined or	1
which they are used. It	1
which they are used. Such	1
which they are declared whenever	1
which they are created. Far	1
which they appear in the	2
which method is likely to	1
which method is fastest on	1
which method to use depends	1
which programming language is best	1
which part of the program	1
which does the same thing	1
which processor models to avoid	1
which processor models to run	1
which solution is optimal on	1
which few programs do. Hence,	1
which contains the address of	1
which would be an infinite	1
which quite likely is a	1
which allows the linker to	1
which implementation is best. These	1
which resources are most critical.	1
which optimizations you can expect	1
which optimizations you have to	1
which range from -128 to	1
which reductions the compilers are	1
which reductions they cannot do.	1
which gives access to the	1
which comes with most modern	1
which platforms and operating systems	1
which prevents out-of-order execution. It	1
which causes a long delay.	1
which not. You cannot rely	1
which counts at the CPU	1
which happens quite often because	1
which returns a reference to	1
which gets information about its	1
which alloca was called. There	1
which otherwise can only be	1
which opens and closes the	1
which consumes CPU time. But	1
which initially points to a	1
which can't be reached with	1
which calculates the sum of	1
which determines the program flow	1
which transposes a quadratic matrix,	1
which redirects it to the	1
which affects other parts of	1
which supposedly is system-independent, in	1
which interprets the intermediate code	1
which imprecisions should be allowed	1
all the functions that it	2
all the CPU cores and	1
all the cache lines we	1
all the integer calculations. The	1
all the compilers I have	2
all the array elements then	1
all the objects in the	1
all the objects together into	1
all the objects (memory pooling)	1
all the dynamic libraries need	1
all the dynamic libraries (*.dll	1
all the bits of an	1
all the necessary cleanup jobs	1
all the problems mentioned above.	1
all the problems associated with	1
all the numbers are powers	1
all the modules of a	1
all the relevant optimization options	1
all the additions are independent	1
all the inputs to the	1
all the factors are generated	1
all the B values. The	1
all the G values, and	1
all the R values first,	1
all is for the sake	1
all of the following conditions	1
all of these classes. Size	1
all to the profiler. The	1
all be below the maximum	1
all on AMD and VIA	1
all code has a parallel	1
all code versions work correctly.	1
all code branches works correctly.	1
all code branches separately and	1
all use single precision. Using	1
all data in a program	1
all data in large arrays.	1
all data members within the	1
all data members. A simple	1
all because the 33 result	1
all functions and a GOT	1
all functions static or inline.	1
all functions called by F1	1
all other bits to zero.	1
all other processes running on	1
all but the first dimension	1
all class objects and is	1
all floating point constants are	1
all compilers are able to	1
all static data, including local	1
all 64-bit CPUs and operating	1
all C++ compilers The register	1
all possible cases of program	1
all objects have been stored	1
all objects have been added?	2
all variables and objects should	1
all software be reinstalled and	1
all elements of a vector	1
all elements to zero. You	1
all elements have been added	1
all libraries have the best	1
all pointers and references in	1
all systems that have floating	1
all these table lookup operations	1
all these purposes. This memory	1
all dynamic libraries contend for	1
all bits except the sign	2
all CPUs that support this	1
all threads have finished the	1
all allocated objects and keep	1
all allocated objects are also	1
all good compilers will reduce	1
all done in a single	1
all operators that have Boolean	1
all information about the destructor	1
all information about the chain	1
all files on access. Sequential	1
all files on access. Run	1
all cases, while many reductions	1
all branches for correctness. It	1
all source files into one	1
all resources are sufficient, and	1
all three versions should be	1
all runtime libraries and frameworks,	1
all means avoid powers of	1
all compilers. Some compilers have	1
all compilers. Use automatic parallelization.	1
all optimizations of a variable	1
all optimizations on the variable.	1
all public and static data.	1
all x86 and x86-64 platforms.	2
all x86 platforms. This library	1
all x86 platforms. Microsoft, Intel,	1
all x86 platforms. Works well	1
all operands in case the	1
all modules that use the	1
all relevant optimization options turned	3
all relevant options. Many optimization	1
all conversions from floating point	1
all platforms. PathScale C++ compiler	1
all installation options at the	1
all modern microprocessors and operating	1
all modern CPUs. The SSE2	1
all modern computers have memory	1
all variables. Obviously, this is	1
all platforms and the possibility	1
all local non-member functions. 80	1
all strings in a memory	1
all strings in one memory	1
all unknown processors that support	1
all kinds of strange and	1
all sizes of matrices. An	1
all newer Intel CPUs have	1
all newer models that were	1
all writes to load a	1
all non-static variables and objects	1
all non-static member functions. The	1
all subsequent elements in the	1
all destructors for local objects	1
all destructors are called and	1
all destructors are called. The	1
all brands of CPUs. The	1
all applications. 2.8 Overcoming the	1
all suitable functions in a	1
all instances of the class.	1
all instances of S1 aligned	1
all five values have to	1
all cleanup of allocated resources.	1
all .cpp modules that make	1
all belong to set number	1
all objects. This is of	1
all caches have to adapt	1
all Unix-like platforms. Clang The	1
all 0's when false. The	1
all 0's gives zero. An	1
all major platforms. However, C++	1
all major platforms. Pascal has	1
all disturbing influences in order	1
all squares: for (r1 =	1
all respects relevant to software	1
all 1's is unchanged, while	1
all 1's when bb[i] >	1
all zeroes. Example: // Example	1
all intrin.h (MS) x86intrin.h (Gnu)	1
all occurrences of ArraySize by	1
but the function names are	1
but the code will be	1
but the compiler is usually	1
but the compiler can make	1
but the compiler may not	1
but the compiler uses position-independent	1
but the program is dividing	1
but the point is that	1
but the variable whose address	1
but the performance is not	1
but the first dimension may	1
but the method used here	1
but the calculation time is	1
but the programmer can. It	1
but the examples have been	1
but the syntax is very	1
but the alignment requirements are	1
but the asmlib function library	1
but is not quite as	1
but is less important on	1
but is less reliable. Event-based	1
but is currently only supported	1
but in a very inefficient	1
but in this case it	1
but in example 12.1b, the	1
but in registers in 64-bit	1
but in applications without an	1
but for most purposes the	1
but for studying a piece	1
but are identified by a	1
but it is not the	1
but it is not clear	1
but it is very inefficient.	1
but it is important to	1
but it is quite certain	1
but it is still the	1
but it is impossible to	1
but it can be useful	1
but it can also be	1
but it can take more	1
but it may be quite	1
but it may be optimal	1
but it may be better	1
but it may be preferable	1
but it will not use	1
but it has the disadvantage	1
but it often gives more	1
but it doesn't work with	1
but it doesn't generate any	1
but it uses more clock	1
but it would be even	1
but it requires that the	1
but it took several minutes	1
but it increases the amount	1
but if we want to	1
but on what instruction sets	1
but as long as this	1
but not the more complicated	1
but not the compiled code.	1
but not in a shared	1
but not if it is	1
but not if b is	1
but not if static linking	1
but not on Intel processors.	1
but not on AMD CPUs	1
but not any other factor.	1
but not long enough to	1
but not always for application-specific	1
but not dynamic libraries (.dll	1
but not safe unless the	1
but not all. Fortunately, there	1
but may be removed after	1
but you can reduce the	1
but you may as well	1
but you should be aware	1
but you cannot always rely	1
but this is not a	1
but this is not necessary	1
but this is often faster	1
but this is permissible when	1
but this is sufficiently accurate	1
but this is extremely inefficient,	1
but this will use full	1
but this memory block is	1
but this makes the code	1
but this method is extremely	1
but this feature is rarely	1
but this feature is seldom	1
but this unit is pipelined,	1
but will save temp in	1
but has a smaller memory	1
but only if certain options	1
but only an addition. Comparing	1
but only after all objects	1
but only show a discrete	1
but only self- relative addresses.	1
but other systems may have	1
but no compiler I have	1
but no other exceptions: __except	1
but no compile- time loops	1
but there is a penalty	1
but there is no reason	1
but there are some differences	1
but there are serious limitations	1
but also the time used	1
but also the innermost loop	1
but also when called from	1
but also very expensive. A	1
but also less safe. This	1
but also supports Linux and	1
but also inconvenient to the	1
but also safer. It may	1
but such expressions may occur	1
but any of the 4	1
but 32-bit systems do not	1
but less optimized. Note that	1
but these are hardly relevant	1
but these address calculations are	1
but they are in fact	1
but they are not able	1
but part of the code	1
but I think that it	1
but its data members can	1
but must go through a	1
but several hundred clock cycles	1
but eight logical processors. Hyperthreading	1
but operators that have Booleans	1
but quite inefficient in large	1
but don't count on it.	1
but read one or more	1
but slow or completely absent	1
but outside the innermost loop	1
but possibly not with earlier	1
but rarely in Linux. Address	1
but risk of overflow Integer	1
but who would like to	1
but expensive if they are	1
but efficient, way of doing	1
but unfortunately the unit-test does	1
but unfortunately it prevents certain	1
but unfortunately this is not	1
but unfortunately there is no	1
but avoids the overflow. Taking	1
but none of the compilers	2
but that's about the only	1
but waits until the first	1
but neither faster nor slower	1
but i*12, because the size	1
but risky. The returned pointer	1
but event-counters do. This results	1
used the trick that N1	1
used is branch prediction. Modern	1
used to avoid modulo operations:	1
used to speed up the	1
used to read and understand	1
used to be. The distinctions	1
used and this will make	1
used and searching for vacant	1
used and popped from the	1
used in the same part	2
used in the most critical	1
used in the most common	1
used in the Gnu C	2
used in the old operating	1
used in the innermost loop	1
used in the Active Template	1
used in a number of	1
used in a critical part	1
used in a small part	1
used in example 15.1b is	1
used in multiple applications, but	1
used in two other situations:	1
used in two ways. The	1
used in 64-bit device drivers	1
used in any situation where	1
used in some embedded systems.	1
used in so that they	1
used in small embedded applications	1
used in shared objects in	1
used in STL for accessing	1
used in almost all modern	1
used for the link pointers	1
used for function libraries distributed	1
used for an increasing number	1
used for other purposes. The	1
used for all static data,	1
used for pointer conversions. It	1
used for multiple variables as	1
used for multiple purposes. Floating	1
used for any other resource,	1
used for variables declared with	1
used for branch prediction are	1
used for file input and	1
used for doing two or	1
used for multiplication } //	1
used for vectorized table lookup.	1
used for accessing the same	1
used for calculating the addresses	1
used for calculating self- relative	1
used for finding the right	1
used for temporary storage. Variables	1
used for debugging and exception	1
used for Java today. But	1
used for storing function return	1
used for giving the function	1
used for giving specific optimization	1
used for converting a pointer	1
used for internal references. 64-bit	1
used for internal references. There	1
used for reducing the time	1
used for turning off all	1
used for defining constants. For	1
used for saving memory space	1
used for constants. Integer constants	1
used for prefetching data for	1
used for implementing a compile-time	1
used for implementing polymorphic classes.	1
used for improving code that	1
used for metaprogramming, as explained	1
used for jumping out of	1
used for relieving the const	1
used for fetching a cache	1
used that most function libraries	1
used or if its body	1
used if the value of	1
used if instruction sets are	1
used if there are specific	1
used if elements have a	1
used if elements have no	1
used by the test program	1
used by a variable until	1
used by all other processes	1
used by multiple threads should	1
used by many users in	1
used by element 0 in	1
used by exception handlers for	1
used by default anyway in	1
used by thousands of people.	1
used with other compilers. This	1
used with other microprocessors. Many	1
used on bigger systems. The	1
used on completely independent divisions.	1
used as a Boolean vector.	1
used as a stand alone	1
used as an array index	1
used as an array index.	1
used as macros are sometimes	1
used as alternatives to the	1
used as command-line versions without	1
used as coprocessors to take	1
used as buffers for storing	1
used an intermediate code like	1
used more efficiently. It is	1
used when the function longjmp	1
used when a thread is	1
used when it is not	1
used at the same time	1
used at the same time.	1
used at all is for	1
used data members come first.	1
used functions separate from seldom	1
used only for objects stored	1
used only for very large	1
used only for avoiding infinite	1
used only when instruction sets	1
used only within the same	1
used cache line then the	1
used set of containers is	1
used most for register variables.	1
used where execution speed, memory	1
used many times in a	1
used variables in a function	1
used variables are stored in	1
used without restrictions. A GNU	1
used inside the pow function	1
used simply to increment an	1
used above the diagonal have	1
used branches such as error	1
used members in the first	1
used intrinsic functions. It is	1
used methods for dealing with	1
used char (or int) instead	1
used data. The speed of	1
used parts of the code.	1
used together are also stored	1
used together are stored near	1
used together should be stored	4
used here is the only	1
used functions, and put seldom	1
used during program development, and	1
used near each other are	1
used here. The compiler option	1
used twice for handling a	1
used most. The opposite of	1
used freely without any cost	1
one is called a loop-carried	1
one is 0 and the	1
one is best. 3.11 Other	1
one is fastest. The typical	1
one of the compilers I	1
one of the elements in	1
one of the following solutions,	1
one of the 32 sets	1
one of the best optimizing	1
one of the four cache	2
one of the few cases	1
one of the main reasons	1
one of the base classes.	1
one of the weekdays. The	1
one of these categories: File	1
one and only one instance.	1
one in a series of	1
one for the SSE2 instruction	1
one for the latest instruction	1
one for AVX2 and all	1
one for constants that are	1
one for initialized variables that	1
one for SSE4.1 and one	1
one for uninitialized variables that	1
one that is used for	1
one that is compatible with	1
one that takes longer time	1
one that works on all	1
one that works best on	1
one that gives the worst	1
one that saves time for	1
one that doesnt. The undocumented	1
one that discriminates between CPU	1
one or a few arrays	1
one or a few machine	1
one or a few places.	1
one or more of the	1
one or more performance monitor	2
one or more dynamic libraries	1
one or multiple elements? If	1
one or two floating point	2
one it is compiling. This	1
one function to another. These	1
one function and later deleted	1
one function can modify x,	1
one if the template parameters	1
one by means of #include	2
one by one, into an	1
one time in thousand so	1
one more integer to the	1
one from Intel and one	1
one from me. My vector	1
one memory block for every	1
one memory pool. See the	1
one CPU core then it	1
one CPU core, but it	1
one other function. A leaf	1
one set of counters in	1
one class to a pointer	1
one floating point addition unit,	1
one object to another. The	1
one array rather than two.	1
one clock cycle if the	1
one clock cycle on most	1
one clock cycle. The operators	1
one clock cycle. The OR	1
one clock cycle. In 64-bit	1
one version that takes advantage	1
one variable if their live-ranges	1
one way in the same	1
one way or the other	1
one way or another. Therefore,	1
one way most of the	1
one way two times and	1
one makes the code faster	1
one call to the inlined	2
one call to Func1, while	1
one register less so that	1
one constant needs to be	1
one (see page 71). In	1
one big memory block than	1
one big block of memory	1
one big problem. Whenever the	1
one element then use a	1
one virtual member functions then	1
one thread is used for	1
one thread can do calculations	1
one thread than another. Therefore,	1
one line at a time	1
one line at a time.	1
one works best. Some common	1
one container for each row	1
one : 1; // always	1
one operator less. Fortunately, all	1
one division by making a	1
one source file and the	1
one addition every clock cycle.	1
one addition every three clock	1
one byte longer in 64	1
one function, if possible. Use	1
one computer is not always	1
one global and one local,	1
one statement in the condition	1
one operation rather than reading	1
one instance of the library	1
one instance for each set	1
one instance for each process	1
one instance for each thread.	2
one instance for each process.	1
one instance then you may	1
one operand is more predictable	1
one operand is faster to	1
one iteration of the loop	1
one iteration to the next.	1
one iteration should depend on	1
one iteration before the preceding	1
one thread. A variable that	1
one square at a time.	1
one thing at the same	1
one logical processor is not	1
one vector. It may be	1
one fraction 2 63 .	1
one 256-bit vector register for	1
one parameter. Further details are	1
one unit of received data	1
one register. Registers are a	1
one vector, the four G	1
one vector, while you can	1
one free register left for	1
one operation. A good compiler	1
one operation. For example, if	1
one contiguous memory block. Do	1
one place to the right	1
one place in the program.	1
one auto_ptr to another by	1
one way, then many times	1
one instance. The function code	1
one instance. Non-static members of	1
one segment then it is	1
one tread can take care	1
one local, and use the	1
cache is a proxy for	1
cache is that communication between	1
cache is used in a	1
cache is used more efficiently.	1
cache is 8 kb =	1
cache is optimized for accessing	1
cache is 512 kb /	1
cache is 512 kb, 8	1
cache is organized if you	1
cache of 8 - 64	1
cache of 8 kb size	1
cache of 256 Kbytes to	1
cache to load the entire	1
cache and the data are	1
cache and the data cache.	1
cache and it fills up	1
cache and data cache are	1
cache and accessed non-sequentially because	1
cache and execution units. If	1
cache in between the calls	1
cache in just a few	1
cache for the hardware definition	1
cache for the sake of	1
cache that can be critical.	1
cache are so expensive that	1
cache are critical resources. Modern	1
cache are less expensive. Using	1
cache or micro-op cache. The	1
cache if there are many	1
cache as when contentions do	1
cache may not be worth	1
cache use and data cache	1
cache use can be critical.	1
cache will be filled up	1
cache will evict the cache	1
cache then you can get	1
cache from the level-2 cache	1
cache from loading any cache	1
cache because the out-of-order execution	1
cache size is a limited	1
cache so we don't have	1
cache between each call, and	1
cache cannot prefetch more than	1
cache called the branch target	1
cache always chooses the least	1
cache access rather than CPU	1
cache (see page 87). Data	1
cache (see p. 87). There	1
cache line to be read	1
cache line in both the	1
cache line that we expect	1
cache line that was used	1
cache line can hold 8	1
cache line will be loaded	1
cache line then the line	1
cache line has to be	1
cache line size is typically	1
cache line size in order	1
cache line size // define	1
cache line size may possibly	1
cache line size (typically 64)	1
cache line would be evicted.	1
cache line size, which is	1
cache works most efficiently if	2
cache works most efficiently when	1
cache works less efficiently if	1
cache space and are difficult	1
cache space or make files	1
cache space by joining a	1
cache space used for constants.	1
cache control instructions than the	1
cache control .............................................................................................. 99 10	1
cache control Microprocessors with the	1
cache contentions is that the	1
cache contentions can be prevented	1
cache contentions if the threads	2
cache contentions than for level-1	1
cache contentions will occur: if	1
cache size. This is because	1
cache size. If this is	1
cache size. When the critical	1
cache size. Alternatively, you may	1
cache lines to use for	1
cache lines in set number	1
cache lines in each set.	1
cache lines in column 28	1
cache lines for matrix a:	1
cache lines from set 0x1C.	1
cache lines we used above	1
cache lines follow the rows,	1
cache lines belong to the	1
cache efficiency and code size	1
cache (e.g. Sandy Bridge) because	1
cache problems. It is not	1
cache space. The syntax in	1
cache space. A situation where	1
cache space. Excessive use of	1
cache space. Putting simple variables	1
cache line. The cache line	1
cache line. This is advantageous	1
cache line. Some compilers will	1
cache line. But these eight	1
cache line. Only one of	1
cache line. 132 Table lookup	1
cache misses is not seen	1
cache misses and branch mispredictions.	2
cache misses by making the	1
cache misses have occurred. This	1
cache size, etc. There are	1
cache effects into account. You	1
cache lines. The critical stride	1
cache lines. This makes code	1
cache size) / (number of	1
cache MOVNTQ _mm_stream_pi SSE Store	1
cache organization for different processors	1
cache level, and in some	1
cache space, as explained in	1
cache sizes. Fortunately, the solution	1
cache misses, branch mispredictions, floating	1
cache misses, branch mispredictions, etc.	1
cache misses, branch misprediction, or	1
cache efficiency, then you may	1
cache miss can be expected.	1
cache miss on a store	1
cache MOVNTDQ _mm_stream_si128 SSE2 Table	1
cache MOVNTPD _mm_stream_pd SSE2 Store	1
cache contentions. See page 87	1
cache contentions. Use simple method.	1
cache (en.wikipedia.org/wiki/L2_cache). The details of	1
cache evictions and other resource	1
cache MOVNTPS _mm_stream_ps SSE Store	1
cache MOVNTI _mm_stream_si32 SSE2 Store	1
cache line: static inline void	1
cache line, because the threads	1
cache contention. You may skip	1
cache contentions, as explained on	1
cache miss. But if the	1
should of course be a	1
should be a class containing	1
should be of the same	1
should be as standardized as	1
should be only one statement	1
should be used only when	1
should be possible to select	1
should be stored in one	1
should be stored at an	1
should be stored together The	1
should be stored together Cache	1
should be stored together ......................................	1
should be stored together...................................... 88	1
should be accessed with the	1
should be compiled three times,	1
should be done by multiplying	1
should be implemented as a	2
should be used. Web systems	1
should be separate for each	1
should be longer than a	1
should be aligned by at	1
should be linked into the	1
should be declared const in	1
should be declared inside the	1
should be based on which	1
should be made local. This	1
should be tested in different	1
should be tested with a	1
should be tested on a	1
should be tested on different	1
should be avoided by calling	1
should be avoided because of	1
should be avoided because they	1
should be clear from this	1
should be organized so that	2
should be standardized and done	1
should be easily available from	1
should be allowed and which	1
should be saved in registers,	1
should be aware that there	2
should be aware of. Big	1
should be measured separately. The	1
should be split up into	1
should be seen in the	1
should be written in C,	1
should be true. template<> class	1
should be identified by their	1
should be multiplied by the	1
should be hidden by using	1
should be performed with a	1
should be taken into account	3
should be handled in a	1
should be predicted. This is	1
should be optional and off	1
should be avoided, if possible,	1
should be regarded as a	1
should be obeyed. Copy protection.	1
should be prepared for several	1
should be weighed against the	1
should be postponed until the	1
should be scheduled in a	1
should by all means avoid	1
should not be evaluated if	2
should not call WriteFile if	1
should not look at CPU	1
should not include any part	1
should have as few branches	1
should have its pointer set	1
should have #if directives around	1
should use this method only	1
should use such methods only	1
should use standard API calls	1
should then handle its own	1
should only be used if	1
should do as little work	1
should also be tested under	1
should also be considered. A	1
should also proceed in a	1
should take installation time and	1
should test the response time	1
should always be a power	1
should always use standardized installation	1
should work efficiently on all	1
should avoid any use of	1
should avoid these and handle	1
should avoid making any pointer	1
should avoid macros with short	1
should therefore be used only	1
should therefore be aware of	1
should therefore not be too	1
should therefore preferably be stored	1
should therefore preferably be put	1
should therefore preferably have a	1
should get a reply about	1
should run in a low	1
should preferably be a simple	1
should preferably be a constant	1
should preferably be a power	2
should preferably be an integer.	1
should preferably be done in	1
should preferably be done on	1
should preferably be declared in	1
should preferably be declared inside	1
should preferably be avoided on	1
should preferably be static, as	1
should preferably be kept small	1
should preferably be kept entirely	1
should preferably be responded to	1
should preferably have no more	1
should automatically detect which instruction	1
should never use static variables.	1
should never return any pointer	1
should never interrupt the user	1
should never respond to a	1
should give a CPU of	1
should look at to see	1
should choose an up-to-date function	1
should rely on static or	1
should produce the same code	1
should save one unit of	1
should allow compile- time if	1
should apply the empty throw()	1
should apply CPU dispatching only	1
should contain a typical degree	1
should multiply it by 100	1
should include not only a	1
should depend on the result	1
should definitely be avoided when	1
should definitely be avoided unless	1
should definitely be avoided. 37	1
should disable it in order	1
should leave a background process	1
integer is within a certain	1
integer is added to a	1
integer is converted to a	1
integer is returned. There is	1
integer is signed, or by	1
integer of a specific size	1
integer to the structure. Incrementing	1
integer to a float or	1
integer to a signed integer	1
integer to a smaller size	1
integer to floating point Conversion	1
integer to floating point. Conversion	1
integer to zero is sometimes	1
integer and this will trigger	1
integer and floating point calculations	1
integer and double vectors SSE3	1
integer and 8 floating point).	1
integer in the loop control	1
integer in the interval 0	1
integer in a different way.	1
integer in one operation. For	1
integer in disguise. Enums are	1
integer that holds a memory	1
integer can be done with	1
integer can be converted to	1
integer if the length of	1
integer if it is stored	1
integer if there is no	1
integer with a constant (see	1
integer with vector integer operations,	1
integer int n; #if defined(__unix__)	1
integer may be used as	1
integer will be interpreted as	1
integer has a particular meaning,	1
integer has enough bits for	1
integer vector from array static	4
integer vector into array static	4
integer vector instructions SSE4.1 some	1
integer vector division. 12.4 Using	1
integer because the integer-to-float conversion	1
integer size is not standardized	1
integer size is big enough	1
integer size in cases where	1
integer size that is big	2
integer size that is larger	1
integer size that doesn't cause	1
integer size if you declare	1
integer size on AMD processors,	1
integer value of temp. The	1
integer takes a very long	1
integer takes a long time	1
integer takes longer time. It	1
integer variable by a float	1
integer register variables is approximately	1
integer rather than two 32-bit	1
integer code. It is more	1
integer registers is extended to	1
integer registers in 64-bit systems.	1
integer registers available for general	1
integer without SSE2 typically takes	1
integer operations for manipulating floating	2
integer operations for incrementing a	1
integer operations are faster than	1
integer operations use different execution	1
integer operations do not add	1
integer operations such as addition,	1
integer operations in-between the floating	1
integer type size_t is 32	1
integer constant with its value.	1
integer calculations in floating point	1
integer doesn't cause overflow. Example:	1
integer overflow with the option	1
integer overflow will make the	1
integer overflow doesn't occur has	1
integer power using loop double	1
integer parameters and the 49	1
integer parameters are transferred in	2
integer known at compile time.	1
integer counter and using the	1
integer multiplication by a constant	1
integer multiplication prior to SSE4.1	1
integer expression -a > -b	1
integer conversion Conversion of a	1
integer parameter comes first when	1
integer division in vectors, but	1
integer division with truncation, and	1
integer division prevents the compiler	1
integer types of a specific	1
integer types Unfortunately, the way	1
integer types available. declaration size,	1
integer expressions than on floating	1
integer expressions than floating point	1
integer expressions rather than Boolean	1
integer expressions Induction variables for	1
integer expressions (except for the	1
integer vectors FMA3 floating point	1
integer variables. 31 7.3 Floating	1
integer registers. Typical candidates for	1
integer calculations. The code in	1
integer calculations. It is necessary	1
integer operations. This can be	1
integer expressions. See page 80	1
integer overflow. Signed versus unsigned	1
integer addition, a floating point	1
integer addition, subtraction and multiplication	1
integer factorial function (n!) as	1
integer arithmetic operations. When an	1
integer vectors. Code that is	1
integer parameters. Floating point parameters	1
integer representation of &list[100] is	1
integer constant. // General case,	1
integer Common subexpression elimin., float	1
integer Register variables, float Live	1
integer counter. A microprocessor with	1
integer counter. Example: // Example	1
integer division. Older CPUs with	1
integer type. Interrupt service routines	1
integer overflow, and invalid pointers.	1
integer constants. Register storage A	1
integer units, one or two	1
integer operations, and to mix	1
integer variable, it makes no	1
integer comparison is likely to	1
integer comparison, which is fast.	1
integer According to the standards	1
integer power, loop unrolled double	1
integer division: Integer division by	1
integer representations in two different	1
integer constant, unless the address	1
integer comparisons. The solution a	1
no function or method should	1
no compiler I have ever	1
no more than the number	1
no more time than single	1
no more time than accessing	1
no more threads with the	1
no other value than 0	2
no other threads have access	1
no other values than 0	2
no other modules call the	1
no other branches. A simple	1
no other exceptions: __except (GetExceptionCode()	1
no instruction for self-relative addressing	1
no loop if the same	1
no cache (see p. 87).	1
no cache problems. It is	1
no pointer aliasing (see page	1
no pointer aliasing (/Oa). The	1
no pointer aliasing /Oa -fno-alias	1
no pointer aliasing. The only	1
no pointer aliasing. See page	1
no pointer aliasing. __declspec(noalias) or	1
no pointer aliasing" if you	1
no pointer aliasing" (if valid)	1
no object is accessed after	1
no such advantage in interpreted	1
no variable or object is	1
no performance cost to using	1
no performance penalty for using	1
no long dependency chains. In	1
no branch prediction (see p.	1
no way the user can	1
no way to tell a	1
no way to tell these	1
no operating system, and therefore	1
no need to use a	1
no need to take branch	1
no need to take special	1
no need to link with	1
no need to break down	1
no need to organize data	1
no need to deallocate the	1
no need for garbage collection.	1
no instructions for integer division	1
no extra code at all.	1
no extra time if it	1
no extra time as long	1
no extra time when the	1
no extra time. It simply	1
no extra time. There are	1
no extra time. These conversions	1
no extra cost to accessing	1
no extra overhead in the	1
no calls to frame functions.	1
no big difference in performance	1
no big arrays, then it	1
no specific order but are	1
no specific recommendation of which	1
no specific option) better: -Ofast	1
no virtual member the object	1
no exception handling. It is	1
no exception ever happens. This	1
no overflow can occur, but	1
no AVX support, then call	1
no check for overflow of	2
no check for overflow. This	1
no check for overflow. Example:	1
no problem if the repeat	1
no advantage to using hyperthreading.	1
no copy constructor and no	1
no copy constructors and destructors	1
no information about the class	1
no certain limit to the	1
no branches inside can be	1
no caching problems for integer	1
no cost to using templates	1
no cost in terms of	2
no cost because it goes	1
no automatic check for integer	1
no induction variable would be	1
no reason to use it	1
no reason to use dynamic	1
no reason to use try,	1
no reason to add statements	1
no reason to unroll the	1
no difference in performance between	1
no difference in speed between	3
no difference in performance. A	1
no difference for the performance.	1
no difference between 32-bit Linux	1
no difference whether you use	1
no longer used and searching	1
no longer used. A smart	1
no longer used. It is	1
no graphics processing unit. Various	1
no negative effect on performance.	1
no overhead while other compilers	1
no checking for array bounds	1
no checking for overflow, and	1
no out-of-order execution. There is	1
no destructor the object has	1
no offset at all. This	1
no clear correspondence between function	1
no risk of overflow, such	1
no risk of overflow: //	1
no risk of underflow. The	1
no penalty for mixing different	1
no checks for array bounds	1
no easy way to control	1
no easy way to roll	1
no explanation why this delaying	1
no try block or function	1
no heavy marketing of 64-bit	1
no absolute addresses that need	1
no loop-carried dependency chain. A	1
no 51 performance penalty for	1
no modification of the program	1
no idea how a piece	1
no reasonable upper limit to	1
no compile- time loops or	1
no multiplications. The following example	1
no doubt obtained with a	1
no warning from the compiler	1
no effect. GOT and PLT	1
no attempt is made to	1
no native floating point execution	1
no guarantee that all destructors	1
no side-effects and its return	1
no yes License license included	1
page and 90 for examples	1
page size (4096). This will	1
page 8 below. This manual	1
page 16 for a discussion	1
page 32 for an explanation	1
page 128 below. Dispatch at	1
page 3 for a list	1
page 130 for an explanation	1
page 130 for how to	2
page 130 for details). The	1
page 120 for how to	1
page 16. If you read	1
page 87 for a discussion	1
page 87 about memory caching.	1
page 122 for how to	2
page 80 for an example	1
page 90 for a further	1
page 107 for how to	1
page 103 for examples of	1
page 51 for the pros	1
page 43 for an explanation	1
page 43 about branch prediction.	1
page 88 for details. Inheritance	1
page 134 and 135 show	1
page 134 on bounds checking).	1
page 150 for further discussion	1
page 146 below. Position-independent code	1
page 146 below. 3.7 File	1
page 26 about data storage	1
page 29 for details. Development	1
page 31 for more discussion	1
page 49 and manual 5:	1
page 49 for a discussion.	1
page 101 for further discussion	1
page 93 for discussion of	1
page 164 below. Those who	1
page 81 for an explanation	1
page 89 for an example	1
page 89 for an example.	1
page 137 about division). The	1
page 136 and 137, respectively.	1
page 153 for further discussion	1
page 145 and 119 for	1
page 140 for further discussion.	1
page 141 for details about	1
page 78 for an explanation.	2
page 107). The Gnu function	1
page 107). Agner's vector class	1
page 16) shows that a	1
page 71). The conclusion is	1
page 71). In this case	1
page 131. Intel Performance Primitives	1
page 131. AMD LIBM library.	1
page 127. The Intel compilers	1
page 15. C++ is definitely	1
page 52. The member functions	1
page 52. You may choose	1
page 73 and 72 for	1
page 73). It is therefore	1
page 73). Current compilers are	1
page 39 shows how you	1
page 105. Floating point addition	1
page 105. 8.7 Checking what	1
page 93. Avoid the function	1
page 93. 7.10 Arrays An	1
page 26. The heap space	1
page 26. Avoid global and	1
page 78). A matrix or	1
page 78). Adding the compiler	1
page 137). The second thing	1
page 137). This also applies	1
page 80. The keyword static,	1
page 43). The Boolean operations	1
page 122. The code becomes	1
page 122. The Intel compiler	1
page 87). Data caching is	1
page 58 shows an example	1
page 105). If the AVX	1
page 105). Using the SSE2	1
page 140). The SSE2 instruction	1
page 140). Mathematical functions must	1
page 72. It is therefore	1
page 72. You have to	1
page 95 and 120 for	1
page 51). The order in	1
page 119). The AMD math	1
page 22. Avoid long dependency	1
page 153. A profiler is	1
page 27). The maximum number	1
page 107. A disadvantage of	1
page 78. Assume no pointer	1
page 60. In the case	1
page 103) will be able	1
page 107), OpenMP and automatic	1
page 122) for the latest	1
page 62. If the critical	1
page 96. 14.5 Integer division	1
page 141. Applications that generate	1
page 53). No general statement	1
page 93). All common implementations	1
page 44. The dispatching mechanism	1
page 143. The trick will	1
page 96). Virtual functions in	1
page 134. The table should	1
page 103), but the compiler	1
page 34. In some cases	1
page 142). 30 Overflow behaves	1
page 54. It is recommended	1
page 81). 77 Pointer aliasing	1
page 90. 15 Metaprogramming Metaprogramming	1
page 84). The compiler can	1
page 53. 7.24 Unions A	1
page 45. This may be	1
page 134) return FactorialTable[n]; //	1
page 135). This extra check	1
page 140. Avoid conversions between	1
page 132. Unfortunately, table lookup	1
page 87. This will happen	1
page 38). Is the size	1
page 87) is likely to	1
page 130. It is often	1
page 72). The compiler cannot	1
page 61. It is recommended	1
page 158. This manual is	1
page 150. Using templates for	1
page 73) automatically then it	1
page 73. Runtime polymorphism is	1
page 70). The programmer does	1
page 27. An array can	1
set the flush-to-zero mode unless	1
set the parentheses manually. The	1
set the denormals-are-zero mode if	1
set is the vector operations	1
set is the scarcity of	1
set is that the compatibility	1
set is that it allows	1
set is not always optimal,	1
set is available then each	1
set is supported in the	1
set is supported by the	3
set is supported by all	1
set is supported by most	1
set is supported on all	1
set is used. It is	1
set is better than its	1
set is particularly interesting because	1
set is enabled. The compiler	1
set is enabled. The advantage	1
set is enabled. There are	1
set is enabled. Conversion from	1
set is enabled. Conversions between	1
set is enabled. Typically, the	1
set is enabled. Few compilers	1
set is available. The number	1
set is available. The best	1
set is available. The older	1
set is available, 256 bits	1
set is enabled there is	1
set is enabled (single precision	1
set is supported. For example,	1
set is specified. The code	1
set is available: // Example	1
set is enabled: // Example	1
set is maintained for the	1
set a to zero for	1
set a to zero memset(a,	1
set a breakpoint in the	1
set of data in order	1
set of cache lines to	1
set of performance monitoring options.	1
set of template parameters. A	1
set of test data and	1
set of test data instead	1
set of test data. The	1
set of test data. That	1
set of CPUs. These costs	1
set of special vector registers.	1
set of containers is the	1
set of counters in each	1
set to NULL. There should	1
set to relax floating point	1
set and one that is	1
set and insert only the	1
set and map are prone	1
set and YMM registers The	1
set and YMM registers .................................................................	1
set and ZMM registers The	1
set and ZMM registers ..........................................................	1
set in the variable Day.	1
set in the cache. When	1
set in order to test	1
set for the vector class	1
set for the appropriate type	1
set that is compatible with	1
set that you want to	1
set are expected to be	1
set can be used. We	1
set can run only if	1
set can still run on	1
set or any higher instruction	1
set it supports. An inferior	1
set if possible. The AVX	1
set if possible. SSE2 is	1
set by using the bitwise	1
set not supported fprintf(stderr, "\nError:	1
set an array to zero.	1
set int iset = instrset_detect();	1
set than the CPU supports	1
set may actually be better	1
set when running on non-Intel	1
set when compatibility with old	1
set then the optimal solution	1
set then it will be	1
set has no instruction for	1
set has support for relative	1
set has nothing between 8	1
set into sub-vectors that fit	1
set multiple bits in a	1
set number 28. The calculation	1
set number 0x1C. There are	1
set also allows 256-bit integer	1
set where the number of	1
set makes floating point code	1
set makes floating point comparisons	1
set SSE2 or later. Example:	1
set SSE2 not supported"); return;	1
set up the performance monitor	1
set up to count certain	1
set up and enable one	1
set AVX instr. set Automatic	1
set values then the line	1
set sign bit of f	1
set sign bit to zero	1
set was originally designed by	1
set char 8 8 64	1
set needed _mm_shuffle_epi8 16 1	1
set control no yes License	1
set supports self-relative addressing of	1
set supports self-relative addressing. In	1
set gives the advantage of	1
set Automatic CPU dispatch Automatic	1
set SSE4.1 instr. set AVX	1
set seconds to zero at	1
set (or higher) is enabled.	1
set #if INSTRSET == 2	1
set available, e.g. AVX, AVX2	1
set Header file MMX mmintrin.h	1
set opens the possibility for	1
set (requires a microprocessor that	1
set (128 bit float vectors)	1
set (128 vectors of inte-	1
set 0x1C. If the program	1
set specified. Insert an explicit	1
set (called x86) of the	1
set Suppl. SSE3 instr. set	1
set extensions. If a profiling	1
set Prefetch PREFETCH _mm_prefetch SSE	1
set (/arch:SSE2, /arch:AVX etc. for	1
set Important features 80386 32	1
class is more efficient than	1
class is less than 128	1
class is 128 bytes or	1
class is implemented in the	1
class is declared or created	1
class is declared by specifying	1
class is given as a	1
class is converted to a	1
class is declared. An object	1
class is responsible for creating	1
class of the object is	1
class of object p points	1
class to a pointer to	1
class and a derived class	1
class and store the shared	1
class and derived class are	1
class in one source file	1
class in another source file.	1
class for containing thread-specific data	1
class that the member pointer	1
class that is used by	1
class that takes care of	1
class that behaves like an	1
class are stored in the	1
class are stored together in	1
class are called from the	1
class are accessed through the	1
class are accessed equally fast.	1
class can be used for	1
class or structure is a	1
class or structure is simply	1
class or structure is created.	1
class or structure are stored	1
class or structure object takes	1
class or give it a	1
class or structure. The situation	1
class or structure. This is	1
class by type-casting its 'this'	1
class with a destructor that	1
class with a default constructor	1
class with members of mixed	1
class code with automatic CPU	1
class will be stored with	1
class data member is unchanged	1
class data members is added	1
class has a pointer to	1
class has at least one	1
class vector { // 2-dimensional	1
class which gets information about	1
class should be aligned by	1
class into an anonymous namespace.	1
class library can emulate a	1
class library have functions for	1
class library will use one	1
class library has not been	1
class library has many features,	1
class library Intel Agner Available	1
class library makes it possible	1
class library #include <stdio.h> //	1
class library exp exp 12.8	1
class objects and is not	1
class objects can often be	1
class objects Conversions involving class	1
class objects (rather than pointers	1
class member function means that	1
class member functions because the	1
class member variable with the	1
class member function. The overhead	1
class libraries use dynamic memory	1
class libraries 113 Number of	1
class template rather than a	1
class need not be passed	1
class must have a destructor	1
class (see page 51). The	1
class doesn't need a constructor.	1
class through a pointer to	1
class through a template parameter.	2
class members may cause a	1
class name and the template	1
class name as template parameter.	1
class library. Open source. Supports	1
class Variables declared inside a	1
class containing the functions that	1
class containing the members of	1
class templates in www.agner.org/optimize/cppexamples.zip. These	1
class templates are available for	1
class declaration and the most	1
class D : public B1	1
class D : public B1,	1
class C1 or C2, then	1
class C1 { public: ...	1
class C1 : public CHello	1
class C1 : public C0	1
class members. The code that	1
class c1 { const int	1
class c1 other than its	1
class library, SSE4.1 gives an	1
class gets information about the	1
class separately in software development.	1
class elements. The size of	1
class objects. The size (in	1
class powN { public: static	1
class CChild1 : public CParent<CChild1>	2
class CHello { public: void	1
class C0 { public: virtual	1
class Vec16s when compiling for	1
class definition. This will prevent	1
class definition. Inlining a function	1
class CChild2 : public CParent<CChild2>	1
class templates, as explained on	1
class B1; class B2; class	1
class B1; class B2; 54	1
class CParent : public CGrandParent	1
class CGrandParent { public: void	1
class declaration. The type of	1
class C2 : public CHello	1
class c1; int c1::*MemberPointer; Here,	1
class SafeArray { protected: T	1
class B2; class D :	1
class B2; 54 class D	1
class powN<true,0> { public: static	1
class powN<true,N> { public: static	1
class S2 { public: int	1
class S3 { public: int	1
class (also called properties) are	1
class (CGrandParent) contains any non-polymorphic	1
class library). The D language	1
class C1, so it can	1
class powN<true,1> { public: static	1
class (CParent<>) contains any member	1
floating point is faster with	1
floating point is faster than	1
floating point to integer without	1
floating point to integer According	1
floating point to integer. The	1
floating point and integer representations	1
floating point if the conversion	1
floating point code and you	1
floating point code more efficient	1
floating point code rather than	1
floating point code slower, especially	1
floating point library which is	1
floating point number is zero	1
floating point number to the	1
floating point number to an	1
floating point number in the	1
floating point number by 2n	1
floating point number simply by	1
floating point value written as	1
floating point variable as an	1
floating point variables is so	1
floating point variables in order	1
floating point variables Floating point	1
floating point variables ......................... 142	1
floating point register variables is	1
floating point register variables in	2
floating point register stack is	1
floating point register variables. Vector	1
floating point register variables, but	1
floating point code. The bigger	1
floating point code. The 128-bit	1
floating point code. If you	1
floating point registers and correspondingly	1
floating point registers are used,	1
floating point registers available in	1
floating point registers organized as	1
floating point operations and choose	1
floating point operations without reducing	1
floating point operations involves eight	2
floating point operations (addition, multiplication,	1
floating point constant always takes	1
floating point stack registers are	3
floating point calculations and the	1
floating point calculations or turn	1
floating point calculations as long	1
floating point calculations will typically	1
floating point calculations should therefore	1
floating point calculations inside the	1
floating point calculations unless the	1
floating point calculations whenever they	1
floating point execution units. Any	1
floating point overflow but no	1
floating point precision (see page	1
floating point parameters are transferred	1
floating point counter then make	1
floating point multiplication at the	1
floating point multiplication units. This	1
floating point division to be	1
floating point induction variables for	1
floating point addition and multiplication	1
floating point addition with floating	1
floating point addition on a	1
floating point addition takes 5	1
floating point addition every clock	1
floating point addition units, and	1
floating point addition unit, but	1
floating point expressions or more	1
floating point expressions may have	1
floating point expressions (see page	1
floating point numbers is less	1
floating point numbers is inefficient.	1
floating point numbers to integers	1
floating point numbers and integers	2
floating point numbers can be	1
floating point numbers simply by	1
floating point operands cannot be	1
floating point operation on such	1
floating point operation takes 5	1
floating point constants are double	1
floating point constants are stored	1
floating point library. If you	1
floating point calculations. Even with	1
floating point operations. You should	1
floating point precision. The following	1
floating point instructions. This is	1
floating point instructions. Each type	1
floating point expressions. It is	1
floating point expressions. For example,	1
floating point expressions. Most reductions	1
floating point expressions. Floating point	1
floating point addition, and a	1
floating point variables, if possible.	1
floating point Conversion of integers	1
floating point vectors. There are	1
floating point rounding mode has	1
floating point capabilities (except in	1
floating point representation directly with	1
floating point number. We can	1
floating point comparisons are more	1
floating point comparisons more efficient.	1
floating point numbers. It can	1
floating point numbers. Therefore, 64-bit	1
floating point division. Correction for	1
floating point underflow in XMM	1
floating point constants, string constants,	1
floating point format is standardized	1
floating point addition. This is	1
floating point multiplication, to mix	1
floating point numbers: // Example	1
floating point comparisons, which are	1
floating point overflow: _controlfp_s(&dummy, 0,	1
floating point expressions, even though	1
floating point precisions when the	1
floating point status: _fpreset(); _controlfp_s(&dummy,	1
floating point comparison. On big	1
floating point variable: // Example	1
floating point multiply-and-add Table 13.1.	1
floating point -ffast-math /fp:fast /fp:fast=2	1
floating point exceptions, etc. Event-based	1
floating point. The reason is,	1
floating point. Use 64-bit mode	1
floating point. Conversion of unsigned	1
floating 26 point constants, string	1
floating point: // Example 14.22b	1
floating point-to-integer conversions in the	1
floating point). There are also	1
each of the most important	1
each of its members are	1
each function is called and	1
each function and branch is	1
each function or class separately	1
each function call to count	1
each function call so that	1
each function relative to the	1
each compiler with the application.	1
each time the function is	3
each time the program starts.	1
each time it is used	1
each time slice are quite	1
each vector can be 64	1
each vector can hold four	1
each vector register is 128	1
each vector depends on the	1
each different value of the	1
each CPU model has its	1
each CPU core). The counters	1
each other is inefficient because	1
each other in the code	1
each other in the same	1
each other in order to	1
each other in memory. Variables	1
each other are also stored	2
each other (not member of	1
each instruction set. A CPU	1
each integer type. Interrupt service	1
each set of template parameters.	1
each floating point operation takes	1
each object in its own	1
each object are called every	1
each object should preferably be	1
each object separately if there	1
each array is a multiple	1
each array element in order	1
each version of the critical	1
each version void FUNCNAME(short int	1
each version FuncType SelectAddMul, SelectAddMul_SSE2,	1
each value is calculated from	1
each value of sum depends	1
each value of n! is	1
each value from the value	1
each value depends on the	1
each value xn is calculated	1
each table element Instruction set	1
each member function has only	1
each address by adding a	1
each call to a driver	1
each bit of a 32-bit	1
each bit in Day for	1
each bit in nn ifbit=1	1
each bit indicates a specific	1
each time. An experiment where	1
each test // Repeat NumberOfTests	1
each new version for marketing	1
each new generation of CPUs	1
each part of the program	1
each part of the program.	1
each part takes. See page	1
each type of microprocessor. These	1
each constant a value that	1
each processor model is going	1
each compiled for the specific	1
each element in vector c	2
each element in vector c2	1
each element in vector bc	1
each element in b to	2
each element __m128i a =	1
each element matrix[r][c] is swapped	1
each thread than to temporarily	1
each thread may run at	1
each thread will run at	1
each thread its own data	1
each allocated block. Walking through	1
each line written. This worked	1
each optimized for a particular	1
each calculation depends on the	2
each run in an array.	1
each particular branch of code	1
each their stack. This can	1
each their smart pointer then	1
each intrinsic function call is	1
each string is checked before	1
each addition has to wait	1
each addition depends on the	1
each set. If the cache	1
each process when compiled without	1
each statement that calls the	1
each instance of the class.	1
each task or thread are	1
each object. A little-known alternative	1
each iteration is a significant	1
each iteration it decides whether	1
each iteration needs the result	1
each thread. This method works	1
each thread. This structure or	1
each thread. It is not	1
each thread. Pointers to contained	1
each thread. Thread-local storage is	1
each access. The compiler may	1
each version. The examples are	1
each row or column. The	1
each row by adding the	1
each label is equal to	1
each case. Inlined functions have	1
each factor rather than the	1
each core. For example, a	1
each step of the sequence	1
each process. A dynamic library	1
each process. Obviously, we loose	1
each other. This is the	1
each other. See page 51	1
each other. See page 88	1
each carefully optimized and fine-tuned	1
each element, bits Number of	2
each calculation. In most cases,	1
each method, it is clear	1
each other's caches and cause	1
each pixel or line separately	1
each call, and the time	1
each clause are separated by	1
do the CPU dispatching explicitly	1
do the optimization unless the	1
do the extra operations outside	1
do the best job optimizing	1
do the necessary calculations of	1
do the check after the	1
do the dispatching only for	1
do the reductions manually. I	1
do the calculations. The time	1
do the algebraic reductions explicitly	1
do the job fast enough.	1
do the reduction in this	1
do the divisions (Division is	1
do the conversion. The constructor	1
do the devirtualization (see page	1
do is to mix different	1
do is to enable the	1
do a floating point addition	1
do a lot of optimization	1
do a lot of modifications	1
do a lot of bookkeeping	1
do a thorough analysis of	1
do to make the code	1
do to take maximum advantage	1
do and which optimizations you	1
do and what it can	1
do it explicitly. In example	1
do function inlining and constant	1
do with bitwise operators using	1
do as much as possible	1
do as little work as	1
do not have the selected	1
do not have to worry	1
do not have this problem.	1
do not have such a	1
do not have inherent support	1
do not use the best	1
do not use branches, provided	1
do not make this kind	1
do not make induction variables	1
do not need relocation at	1
do not always work well	1
do not always work. Data	1
do not support static linking.	1
do not support SSE. Several	1
do not add to the	1
do not know that double	1
do not produce any extra	1
do not expect to 99	1
do not free the memory	1
do not overlap. If c	1
do not overlap. You can	1
do not overlap. See page	1
do not overlap. 27 The	1
do not wrap around on	1
do not overlap or if	1
do not normally use this	1
do not occur. The reason	1
do not 123 correspond to	1
do not alias, if appropriate.	1
do an integer addition, a	1
do an addition with another	1
do have to worry about	1
do have such checks. But	1
do this by invoking the	1
do this optimization automatically in	1
do this optimization explicitly. Divisions	1
do this every time a	1
do this optimization. 8.2 Comparison	1
do this manually. This principle	1
do use the 64-bit vectors	1
do more than one thing	1
do more complicated reductions. Algebraic	1
do more reductions on integer	1
do when you want to	1
do different kinds of optimizations.	1
do because it comes before	1
do other input/output than the	1
do integer operations in-between the	1
do multiple things at the	1
do two additions with double's.	1
do two jobs simultaneously. Each	1
do such a check before	1
do such optimizations automatically, but	1
do such obvious reductions as	1
do any algebraic reductions on	1
do some measurements to see	1
do so is a common	1
do so is also a	1
do so will cause the	1
do so unless you specify	1
do so (i.e. if the	1
do operations on all elements	1
do simple integer calculations in	1
do simple algebraic reductions such	1
do must be done manually	1
do while waiting for disk	1
do calculations on the data.	1
do calculations while another thread	1
do calculations while simultaneously prefetching	1
do much of the trivial	1
do four additions in one	1
do another addition to sum2	1
do mathematical calculations. It is	1
do automatic vectorization. Optimizes moderately	1
do optimizations such as common	1
do things in parallel. Coarse-grained	1
do things in parallel: Using	1
do things with pointers that	1
do whole program optimization. 2.4	1
do out-of-order execution. This means	1
do something about it. Possible	1
do something about them. You	1
do arithmetic operations with pointers.	1
do this: Use assembly language	1
do this. Unfortunately, the syntax	1
do nothing while seconds count	1
do so. The compilers are	1
do so. See page 73.	1
do so. 58 If it	1
do manually. It must be	1
do interprocedural optimizations of the	1
do experiments in order to	1
do immediately before the code	1
do so). A template parameter	1
do cross-module optimizations when interprocedural	1
do searches of the kind:	1
example is a function which	1
example is a cache of	1
example is a double precision	1
example is called with many	1
example is specific to Microsoft	1
example is Perl. Several modern	1
example of a Taylor series.	1
example of how to use	1
example of how to make	1
example of how to do	1
example to produce tables of	1
example in the "Macro loops"	1
example can be accessed sequentially	1
example can be avoided by	1
example if you want to	1
example if you write a	1
example with floating point numbers:	1
example with u.i[1] ^= 0x80000000;	1
example on page 39 shows	1
example may fail in the	1
example use #if instead of	1
example when you discover that	1
example when r = 28.	1
example has three conditions which	1
example only to show how	1
example should be compiled three	1
example using Agner's vector classes	1
example i = 18, then	1
example so that a+b is	1
example 32 bits of a	1
example container classes that use	1
example every time a thousand	1
example sets the sign bit	1
example shows the same code	1
example shows the principle for	1
example shows a code that	1
example shows this calculation implemented	1
example shows first the runtime	1
example shows how to use	1
example shows how to make	2
example shows how to take	1
example shows how to align	1
example shows how to implement	1
example shows what the assembly	1
example containers in cases where	1
example below shows. The best	1
example 15.1b is easier to	1
example 15.1b is implemented. The	1
example 15.1b to metaprogramming would	1
example 15.1b to 15.1c was	1
example 15.1b to 15.1c. We	1
example 15.1b to 15.1c? We	1
example 15.1b and d in	1
example 13.1 can be placed	1
example 13.1 page 127. The	1
example 13.1 below. 126 Make	1
example 16.2 calls the critical	1
example 16.2 above, but read	1
example 15.1c is faster than	1
example 14.8 and 14.9 is	1
example 12.4b and 12.4c is	1
example 12.4b can be replaced	1
example 16.1 const int NumberOfTests	1
example 9.5 because we are	1
example 9.5 so that it	1
example illustrates the difference between	1
example illustrates such a case:	1
example illustrates how to use	1
example illustrates this. My example	1
example 8.26a by rolling out	1
example 8.26a (32-bit mode): ;	1
example 15.1a to 15.1c would	1
example 15.1a to 151 15.1c	1
example 14.28 can be implemented	1
example 14.28 will shift out	1
example 7.4 we are converting	1
example 9.6b. The MOVNTQ instruction	2
example 9.5a on a Pentium	1
example 9.5a goes from the	1
example 11.3 is independent of	1
example 11.3 even without the	1
example explains why bookkeeping is	1
example 14.12b and 14.13b works	1
example 14.14a with 14.14b automatically	1
example 12.4a where current compilers	1
example 12.4a so that we	1
example 8.15a were float instead	1
example 14.19 below. The function	1
example 14.1c is copied from	1
example 11.2b was an odd	1
example transposes a matrix and	1
example 11.1a to 11.1b automatically,	1
example 7.15b below shows. It	1
example 15.1b. Branches are implemented	1
example 14.23 page 143. The	1
example (12.4e) with automatic CPU	1
example 14.7b is converted by	1
example 12.4a, depending on how	1
example 7.32b. A for-loop has	1
example 8.15b. The integer representation	1
example 8.21, you could calculate	1
example 16.2. The measured time	1
example 12.2, the optimized code	1
example 8.23b has two loop-carried	1
example 15.1d to 15.1c as	1
example 14.7b, we are in	1
example 8.24 can be implemented	1
example 12.1a, the compiler can	1
example 12.1b to 12.1a. Enable	1
example 8.26b: ; Example 8.26b	1
example 16.1. This code works	1
example 12.8a to 12.8b automatically	1
example 7.35 page 52. You	1
example converts a zero-terminated ASCII	1
example 12.1b, the compiler cannot	1
example 9.5a: 98 int r,	1
example 12.4b, rewritten with the	1
example 7.22. // Example 7.22	1
example 9.5b. // Example 9.5b	1
example 12.3a, for example, you	1
example 13.1, Requires binutils version	1
example 7.43b is admittedly very	1
example 14.21 is faster than	1
example 9.1b. On the contrary,	1
example 7.30b. The loop control	1
compilers is generally possible on	1
compilers to see whether they	1
compilers to choose between. It	1
compilers and function libraries that	1
compilers and function libraries have	1
compilers and operating systems. 3	1
compilers and operating systems". The	1
compilers and operating systems". For	1
compilers and operating systems". 7.16	1
compilers and operating systems"). An	1
compilers and operating systems" for	1
compilers and optimized function libraries.	1
compilers and development tools. A	1
compilers and microprocessors work. The	1
compilers and invoked with automatic	1
compilers The register keyword can	1
compilers The tests were carried	1
compilers for Windows are fully	1
compilers for Linux. 82 Keywords	1
compilers that a user-defined function	1
compilers that are best at	1
compilers that have support for	1
compilers that support intrinsic functions.	1
compilers that rely on the	1
compilers are not very good	1
compilers are not compatible with	1
compilers are able to do	2
compilers are able to calculate	1
compilers are able to generate	1
compilers are able to mix	1
compilers are able to do,	1
compilers are better at reducing	1
compilers are actually reducing example	1
compilers are mentioned below. Microsoft	1
compilers are becoming better and	1
compilers are inferior to their	1
compilers can in most cases	1
compilers can be used as	1
compilers can use vector operations	1
compilers can make thread-local storage	1
compilers can do a lot	1
compilers can do simple algebraic	1
compilers can automatically detect opportunities	1
compilers can reduce other types	1
compilers can reduce some types	1
compilers can reduce simple algebraic	1
compilers can compute a /	1
compilers or function libraries is	1
compilers may be able to	1
compilers may not vectorize automatically.	1
compilers may behave differently on	1
compilers you can do this	1
compilers have a feature for	1
compilers have a feature called	1
compilers have an option for	3
compilers have an option (Windows:	1
compilers have efficient table-based methods	1
compilers have many keywords and	1
compilers have support for whole	1
compilers have various optimization options	1
compilers have various options to	1
compilers have inefficient code-based methods	1
compilers have difficulties making floating	2
compilers use the software implementation	1
compilers use the name _alloca)	1
compilers will not do such	1
compilers will not do so	1
compilers will use the XMM	1
compilers will use different memory	1
compilers will make temp a	1
compilers will make exactly identical	1
compilers will make two. Some	1
compilers will do this optimization	1
compilers will do such optimizations	1
compilers will often replace integer	1
compilers will replace the code	1
compilers will automatically replace such	1
compilers will automatically choose the	1
compilers will reduce int x	1
compilers will unroll loops if	1
compilers will align data members	1
compilers will align large static	1
compilers will recognize that the	1
compilers then it is recommended	1
compilers from Microsoft, Intel and	1
compilers at the object file	1
compilers has several flaws: The	1
compilers make Sum1 slightly more	1
compilers do not make this	1
compilers do not free the	1
compilers also have fast ways	1
compilers such as the Gnu,	1
compilers cannot do must be	1
compilers cannot reduce the integer	1
compilers need assembly code to	1
compilers without problems if the	1
compilers I have made a	1
compilers I have tested can	1
compilers I have tested were	1
compilers I have tested implement	1
compilers I have tested seem	1
compilers I have studied do	1
compilers I have tried. The	1
compilers optimize Modern compilers can	1
compilers optimize ............................................................................................ 66 8.2	1
compilers don't vectorize the code	1
compilers Intel, Microsoft Intel, Microsoft,	1
compilers produce less optimal code	1
compilers unroll too much. Excessive	1
compilers reduced 15.1a to 15.1c).	1
compilers allow assembly-like intrinsic functions,	1
compilers include standard libraries for	1
compilers available, though less user	1
compilers due to controversies over	1
compilers work. The C++ language	1
compilers behave differently because there	1
compilers offer the choice between	1
compilers offer the possibility of	1
compilers offer profile-guided optimization. This	1
compilers (Microsoft, Intel) know that	1
compilers www.agner.org/ optimize/#vectorclass Include file	1
compilers succeeded in applying the	1
compilers exist for all major	1
most of the time and	1
most of the time on	1
most of the functions are	1
most of the Gnu directives	1
most of the Microsoft directives	1
most of the advantages of	1
most of the resources. In	1
most of the time, but	1
most of its time in	1
most of its time on	1
most of its time waiting	1
most of their time waiting	1
most of their execution time	1
most for register variables. This	1
most function libraries have CPU	1
most other libraries when running	1
most other microprocessors. Integer division	1
most used data. The speed	1
most used parts of the	1
most cache misses, branch mispredictions,	1
most compilers you can do	1
most compilers will do this	1
most compilers do not free	1
most library functions without CPU	1
most C++ compilers allow assembly-like	1
most efficient for such applications,	1
most efficient if the case	1
most efficient if all of	1
most efficient memory space to	1
most efficient vector operations require	1
most efficient loop control condition	1
most efficient integer size if	1
most efficient library and economize	1
most efficient solution for the	1
most efficient solution may be	1
most efficient solution because of	1
most efficient solution. Is a	1
most efficient alternative. The theoretical	1
most variables in a well-structured	1
most software runs most of	1
most critical integer parameter comes	1
most critical part of the	6
most critical part of a	2
most critical parts of the	1
most critical modules with a	1
most often used data members	1
most often used variables in	1
most often used members in	1
most often true last in	1
most libraries it is never	1
most time. Uses debug version	1
most useful for finding problems	1
most cases the microprocessor is	1
most cases be linked into	1
most cases it is also	1
most cases you can rely	1
most cases when the 145	1
most cases where the number	1
most cases they are sure	1
most simple reductions on integer	1
most processors (when vector operations	1
most important or critical parts	1
most important functions are included	1
most important method that is	1
most important disadvantage of the	1
most important addition to the	1
most important thing is to	1
most important remedy is memory	1
most CPUs and operating systems	1
most common memory and string	1
most common cause of errors	1
most common mathematical functions such	1
most common platforms with Windows,	1
most common math functions such	1
most common implementations of smart	1
most common pitfalls of CPU	1
most common obstacles to efficient	1
most common time-consumers are discussed	1
most likely be called, even	1
most cases, the optimal branch	1
most cases, the fastest way	1
most cases, an optimizing compiler	1
most cases, you can assume	1
most cases, but it may	1
most cases, double precision calculations	1
most cases, there is no	1
most cases, even for double	1
most cases, regardless of the	1
most complicated implementation of member	1
most development methods are incremental	1
most appropriate for the desired	1
most advanced code version on,	1
most compatible way is to	1
most cases. The so-called iterators	1
most cases. This means that	1
most cases. Don't change &&	1
most modern C++ compilers. The	1
most efficiently if it is	1
most efficiently if functions that	1
most efficiently if pieces of	1
most efficiently when the data	1
most newer processors. The following	1
most significant part of the	1
most critical. However, there may	1
most time-consuming part of the	1
most time-consuming parts of the	1
most purposes the standard PC	1
most systems, you cannot increase	1
most frequent causes of compatibility	1
most serious problem with the	1
most reliable solution. (In my	1
most predictable operand first. If	1
most popular version of Basic	1
most microprocessors. Multiplication and division	1
most commonly used set of	1
most commonly used variables are	1
most clean solution is to	1
most up-to-date solution. The compiler	1
most cases: The CPU dispatcher	1
most sorting algorithms, are not	1
most distributions of Linux, BSD	1
using the vector registers are:	1
using the same function calling	1
using the same compiler option	1
using the same inline assembly	1
using the integer in the	1
using the performance monitor counters.	1
using the register stack are:	1
using the optimization features of	1
using the instructions listed in	1
using the virtual table. Unfortunately,	1
using the above template class	1
using the keyword __restrict or	1
using the keyword far (arrays	1
using the keyword __thread or	1
using the | operator which	1
using the | operator; you	1
using the so-called time stamp	1
using the so-called intrinsic functions.	1
using the bitwise OR operator,	1
using the previous value. It	1
using the declaration "static" or	1
using the smallest integer size	1
using the normal return route.	1
using the newest instruction set	1
using the larger vector size.	1
using the directive __declspec(cpu_dispatch(...)). See	1
using the fundamental laws of	1
using a function that does	1
using a compiler that can	1
using a different function library.	1
using a 64-bit integer rather	1
using a software implementation rather	1
using a long vector library	1
using a template parameter rather	1
using a constant divisor that	1
using a common denominator can	1
using a particular code version.	1
using a lookup table: //	1
using a shift operation. x*8	1
using a six years old	1
using a profiler. A simple	1
using a pipeline where instructions	1
using a ready-made profiler. This	1
using and turn on all	1
using function inlining, common subexpression	1
using an Intel function library	1
using an Intel compiler, then	1
using an inline function instead	1
using an intermediate code is	2
using this for testing single	1
using vector operations when the	1
using vector classes and overloaded	1
using different types of variables.	1
using functions such as GetPrivateProfileString	1
using only the even-numbered logical	1
using CPU clock cycles rather	1
using CPU dispatching then call	1
using loop double ipow (double	1
using one or more of	1
using one register less so	1
using each bit in Day	1
using example 9.5a on a	1
using Intel vector classes 114	1
using static linking and by	1
using static linking rather than	1
using static here is that	1
using such a framework sometimes	1
using template metaprogramming // Template	1
using registers for the same	1
using pointers and references. Most	1
using pointers rather than references	1
using new and delete is	1
using dynamic memory allocation. Some	1
using short int instead of	1
using & enum Weekdays {	1
using assembly language and automatic	1
using assembly language because a	1
using assembly language. See page	1
using single precision or double	1
using exception handling then you	1
using integers as Boolean vectors,	1
using intrinsic functions or vector	1
using signed and unsigned integers.	1
using vectors if the code	1
using advanced algorithms to predict	1
using advanced facilities of the	1
using references rather than pointers	1
using references instead of pointers,	1
using position-independent code (option -fno-pic).	1
using overloaded functions. 7.27 Overloaded	1
using overloaded operators for things	1
using classes. 7.2 Integers variables	1
using bitwise operators is more	1
using smart pointers is to	1
using nontemporal writes. If the	1
using references. References are safer	1
using templates (see p. 57).	1
using rounding instead of truncation.	1
using exceptions is to return	1
using powers of 2 when	1
using powers of 2 does	1
using powers of 2 applies	1
using Agner vector classes #include	1
using Agner's vector classes looks	1
using asmlib library int level	2
using 8-bit integers which range	1
using exceptions. The function that	1
using templates. Two or more	1
using templates. Ready made container	1
using namespaces. 65 8 Optimizations	1
using __fastcall. Function parameters are	1
using hyperthreading. On the contrary,	1
using hyperthreading, but the performance	1
using multiplications only. The following	1
using alloca. 9.7 Container classes	1
using ready made containers is	1
using InstructionSet(): // Example 13.1	1
using indexes, working with sets	1
using new. The purpose of	1
using new/delete or malloc/free should	1
using memset: // Example 7.16	1
using unions rather than type	1
using inheritance. There may be	1
double the number of calls	1
double the speed by using	1
double is that it is	1
double is bad The C/C++	1
double is represented with 64	1
double a = sin(0.8); The	1
double to int in the	1
double to integer can be	1
double to integer takes a	1
double and long double take	1
double and long double reflects	1
double if the code can	1
double by modifying only half	1
double A = 1.1, B	2
double because all the compilers	1
double which gives access to	1
double Intel SVML v.10.2 &	1
double In example 7.4 we	1
double There is no penalty	1
double takes 4 - 16	1
double takes 8 bytes of	1
double 2 AVX2 _mm256_i64gather_pd unlimited	1
double const & source) {	1
double before multiplying with the	1
double 4 AVX2 Table 12.3.	1
double 8 8 long double	1
double 64 2 128 SSE2	1
double 64 4 256 AVX	1
double 64 8 512 AVX512	1
double take no extra time	1
double without loading a cache	1
double 32 bits at a	1
double (see page 140). The	1
double a, b; a =	3
double a, b; // everything	1
double precision is not supported.	1
double precision is used. A	1
double precision in 32-bit systems	1
double precision in programs compiled	1
double precision or four single	1
double precision or eight single	1
double precision by default, so	1
double precision when the XMM	2
double precision takes only slightly	1
double precision before multiplying with	1
double precision without worrying too	1
double precision constant and then	1
double precision calculations are just	1
double precision calculations take no	1
double precision constant. It is	1
double precision (80 bits). The	1
double 128 float 256 double	1
double uses 64 bits. The	1
double b; a += b;	1
double b; // 8 bytes.	1
double b; int d; //	1
double 256 F32vec4 F64vec2 F32vec8	1
double y = 1.0; while	1
double c; b = (unsigned	1
double vectors AVX2 256 bit	1
double vectors SSE3 horizontal add,	1
double Floating point calculations usually	1
double d; int i[2]; }	1
double d; d = u;	1
double d; d = (double)(signed	2
double d = 1.6; int	1
double x, y; bool b;	1
double x, n, factorial =	2
double x, y, z; bool	1
double precision. You may use	1
double precision. But the software	1
double precision. Conversions between different	1
double precision. Long double precision	1
double temp; for (r =	2
double temp; // Define size	1
double 8, 10, 12 or	1
double plus 6 integer, pointer	1
double p(double x) { //	1
double p(double x) { return	3
double precision, and intermediate results	1
double precision, but there is	1
double y, a1, a2, b1,	2
double xpow10(double x) { double	1
double xpow10(double x) { return	3
double a1, a2, b1, b2,	2
double Y = C; double	1
double format. The formats can	1
double b;}; S1 list[100]; int	1
double b;}; S1 list[100], *temp;	1
double x2 = x *x;	1
double reflects the floating point	1
double Z = A +	1
double x4 = x2*x2; double	1
double Table[100]; int x; for	1
double Table[100]; int x; const	1
double ipow (double x, unsigned	1
double log2 = log(2.0); ...	1
double b[SIZE][SIZE]) { int r,	2
double precision: // Example 14.18b	1
double A2 = A +	1
double x10 = x8*x2; return	1
double x8 = x4*x4; double	1
double Func2(double x) { return	1
double a[arraysize], b[arraysize], c[arraysize]; //	1
double Func1(double) pure_function ; double	1
double matrix[SIZE][SIZE]; transpose(matrix); } }	1
double IntegerPower (double x) {	1
size is a power of	2
size is a limited resource.	1
size is not standardized across	1
size is different for different	1
size is big enough for	1
size is done simply by	1
size is typically 64 bytes	1
size is relevant when the	1
size is handled at half	1
size is insufficient. The user	1
size a multiple of the	1
size of the program as	1
size of the vector registers	1
size of the integer registers	1
size of the object pointed	1
size of the array is	1
size of the array i)	1
size of the type of	1
size of the matrix is	1
size of the variable. For	1
size of the parent class	1
size of the largest vector.	1
size of a memory block	1
size of a matrix line	1
size of a matrix line.	1
size of code and data	1
size of an int is	1
size of an array or	1
size of data files. This	1
size of program or data	1
size of vector registers has	1
size of all data in	1
size of all but the	1
size of each vector can	1
size of each vector register	1
size of each integer type.	1
size of each object should	1
size of each array is	1
size of 64 bytes. Each	1
size of integers and other	1
size of vector, bits Vector	1
size of vector, bits Instruction	1
size of abc is a	1
size of abc is 12	1
size of abc can be	1
size of squares: const int	1
size of 64. Each cache	1
size to avoid dynamic memory	1
size and type of data	1
size and optimizing for speed.	1
size in the future. Typically,	1
size in order to avoid	1
size in cases where the	1
size for the sake of	1
size that is big enough	2
size that is larger than	1
size that doesn't cause overflow	1
size that fits the application.	1
size are only available if	1
size can be allocated dynamically.	1
size can be replaced by	1
size // define matrix //	1
size = 100; // Array	1
size = 100; int i;	1
size = 100; float list[size],	2
size = 100; S1 list[size];	1
size = 256; // Array	1
size = 16; int i;	1
size = 1000; int i;	1
size = 1000; float a[size],	1
size = 1024; int a[size],	2
size = 1024; struct Sab	1
size or data used in	1
size if you declare an	1
size by extending the sign-bit	1
size with a line size	1
size on AMD processors, but	1
size as vector register. Factors	1
size as template parameters, as	1
size may possibly be more	1
size have got low priority.	1
size when doing calculations, and	1
size then add a few	1
size has higher priority than	1
size only when the next	1
size other than short int	1
size should always be a	1
size array or container without	1
size cannot be predicted or	1
size often have execution units,	1
size arrays inside the function	1
size execution units. The size	1
size doesn't matter and there	1
size known at compile time?	1
size known before the first	1
size conversion // Example 7.21	1
size conversion often takes no	1
size parameter is bigger than	1
size parameter is wrong, but	1
size needed before adding the	1
size divisible by vector size.	1
size comes only in the	1
size right from the beginning	1
size causes misses in the	2
size vector. The use of	1
size Time per element Example	1
size (in bytes) of the	1
size (in bytes) of each	1
size Total kilobytes Time per	1
size Alignd ( short int	1
size (16 or 32 bytes).	1
size matrices, clock cycles per	2
size grows by only 50%	1
size (typically 64) can improve	1
size (4096). This will make	1
Intel and one from me.	1
Intel and Gnu compilers are	1
Intel and Gnu compilers. //	1
Intel and Microsoft C++ compilers	1
Intel and PathScale compilers can	2
Intel and Gnu. There is	1
Intel and Gnu). Other compilers	1
Intel The Intel compiler includes	1
Intel or Microsoft compiler for	1
Intel or PathScale compiler for	1
Intel or PathScale. 2. Use	1
Intel function library then make	1
Intel function libraries and compiler-generated	1
Intel function libraries do not	1
Intel function libraries, but who	1
Intel compiler is a good	1
Intel compiler is that the	1
Intel compiler is less efficient	1
Intel compiler is used, then	1
Intel compiler is capable of	1
Intel compiler in favor of	1
Intel compiler for Windows and	1
Intel compiler for Linux have	1
Intel compiler can insert nontemporal	1
Intel compiler has an option	1
Intel compiler has solved this	1
Intel compiler because it has	1
Intel compiler Intel compiler Windows	1
Intel compiler Intel compilers have	1
Intel compiler Windows Intel compiler	2
Intel compiler Windows Linux __INTEL_COMPILER	1
Intel compiler versions 7 through	1
Intel compiler Linux Align by	1
Intel compiler Linux Optimize for	1
Intel compiler works only for	1
Intel compiler allows you to	1
Intel compiler supports vector intrinsics,	1
Intel compiler reduced 15.1a to	1
Intel compiler includes standard function	1
Intel compiler generates the following	1
Intel compiler ......................................................................... 130 14	1
Intel compiler puts the programmer	1
Intel have similar CPU dispatch	1
Intel vector class library has	1
Intel vector classes 114 #include	1
Intel vector math library (VML,	1
Intel vector math libraries. The	1
Intel vector classes): // Example	1
Intel vector classes: // Example	1
Intel CPU dispatcher treats non-Intel	1
Intel CPU detection function In	1
Intel but is currently only	1
Intel compilers and function libraries	1
Intel compilers for Windows are	1
Intel compilers for Linux. 82	1
Intel compilers can use vector	1
Intel compilers have a feature	1
Intel compilers has several flaws:	1
Intel library function __intel_cpu_features_init() sets	1
Intel library functions have several	1
Intel C++ compiler (parallel composer)	1
Intel C++ compilers. Wikipedia article	1
Intel C++ compiler. This library	1
Intel C++ compiler, which is	1
Intel C++ compiler, v. 10.1.020.	1
Intel C++ Compiler v. 11.1	1
Intel C++ Compiler Documentation for	1
Intel before it checks which	1
Intel libraries are used with	1
Intel libraries do not always	1
Intel short vector math library	1
Intel processors is called core	1
Intel processors are not supported	1
Intel CPUs can be increased	1
Intel CPUs have family number	1
Intel CPUs use Intel VTune,	1
Intel CPUs cannot be tolerated.	1
Intel mechanism executes a series	1
Intel compilers. We want to	1
Intel processors. The performance is	1
Intel processors. A non-Intel processor	1
Intel processors. AMD processors and	1
Intel processors. Details about instruction	1
Intel microprocessors are able to	1
Intel CPUs. It uses the	1
Intel CPUs. New versions are	1
Intel compiler. This method is	1
Intel compiler. Use CPUs with	1
Intel math function library with	1
Intel Pentium 4. Even worse,	1
Intel libraries. Supports 32- and	1
Intel header files For example,	1
Intel compiler, then make sure	1
Intel CPU. See page 130	1
Intel Vector class, Agner 8	1
Intel CPUs, not for other	1
Intel CPUs, but not on	1
Intel Math Kernel Library. The	1
Intel processor. The CPU dispatcher	1
Intel Borland Microsoft Constant propagation	1
Intel CodeGear Microsoft Table 2.1.	1
Intel Performance Primitives (IPP). Works	1
Intel Agner Available from Intel	1
Intel Core and later Intel	1
Intel Core 2 0.12 0.18	1
Intel Core 2 0.77 0.89	1
Intel Core 2 0.63 0.75	1
Intel SVML + ia32intrin.h _mm_exp_ps	1
Intel SVML v.10.3 & later	1
Intel SVML v.10.2 & earlier	1
Intel Architecture Software Developers Manual",	2
Intel CPUs: use the core	1
Intel Technology Journal Vol. 11,	1
Intel VTune, for AMD CPUs	1
Intel VTune and AMD CodeAnalyst.	1
Intel CPUs. Another function __intel_cpu_features_init_x()	1
Intel Atom processors, but is	1
pointer is the same as	1
pointer is in fact an	1
pointer is an object that	1
pointer is then de-referenced in	1
pointer is 4 bytes in	1
pointer is simply the address	1
pointer is simply optimized away	1
pointer is used. For example,	1
pointer is needed a few	1
pointer is aligned #pragma vector	1
pointer is deleted. Smart pointers	1
pointer is created, deleted, copied	1
pointer a = (*CriticalFunction)(b, c);	1
pointer of a different type.	1
pointer to the object instead	1
pointer to the best possible	1
pointer to the next block.	1
pointer to the appropriate version	2
pointer to the desired function	1
pointer to the desired version	1
pointer to the desired function.	1
pointer to the right version	1
pointer to a pointer to	1
pointer to a table of	1
pointer to a virtual table	1
pointer to a derived class,	1
pointer to a base class	1
pointer to a contained object	1
pointer to an integer, and	1
pointer to one of the	1
pointer to one class to	1
pointer to its child class.	1
pointer to another class. It	1
pointer to it. This is	1
pointer and makes it point	1
pointer in an import table	1
pointer in member functions is	1
pointer in member functions counts	1
pointer in assembly code. Register	1
pointer can be loaded until	1
pointer can be converted to	2
pointer or a member function	1
pointer or a smart pointer.	1
pointer or a non-const reference,	1
pointer or member function because	1
pointer or const reference cannot	1
pointer or reference is valid	1
pointer or reference to the	2
pointer or reference to a	3
pointer or reference to such	1
pointer or reference to it.	1
pointer or reference to anything	1
pointer or reference can be	1
pointer or reference may be	1
pointer or reference parameters). The	1
pointer or reference, the compiler	1
pointer or reference, or the	1
pointer or reference, 64-bit mode	1
pointer or reference, 32-bit mode	1
pointer or reference. Registers are	1
pointer it gets from the	1
pointer if else if else	1
pointer not aliased #pragma optimize("a",	1
pointer may be considered a	1
pointer then you may consider	1
pointer then its value is	1
pointer at initialization. The program	1
pointer has to be loaded	1
pointer has been loaded. This	1
pointer has been calculated. Therefore,	1
pointer has changed then the	1
pointer has changed. 7.8 Member	1
pointer which is transferred as	1
pointer which does the same	1
pointer which initially points to	1
pointer set to NULL. There	1
pointer takes up one register.	1
pointer stored in a thread	1
pointer type casting. Linked lists	1
pointer does not require a	1
pointer does not alias any	1
pointer does not alias anything	1
pointer (see page 38). Is	1
pointer known in 36 C++	1
pointer well before the pointer	1
pointer simply stores the offset	1
pointer typically takes a few	1
pointer actually points to an	1
pointer points to and you	1
pointer points to. Therefore, it	1
pointer p has been incremented,	1
pointer No runtime type identification	1
pointer alignment and aliasing. Operations	1
pointer eax to the address	1
pointer aliasing is to turn	1
pointer aliasing does not occur.	1
pointer aliasing (see page 78).	1
pointer aliasing (/Oa). The easiest	1
pointer aliasing /Oa -fno-alias Non-strict	1
pointer arithmetic calculations go outside	1
pointer follows a simple regular	1
pointer aliasing. The only way	1
pointer aliasing. See page 78	1
pointer aliasing. __declspec(noalias) or __restrict	1
pointer initially points to the	1
pointer aliasing" if you are	1
pointer aliasing" (if valid) can	1
pointer refers to. For example:	1
pointer -fomit- frame- pointer No	1
pointer serves as entry point.	1
pointer conversions. It does the	1
pointer arithmetics and pointer type	1
b is a float or	1
b is a float, but	1
b is an integer because	1
b is an expression that	2
b is floating point. The	1
b is always 0 or	1
b is true 10% of	1
b is true, which is	1
b is guaranteed to be	1
b is 400 here. Any	1
b to 0 and generate	2
b and c are integers,	1
b and c can share	1
b and c __m128i bc	2
b and c first. b+c	1
b in a union: //	1
b in example 8.15a were	1
b for (i = 0;	1
b are the same after	1
b are 32-bit integers, then	1
b are swapped then both	1
b can be omitted, of	1
b = a + 1;	1
b = a + 1.0f;	1
b = a ^ 1;	1
b = 0, c, d;	1
b = temp * temp;	1
b = (unsigned int)a /	1
b = 100, c =	1
b = LoadVector(bb + i);	3
b = (a+1) * (a+1);	1
b = 6.0f; Constant folding	1
b = 1.0E8, c =	1
b = lrint(d); // Rounding	1
b = MultiplyBy<8>(10); a and	1
b = !a; can be	1
b if b is an	2
b with a & b	1
b with a | b	1
b with 1 for the	1
b as a * (2n	1
b than to write _mm_add_epi16(a,b).	1
b have other values than	1
b have been initialized to	1
b when a is true,	1
b will be 2 In	1
b will both get the	1
b from single precision to	1
b has to start at	1
b different so that they	1
b because of a very	1
b because b has to	1
b because their live ranges	1
b should be of the	1
b double precision: // Example	1
b into a 128-bit vector	1
b + c + d;	2
b + 1 is changed	1
b + 1; for (i	1
b + 1; } The	1
b + 1; return c;	1
b + c; The calculation	1
b + c; y =	1
b + c; Here, y	1
b + a; 72 This	1
b + 2.0 / 3.0;	1
b + 0.666666666666666666667; This is	1
b * b + 1;	2
b * c; a =	1
b * c; Is16vec8 a	1
b * 5 / 2	1
b * c); // Store	2
b * c); a.store(aa+i); }	1
b * 2.5 may be	1
b * 3.5; c =	1
b * 1.2; // everything	1
b * 1.2; // Mixing	1
b * 1.5f; is efficient	1
b * 5). As soon	1
b * (1. / 1.2345);	1
b * 1.2f; // Example	1
b member by 8. The	1
b take the same time	1
b & 1 is certain	1
b through a pointer or	1
b / c; a =	1
b / 10; a =	1
b / 16; a =	1
b / c) 139 can	1
b / 1.2345; Change this	1
b : c (a&&b) ||	1
b : c x-xx----- 75	1
b needs to evaluate b	1
b && a needs to	1
b > 0 ? c	2
b % c; a =	1
b % 10; a =	1
b % 16; a =	1
b ? a : b;	1
b ? a : b)	1
b ? 1.5f : 2.6f;	1
b overlap. You should use	1
b ---xx---- a<<b<<c=a<<(b+c) x-xxx--xx a	1
b Bit vector algebra reductions:	1
b memcpy(b, a, sizeof(b)); 47	1
into the code that allows	1
into the code rather than	1
into the data cache. Single	1
into the program itself. You	1
into the vector registers. It	1
into the same executable. SSE2	1
into the list every time	1
into the Microsoft Visual Studio	1
into the algorithm in question.	1
into the algorithm in question:	1
into the right vector elements.	1
into the right positions in	1
into the least significant bit	1
into the executable file. Only	1
into the vector. This is	1
into the beginning of the	1
into the carry and zero	1
into the pipeline and later	1
into the pipeline then the	1
into the individual bits of	1
into the technical details of	1
into the pipeline. If the	1
into the for-loop: i++; }	1
into a and b. But	1
into a vector of e.g.	1
into a vector goes faster	1
into a vector register. The	1
into a vector register, add	1
into a class or structure.	1
into a class with a	1
into a single object file.	2
into a single branch if	1
into a single register the	1
into a single result. An	1
into a single container, preferably	1
into a container class that	1
into a container class. The	1
into a separate function library.	1
into a separate thread if	1
into a separate thread with	1
into a union is not	1
into a 128-bit vector so	1
into a 128-bit vector register,	1
into a 128-bit XMM register.	1
into a leaf function by	2
into a place indicated by	1
into an intermediate code, which	1
into an STL vector turned	1
into an excessive number of	1
into an arbitrary cache line.	1
into an anonymous namespace. 3.	1
into memory when the program	1
into memory even when just	1
into vector c: CPU dispatching	1
into vector c: __m128i c	2
into vector c: Is16vec8 c	1
into vector b: from cc	1
into vector b: __m128i b	2
into vector b: Is16vec8 b	1
into one of the four	2
into one if the template	1
into one by means of	2
into one thread. A variable	1
into each thread. This method	1
into multiple threads that run	1
into multiple functions. I disagree	1
into multiple smaller functions only	1
into multiple blocks in order	1
into multiple threads. The compiler	1
into multiple threads. The use	1
into multiple threads. There are	1
into multiple threads. Each thread	1
into multiple threads. Out-of-order execution	1
into multiple threads, but the	1
into two 64-bit operations so	1
into two 128-bit reads. The	1
into C++ classes and using	1
into array static inline void	4
into many small subtasks, but	1
into threads with different priorities	1
into small pieces of a	1
into classes or structures. Accessing	1
into eight different cache lines	1
into memory. This is useful	1
into memory. If the word	1
into separate threads with low	1
into three parts: one for	1
into smaller squares and handle	1
into lines and sets. Let	1
into registers. A class member	1
into account in the software.	1
into account that each value	1
into account when optimizing multithreaded	1
into account when deciding whether	3
into account when choosing a	1
into ecx and edx, respectively.	1
into vectors. A lot of	1
into machine code and how	1
into force when I die.	1
into projects made with Microsoft	1
into sub-vectors that fit the	1
into sleep mode. See the	1
into groups of four (or	1
into account. You can calculate	1
+ b than to write	1
+ b + c +	1
+ b + c; The	1
+ b + c; y	1
+ b + c; Here,	1
+ b + a; 72	1
+ b * 1.5f; is	1
+ 2 return (2.5f *	1
+ 2 : b *	2
+ 2 thenaandbcannot use the	1
+ c + d; //	1
+ c + d; This	1
+ i; Here, the value	1
+ 1 is changed to	1
+ 1; for (i =	1
+ 1; } The compiler	1
+ 1; } This code	1
+ 1; } } A	1
+ 1; } else {	2
+ 1; } module2.cpp int	1
+ 1; return c; }	1
+ 1; x[1] = b;	1
+ 1; 69 } else	1
+ c; The calculation here	1
+ c; y = d	1
+ c; Here, y will	1
+ i, a); } }	2
+ i, a); } 111	1
+ 2; } A good	1
+ 2; } } The	1
+ 2; } } void	1
+ 2; } void FuncB	1
+ 2; } These two	1
+ a; 72 This may	1
+ b) + (c +	1
+ d; // makes intermediate	1
+ d; This expression is	1
+ d = x- x-	1
+ d = ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x	1
+ 2, b * c);	2
+ f; The compiler may	1
+ 3; } The compiler	1
+ j * (columns *	1
+ 2) : (bb[i] *	1
+ i); // result =	1
+ i); // Load eight	3
+ i); // Add 2	2
+ 1.; } The compiler	1
+ 1.; } else {	1
+ 1.; } Here, the	1
+ 1.; Eliminate jumps Jumps	1
+ 1.; x.b = y.b	1
+ (c + d); Now	1
+ C; } polynomial //	1
+ 1.0f; The compiler may	1
+ esp ; align by	1
+ esp ebx ecx, DWORD	1
+ esp ;alignby4 ; mangled	1
+ b;} }; int Sum2(S3	1
+ 1.0f;} The compiler may	1
+ 1.0f;} The advantages of	1
+ 1.0f;} 66 float a,	1
+ a. You can take	1
+ c*x + d =	2
+ b*x*x + c*x +	2
+ 2.0f; } 115 from	1
+ 2.0 / 3.0; The	1
+ 3.5; Here, the constant	1
+ c) The creation of	1
+ column; Do not swap	1
+ A; double Y =	1
+ 2;} int a; Plus2	1
+ B; for (x =	1
+ a2*b1) / (b1*b2); The	1
+ (vector const & a)	1
+ log(c[i]); // Increment loop	1
+ e + f; The	1
+ d); Now the two	1
+ list[j].c; } Here, we	1
+ FuncCol(i)) * sizeof(float) in	1
+ 0.666666666666666666667; This is actually	1
+ i/2; } } The	1
+ d.y; Fortunately, most compilers	1
+ B*x + C; }	1
+ a.x, y + a.y);}	1
+ b[i]; c[i] = temp	1
+ r.b;} The three functions	1
+ 0x3FF unsigned int sign	1
+ 0x3FFF unsigned int sign	1
+ two, b * c);	1
+ sign(i) ; shift right	1
+ 4.; }; // Make	1
+ a.y);} vector a, b,	1
+ a2/b2; Here we can	1
+ d.x; a.y = b.y	1
+ 2.; x.c = y.c	1
+ 0x7F unsigned int sign	1
+ 100*16, and temp++ actually	1
+ 3.; x.d = y.d	1
+ ia32intrin.h _mm_exp_ps _mm_exp_pd AMD	1
+ c.x + d.x; a.y	1
+ c.y + d.y; Fortunately,	1
+ p->b;} int Sum3(S3 &	1
+ log(c[i]);. This would double	1
n.a. - a & a	1
n.a. - a & -1	1
n.a. - a & ~a	1
n.a. - a & 0=	1
n.a. - a | -1	1
n.a. - a ^a =	1
n.a. - - - -	6
n.a. - - n.a. n.a.	21
n.a. - x - -	3
n.a. - n.a. - n.a.	4
n.a. - n.a. x n.a.	2
n.a. - Table 8.1. Comparison	1
n.a. - (a&b)|(a&c) = a&(b|c)	1
n.a. - a<<b<<c = a<<(b+c)	1
n.a. - a+b+c = a+(b+c)	1
n.a. - andnot(a,a) = 0	1
n.a. x - n.a. n.a.	3
n.a. x x - -	2
n.a. x x x -	1
n.a. x n.a. - -	1
n.a. x n.a. - n.a.	1
n.a. x n.a. x n.a.	1
n.a. n.a. - a &	4
n.a. n.a. - a |	1
n.a. n.a. - a ^a	1
n.a. n.a. - - n.a.	21
n.a. n.a. - Table 8.1.	1
n.a. n.a. - (a&b)|(a&c) =	1
n.a. n.a. - a<<b<<c =	1
n.a. n.a. - a+b+c =	1
n.a. n.a. - andnot(a,a) =	1
n.a. n.a. x - n.a.	3
n.a. n.a. _MSC_VER and not	1
n.a. Floating point XMM (vector)	1
n.a. -(-a) = a -	1
n.a. MS compiler Windows Gnu	1
n.a. Constant folding - n.a.	1
n.a. a-a = 0 -	1
n.a. x*x*x*x*x*x*x*x = ((x2) 2)	1
n.a. a+b = b+a, a*b	1
n.a. _MSC_VER and not __INTEL_COMPILER	1
n.a. a*0 = 0 -	1
n.a. a*1 = a -	1
n.a. a+0 = a -	1
n.a. a*b+a*c = a*(b+c) -	1
n.a. !(a < b) =	1
n.a. __unix__ __linux__ __unix__ __linux__	1
n.a. 1.00 0.25 0.28 0.22	1
n.a. 1.00 0.35 0.29 0.28	1
n.a. 2.23 0.95 0.6 1.19	1
n.a. (-a)*(-b) = a*b -	1
n.a. (a+b)+c = a+(b+c) -	1
n.a. a+a+a+a = a*4 -	1
library is that if you	1
library is very large or	1
library is loaded or at	1
library is loaded cannot be	1
library is needed. All the	1
library is resolved when the	1
library of math functions should	1
library and the vector class	1
library and you cannot expect	1
library and economize the library	1
library for a few functions	1
library for Windows and C++	1
library that is actually needed	1
library that has a good	1
library that takes care of	1
library that works well on	1
library that comes with the	1
library can be called from	1
library can be useful for	1
library can be linked either	1
library can be updated to	1
library can change the behavior	1
library can emulate a 256-bit	1
library or a separate module	1
library or API function which	1
library function will return the	1
library function from www.agner.org/optimize/asmlib.zip. //	1
library function which we assume	1
library function calls. It is	1
library function 250 times with	1
library function __intel_cpu_features_init() sets the	1
library if possible. This also	1
library with the option -mveclibabi=acml.	1
library with the option -mveclibabi=svml.	1
library with a different compiler	1
library with a well-defined functionality	1
library with CPU dispatching. Add	1
library int level = InstructionSet();	2
library than in a static	1
library may be bigger than	1
library have functions for integer	1
library will use one 256-bit	1
library then make sure it	1
library at www.agner.org/optimize/asmlib.zip. The following	1
library at www.agner.org/optimize/asmlib.zip. If you	1
library at initialization. Each code	1
library at www.agner.org/optimize/asmlib.zip contains various	1
library has a CPU dispatcher	1
library has not been updated	1
library has an initialization routine	1
library has no AVX support,	1
library has many features, see	1
library has reduced performance on	3
library has preprocessing directives that	1
library because it needs an	1
library functions than in optimizing	1
library functions have several versions	1
library functions then it may	1
library functions called by the	1
library functions often belong to	1
library functions without CPU dispatching.	1
library functions like sqrt, pow	1
library functions linked from static	1
library functions directly: Library exp	1
library other than the library	1
library which is very time	1
library Intel Agner Available from	1
library into memory. This is	1
library makes it possible to	1
library file and copies them	1
library function. 12.2 AVX-512 instruction	1
library does not need any	1
library versions instead. The Gnu	1
library through the symbolic link.	1
library functions. The compiler makes	1
library functions. The CPU- specific	1
library functions. 9.4 Variables that	1
library functions. Time- consuming library	1
library contains many functions for	1
library contains many useful mathematical	1
library contains optimized mathematical functions.	1
library contains similar functions, but	1
library files are also included.	1
library #include <stdio.h> // define	1
library made for demonstration purposes.	1
library function, and the function	1
library modules and header files.	1
library functions, or if this	1
library (or at least a	1
library files. Use 64-bit mode	1
library www.agner.org/optimize/asmlib.zip. The name of	1
library exp exp 12.8 Aligning	1
library (*.dll or *.so). The	2
library (STL) is a useful	1
library (STL) if the full	1
library requiring the same address.	1
library (DLL) which is called	1
library asmlib, which is available	1
library libircmt.lib. Function names are	1
library (SVML). This is supplied	1
library asmlib.. // or from	1
library (VML, MKL). Works with	1
library libmmt.lib and the header	1
i is not less than	1
i is stored as a	1
i is outside this interval,	1
i is interpreted as an	1
i to float in this	1
i to unsigned int before	1
i to four bits, and	1
i to p is therefore	1
i and use the induction	1
i and shifts one place	1
i in order to divide	1
i can never be negative	1
i = 0; // Initialize	1
i = 0; i <	13
i = 0 that r	1
i = s; An integer	1
i = 18, then the	1
i by a second induction	1
i by 2. The compiler	1
i by 2. The instruction	1
i with 100 in the	1
i an unsigned int or	1
i will appear as a	1
i which can be calculated	1
i which will delay the	1
i but i*12, because the	1
i into the least significant	1
i + sign(i) ; shift	1
i * 9 + 3;	1
i < 0 and i	1
i < 100; i +=	2
i < 100; i++) {	7
i < 100; i++) sum	1
i < 100; i++) matrix[FuncRow(i)][FuncCol(i)]	1
i < 2; i++) a[i]	1
i < size; i +=	1
i < size; i++) {	7
i < size; i++) a[i]	1
i < size; i++) sum	1
i < size; i++) b[i]	1
i < n; i++) {	1
i < 256; i +=	5
i < 256; i++) {	1
i < 1000; i++) {	1
i < 100. It compares	1
i < 100. pop ebx	1
i < 20; i +=	1
i < 20; i++) {	1
i < rows; i++) for	1
i < rows; i++) {	1
i < NumberOfTests; i++) {	2
i < arraysize; i++) {	1
i < ArraySize; i++) List[i]++;	1
i < list.Size(); i++) {	1
i must be adjusted if	1
i ; i + sign(i)	1
i += 2) { a[i]	1
i += 2) { sum1	1
i += 2) { FuncA(i);	1
i += 4) { s0	1
i += 8) { //	4
i += 16) { b.load(bb+i);	1
i / 3; } This	1
i > 0; i--) *(p++)	1
i instead of j as	1
i >= size can be	1
i >= 0; i--, x++)	1
i >= size) { cout	1
i % 3; } This	1
i <= n; i++) f	1
i <= max) { ...	1
i modulo 16. This method	1
float a = -1.0E8, b	1
float to int. Reinterpret cast	1
float and double is bad	1
float and double (see page	1
float and double vectors AVX2	1
float and double Floating point	1
float and double..................................................................................... 140 14.8	1
float in this example can	1
float or int 4 AVX	1
float or int 8 AVX2	1
float or double to int	1
float or double to integer	2
float or double because all	1
float or double takes 4	1
float or double plus 6	1
float * DynamicArray = (float	1
float 4 4 double 8	1
float 4 AVX2 _mm256_i32gather_ps unlimited	1
float 8 AVX2 _mm_i64gather_pd unlimited	1
float register temp; for (i	1
float rather than double if	1
float 32 4 128 SSE	1
float 32 8 256 AVX	1
float 32 16 512 AVX512	1
float type holds a precision	1
float a, b; a =	3
float a, b, c, d;	1
float a, b, c, d,	3
float 128 double 128 float	1
float uses 32 bits while	1
float 256 double 256 F32vec4	1
float conversion Conversion of a	1
float expressions Automatic vectorization Devirtualization	1
float instead of double, then	1
float x; for (i =	2
float x; *(int*)&x |= 0x80000000;	1
float vectors SSE2 128 bit	1
float a; int b; a	1
float a; int b; static	1
float a; double b; a	1
float a; bool b; a	1
float conversions can sometimes be	1
float b) {x = a;	1
float sum = 0; for	1
float sum = 1.f; float	1
float variable. Example: // Example	1
float x, y; // x,y	1
float x, y, z; a	1
float square (float a) {	1
float f; int i; }	7
float f; unsigned int i;	1
float f; f=i; f =	1
float additions in the same	1
float xn = x; float	1
float a[100]; int i; float	1
float a[100]; int i; for(i=0;	1
float a[100]; float sum =	1
float a[100]; float s0 =	1
float SomeFunction (int x) {	1
float Register variables, integer Register	1
float a[size], b[size]; // set	2
float a[size], b[size], c[size]; float	1
float parabola (float x) {	3
float x2 = x *	1
float matrix[rows][columns]; int i; float	1
float matrix[rows][columns]; int i, j;	2
float list[100]; memset(list, 0, sizeof(list));	1
float 140 a = b	1
float x4 = x2 *	1
float Exp(float x) { float	1
float Exp(float x) { __declspec(align(16))	1
float nfac = 1.f; for	1
float list[size]; ... if (i	1
float list[size], sum = 0;	1
float list[size], sum1 = 0,	1
float Live range analysis Join	1
float s0 = 0, s1	1
float b[1000]; }; if (y)	1
float b[1000]; F2(b); } }	1
float OneOrTwo5[2] = {1.0f, 2.5f};	1
float coef[16] = { //	1
float add_elements(__m128 const & x)	1
float vectors) /arch:SSE -msse /arch:SSE	1
float lookup[2] = {2.6f, 1.5f};	1
float list[16]; int i; ...	1
float i2; for(i=0,i2=0; i<100; i++,i2+=2.0f)a[i]=i2;	1
float list[] = {1.1, 0.3,	1
float list[ARRAYSIZE]; if (i <	1
multiple of the vector size.	1
multiple of the size of	1
multiple of the critical stride	4
multiple of the matrix line	1
multiple of the level-1 cache	1
multiple of 0x800 apart. I	1
multiple // versions: class CChild1	1
multiple function calls. The calculation	1
multiple code versions for different	1
multiple memory blocks makes the	1
multiple memory blocks, either in	1
multiple data elements and the	1
multiple data structures in the	1
multiple CPU cores is to	2
multiple CPU cores or logical	1
multiple CPU cores. You may	1
multiple CPU cores: Define multiple	1
multiple variables as long as	1
multiple operating systems. 10 Gnu	1
multiple pointers to the same	1
multiple programming languages, profiling and	1
multiple dynamic libraries. The dynamic	1
multiple bits in a single	1
multiple bits with the &	1
multiple bits with the ^	1
multiple times in the final	1
multiple CPUs or a CPU	1
multiple CPUs or CPU cores,	1
multiple CPUs or multi-core CPUs,	1
multiple calculations in parallel if	1
multiple calculations in parallel. Modern	1
multiple calculations simultaneously or out	1
multiple versions of the most	1
multiple versions of the user-written	1
multiple versions of a function	1
multiple versions for different instruction	2
multiple versions for different CPUs.	1
multiple versions with and without	1
multiple versions should be used	1
multiple versions even of functions	1
multiple processor cores. Each thread	1
multiple threads and put an	1
multiple threads in the same	1
multiple threads that run in	1
multiple threads are sharing the	1
multiple threads can add, remove	1
multiple threads on a system	1
multiple threads should rely on	1
multiple threads must be declared	1
multiple threads writing to the	1
multiple threads Parallelization by OpenMP	1
multiple functions. I disagree with	1
multiple values at once The	1
multiple values at once................................... 135	1
multiple smaller functions only makes	1
multiple things at the same	1
multiple platforms or multiple configurations	1
multiple conditions in a single	1
multiple conditions using & enum	1
multiple conditions enum Weekdays {	1
multiple overloaded operators will cause	1
multiple purposes. All dynamic memory	1
multiple purposes. Floating point operations	1
multiple cores are advantageous for	1
multiple statements within each clause	1
multiple blocks in order to	1
multiple parent classes in the	1
multiple instances that take up	1
multiple threads. The compiler supports	1
multiple threads. The use of	1
multiple threads. There are two	1
multiple threads. Each thread can	1
multiple threads. Out-of-order execution (chapter	1
multiple cores. 3.15 Dependency chains	1
multiple inheritance by making objects	1
multiple inheritance class B1; class	1
multiple inheritance where a much	1
multiple processes or threads simultaneously.	1
multiple processes because it often	1
multiple threads, but the compiler	1
multiple threads, but it can	1
multiple threads, while data that	1
multiple .cpp files into a	2
multiple .cpp modules into one	1
multiple cores, and a processing	1
multiple versions. This method is	1
multiple layers and it needs	1
multiple counters, as in example	1
multiple accumulators if there is	1
multiple applications, but not always	1
multiple processes. The data section	1
multiple configurations with the same	1
multiple versions, each carefully optimized	1
multiple streams with different strides.	1
multiple elements? If the container	1
multiple logically distinct tasks. A	1
multiple inheritance, virtual functions, and	1
two and making an explicit	1
two = _mm_set1_epi16(2); // Roll	2
two or more integer units,	1
two or more versions of	2
two or more threads writing	1
two or more iterations back.	1
two or more jobs simultaneously	1
two or more cores, and	1
two or more constants. For	1
two or three levels of	1
two then there is an	1
two data members that are	1
two different versions of a	1
two different types of floating	2
two different registers. You need	1
two different kinds of vector	1
two different implementations of the	1
two different implementations of C++,	1
two functions are doing the	1
two functions are unrelated to	1
two other situations: The stack	1
two integer parameters are transferred	1
two floating point multiplication units.	1
two floating point addition units,	1
two floating point comparisons, which	1
two double precision or four	1
two 64-bit operations so that	1
two array elements: #define swapd(x,y)	1
two clock cycles after the	1
two clock cycles. Obviously, the	1
two clock counts. The value	1
two 32-bit integers to alias	1
two 32-bit integers, which is	1
two operating systems are using	1
two libraries It is not	1
two pointers of different types	1
two pointers requires a division,	1
two pointers requires only an	1
two simple expressions. Operations that	1
two instructions add ebx, eax	1
two times the first way	1
two times and the other	1
two versions of the CPU	1
two versions of a program	1
two versions and turn off	1
two threads in the same	1
two threads in each core.	1
two threads are often waiting	1
two threads with widely different	1
two threads from attempting to	1
two threads where one thread	1
two integers of 64 bits	1
two integers are equally near	1
two functions. The difference is	1
two values is closest to	1
two branches to feed into	1
two induction variables Y and	1
two induction variables: // Example	1
two types of floating point	1
two expressions for every element	1
two modules contiguous in program	1
two things to test when	1
two main principles here: functional	1
two positive floating point numbers	1
two gives the chosen expression.	1
two constants are identical so	1
two constants can be replaced	1
two 128-bit vectors. The following	1
two 128-bit reads. The same	1
two kinds of code gives	1
two loops would make the	1
two loops (except in Fortran	1
two iterations in one. The	1
two additions by the use	1
two additions with double's. It	1
two comparisons by one makes	1
two comparisons i < 0	1
two AND operations: __m128i a	1
two ways. The first way	1
two ways. Switch statements are	1
two loop-carried dependency chains, namely	1
two jobs simultaneously. Each thread	1
two commonly used methods for	1
two versions. A 32- bit	1
two double. The intrinsic vector	1
two books contain many tips	1
two arrays, a and b,	1
two elements: #define swapd(x,y) {temp=x;	1
two parentheses can be calculated	1
two (three on CodeGear compiler)	1
two suggested improvements). // Example	1
two decimals, for example, you	1
two formulas in this example	1
two steps. All source files	1
two entries. This may improve	1
two branches: one for the	1
two names, one global and	1
two 128- bit vector registers	1
two summation variables sum1 and	1
two gives: // Example 7.30b	1
object is not necessarily done	1
object is not modified. Unlike	1
object is no longer used.	1
object is so small that	1
object is accessed in more	1
object is accessed after it	1
object is large then it	1
object is allocated separately. The	1
object is copied to the	1
object is copied by assignment,	1
object is called, it is	1
object is treated as bigger	1
object is deleted properly and	1
object is overwritten, possibly in	1
object is known. This information	1
object is accessed, it is	1
object is moved, which may	1
object of the class is	1
object of the class. Data	1
object of the derived class	1
object of the derived class.	1
object of a class is	1
object of a simple class	1
object of a derived class	2
object of a class, structure	1
object of class C1, so	1
object of known type, but	1
object to the vector. The	1
object to a function that	1
object to another. The object	1
object in the GOT, and	1
object in case memory re-allocation	1
object in its own allocated	1
object for the intermediate result	1
object for (b + c)	1
object that is allocated dynamically	1
object that behaves like a	1
object that looses ownership of	1
object are called every time	1
object can be made available	1
object can be copied simply	1
object can be speeded up	1
object or library files. Use	1
object or array coincides with	1
object it points to is	1
object by *p or p->member	1
object with new and return	1
object on its final destination,	1
object as if it had	1
object x when it returns.	1
object then you don't need	1
object It is possible to	1
object has a table of	1
object has no virtual member	1
object has no copy constructor	1
object because the container may	1
object which is typically loaded	1
object should preferably be a	1
object static then it becomes	1
object where most of the	1
object takes no more time	1
object cannot be stored in	1
object rather than making a	1
object without the -fpic option.	1
object without -fpic in 64	1
object file format. The intermediate	1
object file level, and the	1
object file disassembler. Note that	1
object file level. My recommendation	1
object file formats. Comments All	1
object does not use runtime	1
object must be dynamically created	1
object compiled without -fpic is	1
object doesn't need initialization. A	1
object through a pointer or	1
object through a smart pointer.	1
object through this address. Step	1
object files and executables. Make	1
object files from different compilers	1
object files need to be	1
object instead of copying it	1
object after it has been	1
object made with option -fpie	1
object p points to (see	1
object defined inside the function.	1
object oriented programming are dominating.	1
object oriented programming as a	1
object oriented programming without paying	1
object oriented programming are: Non-static	1
object oriented programming style if	1
object oriented programming style has	1
object oriented programs can be	1
object file. This enables the	2
object file. Use another function	1
object pointed to is a	1
object pointed to can be	1
object pointed to. For example:	1
object separately if there are	1
object (except for char pointers).	1
object belongs to class C1	1
object owns. A destructor is	1
number is not necessarily newer.	1
number is zero by testing	1
number of function calls in	1
number of different targets is	1
number of CPU cores. 60	1
number of cache misses and	1
number of integer register variables	1
number of floating point register	1
number of possible inputs is	1
number of possible inputs. Let's	1
number of possible remedies against	1
number of clock pulses since	1
number of objects is not	1
number of objects is often	1
number of objects is known	1
number of objects is high	1
number of objects can be	1
number of variables can be	1
number of elements is small	1
number of elements is known	1
number of elements to store	1
number of elements in a	3
number of elements in an	1
number of elements in each	1
number of elements in table	1
number of elements in list	1
number of elements per vector.	2
number of elements per row	1
number of registers is very	1
number of registers is doubled.	1
number of registers has been	1
number of bits in an	1
number of available registers is	1
number of times each function	1
number of times CriticalFunction is	1
number of arrays that you	1
number of calls to log,	1
number of threads with the	1
number of branches and switch	1
number of separate layers of	1
number of points is not	1
number of unused bytes can	1
number of columns a power	1
number of columns in a	3
number of lines is 8*1024/64	1
number of constants we can	1
number of rows and columns	2
number of logical processors available	1
number of logical processors. There	1
number of cores in order	1
number of cores or logical	1
number of cores will grow	1
number of purposes such as	1
number of iterations is not	1
number of devices and machines	1
number of vectors. 12.10 Conclusion	1
number of machine instructions executed,	1
number of bits. The method	1
number of bits. This is	1
number of branches. Manual 3:	1
number of context switches is	1
number of context switches by	1
number of physical processors and	1
number of allocations is limited.	1
number of accumulators for floating	1
number of dangers to be	1
number of iterations. The advantage	1
number of sources. For example,	1
number of DLLs, configuration files,	1
number of rows/columns in matrix	1
number of jumps, calls and	1
number to the nearest integer.	1
number to be calculated with	1
number to an integer takes	1
number to reflect this or	1
number and sets all other	1
number and types of elements	1
number in the interval [1.0,	1
number by 2n by adding	1
number when i is interpreted	1
number when converted to unsigned.	1
number then we would have	1
number one in a series	1
number we get 0 rather	1
number 16 in column 28,	1
number simply by inverting the	1
number 1. Number 18 will	1
number 2, etc. This means	1
number (e.g. with _finite()) and	1
number information. It is often	1
number 28. The calculation becomes	1
number 0x1C. There are only	1
number i. The size of	1
number (the instruction set has	1
number 6! The speed on	1
number generators. In general, it	1
static is removed from the	1
static to the function definition.	1
static to the function declaration.	1
static and dynamic versions. It	1
static and dynamic linking. The	1
static and global variables by	1
static or by using a	1
static or global arrays require	1
static or global variables. (See	1
static or inline. This will	1
static if they don't need	1
static then it becomes invalid	1
static memory is also used	1
static memory to the stack	2
static memory to stack memory	1
static memory to stack memory.	1
static memory and will have	1
static memory and insert a	1
static memory can cause caching	1
static data is that it	1
static data are likely to	1
static data area is usually	1
static has a different meaning.	1
static double p(double x) {	4
static float list[] = {1.1,	1
static object defined inside the	1
static static static static Assume	1
static static static Assume member	1
static static Assume member function	1
static where appropriate. Compiler-specific keywords	1
static version if speed is	1
static variables if possible, and	1
static member function is faster	1
static member function is 83	1
static member function cannot access	1
static const int ABC =	1
static const int FactorialTable[13] =	1
static const double log2 =	1
static const float OneOrTwo5[2] =	1
static const float coef[16] =	1
static const float lookup[2] =	1
static libraries (.lib or .a),	1
static part of the memory.	1
static arrays in the final	1
static arrays automatically but you	1
static inline int lrint (double	2
static inline int lrintf (float	1
static inline double IntegerPower (double	1
static inline float add_elements(__m128 const	1
static inline void StoreVector(void *	3
static inline void StoreNTD(double *	1
static inline void StoreVectorA(void *	1
static inline __m128i LoadVector(void const	3
static inline __m128i LoadVectorA(void const	1
static inline T max(T const	1
static memory. If you don't	1
static memory. Example: // Example	1
static memory. Most compilers will	1
static keyword to all local	1
static keyword has a different	1
static keyword has several meanings	1
static keyword also makes various	1
static char const * const	1
static data. 148 It is	1
static linking is that the	1
static linking is used. The	1
static linking is used. Dynamic	1
static linking is preferable for	1
static linking and by not	1
static linking for any library	1
static linking rather than dynamic	1
static linking (e.g. option /MT).	1
static storage Variables that are	1
static link library because it	1
static link libraries (*.lib, *.a)	2
static link libraries. These factors	1
static here is that the	1
static variables. See chapter 10	1
static Assume member function called	1
static library. A runtime DLL	1
static libraries. A shared object	1
static buffer or send data	1
static declaration makes it easier	1
static variables, floating point constants,	1
static library, except when several	1
static modifier will be stored	1
static linking. A dynamic library	1
static data, including local data	1
static if), but no compile-	1
static linking, as explained in	1
static keyword: // Example 14.1c	1
static keyword, for floating 26	1
64-bit code for the Microsoft,	1
64-bit vector operations and before	1
64-bit instruction set has support	1
64-bit integer rather than two	1
64-bit integer calculations. It is	1
64-bit compilers are inferior to	1
64-bit double is that it	1
64-bit double 32 bits at	1
64-bit version is better than	1
64-bit version for best performance.	1
64-bit operating systems and programs	1
64-bit operating systems are common,	1
64-bit operating systems. Some compilers	1
64-bit code. However, we still	1
64-bit systems and in 32-bit	1
64-bit systems can improve the	1
64-bit systems if the program	1
64-bit systems by using a	1
64-bit systems will dominate in	1
64-bit systems we can use	1
64-bit operations so that there	1
64-bit CPUs and operating systems.	1
64-bit Windows and 32-bit and	1
64-bit Windows and Linux. Asmlib	1
64-bit Windows if functions have	1
64-bit Windows may be mitigated	1
64-bit Windows allows a maximum	1
64-bit Windows allows only four	1
64-bit Windows (See page 49	1
64-bit execution units. Each 128-bit	1
64-bit integers in 32-bit systems,	1
64-bit integers if the application	1
64-bit integers with hardly any	1
64-bit Linux is more efficient	1
64-bit Linux and Windows platforms.	1
64-bit Linux and BSD. The	1
64-bit Linux as well as	1
64-bit Linux than in 64-bit	3
64-bit mode or when the	3
64-bit mode or enable the	1
64-bit mode than in 32-bit	1
64-bit mode because the function	1
64-bit mode because the 64-bit	1
64-bit mode because the x86-64	1
64-bit mode where the parameters	1
64-bit mode 8 8 float	1
64-bit mode Parameter transfer is	1
64-bit addresses for everything, which	1
64-bit shared object made with	1
64-bit shared objects in Mac	1
64-bit programs to run a	1
64-bit Mac OS X The	1
64-bit systems. The appropriate version	1
64-bit systems. The latter is	1
64-bit systems. A software developer	1
64-bit systems. It is intended	1
64-bit systems. If you are	1
64-bit systems. Some compilers have	1
64-bit systems. Floating point variables	1
64-bit systems. Applications that use	1
64-bit systems. 67 The maximum	1
64-bit vectors then you have	1
64-bit Windows, the first four	1
64-bit Windows, Linux and Mac.	1
64-bit Linux, the first six	1
64-bit Linux, BSD and Mac	1
64-bit Linux, BSD, Windows and	1
64-bit mode. A conversion from	1
64-bit mode. Therefore, the __fastcall	1
64-bit mode. Make functions local	1
64-bit mode. 16-bit mode is	1
64-bit mode. Much of the	1
64-bit Windows. The disadvantage of	1
64-bit Windows. The integrated development	1
64-bit Windows. In 64-bit Linux,	1
64-bit Windows. Borland / CodeGear	1
64-bit device drivers for Windows.	1
64-bit integers. The allocation and	1
64-bit integers. Many 32-bit systems	1
64-bit systems, you may use	1
64-bit systems, there is only	1
64-bit integer, signed or unsigned	1
64-bit mode, the parameters would	1
64-bit mode, as explained below.	1
64-bit Linux. Has many good	1
64-bit integers, as long as	1
64-bit integers, but they are	1
64-bit MMX to 128-bit XMM	1
64-bit versions. The x86 processors	1
64-bit Windows). The XMM vector	1
64-bit Linux: long int unsigned	1
64-bit Linux: unsigned long int	1
64-bit double, then the code	1
64-bit Unix systems allow up	1
64-bit software, but it is	1
64-bit systems). 28 Dynamic memory	1
64-bit extension to the x86	1
there is a pointer to	1
there is a pointer or	1
there is a way to	1
there is a specific advantage	1
there is a single task	1
there is a copy constructor	1
there is a hot spot	1
there is a level-1 data	1
there is a risk that	1
there is a penalty for	1
there is a try block.	1
there is a 90% chance	1
there is a compelling security	1
there is an extra cost	1
there is an extra iteration	1
there is an extra layer	1
there is an advantage to	1
there is more than one	1
there is more focus on	1
there is only a minimal	1
there is only one call	1
there is only half a	1
there is other code that	1
there is other work that	1
there is no loop if	1
there is no such advantage	1
there is no way to	1
there is no operating system,	1
there is no need to	1
there is no big difference	1
there is no exception handling.	1
there is no advantage to	1
there is no cost in	1
there is no reason to	3
there is no difference in	4
there is no graphics processing	1
there is no clear correspondence	1
there is no risk of	3
there is no try block	1
there is no loop-carried dependency	1
there is no guarantee that	1
there is often a lot	1
there is always one, and	1
there is simply no difference	1
there is something that can	1
there is hardly any performance	1
there is nothing to clean	1
there is virtually no cost	1
there are a few cases	1
there are a few pitfalls	1
there are a couple of	1
there are not enough registers	1
there are more efficient alternatives	1
there are different ways of	1
there are different opinions on	1
there are no cache problems.	1
there are no long dependency	1
there are no big arrays,	1
there are no copy constructors	1
there are no caching problems	1
there are floating point-to-integer conversions	1
there are two or more	1
there are two versions of	1
there are many function calls,	1
there are many functions scattered	1
there are many cases where	1
there are many allocations of	1
there are many branches): if	2
there are objects in the	1
there are some differences due	1
there are cases where it	1
there are specific advantages that	1
there are allocated resources that	1
there are various ways to	1
there are special cases such	1
there are 100 floating point	1
there are 6 unused bytes	1
there are search requests for	1
there are serious limitations to	1
there are disadvantages of using	1
there are inherent performance costs	1
there are smarter ways of	2
there are wrapper classes with	1
there may be a difference	1
there may be only one	1
there may be no certain	1
there may be so many	1
there when the program is	1
there will be cache contentions	1
there between x and y?"	1
there was hardly any speed	1
there is, in order to	1
C++ is an advanced high-level	1
C++ is also a language	1
C++ is supported by some	1
C++ is quite efficient thanks	1
C++ is Microsoft Foundation Classes	1
C++ is chosen for the	1
C++ is fully portable in	1
C++ is definitely the preferred	1
C++ and assembly code for	2
C++ and Fortran code. The	1
C++ and Fortran. These directives	1
C++ for several reasons. C++	1
C++ for doing some calculations	1
C++ or assembly language and	1
C++ or assembly language. It	1
C++ as 'this'. We can	1
C++ compiler is available for	2
C++ compiler for 32- and	2
C++ compiler (parallel composer) This	1
C++ program that produces another	1
C++ program are in fact	1
C++ program (or part of	1
C++ has many advantages when	1
C++ but is not quite	1
C++ should allow compile- time	1
C++ compilers to see whether	1
C++ compilers to choose between.	1
C++ compilers and operating systems.	1
C++ compilers and operating systems".	3
C++ compilers and operating systems").	1
C++ compilers and operating systems"	1
C++ compilers The register keyword	1
C++ compilers The tests were	1
C++ compilers are able to	1
C++ compilers have various optimization	1
C++ compilers have various options	1
C++ compilers allow assembly-like intrinsic	1
C++ compilers www.agner.org/ optimize/#vectorclass Include	1
C++ compilers exist for all	1
C++ takes only slightly more	1
C++ so you need to	1
C++ way of handling cleanup	1
C++ faster than in other	1
C++ take more resources than	1
C++ code. Compilers and IDE's	1
C++ template feature was never	1
C++ template metaprogramming, loops are	1
C++ file and compiled for	1
C++ programming language and a	1
C++ An optimization guide for	1
C++ language is chosen as	1
C++ language is portable in	1
C++ language also includes the	1
C++ language elements in order	1
C++ language While C++ has	1
C++ language relates to security.	1
C++ exception handling system makes	1
C++ classes and using overloaded	1
C++ program. This has influence	1
C++ programs and also a	1
C++ implementation may look like	1
C++ compilers. The advantage of	1
C++ compilers. 2.5 Choice of	1
C++ compilers. Wikipedia article on	1
C++ based on what is	1
C++ compiler. This library contains	1
C++ syntax in example 8.15b.	1
C++ syntax has several different	1
C++ v. 3.1, 2007. PGI	1
C++ v. 4.1.0, 2006 (Red	1
C++ v. 7.1-4, 2008. Digital	1
C++ program, you should choose	1
C++ compiler, which is available	1
C++ compiler, v. 10.1.020. Functions	1
C++ Compiler v. 11.1 for	1
C++ Compiler v. 14.00 for	1
C++ Compiler Documentation for details.	1
C++ Compiler Documentation". Included with	1
C++ casting operator These different	1
C++ Performance for further explanation.	1
C++ programming, how to avoid	1
C++ programs. Writing past the	1
C++ projects can be improved	1
C++ language, all conversions from	1
C++ constructs Most programmers have	1
C++ relates to security. There	1
C++ constructs........................................................................ 26 7.1 Different	1
C++ imple- mentations have no	1
C++ builder. Not optimized for	1
C++ 5.82 (Embarcadero/CodeGear/Borland C++ Builder	1
C++ builder Has an IDE	1
C++ language...................................................... 14 3 Finding	1
C++ Builder 5, 2009). Intel	1
C++ Performance". www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP.	1
also the time used by	1
also the innermost loop that	1
also a cache that can	1
also a possible point of	1
also a language that allows	1
also a common programming error.	1
also a lookup in a	1
also a kind of branch.	1
also be a type. The	1
also be a level-3 cache.	1
also be an efficient solution.	1
also be used for other	1
also be used for accessing	1
also be used for turning	1
also be used with other	1
also be used as a	1
also be advantageous to mix	1
also be tested under worst-case	1
also be predicted quite well	1
also be vectorized if you	1
also be convenient for adding	1
also be eliminated if the	1
also be considered. A realistic	1
also be huge). Far storage,	1
also have a dedicated physics	1
also have a physics processing	1
also have an empty throw()	1
also have fast ways of	1
also time consuming, especially if	1
also use vector operations where	1
also when called from the	1
also has something to clean	1
also has disadvantages: The unrolled	1
also has disadvantages: It is	1
also other advantages that may	1
also other details that make	1
also used in two other	1
also used for variables declared	1
also used when the function	1
also page 119). The AMD	1
also possible to see the	1
also possible to tell the	1
also very expensive. A limited	1
also makes the code less	1
also makes various other optimizations	1
also makes testing and maintenance	1
also stored together if they	1
also stored near each other	1
also stored near each other.	2
also called from another module.	1
also called shared objects (*.dll,	2
also called Single-Instruction-Multiple-Data (SIMD) operations.	1
also 4 unused bytes in	1
also less safe. This safety	1
also useful to put file	1
also useful in situations where	1
also useful for testing multiple	1
also available in the function	1
also available from the IDE	1
also work when Intel libraries	1
also works on Intel processors.	1
also likely to lead to	1
also quite efficient, but the	1
also recommended to declare the	1
also see emulated processors and	1
also allows 256-bit integer vectors.	1
also look at the "worst	1
also 512 bits (ZMM). Vector	1
also relevant to small devices,	1
also supports Linux and Windows	1
also find more examples of	1
also costs in terms of	1
also prevents the compiler from	1
also occur quite often as	1
also includes the low-level C	1
also discussed which method is	1
also situations where pre-increment is	1
also applies to the modulo	1
also applies to BSD systems.	1
also applies to decrement operators	1
also available. Microsoft Comes with	1
also involves the risk of	1
also eliminate i and use	1
also available, such as the	1
also deallocated in all possible	1
also repeats 1000 times then	1
also inconvenient to the end	1
also treated like a parameter,	1
also deallocated. Failure to do	1
also proceed in a standardized	1
also third-party profilers such as	1
also treat non-Intel CPUs in	1
also safer. It may catch	1
also de-allocated. This is the	1
also work, 133 although slightly	1
also included. Combining the Borland	1
also tends to make the	1
such a way that there	1
such a check before the	1
such a complicated code that	1
such a framework in its	1
such a framework sometimes have	1
such a feature for reserving	1
such a response is delayed	1
such a subexpression to make	1
such a case: // Example	1
such a formalism. The splitting	1
such code is so high	1
such as the number of	1
such as the Gnu, Clang	1
such as the "Intel Math	1
such as a make utility.	1
such as a structure or	1
such as function inlining. Reducible	1
such as cache and execution	1
such as most sorting algorithms,	1
such as multiple inheritance where	1
such as C++ for doing	1
such as many encryption algorithms,	1
such as 32-bit integer multiplication	1
such as simple variables, loop	1
such as error handling in	1
such as common subexpression elimination,	1
such as AMD and VIA.	1
such as supported instruction sets	1
such as string or CString.	1
such as dynamically allocated memory,	1
such as copying an array	1
such as e.g. .R. for	1
such as addition, subtraction, comparison,	1
such as heavy mathematical calculations,	1
such as Gnu, Clang, Intel	1
such as int, float, double,	1
such as list, set and	1
such as -(-a) = a,	1
such as Taylor expansions and	1
such as DOS and 16-bit	1
such as logarithms and trigonometric	1
such as C#, Visual Basic	1
such as memcpy, memmove, memset,	1
such as semaphores, mutexes and	1
such as floppy disks and	1
such as price, compatibility, second	1
such as logarithms, exponential functions,	2
such as Java, use dynamic	1
such as sorting and searching,	1
such as sqrt and pow	1
such as eliminating the if-branch	1
such as spell-checking and repagination	1
such as GetPrivateProfileString and WritePrivateProfileString	1
such as sorting, searching, and	1
such as strcpy, strcat, strlen,	1
such as VHDL or Verilog.	1
such as flush and fence	1
such as pow, log, exp,	1
such as email and web	1
such as <. The result	1
such as ReadB needs to	1
such as gates, flip-flops, multiplexers,	1
such as AQtime, Intel VTune	1
such an object to a	1
such an application to a	1
such an assumption is that	1
such systems than it is	1
such processors requires a big	1
such small devices if you	1
such small devices, as discussed	1
such container classes. Unfortunately, many	1
such advantage in interpreted languages	1
such programs installed can take	1
such cases, you can obtain	1
such dependency chains can be	1
such methods only if you	1
such applications are highly system	1
such runtime frameworks are used	1
such expressions may occur as	1
such optimizations with option -Wstrict-overflow=2,	1
such optimizations automatically, but as	1
such feature will become available	1
such contentions is that branches	1
such errors is to replace	1
such errors in cases where	1
such errors in programs where	1
such cases. The most critical	1
such loops by calls to	1
such checks makes the code	1
such devices typically have much	1
such applications. Alternatively, use a	1
such obvious reductions as 0/a	1
such errors. See page 90	1
such applications, but it is	1
such contrived examples exist. Therefore	1
such checks. But it is	1
efficient the calculation of the	1
efficient to have separate containers	1
efficient to use a loop	1
efficient to use a lookup	1
efficient to make a loop	1
efficient to make a single	1
efficient to store many objects	1
efficient to store application-specific information	1
efficient to convert unsigned integers	1
efficient to allocate one big	1
efficient to define your own	1
efficient to implement a queue	1
efficient to determine the worst-case	1
efficient to re-use a container	1
efficient to pool all the	1
efficient and you want to	1
efficient and enables interprocedural optimizations.	1
efficient in 64-bit Linux than	2
efficient in 64-bit mode than	1
efficient in some systems because	1
efficient in some cases and	1
efficient for such applications, but	1
efficient for simple types such	1
efficient if the data are	1
efficient if the loop control	1
efficient if the case labels	1
efficient if it is known	1
efficient if all of the	1
efficient code caching. This problem	1
efficient as a member function.	2
efficient as a virtual member	1
efficient as using a function	1
efficient as any other member	1
efficient as integers. 7.5 Booleans	1
efficient than the Gnu compiler	1
efficient than the runtime polymorphism	1
efficient than a linear array	1
efficient than a polymorphous class?	1
efficient than if because #if	1
efficient than x = *(++p)	1
efficient than x = array[++i]	1
efficient than when a fixed-size	1
efficient than 64-bit Windows if	1
efficient than functions. See page	1
efficient than signed integers. It	1
efficient than frame functions for	1
efficient than accessing a member	1
efficient than mov eax,0. The	1
efficient than comparing it to	1
efficient than necessary. Take the	1
efficient than post-increment. For example,	1
efficient than Sum2 and Sum3	1
efficient than relocation, especially in	1
efficient than investing in a	1
efficient than non-object oriented programs.	1
efficient use of software. For	1
efficient when the row length	1
efficient when b is a	1
efficient when there is no	1
efficient when arrays are accessed	1
efficient memory space to store	1
efficient vector operations require that	1
efficient because the compiler has	1
efficient because the template parameters	1
efficient because it handles eight	1
efficient because they are in	1
efficient because relative references do	1
efficient functions for string searching	1
efficient loop control condition is	1
efficient integer size if you	1
efficient library and economize the	1
efficient way of keeping data	1
efficient way of removing superfluous	1
efficient way if the value	1
efficient (see page 53). No	1
efficient solution in this case	1
efficient solution in some cases.	1
efficient solution for the memory	1
efficient solution that doesn't compromise	1
efficient solution may be a	1
efficient solution because of its	1
efficient container class templates, as	1
efficient container classes. An appendix	1
efficient container classes. Text strings	1
efficient whether the arrays are	1
efficient code, but this makes	1
efficient solution. Is a multidimensional	1
efficient solution. Is searching needed	1
efficient solution. Sort the array	1
efficient thanks to the availability	1
efficient alternatives that can be	1
efficient today where cache size	1
efficient because, in most cases,	1
efficient alternative. The theoretical background	1
efficient table-based methods with little	1
In the same way, the	1
In the case of the	2
In the case of data	1
In the case of Boolean	1
In the cases where dynamic	1
In the simple function, m	1
In the Windows operating system,	1
In the above example, the	2
In the preceding example, this	1
In the future we may	1
In the latter case, you	1
In a C++ program, you	1
In this example, the sign	1
In this example, the conversion	1
In this example, the DelayFiveSeconds	1
In this example, we are	1
In this example, a, b	1
In this example, f(x) or	1
In this case it doesn't	1
In this case you have	1
In this case there is	1
In this case we need	1
In this case, the performance	1
In this manual, I am	1
In this chapter, I have	1
In other cases, it is	1
In other words, the program	1
In other words, it is	1
In other words, you need	1
In other words, you must	1
In other programs, 99% of	1
In example 7.4 we are	1
In example 8.21, you could	1
In example 12.2, the optimized	1
In example 12.1a, the compiler	1
In example 12.3a, for example,	1
In most cases the microprocessor	1
In most cases it is	1
In most cases, the optimal	1
In most cases, the fastest	1
In most cases, you can	1
In most cases, double precision	1
In most cases, there is	1
In most systems, you cannot	1
In 64-bit systems we can	1
In 64-bit mode or when	1
In 64-bit Windows, the first	1
In 64-bit Linux, the first	1
In 64-bit systems, you may	1
In 64-bit systems, there is	1
In C++ template metaprogramming, loops	1
In such cases, you can	1
In many cases it is	1
In many cases, the compiler	1
In many cases, however, there	1
In any event, the clock	1
In some cases the compiler	1
In some cases the SSE2	1
In some cases it is	2
In some cases it can	2
In some cases you may	1
In some cases this multiplication	1
In some cases, the Intel	1
In some cases, the log	1
In some cases, it is	1
In some cases, there is	1
In some cases, there are	1
In some programs, more than	1
In order to take advantage	1
In order to access an	1
In order to facilitate porting	1
In 32-bit Linux and BSD,	1
In these examples we are	1
In cases where the chosen	1
In simple cases, a data	1
In large arrays, it may	1
In Linux and Mac systems,	1
In difficult cases like these,	1
In Windows, you can use	1
In general, the out-of-order execution	1
In general, it is faster	1
In general, you can assume	1
In general, you can expect	1
In general, you have this	1
In general, there is no	1
In C++, it is often	1
In 50 simple cases, the	1
In multithreaded applications it is	1
In fact, the compiler may	1
In fact, the STL has	1
In fact, you may get	1
* x - 8.0f) *	1
* x + 1.0f;} The	1
* x + 1.0f;} 66	1
* x + 2.0f; }	1
* b + 1; for	1
* b + 1; }	1
* 2 > v.i *	1
* const Greek[4] = {	1
* 4 = 32. This	1
* 8 = 80. The	1
* 32 with j <<	1
* c > b) But	1
* c; a = select(b	1
* c; Is16vec8 a =	1
* x; // x^2 float	1
* 2; // Find numerically	1
* 2; } else {	2
* 2; return a +	2
* 5 * 0.5 ns	1
* 5 / 2 (be	1
* p = & obj1;	1
* 100 * 5 *	1
* temp; c = temp	1
* temp; 104 } Microprocessors	1
* CriticalFunction = &CriticalFunction_Dispatch; //	1
* 3; } if (b)	1
* 3; } return a	1
* 3; return a -	1
* 3; return a +	1
* p) { int i;	1
* p) { return _mm_loadu_si128((__m128i	3
* p) { return _mm_load_si128((__m128i	1
* p) { *p =	2
* p) {return p->a +	1
* __restrict aa, int *	1
* __restrict bb) { for	1
* 2) { // abs(u.f)	1
* c); // Store the	2
* c); a.store(aa+i); } }	1
* d, __m128i const &	4
* 9 + 3; }	1
* SelectAddMul_pointer = &SelectAddMul_dispatch; //	1
* reciprocal_divisor; y2 = a2	1
* reciprocal_divisor; 14.7 Don't mix	1
* 2.5 may be changed	1
* (2n / b) >>	1
* CriticalFunctionDispatch(void) { // Returns	1
* CriticalFunctionDispatch(void) __asm__ ("CriticalFunction"); typeof(CriticalFunction)	1
* p; int i; p	1
* p; p = &Object1;	1
* 3.5; c = d	1
* 1.2; // everything is	1
* 1.2; // Mixing float	1
* (columns * sizeof(float)). Now,	1
* Func1(x) + 1.; }	1
* m;} int a, b;	1
* m;} template <int m>	1
* b2); y1 = a1	1
* p1; p1 = &Object1;	1
* powN<true,N/2>::p(x); } }; //	1
* cc[i]); } 109 }	1
* c[i]); } } //	1
* powN<true,N-N1>::p(x); #undef N1 }	1
* sizeof(float)); // (Some compilers	1
* sizeof(float)). Now, the factor	1
* a;} float parabola (float	1
* _mm_load_ps(coef+i); // s +=	1
* 17is calculated as(a <<	1
* 1.5f; is efficient when	1
* 16is calculated asa <<	1
* 5; to int x	1
* b2 * reciprocal_divisor; y2	1
* b1 * reciprocal_divisor; 14.7	1
* (a+1); c = (a+1)	1
* 5). As soon as	1
* sizeof(float)) = 8 *	1
* dest, double const &	1
* sizeof(float) in order to	1
* DynamicArray = (float *)alloca(n	1
* (1. / 1.2345); The	1
* x2; // x^4 //	1
* 0.5 ns = 250	1
* p2; p2 = &Object2;	1
* 1.2f; // Example 14.18c	1
* 2.5; // Use signed	1
There is a performance penalty	1
There is a large cost	1
There is a large overhead	1
There is a problem when	1
There is a lot to	2
There is a disadvantage when	1
There is a higher risk	1
There is a portability issue	1
There is a considerable debate	1
There is an even faster	1
There is an important distinction	1
There is no performance cost	1
There is no performance penalty	1
There is no way the	1
There is no way to	1
There is no need to	5
There is no need for	1
There is no extra cost	1
There is no check for	2
There is no cost in	1
There is no automatic check	1
There is no reason to	2
There is no difference between	1
There is no checking for	1
There is no penalty for	1
There is no easy way	2
There is no heavy marketing	1
There is no 51 performance	1
There is very little overhead	1
There is nothing to gain	1
There are a number of	2
There are a few cases,	1
There are only four cache	1
There are other cache control	1
There are other possible ways	1
There are no instructions for	1
There are no checks for	1
There are two or more	1
There are two different kinds	1
There are two things to	1
There are two main principles	1
There are two commonly used	1
There are also other advantages	1
There are also other details	1
There are also 4 unused	1
There are also situations where	1
There are also third-party profilers	1
There are so many different	1
There are several different C++	1
There are several different ways	1
There are several different profiling	1
There are several ways to	1
There are several factors that	2
There are four kinds of	1
There are eight floating point	1
There are certain restrictions on	2
There are cases, however, where	1
There are intrinsic instructions for	1
There are various function libraries	1
There are various methods for	1
There are various ways to	3
There are various ways around	1
There are various things you	1
There are various discussion forums	1
There are various profilers available	1
There are various alternatives to	1
There are three ways to	2
There are approximately six integer	1
There are situations where a	1
There are lots of things	1
There are hundreds of different	1
There may be a slight	1
There may be two or	1
There may be cases where	2
There may be situations where	1
There may also be a	1
There will be no extra	1
There should of course be	1
There should be only one	1
array is the most efficient	1
array is a multiple of	1
array is not known at	1
array is less efficient when	1
array is implemented simply by	1
array is made very big	1
array is stored. This makes	1
array is defined. This can	1
array a and edx contains	1
array of structure or class	1
array of n floats: float	1
array of 100 floats for	1
array of thousand numbers as	1
array of structures: // Example	1
array to make the array	1
array to all zeroes. Example:	1
array to zero. The []	1
array and for more advanced	1
array for the following reasons:	1
array for multiple purposes. All	1
array can be allocated dynamically	1
array can be used. If	1
array can be initialized to	1
array can cause other variables	1
array or the number of	1
array or object that is	1
array or container is too	1
array or container without dynamic	1
array or setting an array	1
array with a top-of-stack index.	1
array with bounds checking, as	1
array with alloca: // Example	1
array may need to be	1
array will be an efficient	1
array should be stored in	1
array should be organized so	1
array using the above template	1
array size a multiple of	1
array size right from the	1
array pointer eax to the	1
array into a container class	1
array static inline void StoreVector(void	3
array static inline void StoreVectorA(void	1
array static inline __m128i LoadVector(void	3
array static inline __m128i LoadVectorA(void	1
array elements of simple types	1
array elements more complicated and	1
array elements then this might	1
array elements Induction variables for	1
array before calling the function	1
array address is. ecx contains	1
array rather than two. Some	1
array must begin at an	1
array ; jump to top	1
array ; i++ ;checkifi<100 ;	1
array element is accessed, and	1
array element in order to	1
array element if the address	1
array element } An array	1
array element has to wait	1
array element a[i] is ecx+eax*4.	1
array overflow can cause unpredictable	1
array after all elements have	1
array index is out of	2
array index than when n	1
array index then it is	1
array index operator } };	1
array initialized by a list	1
array bounds is probably the	1
array bounds violations, invalid pointers,	1
array bounds violations and invalid	1
array bounds violation, integer overflow,	1
array sizes and array indices	1
array cout << list[i] <<	1
array element. In some cases	1
array element. Matrix size Total	1
array element. Rather than comparing	1
array elements. The instruction add	1
array elements. Example: // Example	1
array index. The data cache	1
array sequentially. Some applications (e.g.	1
array elements: #define swapd(x,y) {temp=x;	1
array indices when you want	1
array grows during program execution	1
array i) { // Safe	1
array 800 bytes smaller. Structure	1
array initializer lists, switch statement	1
array coincides with the beginning	1
where the function was called	1
where the compiler is unable	2
where the data are used	1
where the same operation is	1
where the loop control branch	1
where the size of each	1
where the size doesn't matter	1
where the object of the	1
where the number of possible	1
where the number of registers	1
where the number of columns	1
where the performance of the	1
where the critical stride causes	1
where the type of objects	1
where the parameters are transferred	1
where the dispatch branches are	1
where the storage order is	1
where the main feedback comes	1
where the network is overloaded	1
where the level-1 data cache	1
where the chosen compiler doesn't	1
where the logic structure of	1
where the parallelism is obvious	1
where the parallelism is obvious.	1
where the carry bit must	1
where the compilation is finished.	1
where the reduction would cause	1
where the combined size of	1
where the obstacles to optimization	1
where is the sign, eee	1
where a program has several	1
where a program chooses between	1
where a vector implementation is	1
where a long sequence of	1
where a much more complicated	1
where a hardware definition language	1
where a particular code implementation	1
where a high level framework	1
where a #define directive never	1
where a task is divided	1
where a soft processor activates	1
where it is not possible	1
where it is more relevant	1
where it is also discussed	1
where it is less advantageous	1
where it is accessed quite	1
where it should be true.	1
where it makes sense to	1
where it still uses a	1
where it expects a GOT	1
where it matters: Division by	1
where code caching is critical.	1
where you can get answers	1
where you want to check	1
where you want vectorization then	1
where data members share the	1
where only few of the	1
where one thread is used	1
where cache size is a	1
where each bit indicates a	1
where each calculation depends on	1
where each addition has to	1
where each iteration needs the	1
where each label is equal	1
where most of the functions	1
where static has a different	1
where there is no loop	1
where there are different ways	1
where we are writing to	1
where template metaprogramming is the	1
where they are unavoidable. It	1
where they cannot be ruled	1
where dynamic linking cannot be	1
where instructions are fetched and	1
where execution speed, memory economy	1
where necessary (see page 96).	1
where speed is particularly critical.	1
where speed is important. This	1
where automatic vectorization leads to	1
where n is the number	1
where r is the number	1
where 10 elements were inserted,	1
where operands have mixed precision	1
where N is a positive	1
where RAM memory and disk	1
where current compilers don't vectorize	1
where everything happens at runtime).	1
where almost the entire level-1	1
where security matters. Problems with	1
where necessary. Fast versions of	1
where pre-increment is more efficient	1
where appropriate. Compiler-specific keywords Fast	1
many of the same features	1
many of the advantages of	1
many of the features of	1
many of the drawbacks of	1
many of these purposes. Unfortunately,	1
many function calls may run	1
many function calls. If the	1
many function calls, if there	1
many different cases for different	1
many different CPUs to verify	1
many different purposes. The most	1
many different purposes. However, the	1
many different factors as template	1
many different applications. Therefore, it	1
many different places). Some compilers	1
many functions for common mathematical	1
many functions for audio and	1
many functions for statistics, signal	1
many functions scattered around in	1
many such programs installed can	1
many objects can be copied	1
many objects together in one	1
many variables and objects that	1
many software products fail to	1
many branch mispredictions. Boolean vector	1
many elements are there between	1
many bit manipulation tricks Michael	1
many optimization features and for	1
many useful mathematical functions. A	1
many file input/output operations. It	1
many cases it is possible	1
many cases where the compiler	1
many times the function is	1
many times the other way	1
many times in a loop	1
many times with a suitable	1
many times an interrupt occurs	1
many times one way, then	1
many times each function is	1
many times each part of	1
many times faster than any	1
many calls and branches. The	1
many common programs use inappropriate	1
many common purposes (www.boost.org). The	1
many small dynamically allocated objects	1
many small subtasks, but it	1
many good optimization options. Supports	1
many standard container classes use	1
many standard tasks are available	1
many files to be installed.	1
many programs use more time	1
many cases, the compiler will	1
many cases, however, there is	1
many branches and function calls	1
many branches or function calls.	1
many Boolean expressions. Whether the	1
many applications even on such	1
many examples of poor CPU	1
many advantages when it comes	1
many advanced optimizing features, and	1
many reductions involving division and	1
many computer users and much	1
many cases. For example: //	1
many cases. Integer expressions are	1
many unknown factors in the	1
many programmers and they are	1
many programmers do not know	1
many processors, a loop that	1
many hard working software users.	1
many instances makes the compiled	1
many rules of algebra in	1
many users in many different	1
many users will prefer to	1
many branches. If you are	1
many processes simultaneously. Actually, only	1
many platforms, including 32-bit and	1
many features, but also very	1
many features, see http://www.agner.org/optimize/ -	1
many commercial compilers due to	1
many years to come. Even	1
many keywords and directives which	1
many labels that have values	1
many allocations of large memory	1
many users. Firewalls, virus scanners	1
many branches): if (level >=	2
many respects and highly compatible	1
many tips on advanced C++	1
many renamed instances of the	1
many encryption algorithms, cannot easily	1
many decimals. It is recommended	1
many people who have sent	1
many strings. In most cases,	1
possible to use the same	1
possible to use the bitwise	1
possible to use vector instructions	1
possible to make the compiler	1
possible to make the scope	1
possible to make a piece	1
possible to make a thread-like	1
possible to make software that	1
possible to make shared objects	1
possible to do the check	1
possible to do the dispatching	1
possible to do an integer	1
possible to do integer operations	1
possible to do two jobs	1
possible to do such a	1
possible to do operations on	1
possible to do things with	1
possible to access a multidimensional	1
possible to avoid this problem	1
possible to compile a shared	1
possible to compile for different	1
possible to get a good	1
possible to calculate pow(x,10) with	1
possible to add unused columns	1
possible to store objects of	1
possible to store intermediate data	1
possible to write the same	1
possible to replace the CPU	1
possible to replace a database	1
possible to replace a poorly	1
possible to see the compiler-generated	1
possible to see which part	1
possible to give each thread	1
possible to improve the performance	1
possible to reduce the number	1
possible to start a new	1
possible to tell the compiler	1
possible to insert a fixed	1
possible to insert optimization hints	1
possible to come from example	1
possible to implement a microprocessor	1
possible to implement a universal	1
possible to contain all data	1
possible to vectorize code explicitly	1
possible to select all installation	1
possible to obtain the desired	2
possible to utilize the computational	1
possible to construct obscure examples	1
possible to distribute function libraries	1
possible to organize the code	1
possible to express any algorithm	1
possible and by changing the	1
possible in some cases to	1
possible in Linux). Threads are	1
possible for the compiler to	2
possible for the CPU to	1
possible for usability reasons. The	1
possible or when code caching	1
possible if the value of	1
possible if the expression contains	1
possible if F1 has saved	1
possible on Linux platforms, and	1
possible when parts of the	1
possible memory requirement. Useful when	1
possible at compile time. For	1
possible vector objects // Roll	1
possible because the compiler doesn't	1
possible only if the programmer	1
possible instruction set when running	1
possible point of attack for	1
possible pointer aliasing is to	1
possible into the data cache.	1
possible version of the code	1
possible branch if it has	1
possible user interface is obtained	1
possible access to the most	1
possible case and make a	1
possible cases of program flow.	1
possible exception handling support anyway.	1
possible overflow on the intermediate	1
possible implementation if possible, and	1
possible ways of handling errors	1
possible negative value of i	1
possible performance. We must bear	1
possible version. See the vectorclass	1
possible inputs is limited and	1
possible alternatives to exception handling	1
possible minor increase in develop-	1
possible inputs. Let's take the	1
possible workaround. Supports all x86	1
possible remedies against this problem:	1
clock = __rdtsc(); return clock;	1
clock by using the so-called	1
clock cycles to do a	1
clock cycles to read from	1
clock cycles to fetch the	1
clock cycles in the case	1
clock cycles for 32-bit integers,	1
clock cycles that we may	1
clock cycles if it is	2
clock cycles on most other	1
clock cycles on Pentium 4	1
clock cycles than other CPUs	1
clock cycles more than it	1
clock cycles more than calling	1
clock cycles then it will	1
clock cycles at the actual	1
clock cycles before the time	1
clock cycles rather than seconds	1
clock cycles even if the	1
clock cycles counter is counting	1
clock cycles after the pointer	1
clock cycles after the value	1
clock cycles later and the	1
clock cycles per array element.	1
clock cycles per element for	1
clock cycles per byte of	1
clock cycles per element. The	1
clock cycles per element. 100	1
clock cycles whenever it feeds	1
clock cycles spent on executing	1
clock cycles (depending on the	1
clock count before and after	1
clock cycles. The reason is	1
clock cycles. The core clock	1
clock cycles. The rules for	1
clock cycles. It may in	1
clock cycles. If you cannot	1
clock cycles. In most cases	1
clock cycles. You can improve	1
clock cycles. You cannot assume	1
clock cycles. But if all	1
clock cycles. Floating point comparisons	1
clock cycles. Obviously, the initial	1
clock cycles. Division takes 14	1
clock cycles. Calculations in a	1
clock frequency is 2 GHz	1
clock frequency is limited is	1
clock frequency is increased when	1
clock frequency is doubled. The	1
clock frequency of the CPU	1
clock frequency that the CPU	1
clock frequency than other CPUs,	1
clock frequency may be a	1
clock frequency may vary dynamically	1
clock frequency goes up and	1
clock frequency dynamically depending on	1
clock frequency (in Windows: __rdtsc()).	1
clock counts that you measure	1
clock counts are often fluctuating	1
clock counts should be multiplied	1
clock cycle is the reciprocal	2
clock cycle is 1 0.5ns.	1
clock cycle if the source	1
clock cycle on one computer	1
clock cycle on most microprocessors.	1
clock cycle on another computer.	1
clock cycle counter is very	1
clock cycle counter (see below)	1
clock cycles, then this loop	1
clock cycles, then we can	1
clock cycles, but it can	1
clock cycles, depending on the	5
clock cycle. The operators &,	1
clock cycle. The OR operator	1
clock cycle. The highest performance	1
clock cycle. This means that	1
clock cycle. In 64-bit systems,	1
clock counts. The value of	1
clock frequency. The core clock	1
clock frequency. For example, if	1
clock cycle? In this manual,	1
clock cycle? ...................................................................................... 16 3.2	1
clock frequency, as explained on	1
clock pulses since the CPU	1
clock cycles). Floating point division	1
clock period and by the	1
version is implemented in a	2
version is better than the	1
version is preferred when speed	1
version is currently not up	1
version of the code is	3
version of the program may	1
version of the same dynamic	1
version of the C++ compiler	1
version of the critical function	1
version of the critical code	1
version of the critical function.	1
version of the code. This	1
version of the code. Some	1
version of the code. Inserting	1
version of the function. The	1
version of the function. This	2
version of the function. Compile	1
version of the virtual function	1
version of the virtual function.	1
version of the virtual 53	1
version of the application program.	1
version of the compiler. The	1
version of the library. The	1
version of the library. This	1
version of the library. Add	1
version of the executable. Most	1
version of the subroutine for	1
version of a virtual function	1
version of a piece of	1
version of a polymorphic member	1
version of most library functions	1
version of object files and	1
version of C++ should allow	1
version of Intel's Math Kernel	1
version of Basic is Visual	1
version of Basic was too	1
version of Mathcad (v. 15.0)	1
version to use in case	1
version and a release version	1
version in a procedure linkage	1
version in main will take	1
version for the sake of	1
version for CPUs with only	1
version for best performance. The	1
version for specific CPU models.	1
version for marketing reasons. This	1
version that is compatible with	1
version that takes advantage of	1
version that works best on	1
version that fits the microprocessor	1
version that performs best under	1
version // Get supported instruction	1
version if speed is important.	1
version with all relevant optimization	1
version with full debugging support	1
version on the processors that	1
version on all newer models	1
version int CriticalFunction_386(int parm1, int	2
version int CriticalFunction_SSE2(int parm1, int	2
version int CriticalFunction_AVX(int parm1, int	1
version because the debugging options	1
version return &CriticalFunction_386; } int	1
version return (*SelectAddMul_pointer)(aa, bb, cc);	2
version return (*CriticalFunction)(parm1, parm2); }	1
version without the need to	1
version void FUNCNAME(short int aa[],	1
version control tool. 7 The	1
version causes problem that were	1
version CriticalFunction = &CriticalFunction_386; }	1
version changes then you may	1
version 127 int CriticalFunction_AVX(int parm1,	1
version on, then it will	2
version performs well. The reason	1
version performs poorly. It is	1
version CriticalFunctionType * CriticalFunction =	1
version (May use a table	2
version FuncType * SelectAddMul_pointer =	1
version FuncType SelectAddMul, SelectAddMul_SSE2, SelectAddMul_SSE41,	1
version 2.11 ifunc branch). This	1
version 2.20 or later //	1
version satisfies the user's needs.	1
version 2.20, glibc version 2.11	1
version 2.6.30 and later. The	1
value is less than 2n	1
value is calculated from the	1
value is calculated from a	1
value is zero if all	1
value is poorly predictable, then	1
value is already in the	1
value is multiplied by the	1
value of the function pointer	2
value of the time stamp	2
value of the loop count	1
value of the floating point	1
value of the pointer is	1
value of the pointer or	1
value of the pointer has	1
value of the template parameter.	1
value of the parameter is	1
value of the induction variable	1
value of the second operand.	1
value of the divisor is	2
value of the residual error	1
value of a class data	1
value of a pointer well	1
value of A is not	1
value of b is guaranteed	1
value of i to four	1
value of i will appear	1
value of i which will	1
value of i must be	1
value of register temp in	1
value of temp before it	1
value of sum depends on	1
value of N with the	1
value of ebx that was	1
value of seconds and wait	1
value of n! is calculated	1
value of ebx. Only the	1
value of m and therefore	1
value of b+c will be	1
value of cc[i]+2 is AND'ed	1
value of i&15 is guaranteed	1
value of temp. The compiler	1
value of sum. The trick	1
value to make the data	1
value and write it with	1
value in the last vector.	1
value in the previous iteration.	1
value in one vector, the	1
value in most cases. This	1
value in edx as a	1
value in stdint.h char 8	1
value that is a power	1
value that is two or	1
value that is four places	1
value that is n places	1
value that is added to	1
value that lies r places	1
value it was assigned previously	1
value by setting the sign	1
value as xn = xxn-1,	1
value as n! = n(n-1)!.	1
value than from the loop	1
value than 0 or 1	1
value than 0 or 1.	1
value than 0 or 1,	1
value will propagate through the	1
value from the value that	1
value from the counts. It	1
value from a variable in	1
value from a table of	1
value from memory plus the	1
value at compile time so	1
value has changed five times.	1
value each time the function	1
value before the decimal point	1
value 0 for false and	1
value 10 * 8 =	1
value depends on the value	1
value depends only on the	1
value maximum value in stdint.h	1
value pointed to by r	1
value pointed to by p	1
value xn is calculated from	1
value wrap around. Adding 1	1
value written as 2eee 1.fffff,	1
value 1000. The loop in	1
value -100+100+100 = 100. Now,	1
value infinity, and this value	1
value 0x2C so that the	1
objects is not known at	1
objects is often implemented as	1
objects is known at compile	1
objects is high then the	1
objects of a composite type	1
objects of different types or	1
objects of different sizes are	2
objects of variable size can	1
objects to a function is	1
objects and is not efficient.	1
objects and arrays by the	1
objects and keep track of	1
objects and fixed size arrays	1
objects in the same memory	1
objects in the container. STL	1
objects in a computer game	1
objects in 64 bit Linux	1
objects in 32 bit Linux	1
objects in Mac OS X.	1
objects in computer games and	1
objects in computer games. Such	1
objects in Linux, BSD and	1
objects in BSD work the	1
objects in BSD Shared objects	1
objects in Unix-like systems use	1
objects in Unix-like systems. Mac	1
objects for intermediate results, which	1
objects that are scattered around	1
objects that take a lot	1
objects are not stored contiguously	1
objects are not used. The	1
objects are not overlapping or	1
objects are also deallocated in	1
objects are stored in different	1
objects are accessed in a	1
objects are accessed on a	2
objects are called. The program	1
objects are instances of structures	1
objects are returned by copying	1
objects are identified by consecutive	1
objects are normally compiled with	1
objects are aligned. It is	1
objects can be allocated dynamically	1
objects can be copied or	1
objects can be added at	1
objects can be returned in	1
objects can often be made	1
objects // Roll out loop	1
objects if no other threads	1
objects with each their smart	1
objects on the stack, which	1
objects as function parameters because	1
objects have a natural ordering?	1
objects have been stored in	1
objects have been added? If	2
objects have mixed types or	1
objects will be stored on	1
objects should preferably be a	1
objects should preferably be declared	2
objects stored in an STL	1
objects stored in memory. It	1
objects stored in dynamically allocated	1
objects stored are containers 93	1
objects they point to become	1
objects they contain is provided	1
objects without position-independent code when	1
objects even when their live	1
objects accessed in a FIFO	1
objects accessed in a FILO	1
objects inside the derived class:	1
objects together in one big	1
objects together into a single	1
objects declared in the thread	1
objects declared in a class	1
objects declared inside a function	2
objects come last in a	1
objects share the same memory	1
objects Conversions involving class objects	1
objects simultaneously. In multithreaded applications	1
objects identified by a key?	1
objects Vec8s a, b, c;	1
objects (memory pooling) than to	1
objects (*.dll, *.so). The mechanism	1
objects (*.dll, *.so). There are	1
objects numbered consecutively? If objects	1
objects (rather than pointers to	1
takes the hint about no	1
takes a very long time	1
takes a long time when	1
takes a long time, such	1
takes a few clock cycles	1
takes a considerable amount of	1
takes to make a multiplication	1
takes to make support for	1
takes to do two additions	1
takes to do calculations on	1
takes to call the ReadTSC	1
takes to call a virtual	1
takes to call a non-virtual	1
takes to calculate the function	1
takes to calculate the table	1
takes to calculate the absolute	1
takes to add i to	1
takes to load the framework	1
takes to start and stop	1
takes to execute the program,	1
takes to execute CriticalFunction when	1
takes to transpose a matrix	1
takes to install a program	1
takes to install a software	1
takes to recover from a	1
takes to reload the value	1
takes to reload the level-1	1
takes to develop and market	1
takes to develop and publish	1
takes to refresh the screen.	1
takes time to copy the	1
takes more time to load	1
takes more time than the	1
takes more time than looping	1
takes more time but avoids	1
takes more memory resources than	1
takes memory space. A floating	1
takes memory space, even when	1
takes only a few clock	1
takes only slightly more time.	1
takes only slightly more resources	1
takes only 2-3 clock cycles	1
takes one clock cycle if	1
takes no more time than	1
takes no extra time if	1
takes no extra time as	1
takes no extra time. It	1
takes no extra time. These	1
takes some experience to get	1
takes between 2 and 15	1
takes before the application programmer	1
takes 4 - 8 clock	1
takes 4 - 16 clock	1
takes 8 bytes of storage	1
takes time. Dispatch on first	1
takes up more space in	1
takes up one register. Registers	1
takes extra time. The delay	1
takes extra time, of course,	1
takes much more time than	2
takes much longer time than	3
takes advantage of the AVX	1
takes typically 0 - 2	1
takes zero or one clock	1
takes too long time to	1
takes too much space in	1
takes longer time to call	1
takes longer time in the	1
takes longer time than addition	1
takes longer time. It is	1
takes 10 clock cycles then	1
takes 10 s today, then	1
takes 5 clock cycles, then	2
takes little space in the	1
takes 3 - 6 clock	1
takes care of the CPU	1
takes care of the alignment.	1
takes care of this alignment	1
takes 14 - 45 clock	1
takes six times as long	1
takes 11 clock cycles on	1
takes 50 - 100 clock	1
takes 40 - 80 clock	1
takes 40 clock cycles. If	1
takes 40% more time to	1
takes hours to install automatic	1
variable is the range of	1
variable is only used in	1
variable is stored in a	1
variable is stored in memory	1
variable is accessed from within	1
variable is accessed most efficiently	1
variable is used. An optimizing	1
variable is never stored in	1
variable is never changed. This	1
variable is declared. If the	1
variable to be stored in	1
variable in the code. Example:	1
variable in the shared object,	1
variable in the global offset	1
variable in a shared object	1
variable in a DLL can	1
variable in memory takes only	1
variable in example 11.3 even	1
variable in many cases. For	1
variable in main has the	1
variable in memory, as in	1
variable in eax. The loop	1
variable in parts, for example	1
variable for test purposes. The	1
variable for accessing list[i].a and	1
variable that is shared between	1
variable that r points to.	1
variable that could benefit from	1
variable can be calculated in	1
variable can be changed by	1
variable can be fetched from	1
variable or object is accessed	1
variable or object as if	1
variable or object through a	1
variable or replace it with	1
variable if their live-ranges do	1
variable by a float variable.	1
variable with the static modifier	1
variable as function parameter. But	1
variable as an integer if	1
variable as loop counter when	1
variable from address 0x2710 will	1
variable from RAM memory if	1
variable at the same time.	1
variable because it is a	1
variable because optimizing compilers can	1
variable which is known to	1
variable size can be allocated	1
variable two names, one global	1
variable number of objects is	1
variable number of objects can	1
variable where it expects a	1
variable cannot be stored in	1
variable even smaller by declaring	1
variable method unfavorable, unless the	1
variable always has the value	1
variable through a pointer or	1
variable inside the class. Which	1
variable would be needed because	1
variable unless the loop is	1
variable members of the same	1
variable means that it is	2
variable storage are explained on	1
variable storage Variables and objects	1
variable global if it is	1
variable size. The alternative solution	1
variable outside the loop if	1
variable until the function returns	1
variable names from string functions.	1
variable declaration to tell the	1
variable pointed to is identical	1
variable pointed to can be	1
variable names. Remember to remove	1
variable produces a negative result.	1
variable produces a low positive	1
variable lengths that are not	1
variable Y // Update induction	1
variable Z } The loop	1
variable having the same name,	1
variable whose address is in	1
variable Day. Note the difference	1
variable storage............................................................................. 26 7.2 Integers	1
variable __intel_cpu_feature_indicator where each bit	1
variable __intel_cpu_feature_indicator_x. You can bypass	1
variable 85 ; eax =	1
variable m. The advantage of	1
variable (eax) which contains the	1
any of the 4 lines	1
any of the bits for	1
any of the shared resources	1
any of the examples I	1
any of the storage methods	1
any of these instruction sets.	1
any of these methods then	1
any of these conditions is	1
any function are called global	1
any function or variable having	1
any code branch for test	1
any use of floating point	1
any memory block that the	1
any other function is called	1
any other value than 0	1
any other member functions. This	1
any other address in this	1
any other error reporting here:	1
any other function. A leaf	1
any other module then add	1
any other number. Therefore, it	1
any other form of error	1
any other cleanup that may	1
any other factor. If a	1
any other modules. This makes	1
any other modules. This enables	1
any other module. The static	1
any other resource, such as	1
any other constructors. A class	1
any cache lines for matrix	1
any floating point code. The	1
any floating point instructions. This	1
any size other than short	1
any pointer or reference to	2
any library functions called by	1
any objects if no other	1
any objects declared in the	1
any performance penalty to using	1
any branch misprediction long before	1
any member functions that need	1
any elements in the array.	1
any call to the function	1
any part of the program	1
any type of parameters then	1
any function. Global variables are	1
any extra code and doesn't	1
any extra code for actually	1
any extra code. It is	1
any extra code. Example: //	1
any extra code. Dynamic cast	1
any extra time. This is	1
any processor that you optimized	1
any necessary destructors after jumping	1
any speed advantage in using	1
any specific calling conventions for	1
any specific recommendation about which	1
any specific model. Instead, I	1
any exception so that it	1
any option that limits the	1
any known hardware CPU. These	1
any cost in performance. Integer	1
any public variables. All global	1
any higher instruction set, but	1
any hot spots in the	1
any particularly slow instruction that	1
any algorithm with template metaprogramming,	1
any effect on the total	1
any time, then the solution	1
any algebraic reductions on floating	1
any situation where a program	1
any non-static data members or	2
any non-static access. 7.20 Virtual	1
any brand of CPU. These	1
any brand name and model	1
any compile-time constant n, then	1
any loss of efficiency. The	1
any constructors are called. Therefore,	1
any assumption about an unknown	1
any non-polymorphic member functions. The	1
any expression, but none of	1
any function) should be hidden	1
any answer. Beginners are advised	1
any transition from AVX code	1
any non-vector library. 119 The	1
any event, the clock counts	1
any patch. 131 Note that	1
we are in fact using	1
we are using 8-bit integers	1
we are using unions rather	1
we are running this code	1
we are writing to uncached	1
we are adding -100 to	1
we are reading and writing	1
we are waiting for better	1
we are converting a to	1
we are swapping column 29	1
we are assuming that the	1
we are seeing an increasing	1
we are breaking out of	1
we are relying on the	1
we can use 64-bit integers	1
we can do four additions	1
we can access internal variables	1
we can avoid the inefficient	1
we can calculate that the	1
we can store the values	1
we can handle eight elements	1
we can define in this	1
we can help the compiler	1
we can eliminate one division	1
we can see, it is	1
we can roughly estimate that	1
we can surely rely on	1
we can learn from this	1
we may also see emulated	1
we may need metaprogramming. The	1
we may choose the compilers	1
we may save by avoiding	1
we may write: y =	1
we have a = 0x2710	1
we have to take into	1
we have an estimated calculation	1
we have (set) = (10000	1
we have inserted UnusedFiller in	1
we use hexadecimal numbers because	1
we will not get the	1
we will have to calculate	1
we will calculate xn as	1
we will consider if there	1
we used above the diagonal	1
we should preferably have no	1
we do not have to	1
we do not expect to	1
we do have to worry	1
we need the next element.	1
we need to divide the	1
we need to split up	1
we need metaprogramming. None of	1
we want to read from	1
we want to generate a	1
we want to measure //	1
we want to roll out	1
we want it to do.	1
we must consider that the	1
we compile the shared object	1
we get 0 rather than	1
we get rid of all	1
we would have to add	1
we add a to this	1
we don't have to do	1
we don't have to care	1
we don't have to wait	1
we don't need an error	1
we don't get rid of	1
we end up with the	1
we read from 0x4700. Reading	1
we assume is optimized. We	1
we assume that b is	1
we know that u.f and	1
we change the order of	1
we still want to get	1
we expect to use later	1
we modify example 9.5 so	1
we try to optimize this	1
we notice is that the	1
we notice is that it	1
we roll out the loop	1
we specify the options for	1
we prefer a to be	1
we forgot to tell the	1
we loose the ability to	1
we encounter another problem. The	1
we have: // Example 12.8b.	1
we reach element number 16	1
some of the compiler optimizations	1
some of the most common	1
some of the best optimized	2
some of the difference is	1
some of the heavy graphics	1
some of the considerations that	1
some of these also treat	1
some more vector instructions SSE4.2	1
some other functions that are	1
some other variable in the	1
some compilers will make exactly	1
some compilers unroll too much.	1
some very good compilers and	1
some very old DOS compilers).	1
some long vector math libraries:	1
some operating systems are not	1
some systems because of the	1
some cases the compiler can	1
some cases the SSE2 instruction	1
some cases to use the	1
some cases and it makes	1
some cases be advantageous to	1
some cases be determined by	1
some cases it is possible	2
some cases it can be	2
some cases on Windows platforms.	1
some cases you may have	1
some cases this multiplication will	1
some cases take memory space	1
some cases even the same	1
some cases ignore a request	1
some processors that have a	1
some extra complications. A double	1
some calculations at compile time	1
some small low-power CPUs (Intel	1
some support for intrinsic functions,	1
some information for the exception	1
some cases, the Intel mechanism	1
some cases, the log on	1
some cases, for example to	1
some cases, it is optimal	1
some cases, but not all.	1
some cases, there is an	1
some cases, there is no	1
some cases, there are two	1
some expression is optimized away.	1
some development tools have powerful	1
some systems. If the compiler	1
some types of expressions and	1
some compilers. If exception handling	1
some processors. On many processors,	1
some microprocessors when an operand	1
some microprocessors have. In some	1
some things very smart and	1
some positive value, n. But	1
some syntax checking and is	1
some cases. An even more	1
some cases. Multiple threads? Container	1
some cases. Does not allocate	1
some programmers use a hash	1
some help if you want	1
some typical sources of frustration	1
some heavy work to do	1
some disadvantages that make developers	1
some changes for each version.	1
some measurements to see if	1
some embedded systems. A look	1
some CPU-intensive applications with many	1
some tests with the sizeof	1
some programs, more than 99%	1
some formula into a single	1
some experience to get used	1
some differences due to the	1
some funny things with the	1
some legacy software. It may	1
some tips on improving performance.	1
some caveats. We can change	1
some situations, and which reductions	1
some links. 20 Copyright notice	1
some indication of which optimizations	1
some day be implemented in	1
some examples: strlen function. The	1
some rare cases of floating	1
so the compiler can replace	1
so the floating point rounding	1
so the value of b+c	1
so the misprediction penalty is	1
so is a common source	1
so is also a common	1
so a cache line will	1
so in a suboptimal way.	1
so that the if condition	1
so that the code cache	1
so that the compiler sees	1
so that the memory footprint	1
so that the value before	1
so that the first two	1
so that the result can	1
so that the last index	1
so that the alignment is	1
so that the final result	1
so that the amount of	1
so that the rest of	1
so that the resulting machine	1
so that the remaining bits	1
so that it is stored	1
so that it is necessary	1
so that it can be	2
so that it can have	1
so that it can use	1
so that it can start	1
so that it may detect	1
so that it has i	1
so that it cannot be	1
so that it doesn't have	2
so that it writes only,	1
so that you have to	1
so that you don't have	1
so that only one constant	1
so that one thread can	1
so that each value depends	1
so that each statement that	1
so that there was hardly	1
so that we can do	1
so that we can handle	1
so that we don't have	2
so that they are deallocated	1
so that they cannot use	1
so that a+b is calculated	1
so it can call C1::f	1
so as to make pointers	1
so you can have eight	1
so you will never spend	1
so you need to use	1
so this feature is rarely	1
so will cause the heap	1
so there may be only	1
so many different cases for	1
so many unknown factors in	1
so we can calculate that	1
so we can store the	1
so we don't have to	1
so we don't get rid	1
so long that the user	1
so important and generally used	1
so large that we do	1
so big that overflow can	1
so big that caching becomes	1
so much stronger for level-2	1
so small that a binary	1
so small that it fits	1
so fast that the clock	1
so fast that what is	1
so unless you specify an	1
so complicated that I consider	1
so high that it is	2
so high that it rarely	1
so expensive that it is	1
so (i.e. if the member	1
so on. 7.31 Other cases	1
so kludgy that it may	1
so 1.2 in this example	1
so complicated? Because the C++	1
variables is so large that	1
variables is eight in 32-bit	1
variables is approximately six in	1
variables to be stored in	1
variables to be overwritten, and	1
variables to calculate the addresses	1
variables to zero and then	1
variables and objects that are	1
variables and objects will be	1
variables and objects should preferably	1
variables and objects declared in	1
variables and objects declared inside	1
variables and therefore likely to	1
variables and operators Integer sizes	1
variables and operators Modern microprocessors	1
variables and operators ...................................................................... 32	1
variables and internal functions in	1
variables and operators............................................................................... 29 7.3	1
variables in the XMM registers	1
variables in the YMM registers.	1
variables in a function for	1
variables in a class or	1
variables in a 64-bit shared	1
variables in a well-structured C++	1
variables in memory or cache.	1
variables in order to avoid	1
variables in 32-bit systems unless	1
variables in 32-bit mode unless	1
variables in registers rather than	1
variables The most commonly used	1
variables for the same reason	1
variables for other integer expressions	1
variables for floating point expressions	1
variables for float expressions Automatic	1
variables for array elements Induction	1
variables for calculating a polynomial.	1
variables that are used in	1
variables that are used most	1
variables that are shared between	1
variables that may be modified	2
variables that count how many	1
variables are stored in a	1
variables are stored in registers	1
variables are stored as 8-bit	1
variables are often used for	1
variables are temporary intermediates, loop	1
variables are stored. The storage	1
variables are overdetermined in the	1
variables are overdetermined Boolean variables	1
variables can be stored in	1
variables can be 8, 16	1
variables can also be vectorized	1
variables or hide them for	1
variables if possible, and avoid	1
variables by using the keyword	1
variables as long as their	1
variables as input less efficient	1
variables as input check if	1
variables than if the operands	1
variables may be needed for	1
variables have one instance for	1
variables use a different kind	1
variables will be used most.	1
variables because of the way	1
variables do not wrap around	1
variables into a union is	1
variables const double A =	1
variables called global offset table	1
variables (see below). A variable	1
variables An expression that is	1
variables declared with the static	1
variables Floating point numbers are	1
variables go through the PLT	1
variables global if you can	1
variables defined outside any function)	1
variables might have other values	1
variables happen to be spaced	1
variables (i.e. variables defined outside	1
variables sum1 and sum2 are	1
variables Compilers cannot make floating	1
variables Y and Z. Each	1
variables ......................... 142 14.10 Mathematical	1
return the result in a	1
return a - 1; }	2
return a pointer to it.	1
return a pointer or reference	1
return a + 1; }	4
return a + 1; 69	1
return a * a;} float	1
return a > b ?	1
return to its own caller,	1
return and parameter transfer are	1
return with an error code	1
return an error code if	1
return x * x +	2
return x * m;} int	1
return x * m;} template	1
return from the function. The	1
return from functions that require	1
return from Func 87 used	1
return value depends only on	1
return any pointer or reference	1
return address of the function	1
return 0; // return 0	1
return 0; } The InstructionSet()	1
return 0; } The indirect	1
return operations with other calculations	1
return 0 if out of	1
return type of a function	1
return ; align ; mark	1
return addresses to be mispredicted	1
return addresses (i.e. where the	1
return y = pow(x,n) As	1
return c; } In this	1
return types The return type	1
return types .............................................................................................. 50 7.17	1
return x; } }; //	1
return f; } This calculation	1
return y; } double xpow10(double	1
return value. The copy constructor	1
return 1.0; } }; //	1
return a[i]; // Return a	1
return _mm_loadu_si128((__m128i const*)p); } //	2
return _mm_loadu_si128((__m128i const*)p);} // Function	1
return sum; } Here, each	1
return clock; } // Or	1
return &CriticalFunction_386; } int main()	1
return x^10 // loop for	1
return &CriticalFunction_SSE2; } // Default	1
return (*SelectAddMul_pointer)(aa, bb, cc); }	2
return Func1(x) * Func1(x) +	1
return &CriticalFunction_AVX; } if (level	1
return pow(x,10); } The pow	1
return x10; } // x^2	1
return (2.5f * x -	1
return IntegerPower<10>(x); } 152 If	1
return powN<(N & N-1)==0,N>::p(x); }	1
return x*x + 1; }	1
return n;} This code will	1
return ipow(x,10); // used for	1
return (*CriticalFunction)(parm1, parm2); } int	1
return powN<(N1&(N1-1))==0,N1>::p(x) * powN<true,N-N1>::p(x); #undef	1
return powN<true,N/2>::p(x) * powN<true,N/2>::p(x); }	1
return _mm_load_si128((__m128i const*)p); } //	1
return square(x) + 1.0f;} The	1
return _mm_cvtss_si32(_mm_load_ss(&x));} static inline int	1
return list[x]; } The advantage	1
return a+1;. The compiler can	1
return add_elements(s); // add the	1
return N; } T &	1
return _mm_cvtss_f32(s); } // Approximate	1
return FactorialTable[n]; // Table lookup	1
return prediction). 149 All code	1
return route. This mechanism is	1
return vector(x + a.x, y	1
return statement: // Example 8.9b	1
return _mm_cvtsd_si32(_mm_load_sd(&x));} The code in	1
return *(T*)0; } // No	1
2 is faster than multiplying	1
2 to x 43 speculatively	1
2 to each element in	2
2 and the matrix is	1
2 and 15 clock cycles	1
2 in example 14.28 will	1
2 in example 14.7b, we	1
2 in order to make	1
2 can be done with	1
2 // make dispatcher in	1
2 // Still faster if	2
2 or not. The advise	1
2 if the objects are	1
2 if the elements are	1
2 if the rows are	2
2 if a matrix is	1
2 if possible and by	1
2 by using a shift	1
2 by putting the smallest	1
2 - n.a. a+a+a+a =	1
2 int unsigned int 64	1
2 when multiplying with a	1
2 then the multiplication can	1
2 then the multiplication would	1
2 then N&(N-1) is 0.	1
2 double Intel SVML v.10.2	1
2 In 64-bit mode or	1
2 * 5; to int	1
2 clock cycles in the	1
2 return (2.5f * x	1
2 return powN<(N & N-1)==0,N>::p(x);	1
2 2 int unsigned int	1
2 2 int, signed or	1
2 64 MMX long long	1
2 template <int N> class	1
2 32 8 64 4	1
2 does not always apply	1
2 does not apply to	1
2 ; add what r	1
2 128 SSE2 float 32	1
2 128 SSE2 char 8	1
2 : b * c;	2
2 Integer division by a	1
2 > v.i * 2)	1
2 AVX2 _mm256_i64gather_pd unlimited 8	1
2 AVX2 _mm256_i64gather_epi32 unlimited 8	1
2 #define FUNCNAME SelectAddMul_SSE2 #elif	1
2 unused bytes S1 ArrayOfStructures[100];	1
2 == 0) { FuncA(i);	1
2 (See page 137 about	1
2 (See page 137). The	1
2 bytes. first // 6	1
2 bytes. first byte at	1
2 applies only when elements	1
2 int64_t 128 I64vec2 Vec2q	1
2 (i.e. 2, 4, 8,	1
2 int, signed or unsigned	1
2 Choosing the optimal platform	2
2 63 . The value	1
2 uint64_t 128 Vec2uq 8	1
2 0.12 0.18 0.12 0.11	1
2 23 , doublevalue (	1
2 13.4 Test and maintenance	1
2 GHz then the length	1
2 GHz CPU. Should we	1
2 a+a+a+a=a*4 -(-a)=a --xxxxxx- a-(-b)=a+b	1
2 12.6 Transforming serial code	1
2 52 , longdoublevalue (	1
2 thenaandbcannot use the same	1
2 Gbytes. This large memory	1
2 gigabytes of data. The	1
2 Mbytes. There may also	1
2 0.77 0.89 0.40 0.30	1
2 (be aware of possible	1
2 GB, but not in	1
2 GB. When considering whether	1
2 0.63 0.75 0.18 0.11	1
You can use the same	1
You can use this function	1
You can take advantage of	2
You can avoid the conversions	1
You can avoid this by	1
You can avoid this error	1
You can check the order	1
You can calculate how much	1
You can assume that the	1
You can assume that there	1
You can improve the performance	1
You can improve this by	1
You can change what a	1
You can save a lot	1
You can divide by 2n	1
You can generally assume that	1
You can disable exception handling	2
You can force a member	1
You can bypass the check	1
You can subtract this value	1
You may have to fix	1
You may use the Intel	1
You may use the upper	1
You may use an object	1
You may use double precision	1
You may use single precision	1
You may make member functions	1
You may make separate executables	1
You may need to lock	1
You may even add dummy	1
You may avoid this method	1
You may avoid multiple inheritance	1
You may add the static	1
You may add counter variables	1
You may write your own	1
You may replace this line	1
You may preferably avoid global	1
You may look at the	1
You may choose the method	1
You may choose a newer	1
You may choose to align	1
You may choose one of	1
You may choose either C	1
You may save RAM space,	1
You may insert any other	1
You may remove the memset	1
You may declare the function	1
You may prefer to use	1
You may think that exception	1
You may mirror the entire	1
You may ignore the problem	1
You may skip this section	1
You may deviate from the	1
You have to make sure	1
You have to set the	1
You have to check if	1
You have to include the	1
You have to distinguish between	1
You have to consult the	1
You will not get any	1
You should be aware that	1
You should use this method	1
You should use such methods	1
You should avoid these and	1
You should therefore be aware	1
You should therefore not be	1
You cannot be certain that	1
You cannot use ~ for	1
You cannot avoid this in	1
You cannot replace a &&	1
You cannot assume that an	1
You cannot rely on the	1
You cannot expect a compiler	2
You cannot expect a directive	1
You cannot swap the operands	1
You need to check if	1
You can't have public variables	1
You may, in addition, set	1
table is not significant as	1
table is used for finding	1
table is advantageous in most	1
table is initialized when the	1
table is cached. Usually it	1
table of const double A	1
table of pointers to the	1
table of pointers to its	2
table of constants is very	1
table of jump targets. A	1
table of coefficients is calculated	1
table of 1/n! 1., 1./2.,	1
table to be evicted from	1
table to stack memory at	1
table to see whether the	1
table and possibly also a	1
table in the program than	1
table in the level-1 cache.	1
table in static memory and	1
table The following table lists	1
table for even the smallest	1
table that is stored in	1
table are core clock cycles	1
table can give some indication	1
table can improve search times	1
table // of function pointers	2
table or a pointer. A	1
table if you expect the	1
table by 16 float Exp(float	1
table with two entries. This	1
table may be of some	1
table may go undetected. The	1
table from static memory to	1
table at runtime, if only	1
table has const twice because	1
table should be declared const	1
table takes extra time, of	1
table before the first data	1
table element Instruction set needed	1
table inside a function but	1
table values by hand and	1
table lookup is to use	1
table lookup is often an	1
table lookup for a virtual	1
table lookup can be used	1
table lookup or require a	1
table lookup if the function	1
table lookup at the vector	1
table lookup operations slow down	1
table lookup Using intrinsic functions	1
table lookup Lookup tables can	1
table lookup mechanisms explained above.	1
table instead of calculating the	1
table shows that it takes	1
table shows whether the different	1
table 19 in manual 5:	1
table lists the available vector	1
table 8.1 below. Devirtualization An	1
table 9.3 shows, the method	1
table lookups are needed even	1
table lookup. For example: //	1
table lookup. These instructions are	1
table lookup. Lookup tables are	1
table (PLT) and a table	1
table (PLT) in the following	1
table (PLT) that is initialized	1
table 9.1 show that it	1
table static. This makes sure	1
table lookup: // Example 7.29b	1
table lookup: // Example 14.2b	1
table increases the size of	1
table 8.1. The table shows	1
table (PLT). The memory space	1
table (PLT). And whenever a	1
table 9.2. All these instructions	1
table (GOT). These table lookups	1
table (GOT) in order to	1
table summarizes the different integer	1
table 9.2, such as flush	1
performance is to use the	1
performance is not doubled. A	1
performance is important to the	1
performance is limited by the	1
performance is obtained if the	1
performance is obtained by choosing	1
performance is obtained with the	1
performance is inferior to the	1
performance of the function in	1
performance of the STL is	1
performance of the final product.	1
performance of a program. The	1
performance of this function on	1
performance of different function libraries.	1
performance of two different implementations	1
performance of competing brands of	1
performance and precision. The speed	1
performance and studying the bottlenecks	1
performance in some cases. Multiple	1
performance for the functions that	1
performance for vector intrinsics. Digital	1
performance for many applications even	1
performance for 32-bit software because	1
performance for background services under	1
performance that can possibly be	1
performance can be improved by	1
performance can easily justify a	1
performance if the branch is	1
performance if the time-critical part	1
performance by unit-testing is unfortunately	1
performance by organizing the data	1
performance by 5-10% for some	1
performance on CPUs without the	1
performance on AMD and VIA	1
performance on non-Intel processors can	1
performance on non-Intel CPUs unless	2
performance then there is no	1
performance has high priority. The	1
performance because the integer operations	1
performance because the contents of	1
performance because they are resolved	1
performance should be seen in	1
performance between the systems. There	1
performance between 32-bit and 64-bit	1
performance test that measures the	1
performance test should include not	1
performance even matters, which few	1
performance cost to using templates.	1
performance costs to such a	1
performance counters inside your program	1
performance during the development of	1
performance monitor counter is a	1
performance monitor counter in Intel	1
performance monitor counters in all	1
performance monitor counters are CPU-specific	1
performance monitor counters when they	1
performance monitor counters before running	1
performance monitor counters instead of	1
performance monitor counters Many CPUs	1
performance monitor counters .................................................................... 155	1
performance monitor counters. A performance	1
performance monitor counters. My test	1
performance under the worst- case	1
performance penalty to using inheritance.	1
performance penalty for using overloaded	1
performance penalty for organizing data	1
performance penalty when going from	1
performance problems. The performance monitor	1
performance problems. Avoid nested function	1
performance over other programming languages	1
performance reasons. Use these example	1
performance options. I don't know	1
performance measurement should not include	1
performance tests are done under	1
performance significantly simply by using	1
performance dramatically by unrolling the	1
performance bottlenecks is to put	1
performance monitoring options. CPU vendors	1
performance somewhat. The AVX2 instruction	1
performance costs. The time it	1
very time consuming. Therefore, you	1
very different speeds. If I	1
very efficient because it handles	1
very efficient way of removing	1
very efficient solution in some	1
very long and very time-	1
very long and difficult to	1
very long on a particular	1
very long time unless the	1
very often underestimate this time	1
very user friendly compiler with	1
very useful to study the	1
very useful for many different	1
very useful for investigating performance	1
very useful when testing which	1
very useful way to keep	1
very important to do something	1
very important to optimize the	1
very important for tasks such	1
very large or if different	1
very large data bases, but	1
very large number of bits.	1
very large shared object where	1
very large runtime framework that	1
very large positive number when	1
very large libraries. The memory	1
very big to cover the	1
very big in order to	1
very big data structures. On	1
very big problem if the	1
very much on the compiler.	1
very small or if it	1
very small loops (less than	1
very good at optimizing away	1
very good compilers and optimized	1
very good performance and precision.	1
very good choice for all	1
very few restrictions on alignment	1
very likely to be in	1
very likely that code cache	1
very well spend more CPU	1
very fast if the table	1
very high resolution if time	1
very efficient. The following example	1
very difficult to diagnose. It	1
very old DOS compilers). The	1
very inefficient if the list	1
very inefficient because the body	1
very inefficient way. The Codeplay	1
very inefficient solution. Many containers	1
very little overhead to the	1
very smart and other things	1
very well. This compiler is	1
very similar thanks to heavy	1
very low repeat count may	1
very inefficient. Linear arrays are	1
very time-consuming function in system	1
very time-consuming tasks because this	1
very time-consuming garbage collector at	1
very fast. The result of	1
very fast. This can be	1
very fast. All optimizing compilers	1
very fast. Simple integer operations	1
very expensive cache contentions, as	1
very dramatic effect on the	1
very expensive. A variable can	1
very expensive. A limited "express"	1
very time- consuming. There is	1
very limited. There are approximately	1
very big. In the above	1
very problematic because these time	1
very contrived example, but the	1
very obscure possibility of overflow.	1
very common. Even some of	1
very kludgy. The few clock	1
very old-fashioned. Development in C++	1
very smart. They can detect	1
very often, but such expressions	1
very helpful for later maintenance.	1
very stupid. Some common compilers	1
software is to find the	1
software is implemented as a	1
software to be slower or	1
software to add new features	1
software in a high-level language	1
software in two versions. A	1
software in C++ An optimization	1
software in C++: An optimization	1
software for speed or size.	1
software that is part of	1
software that is slow, difficult	1
software that runs quite fast	1
software that dates back to	1
software be reinstalled and user	1
software are available from Intel.	1
software can cause problems if	1
software with network access to	1
software more clear and modular.	1
software because the two operating	1
software should be tested on	1
software into an excessive number	1
software performance should be seen	1
software optimization is to save	1
software optimization issue. But it	1
software programming language defines an	1
software programming language, e.g. C++,	1
software uses CPU dispatching: 1.	1
software contains a negative list	1
software contains a positive list	1
software was coded. If the	1
software was developed. A CPU	1
software programs automatically download updates	1
software implementation is faster than	2
software implementation if the SSE2	1
software implementation rather than a	1
software development and the low	1
software development work as a	1
software development process and software	1
software development models have a	1
software development process. These requirements	1
software development kit (SDK or	1
software applications use a database	1
software applications need better backup	1
software framework that uses few	1
software writing style are that	1
software optimization. Everything that is	1
software module for correctness must	1
software programmers to some of	1
software faster. It is assumed	1
software developers should be aware	1
software developers who want to	1
software users as well as	1
software specifies the calculation of	1
software development, and that computers	1
software package and make it	1
software package in order to	1
software package on a complex	1
software package several times in	1
software project together and tested	1
software project goes to the	1
software runs most of the	1
software layers and frameworks typically	1
software projects have become bigger	1
software packages and who is	1
software packages faster and smaller.	1
software product is one that	1
software users. In some cases,	1
software develop- ment in order	1
software development. This unit-testing is	1
software companies often fail to	1
software installed, a lot of	1
software products fail to recognize	1
software development", Addison- Wesley 1997.	1
software engineering principles to use.	1
software package, including all runtime	1
software teachers to recommend that	1
software design, it is possible	1
software project, it is important	1
software developer may choose to	1
order is usually the order	1
order is opposite). 9.10 Cache	1
order of the two loops	2
order of the Boolean operands	1
order of the operands and	1
order of the operands because	1
order of functions in memory	1
order of floating point operands	1
order of Boolean operands The	1
order of Boolean operands. You	1
order of inheritance is now	1
order to make the code	1
order to make the address	2
order to make the division	1
order to make the measurements	1
order to make a reliable	1
order to make it possible	1
order to make software packages	1
order to make sure that	1
order to make better use	1
order to make profiling feasible.	1
order to take advantage of	1
order to test all branches	1
order to access an element	1
order to access x as	1
order to avoid that the	1
order to avoid multiple threads	1
order to avoid conversions from	1
order to get a realistic	1
order to get an integral	1
order to get access to	1
order to get reliable results	1
order to calculate the address	1
order to optimize access, as	1
order to improve cache efficiency,	1
order to improve performance. It	1
order to know how to	1
order to find the one	1
order to find the address	1
order to find and resolve	1
order to prevent such errors	1
order to save power. There	1
order to divide the work	1
order to divide i by	2
order to predict which resources	1
order to enable constant propagation	1
order to align its b	1
order to implement this "override"	1
order to help the programmer	1
order to increase the likelihood	1
order to identify individual functions	1
order to force the swapping	1
order to cover the worst	1
order to utilize the multiple	1
order to determine whether it	1
order to emulate the while	1
order to reserve resources for	1
order to facilitate porting between	1
order to minimize the amount	1
order and it can calculate	1
order and there are search	1
order in which the elements	1
order in which the modules	2
order in which data are	1
order in which they are	1
order in which they appear	2
order in order to make	1
order or do more than	1
order but are identified by	1
order execution All modern x86	1
order execution ................................................................................................. 103 12	1
order calculation capabilities. Here is	1
order polynomial: // Example 8.23a.	1
order a[0], b[0], a[1], b[1],	1
long and very time- consuming.	1
long and difficult to maintain.	1
long and irregular response times.	1
long that the user actually	1
long or int64_t MS compiler:	1
long or uint64_t MS compiler:	1
long on a particular subtask	1
long as the error doesn't	1
long as it is done	1
long as you are not	1
long as you avoid an	1
long as you don't need	1
long as this is not	1
long as their uses (live	1
long int unsigned char 8	1
long int 64 0 264-1	1
long int 32 -231 231-1	1
long time to execute then	1
long time to transpose a	1
long time to calculate. If	1
long time in case of	1
long time it takes. The	1
long time when the floating	1
long time unless the SSE2	1
long time compared to the	1
long vector library is that	1
long vector libraries and short	1
long vector math libraries: Intel	1
long vector library, you are	1
long because the speed here	1
long double take no extra	1
long double precision is used.	1
long double precision (80 bits).	1
long double precision. Conversions between	1
long double 8, 10, 12	1
long double format. The formats	1
long double reflects the floating	1
long long or int64_t MS	1
long long or uint64_t MS	1
long long 64 2 128	1
long long 64 4 256	1
long long 64 8 512	1
long long 64 1 64	1
long long ReadTSC() { int	1
long long clock; __cpuid(dummy, 0);	1
long long time1; long long	1
long long timediff[NumberOfTests]; for (i	1
long before the floating point	1
long 64 2 128 SSE2	1
long 64 4 256 AVX2	1
long 64 8 512 AVX512	1
long 64 1 64 MMX	1
long time. It is more	1
long 32 0 232-1 uint32_t	1
long does not make the	1
long list of numbers: //	1
long dependency chains then each	1
long dependency chain may fill	1
long dependency chain. If a	1
long dependency chain. We want	1
long dependency chains. A dependency	1
long dependency chains. In this	1
long dependency chains. Another thing	1
long dependency chains, especially loop-carried	1
long response times to simple	1
long response times to keyboard	1
long response times for simple	1
long response times, even for	1
long time, such as heavy	1
long sequence of operations can	1
long enough to be noticeable	1
long enough to be annoying.	1
long ReadTSC() { int dummy[4];	1
long clock; __cpuid(dummy, 0); DontSkip	1
long time1; long long timediff[NumberOfTests];	1
long delay. See page 43	1
long latencies. 8.5 Compiler optimization	1
long timediff[NumberOfTests]; for (i =	1
long long, double. Misaligned data.	1
between the different execution units	1
between the different cores is	1
between the two clock counts.	1
between the two kinds of	1
between the number of physical	1
between the operating systems disappears	1
between the operating system API	1
between the optimization capabilities for	1
between the calls to CriticalFunction.	1
between the Boolean operators &&,	1
between the systems. There is	1
between the efficiency of 32-bit	1
between the latency and the	1
between a and b because	1
between a function parameter and	1
between a software programming language,	1
between function names and code	1
between x and y?" then	1
between different CPU cores. You	1
between different threads in a	1
between different parts of the	1
between different parts of a	1
between different tasks in a	1
between different threads, but that's	1
between different precisions take no	1
between CPU brands and similarly	1
between CPU cores. A process	1
between CPU brands, and one	1
between floating point numbers and	2
between each call, and the	1
between using signed and unsigned	1
between multiple CPU cores. You	1
between multiple CPU cores: Define	1
between multiple dynamic libraries. The	1
between multiple threads must be	1
between multiple processes because it	1
between multiple threads, but it	1
between multiple threads, while data	1
between multiple processes. The data	1
between two or more constants.	1
between two pointers requires a	1
between two simple expressions. Operations	1
between two expressions for every	1
between two constants can be	1
between 2 and 15 clock	1
between 32-bit and 64-bit systems.	1
between 32-bit Linux and 32-bit	1
between 8 bit and 32	1
between these considerations. It is	1
between simple processors and vector	1
between threads is minimized. For	1
between threads becomes faster and	1
between single and double precision.	1
between several execution units. Typically,	1
between integers and floating point	3
between optimizing for size and	1
between signed and unsigned integers	2
between development time, usability, program	1
between 5 and 20 clock	1
between rows in a big	1
between c2 and bc for	1
between rounding and truncation. The	1
between rounding and truncation. Efficient	1
between threads. The overhead of	1
between 9 and 64, depending	1
between leaf functions and frame	1
between platforms, it is recommended	1
between threads, such as semaphores,	1
between float, double and long	1
between RISC and CISC processors,	1
between PC's and mainframes, and	1
between efficiency, portability and development	1
between coarse-grained parallelism and fine-grained	1
between commas and semicolons in	1
between recoverable and non-recoverable errors;	1
32-bit and 64-bit code for	1
32-bit and 64-bit operating systems	1
32-bit and 64-bit Windows and	1
32-bit and 64-bit Linux and	1
32-bit and 64-bit Linux as	1
32-bit and 64-bit systems. The	1
32-bit and 64-bit systems. Applications	1
32-bit and 64-bit Linux, BSD,	1
32-bit and 64-bit mode. 16-bit	1
32-bit and 64-bit Windows. The	1
32-bit and 64-bit Windows. Borland	1
32-bit and 64-bit. Supports OpenMP	1
32-bit and 64-bit. They have	1
32-bit or 64-bit mode. Much	1
32-bit integer has a particular	1
32-bit integer multiplication prior to	1
32-bit number (the instruction set	1
32-bit software because the two	1
32-bit software development", Addison- Wesley	1
32-bit operating systems and fourteen	1
32-bit operating systems and sixteen	1
32-bit systems and 8 bytes	1
32-bit systems and 64 bits	1
32-bit systems and fourteen in	1
32-bit systems and sixteen in	1
32-bit systems when the SSE2	1
32-bit systems do not have	1
32-bit systems unless the SSE2	1
32-bit systems gives rise to	1
32-bit systems allow you to	1
32-bit Windows and 32-bit Linux	1
32-bit Windows in this respect.	1
32-bit Windows by transferring 'this'	1
32-bit integers to alias upon	1
32-bit integers and 64-bit integers,	1
32-bit integers in 16-bit systems	1
32-bit Linux is that the	1
32-bit Linux and 32-bit Windows	1
32-bit Linux and BSD, the	1
32-bit Linux with Microsoft, Intel	1
32-bit mode so that the	1
32-bit mode 4 4 pointer	1
32-bit mode unless the SSE2	1
32-bit programs if there are	1
32-bit Mac code uses an	1
32-bit Mac Intel CodeGear Microsoft	1
32-bit Mac OS X make	1
32-bit Mac OS X Compilers	1
32-bit Mac OS X, unless	1
32-bit systems. Virtual member functions	1
32-bit Windows, including an IDE.	1
32-bit Windows, Intel/MASM syntax: __asm	1
32-bit Linux, Gnu/AT&T syntax: __asm	1
32-bit mode. The first two	1
32-bit mode. The next chapter	1
32-bit mode. The 32- bit	1
32-bit mode. If there are	1
32-bit mode. Storing the parameters	1
32-bit version. The Gnu compiler	1
32-bit Windows. Gnu Comes with	1
32-bit Windows. Does not support	1
32-bit Windows. Does not, by	1
32-bit Windows. Integrates into the	1
32-bit systems, but in registers	1
32-bit systems, especially if the	1
32-bit mode, and more efficient	1
32-bit mode, for reasons explained	1
32-bit integer. Floating point precision	1
32-bit case. The -fpie option	1
32-bit absolute addresses. This works	1
32-bit integers, and they always	1
32-bit integers, then the expression	1
32-bit integers, which is less	1
32-bit integers, depending on the	1
32-bit number. If a and	1
32-bit -fno-builtin Gnu 32-bit Mac	1
32-bit counterparts. In general, you	1
32-bit (signed) address. The linker	1
branch is executed. The compiler	1
branch is mispredicted only one	1
branch is poorly predictable. For	1
branch is executed 10 times	1
branch is eliminated. Loop unrolling	1
branch is fed into the	1
branch of the latter is	1
branch of code is so	1
branch of code is intended	1
branch to use for each	1
branch and other nearby branches.	1
branch in example 15.1b is	1
branch for a low instruction	1
branch for test purposes. If	1
branch that is always true/false	1
branch that can go more	1
branch that always goes the	1
branch that goes one way	1
branch that goes many times	1
branch that goes randomly one	1
branch that follows a simple	1
branch that chooses between two	2
branch can be chosen based	1
branch can be eliminated if	1
branch can also be eliminated	1
branch // Loop with branch	1
branch if the constants Sunday,	1
branch if it has an	1
branch by a table lookup.	1
branch by a table lookup:	1
branch by a conditional move,	1
branch will be mispredicted 50%	1
branch will go based on	1
branch only when a new	1
branch instruction takes typically 0	1
branch should be predicted. This	1
branch into the pipeline and	1
branch void SelectAddMul(short int aa[],	1
branch must rely on instructions	1
branch inside the loop can	1
branch inside the loop is.	1
branch inside the loop. Example	1
branch inside the template. The	1
branch depends on the calculations	1
branch depends on calculations inside	1
branch (e.g. an if-else structure),	1
branch target buffer is also	1
branch target buffer can occur	1
branch target buffer (BTB). Contentions	1
branch target buffer. Contentions in	1
branch target buffer, branch pattern	1
branch prediction are different for	1
branch prediction into account in	1
branch prediction (see p. 43).	1
branch prediction mechanism. See page	1
branch misprediction is approximately 12	1
branch misprediction long before the	1
branch misprediction penalty. Branches are	1
branch prediction. A loop with	1
branch prediction. A Pentium M	1
branch prediction. If one operand	1
branch prediction. Example: // Example	1
branch prediction. Modern microprocessors are	1
branch mispredictions. The performance measurement	1
branch mispredictions. Boolean vector operations	1
branch mispredictions. When the most	1
branch mispredictions. Test the whole	1
branch pattern history, etc. may	1
branch tree or switch statement	1
branch mispredictions if the critical	1
branch mispredictions by making the	1
branch ahead of time and	1
branch tree. On older processors,	1
branch mispredictions, floating point exceptions,	1
branch mispredictions, etc. These counters	1
branch misprediction, or long dependency	1
branch predictions in the different	1
< b because of a	1
< 0 and i >=	1
< 0 || i >=	1
< 100; i += 2)	1
< 100; i += 4)	1
< 100; i++) { a[i]	6
< 100; i++) { list[i].a	1
< 100; i++) sum +=	1
< 100; i++) matrix[FuncRow(i)][FuncCol(i)] +=	1
< 100; x++) { Table[x]	2
< 2; i++) a[i] =	1
< b) = (a >=	1
< 0) { // test	1
< size; i += 2)	1
< size; i++) { //	1
< size; i++) { a[i]	1
< size; i++) { temp	1
< size; i++) { j	1
< size; i++) { b[i]	1
< size; i++) { aa[i]	1
< size; i++) { ab[i].b	1
< size; i++) a[i] =	1
< size; i++) sum +=	1
< size; i++) b[i] =	1
< n; i++) { 92	1
< 256; i += 8)	4
< 256; i += 16)	1
< 256; i++) { aa[i]	1
< SIZE; r++) { for	3
< SIZE; r++) { //	1
< SIZE; c++) { StoreNTD(&a[c][r],	1
< SIZE; c++) { a[c][r]	1
< SIZE; r1 += TILESIZE)	1
< 4) { // Check	1
< 1000; i++) { ...	1
< 5) { // do	1
< 5) {} which would	1
< r; c++) { //	2
< 100. It compares eax	1
< 100. pop ebx restores	1
< r1; c1 += TILESIZE)	1
< 2.0 This method is	1
< 20; i += 2)	1
< 20; i++) { if	1
< 0. The division is	1
< ARRAYSIZE && list[i] >	1
< r1+TILESIZE; r2++) { for	2
< rows; i++) for (j	1
< rows; i++) { j	1
< NumberOfTests; i++) { //	1
< NumberOfTests; i++) { time1	1
< 10) { ... Conversions	1
< 223 to a floating	1
< arraysize; i++) { //	1
< NUMROWS; row++) for (column	1
< NUMCOLUMNS; column++) matrix[row][column] =	1
< ArraySize; i++) List[i]++; Here,	1
< c1+TILESIZE; c2++) { swapd(a[r2][c2],a[c2][r2]);	1
< &list[100]; temp++) { temp->a	1
< arraysize) { // Catch	1
< 231 then convert it	1
< r2; c2++) { swapd(a[r2][c2],a[c2][r2]);	1
< list.Size(); i++) { //	1
< 13) { // Bounds	1
< columns; j++) 39 matrix[i][j]	1
member the object does not	1
member is more compact if	1
member is unchanged across a	1
member of the same class.	1
member of the same class).	1
member of the class or	1
member of the object's class	1
member of the object's class.	1
member of a class or	1
member of a structure. The	1
member of a bitfield is	1
member of its child class	1
member or after the last	1
member function is a few	1
member function is as fast	1
member function is faster than	1
member function is big and	1
member function is called. If	1
member function is 83 called	1
member function to be inlined	1
member function or friend function	1
member function has only one	1
member function because it doesn't	2
member function because this may	1
member function which returns a	1
member function pointer is simply	1
member function such as ReadB	1
member function cannot access any	1
member function cannot modify data	1
member function called only from	1
member function means that it	1
member by 8. The number	1
member functions is not expensive.	1
member functions is also treated	1
member functions of a parent	1
member functions of parent and	1
member functions of parent class	1
member functions that need to	1
member functions are less efficient	1
member functions if the class	1
member functions have a 'this'	1
member functions then there is	1
member functions because the static	1
member functions static where appropriate.	1
member functions faster by making	1
member functions counts a one	1
member functions Virtual functions are	1
member functions ........................................................................................ 53 7.21	1
member functions (methods) Each time	1
member functions (methods)......................................................................... 53 7.20	1
member pointer simply stores the	1
member pointer refers to. For	1
member variable with the static	1
member pointers and virtual functions	1
member pointers are implemented. Use	1
member pointers if it has	1
member pointers less efficient. Most	1
member pointers /vms Fastcall functions	1
member function. The overhead of	1
member function. See page 53.	1
member function. But there are	1
member function. Do not make	1
member function. 7.12 Branches and	1
member functions. The following example	1
member functions. The second generation	1
member functions. The 'this' pointer	1
member functions. This applies to	1
member functions. A static member	2
member functions. You can force	1
member function, provided that the	1
member pointer. This can be	1
member pointer. 7.9 Smart pointers	1
member relative to the beginning	2
member functions, where static has	1
member functions) has no negative	1
way the register stack is	1
way the user can see	1
way the programming language is	1
way is to make a	1
way is to set up	1
way is to insert the	1
way is predicted well, of	1
way is mispredicted only when	2
way is equal to the	1
way a branch will go	1
way a profiler works then	1
way of example 12.4b and	1
way of making the container	1
way of making sure that	2
way of doing whole program	1
way of handling cleanup jobs	1
way of setting a register	1
way of declaring an integer	1
way of defining integer types	1
way of keeping data together.	1
way of removing superfluous code,	1
way of relieving a syntax	1
way of solving the problem	1
way to use multiple CPU	1
way to make sure that	2
way to make thread-specific data	1
way to set an array	1
way to test this is	1
way to work around this	1
way to avoid the burdensome	1
way to check the code	1
way to check for overflow	1
way to control the addresses	1
way to prevent memory leaks	1
way to prevent such errors	1
way to tell a hyperthreading	1
way to tell these compilers	1
way to handle an unrecoverable	1
way to handle strings is	1
way to keep track of	1
way to fully utilize systems	1
way to increase the throughput	1
way to identify performance bottlenecks	1
way to roll out the	1
way to overcome the obstacle	1
way to limit the range	1
way to solve this problem	1
way and three times the	1
way in the same part	1
way in case of error.	1
way that can be vectorized	1
way that there is no	1
way that takes more time	1
way that avoids overflow: a[i]	1
way or the other with	1
way or another. Therefore, micro-	1
way or bypassing syntax checks.	1
way if the value of	1
way by wrapping the vectors	1
way as in Linux. 32-bit	1
way as an object of	1
way as last time it	1
way than last time. Newer	1
way has become a serious	1
way most of the time	1
way two times and the	1
way member pointers are implemented.	1
way three times. Then again	1
way microprocessors are constructed. All	1
way includes the time it	1
way m is transferred to	1
elements is small then a	1
elements is known at compile	2
elements of a vector simultaneously.	1
elements of a vector, uses	1
elements of b into a	1
elements of type T //	1
elements of simple types because	1
elements to store is known	1
elements to zero. You may	1
elements and the program logic	1
elements in the sequence to	1
elements in the array. This	1
elements in a vector or	1
elements in a specific interval.	1
elements in a vector. If	1
elements in a vector. 6.	1
elements in an array grows	1
elements in vector Type of	1
elements in each vector depends	1
elements in table The following	1
elements in order to help	1
elements in list in example	1
elements in row 28 share	1
elements in aa: StoreVector(aa +	3
elements in aa: a.store(aa+i); }	1
elements in a[] which will	1
elements that come with the	1
elements are there between x	1
elements are stored in memory.	1
elements are accessed in the	1
elements are accessed in a	1
elements are accessed in non-	1
elements are accessed sequentially. The	1
elements are cumbersome to use	1
elements // align by cache	1
elements with a relative difference	1
elements with column 28 above	1
elements have a natural order	1
elements have no specific order	1
elements have been added and	1
elements more complicated and time	1
elements will go into eight	1
elements } } } }	1
elements then this might be	1
elements from row 28 below	1
elements from cc into vector	3
elements from bb into vector	3
elements at the end of	1
elements at the diagonal remain	1
elements at a time and	1
elements at a time in	1
elements inside sqaure: for (r2	1
elements }; vector() {} vector(float	1
elements were inserted, one by	1
elements per vector. The simplest	1
elements per vector. You may	1
elements per row is a	1
elements Induction variables for other	1
elements are. For example, you	1
elements consecutively in memory. No	1
elements Total size of vector,	2
elements matrix[r][c] below the diagonal	1
elements Size of each element,	1
elements c.load(cc+i); // result =	1
elements matrix[c][r] above the diagonal	1
elements b.load(bb+i); // Load eight	1
faster the smaller the integer	1
faster to use the functions	1
faster to use than others.	1
faster to make log2 a	1
faster to first convert the	1
faster to access a floating	1
faster to access a file	1
faster to calculate than the	1
faster to transfer a pointer	1
faster to compose a bitfield	1
faster and that threads can	1
faster and more compact than	1
faster and makes an extra	1
faster and smaller. This manual	1
faster in a programmable logic	1
faster in 64-bit Linux than	1
faster in 32-bit mode. The	1
faster // Still faster if	2
faster if the data are	1
faster if the number of	1
faster if the constant is	1
faster if the dividend is	2
faster if a and b	1
faster if unsigned The same	1
faster if unsigned // Faster	2
faster if unsigned You can	1
faster by making them static	1
faster with signed than with	1
faster than the function add_horizontal)	1
faster than the simple function	1
faster than the speed of	1
faster than the hardware implementation	2
faster than the Boolean operators	1
faster than the intrinsic hardware	1
faster than a floating point	1
faster than a non-static member	2
faster than in other programming	1
faster than x = -abs(x);.	1
faster than when compiled with	1
faster than from floating point	1
faster than other methods of	1
faster than other languages that	1
faster than floating point operations.	1
faster than example 12.4a, depending	1
faster than double precision when	1
faster than any non-vector library.	1
faster than 32-bit programs if	1
faster than making a separate	1
faster than signed when you	1
faster than division by a	2
faster than linked lists in	1
faster than reading or writing	1
faster than calculating the logarithm	1
faster than multiplying by other	1
faster than random access. Reading	1
faster than pow The method	1
faster than 15.1b, and in	1
faster when the factor is	1
faster when columns is a	1
faster at the cost of	1
faster because the template parameter	1
faster because we can access	1
faster because testing a condition	1
faster way to limit the	1
faster vectorized code. Storing something	1
faster either by making the	1
faster nor slower than truncation	1
faster despite the extra function	1
const in order to enable	1
const or typedef instead of	1
const function that is member	1
const int size = 100;	5
const int size = 256;	1
const int size = 16;	1
const int size = 1000;	2
const int size = 1024;	3
const int x; public: c1()	1
const int rows = 20,	2
const int rows = 10,	1
const int declaration may in	1
const int SIZE = 512;	2
const int SIZE = 64;	1
const int TILESIZE = 8;	1
const int ArraySize = 1000;	1
const int ABC = 123;	1
const int NumberOfTests = 10;	1
const int min = 100,	1
const int ARRAYSIZE = 100;	1
const int FactorialTable[13] = {1,	2
const int NUMROWS = 100,	1
const int arraysize = 1000;	1
const double A = 1.1,	2
const double log2 = log(2.0);	1
const double A2 = A	1
const pointer or const reference	1
const float OneOrTwo5[2] = {1.0f,	1
const float coef[16] = {	1
const float lookup[2] = {2.6f,	1
const * const Greek[4] =	1
const * p) { return	4
const variable or replace it	1
const variable means that it	1
const member function cannot modify	1
const & a, T const	1
const & x) { //	1
const & x) { _mm_storeu_si128((__m128i	3
const & x) { __m128	1
const & x) { _mm_store_si128((__m128i	1
const & b) { return	1
const & a) { return	1
const & source) { _mm_stream_pi((__m64*)dest,	1
const x) { // Round	1
const x) { return _mm_cvtss_si32(_mm_load_ss(&x));}	1
const x) { return _mm_cvtsd_si32(_mm_load_sd(&x));}	1
const reference if the function	1
const reference makes sure that	1
const reference cannot change what	1
const reference allows the function	1
const keyword tells that a	1
const keyword wherever appropriate to	1
const twice because both the	1
const reference. A const reference	1
const restriction on x. It	1
const restriction from a pointer.	1
const Greek[4] = { "Alpha",	1
const definitions when used for	1
makes the code more compact	1
makes the code faster because	1
makes the code less clear	1
makes the code difficult to	1
makes the code section position-independent,	1
makes the code execute faster	1
makes the code incompatible with	1
makes the compiler interpret the	1
makes the use of arrays	1
makes the data caching less	1
makes the program less efficient.	1
makes the access to individual	1
makes the assembly output more	1
makes the compiled code big	1
makes the microprocessor jump to	1
makes the dispatcher signal an	1
makes the entire library (or	1
makes a critical dependency chain	1
makes a runtime check that	1
makes a PLT for all	1
makes a distinction between leaf	1
makes a symbolic link to	1
makes it more clear to	1
makes it point to the	1
makes it possible to use	1
makes it possible to compile	1
makes it possible to store	1
makes it possible to see	1
makes it less efficient. The	1
makes it necessary to load	1
makes it easier for the	2
makes function calls more efficient.	1
makes function calls faster and	1
makes code caching and data	1
makes an error message when	1
makes an extra register available	1
makes data caching more efficient	1
makes data caching more efficient.	1
makes data caching very efficient.	1
makes data caching less efficient.	3
makes data caching inefficient. An	1
makes data caching inefficient. Dynamic	1
makes program development more expensive	1
makes no difference for the	1
makes no difference whether you	1
makes floating point code more	1
makes floating point code slower,	1
makes floating point comparisons more	1
makes code. For example, in	1
makes sure the variable is	1
makes sure the file is	1
makes sure that the table	1
makes sure that the elements	1
makes sure that the beginning	1
makes sure that the original	1
makes sure that a variable	1
makes sure that all destructors	1
makes sure that no overflow	1
makes operations with Boolean variables	1
makes intermediate object for (b	1
makes dispatching on every call	1
makes caching more efficient today	1
makes caching less efficient. There	1
makes various other optimizations possible	1
makes inlining more efficient and	1
makes testing and maintenance easier.	1
makes sense to dispatch by	1
makes detailed optimization more difficult.	1
makes position- independent code more	1
makes dynamic_cast more time-consuming than	1
cannot be used in 64-bit	1
cannot be used for function	1
cannot be stored in a	2
cannot be called from any	1
cannot be sure that all	1
cannot be calculated at compile	1
cannot be known at compile	1
cannot be certain that a	1
cannot be predicted or if	1
cannot be loaded into an	1
cannot be vectorized with the	1
cannot be vectorized automatically. For	1
cannot be inlined or cannot	1
cannot be overloaded or limited	1
cannot be changed without the	1
cannot be determined in advance,	1
cannot be mixed with x87	1
cannot be executed as it	1
cannot be ruled out by	1
cannot be controlled. The network	1
cannot be controlled. Small hand-held	1
cannot be shared. You can't	1
cannot be avoided, there are	1
cannot be tolerated. PGI C++	1
cannot be ignored if the	1
cannot use the same register.	1
cannot use ~ for NOT.	1
cannot make floating point register	1
cannot make floating point induction	1
cannot make any assumption about	1
cannot make algebraic reductions on	1
cannot point to the same	2
cannot set a breakpoint in	1
cannot do the optimization unless	1
cannot do must be done	1
cannot always rely on the	1
cannot access any non-static data	2
cannot avoid this in a	1
cannot avoid conversions from float	1
cannot inline the function or	1
cannot replace a && b	1
cannot replace a || b	1
cannot assume that an optimizing	1
cannot assume that model N+1	1
cannot know for sure whether	1
cannot know that a function	1
cannot reduce the integer expression	1
cannot change its possible exception	1
cannot change what it points	1
cannot find the answers in	1
cannot rely on the compiler	1
cannot rely on a unit-test	1
cannot rely on anything else	1
cannot expect the compiler to	1
cannot expect a compiler to	2
cannot expect a directive for	1
cannot swap the order of	2
cannot swap the operands if	1
cannot modify data members. It	1
cannot multiply integers of any	1
cannot easily be implemented as	1
cannot easily be obtained. In	1
cannot do. All the reductions	1
cannot increase the size of	1
cannot prefetch more than one	1
cannot rule out the possibility	1
cannot rule out the theoretical	1
cannot rule out aliasing (see	1
before the function returns. The	1
before the function returns. This	1
before the function returns. Global	1
before the function returns. Every	1
before the code to test.	1
before the compiler and it	1
before the time the variable	1
before the program is compiled.	1
before the program starts running	1
before the program starts. The	1
before the loop or the	1
before the loop if all	1
before the cache line would	1
before the floating point calculations	1
before the pointer is used.	1
before the performance even matters,	1
before the first data member	1
before the first call to	1
before the first element is	2
before the test and setting	1
before the file is closed.	1
before the calculation of A	1
before the application programmer gets	1
before the end user gets	1
before the preceding addition is	1
before the preceding iteration is	1
before the decimal point is	1
before and after the piece	1
before and after each of	1
before and after executing the	1
before and after executing a	1
before it is used and	1
before it is too late.	1
before it is finished using	1
before it is compiled. This	1
before it can run. Some	1
before it has finished the	2
before it checks which instruction	1
before it occurs, (2) use	1
before you start to program.	1
before all objects have been	1
before any floating point code.	1
before any floating point instructions.	1
before any constructors are called.	1
before any transition from AVX	1
before we need the next	1
before test // Critical function	1
before they are executed. However,	1
before conversion to floating point	1
before running a program you	1
before calling the function for	1
before calling the library function.	1
before your code is running	1
before p is incremented. See	1
before adding the first object	1
before multiplying with the double	1
before multiplying with the constant	1
before multiplying them. This would	1
before converting to floating point:	1
before compilation. The following example	1
before leaving the AVX part.	2
before leaving their workplace and	1
before terminating a thread. You	1
before dividing by 2 (See	1
before MemberPointer is declared. Avoid	1
before coordination with other subtasks	1
before storing. The standard solution	1
before trying the techniques in	1
before you. Optimized function libraries	1
stored in the order in	2
stored in the container, then	1
stored in a static part	1
stored in a register if	1
stored in a register (see	1
stored in a register except	1
stored in a thread environment	1
stored in a binary representation	1
stored in a global object.	1
stored in a far data	1
stored in a register, not	1
stored in an STL container	1
stored in memory rather than	1
stored in different parts of	1
stored in different modules. This	1
stored in one contiguous memory	1
stored in integer registers. Typical	1
stored in static memory and	1
stored in static memory. Example:	1
stored in static memory. Most	1
stored in registers are accessed	1
stored in registers (see page	1
stored in registers instead of	1
stored in stack memory which	1
stored in memory. It will	1
stored in memory. Example: //	1
stored in binary form than	1
stored in dynamically allocated memory,	1
stored in x, and last	1
stored in memory, at least	1
stored in memory, but not	1
stored in ASCII form. A	1
stored in y. The purpose	1
stored in edx. Furthermore, this	1
stored are containers 93 themselves.	1
stored can be important if	1
stored by the heap manager	1
stored with each instance of	1
stored on the stack and	1
stored on the stack in	1
stored on the stack always	1
stored on the stack. Each	1
stored on the stack, which	1
stored on the stack, except	1
stored as the binary digits.	1
stored as a register variable	1
stored as a single bit	1
stored as a biased binary	1
stored as it is, and	1
stored as 8-bit integers with	1
stored at a memory address	3
stored at an address divisible	2
stored at address [ecx+eax*4]. This	1
stored together in an object	2
stored together The code cache	1
stored together if they are	1
stored together Cache misses are	1
stored together ...................................... 88 9.5	1
stored near each other in	2
stored near each other. See	2
stored (or if a reasonable	1
stored sequentially in memory. They	1
stored consecutively in the order	1
stored contiguously in the memory.	1
stored together...................................... 88 9.4 Variables	1
called the branch target buffer.	1
called the branch misprediction penalty.	1
called the heap is reserved	1
called a frame function, while	1
called a leaf function. Leaf	1
called a loop-carried dependency chain.	1
called and the local object	1
called and how much time	2
called and resources cleaned up.	1
called in the copying process,	1
called in a single session.	1
called in a typical application	1
called for the first time	1
called by the critical code	1
called by the rest of	1
called by F1 also have	1
called with many different factors	1
called with IsPowerOf2 = false	1
called on an object of	1
called when the object is	1
called when the original is	1
called from the same critical	1
called from the shared object.	1
called from the message loop	1
called from a command line	1
called from only one or	1
called from many different places).	1
called from any other module.	1
called from programming languages that	1
called from another module. The	1
called from another module. This	1
called from main, but also	1
called only from same module	2
called only from one place	1
called only first time int	1
called CPU dispatching. For example,	1
called performance monitor counters. A	1
called faster than a non-static	1
called before the function returns.	1
called before the program starts	1
called before the first call	1
called register renaming. The CPU	1
called stack unwinding that is	1
called stack unwinding. All functions	1
called function. Example: // Example	1
called function. But in the	1
called through a function pointer	1
called every time an object	1
called shared objects (*.dll, *.so).	2
called name mangling. The characters	1
called core clock cycles. The	1
called global variables. They can	1
called global offset table (GOT)	1
called whole program optimization, which	1
called square blocking or tiling.	1
called garbage collection. Objects that	1
called whenever an object is	1
called near each other are	1
called procedure linkage table (PLT)	1
called once or multiple times	1
called once. The reasons for	1
called CodeAnalyst. These profilers are	1
called before. This is faster	1
called accumulators. Current CPUs have	1
called Single-Instruction-Multiple-Data (SIMD) operations. The	1
called VTune; AMD's profiler is	1
called properties) are always stored	1
called from), function parameters, local	1
called "Gnu indirect function" has	1
address is in edx, to	1
address is not vacant then	1
address is likely to be	1
address is predicted if the	1
address is taken, i.e. if	1
address a = 10000, then	1
address of the function in	1
address of the data object	1
address of the array element	1
address of the variable in	1
address of the variable that	1
address of the member function.	1
address of the first element	1
address of the matrix element.	1
address of the end of	1
address of the preceding row.	1
address of the beginning of	2
address of the current array	1
address of a linked function	1
address of it (&ArraySize) is	1
address of an array element	1
address of an array element.	1
address of x is type-casted	1
address of each function relative	1
address of each row by	1
address of array element a[i]	1
address of element number i.	1
address of list[i] is equal	1
address of matrix[j][0] is calculated	1
address and shared between multiple	1
address and back again. This	1
address and attempts to translate	1
address in the procedure linkage	1
address in this range then	1
address that is divisible by	2
address can be expressed as	1
address can be predicted. The	1
address by the formula: (set)	1
address by adding a constant	1
address at which a dynamic	1
address which is divisible by	1
address which can't be reached	1
address so a cache line	1
address cannot be loaded into	1
address calculations are done only	1
address calculations have to be	1
address through a function call.	1
address calculation and table lookup	1
address calculation in 64 bit	1
address calculation more efficient: //	1
address calculation faster. The advantage	1
address space of the 64-bit	1
address divisible by the vector	1
address divisible by 8 in	1
address divisible by 16. You	1
address divisible by 8. The	1
address divisible by 8. There	1
address range from 0x2700 to	2
address below 2 GB, but	1
address might clash with another	1
address again before the cache	1
address is. ecx contains the	1
address plus a constant plus	1
address 0x2710 and later reads	1
address 0x2710 will cause the	1
address 0x2710 will cause a	1
address 0x2700 to 0x273F into	1
address [ecx+eax*4]. This is all	1
address esp+8 and esp+12 and	1
4 and AMD processors are	1
4 in the best cases.	1
4 = 32. This is	1
4 = 2048 bytes =	1
4 or 8, but not	1
4 with different matrix sizes.	1
4 - 8 clock cycles.	1
4 - 16 clock cycles,	1
4 int 128 Is32vec4 Vec4i	1
4 double 8 8 long	1
4 pointer or reference, 64-bit	1
4 + esp ;alignby4 ;	1
4 float a[100]; float s0	1
4 64-bit integer, signed or	1
4 clock cycles on most	1
4 clock cycles. In most	1
4 2 Choosing the optimal	2
4 4 double 8 8	1
4 4 pointer or reference,	1
4 4 64-bit integer, signed	1
4 4 bytes = float	2
4 unsigned int 128 Iu32vec4	1
4 unsigned short int 64	1
4 unsigned 256 short int	1
4 64 2 32 8	1
4 64 4 32 4	1
4 64 MMX int 32	1
4 32 4 64 2	1
4 short int 64 Is16vec4	1
4 ; mangled function name	1
4 bytes in 32-bit systems	1
4 bytes = int 4	1
4 bytes = int 8	1
4 bytes = float or	2
4 bytes = float 4	1
4 bytes = float 8	1
4 bytes without cache MOVNTI	1
4 AVX _mm256_permutevar_ps 4 4	1
4 128 SSE2 long long	1
4 128 SSE double 64	1
4 Most of the comments	1
4 256 AVX int 32	1
4 256 AVX2 float 32	1
4 AVX2 Table 12.3. Intrinsic	1
4 AVX2 _mm256_i32gather_epi32 unlimited 4	1
4 AVX2 _mm_i32gather_ps unlimited 4	1
4 AVX2 _mm256_i32gather_ps unlimited 4	1
4 computer where the level-1	1
4 unused bytes in the	1
4 unused bytes byte at	1
4 lines in the set	1
4 bytes. first // 4	1
4 bytes. first byte at	2
4 processors, and 3 -	1
4 processor. Extra time is	1
4 Performance and usability A	1
4 Performance and usability ...............................................................................................	1
4 computer. The measured results	1
4 ways. This means that	1
4 floats A structure of	1
4 floats exp function of	1
4 ways, with a line	1
4 PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROCNEAR	1
4 PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROC	1
4 rows. Let's look at	1
4 ?Func2@@YAXQAHAAH@Z ENDP ecx, 1	1
4 (NetBurst) CPU is designed	1
See the compiler documentation for	2
See the Intel C++ Compiler	1
See the manual for your	1
See the manual for my	1
See the end of this	1
See the examples in the	1
See the preceding paragraph and	1
See the discussion of container	1
See the vectorclass manual for	1
See page and 90 for	1
See page 16 for a	1
See page 32 for an	1
See page 128 below. Dispatch	1
See page 3 for a	1
See page 130 for an	1
See page 130 for details).	1
See page 120 for how	1
See page 87 for a	1
See page 122 for how	2
See page 80 for an	1
See page 90 for a	1
See page 107 for how	1
See page 103 for examples	1
See page 51 for the	1
See page 43 for an	1
See page 43 about branch	1
See page 88 for details.	1
See page 150 for further	1
See page 26 about data	1
See page 29 for details.	1
See page 31 for more	1
See page 49 for a	1
See page 93 for discussion	1
See page 81 for an	1
See page 89 for an	2
See page 153 for further	1
See page 145 and 119	1
See page 140 for further	1
See page 141 for details	1
See page 78 for an	2
See page 131. Intel Performance	1
See page 131. AMD LIBM	1
See page 52. The member	1
See page 73 and 72	1
See page 26. The heap	1
See page 80. The keyword	1
See page 95 and 120	1
See page 78. Assume no	1
See page 141. Applications that	1
See page 34. In some	1
See page 54. It is	1
See page 90. 15 Metaprogramming	1
See page 53. 7.24 Unions	1
See page 45. This may	1
See page 140. Avoid conversions	1
See page 61. It is	1
See page 73. Runtime polymorphism	1
See Intel Technology Journal Vol.	1
See manual 5: "Calling conventions	1
See my blog for details.	1
See chapter 10 page 101	1
See www.agner.org/optimize/cppexamples.zip for examples of	1
See www.agner.org/optimize/cppexamples.zip. If the number	1
See ISO/IEC TR18015 Technical Report	1
See www.agner.org/optimize and the FAQ	1
See www.openmp.org and the compiler	1
critical function is called. This	1
critical function is inserted in	1
critical function a = CriticalFunction(b,	1
critical function and you want	1
critical function may be the	1
critical function many times with	1
critical function through function pointer	1
critical function ten times and	1
critical code to see which	1
critical code in multiple versions	2
critical code are compiled with	1
critical code so that you	1
critical time consumers. Choose the	1
critical when there is no	1
critical because they can block	1
critical functions and hot spots.	1
critical functions take microseconds to	1
critical functions inline or static	1
critical integer parameter comes first	1
critical code. A test setup	1
critical part of the code	5
critical part of the program	2
critical part of the program.	1
critical part of the code,	1
critical part of a code	1
critical part of a program	3
critical part of a program.	2
critical part of a program,	1
critical part can run optimally	1
critical function. The initialization routine	1
critical function. The branching is	1
critical function. In some cases,	1
critical dependency chain which prevents	1
critical dependency chain, especially on	1
critical applications because the response	1
critical parts of the code	3
critical parts of the program	1
critical parts of the program.	1
critical piece of code then	1
critical innermost loop of a	2
critical innermost loop should preferably	1
critical innermost loop. The loop	1
critical innermost loop. log is	1
critical innermost loops. 13.1 CPU	1
critical modules with a different	1
critical resources. Modern CPUs are	1
critical stride is a multiple	2
critical stride is 8192 /	1
critical stride and cause contentions	1
critical stride for the level-2	1
critical stride can be calculated	1
critical stride will contend for	1
critical stride then this can	1
critical stride (see above, page	1
critical stride causes all writes	1
critical stride, as explained on	1
critical stride. Variables whose distance	1
critical application- specific instructions that	1
call the function billions of	1
call the library function 250	1
call the library functions directly:	1
call the version that fits	1
call the function. This fragmentation	1
call the destructor of x.	1
call the destructor for the	1
call the chosen version return	1
call the polymorphic member of	1
call the CPUID instruction directly,	1
call the ReadTSC function. 154	1
call the std::unexpected() function in	1
call is translated to just	1
call a function in a	1
call a virtual member function	1
call a polymorphic function goes	1
call a polymorphic function. The	1
call a non-virtual member function,	1
call of the critical function.	1
call to the function go	1
call to the critical function.	1
call to the inlined function	1
call to the inlined function.	1
call to a const function	1
call to a graphics function	2
call to a graphics library	1
call to a driver involves	1
call to count how many	1
call to square by the	1
call to CriticalFunction in example	1
call to memcpy rather than	1
call to C1::f } 73	1
call to _endthread() cleans up	1
call to Func1, while other	1
call to Object1.Hello(), though future	1
call and return and parameter	1
call and return operations with	1
call // Header file for	1
call or any other cleanup	1
call it will point to	1
call it from a project	1
call it points to the	1
call if it is known	1
call by the body of	1
call with a table lookup	1
call this distance the critical	1
call from the main executable	1
call all code branches separately	1
call any other function is	1
call any other function. A	1
call so that you have	1
call makes the microprocessor jump	1
call method using InstructionSet(): //	1
call stack in the debugger	1
call inline void SelectAddMul(short int	1
call statement always calls the	1
call statement occupies a space	1
call (e.g. GetProcessAffinityMask in Windows).	1
call polymorphic child function: (static_cast<MyChild*>(this))->Disp();	1
call transpose function swapd(a[r][c], a[c][r]);	1
call method. When the function	1
call _mm256_zeroupper() before calling the	1
call _mm256_zeroupper() before leaving the	2
call C1::f directly without using	1
call WriteFile if the handle	1
call p->f() goes to C0::f	1
call (other than log) inside	1
call __intel_cpu_features_init_x(). In other cases,	1
0; for (i = 0;	1
0; for (int i =	1
0; for (i=0; i<100; i++)	1
0; // return 0 if	1
0; // Initialize loop counter	1
0; int i; for (i	2
0; int i, largest_index =	1
0; x < 100; x++)	2
0; } The InstructionSet() function	1
0; } The indirect function	1
0; } if (a ==	1
0; } else { goto	1
0; i < 100; i	2
0; i < 100; i++)	9
0; i < 2; i++)	1
0; i < size; i	1
0; i < size; i++)	10
0; i < n; i++)	1
0; i < 256; i	5
0; i < 256; i++)	1
0; i < 1000; i++)	1
0; i < 20; i	1
0; i < 20; i++)	1
0; i < rows; i++)	2
0; i < NumberOfTests; i++)	2
0; i < ArraySize; i++)	1
0; i < list.Size(); i++)	1
0; while (seconds < 5)	1
0; c < SIZE; c++)	2
0; c < r; c++)	2
0; r < SIZE; r++)	2
0; row < NUMROWS; row++)	1
0; j < columns; j++)	1
0; column < NUMCOLUMNS; column++)	1
0; c1 < r1; c1	1
0; 14.6 Floating point division	1
0; list[i+1] = 1; list[i+2]	1
0; r1 < SIZE; r1	1
0; i--, x++) factorial *=	1
0; 35 This is optimal	1
0; i--) *(p++) |= 0x20;	1
8 and no induction variable	1
8 in order to align	1
8 = 64 kb. This	1
8 = 80. The difference	1
8 or 16 bits of	1
8 or 16 Table 7.2.	1
8 - 64 Kbytes and	1
8 floating point). There are	1
8 most popular version of	1
8 pointer or reference, 32-bit	1
8 + esp ; align	1
8 float 4 4 double	1
8 * 4 = 32.	1
8 clock cycles. Division takes	1
8 long double 8, 10,	1
8 8 pointer or reference,	1
8 8 float 4 4	1
8 8 long double 8,	1
8 8 unsigned char 64	1
8 8 64 MMX short	1
8 8 char 64 Is8vec8	1
8 bit and 32 bit	1
8 unsigned short int 128	1
8 unsigned char 64 Iu8vec8	1
8 64 4 unsigned 256	1
8 64 4 64 4	1
8 64 MMX short int	1
8 rather than the variable	1
8 rather than by 16.	1
8 16 unsigned char 128	1
8 16 128 SSE2 short	1
8 16 char 128 Is8vec16	1
8 32 8 64 4	1
8 32 256 AVX2 short	1
8 32 char 256 Vec32c	1
8 bits each, eight integers	1
8 0 255 uint8_t unsigned	1
8 short int 128 Is16vec8	1
8 bytes of storage space.	1
8 bytes in 64-bit systems.	1
8 bytes = double 2	1
8 bytes = double 4	1
8 bytes = int64_t 2	1
8 bytes = int64_t 4	1
8 bytes without cache MOVNTQ	1
8 bytes smaller and the	1
8 bytes each. The critical	1
8 128 SSE2 int 32	1
8 256 AVX double 64	1
8 256 AVX2 long long	1
8 below. This manual is	1
8 char 64 Is8vec8 8	1
8 AVX2 _mm_i64gather_pd unlimited 8	1
8 AVX2 _mm_i32gather_epi32 unlimited 4	1
8 AVX2 _mm_i64gather_epi32 unlimited 8	1
8 512 AVX512 float 32	1
8 512 AVX512 Table 12.1.	1
8 #define FUNCNAME SelectAddMul_AVX2 #endif	1
8 columns unused. This removed	1
8 bytes. first // 4	1
8 bytes. first byte at	1
8 edx, eax $B2$2 ;	1
8 ways. The critical stride	1
8 -128 127 int8_t short	1
8 2.5 Choice of compiler	1
8 kb = 8192 bytes,	1
8 kb size with a	1
8 Optimizations in the compiler	2
8 double's of 8 bytes	1
less be possible to organize	1
less than the time it	2
less than the time you	1
less than the cache size.	1
less than a few kilobytes	1
less than in a PC.	1
less than 128 because the	1
less than half speed because	1
less than 2n and not	1
less than 231. This extra	1
less than 1/50 of the	1
less than 2-20, but this	1
less than ARRAYSIZE. Another example:	1
less than 1% goes to	1
less memory and computing power	1
less each time. An experiment	1
less efficient and you want	1
less efficient in some systems	1
less efficient if the loop	1
less efficient code caching. This	1
less efficient than the Gnu	1
less efficient than a linear	1
less efficient than signed integers.	1
less efficient than accessing a	1
less efficient than necessary. Take	1
less efficient than relocation, especially	1
less efficient than non-object oriented	1
less efficient when the row	1
less efficient because the compiler	1
less efficient (see page 53).	1
less so that it doesn't	1
less critical parts of the	1
less user friendly. It is	1
less useful in 32- bit	1
less important on most newer	1
less important than it used	1
less advantageous to use vector	1
less likely to be a	1
less optimal code because they	1
less efficient. The size of	1
less efficient. The performance can	1
less efficient. In 64-bit systems,	1
less efficient. In many cases,	1
less efficient. There are various	1
less efficient. You may use	1
less efficient. Most C++ compilers	1
less efficient. Dynamic libraries are	1
less efficient. Do not make	1
less efficient. Access to static	1
less efficient. Extra memory space	1
less efficient. Splitting up a	1
less clear and more difficult	1
less efficiently if the code	1
less efficiently when data are	2
less popular at the time	1
less strict when compiling for	1
less computing resources than standard	1
less expensive. Using complicated techniques	1
less optimized. Note that the	1
less compact. See page 52.	1
less intensive applications. Some systems	1
less safe. This safety problem	1
less favorable: Larger data types:	1
less efficiently. This method is	1
less precise floating point calculations.	1
less reliable. Event-based sampling: The	1
less susceptible to problems of	1
less well-known languages. My preference	1
For this reason, you can	1
For more on this topic,	1
For example use #if instead	1
For Intel CPUs use Intel	1
For example, the compiler can	1
For example, the first PC's	1
For example, the latest version	1
For example, the Boost collection	1
For example, a = b	1
For example, a compiler may	1
For example, a loop that	1
For example, a double takes	1
For example, a library of	1
For example, a branch that	1
For example, a programmer may	1
For example, a 128-bit XMM	1
For example, a heavy graphics	1
For example, a Core i7	1
For example, a FIFO queue	1
For example, to test the	1
For example, in the case	1
For example, in the expression	1
For example, in a word	1
For example, in Windows, you	1
For example, in interpreted script	1
For example, for (i=0; i<n;	1
For example, it may be	1
For example, it may take	1
For example, if the number	1
For example, if the clock	1
For example, if a and	1
For example, if a program	1
For example, if a loop	1
For example, if you want	1
For example, if each bit	1
For example, if multiple threads	1
For example, if we want	1
For example, x = *(p++)	1
For example, x = array[i++]	1
For example, you may want	1
For example, you get four	1
For example, use AVX only	1
For example, when a pointer	1
For example, only one of	1
For example, all good compilers	1
For example, one tread can	1
For example, compilers cannot reduce	1
For example, many programmers do	1
For example, some programmers use	1
For example, #define ABC 123	1
For example, let's look at	1
For example, b*2.0/3.0 will be	1
For these reasons, the preferred	1
For example: // Example 8.4	1
For example: // Example 7.7	1
For example: // Example 7.11	1
For example: // Example 7.14	1
For example: // Example 7.13	1
For example: // Example 7.29a	1
For example: // Example 7.35a	1
For example: // Example 8.24.	1
For example: // Example 14.16a	1
For example: // Example 7.37	1
For example: // Example 14.15a	1
For example: // Example 14.2a	1
For my own research, I	1
For unused returns // Volatile	1
For example,a * 16is calculated	1
For team projects, it is	1
For one-man projects, it is	1
example, the compiler is able	1
example, the compiler can safely	1
example, the size of abc	1
example, the first PC's had	1
example, the template function is	1
example, the sign bit of	1
example, the conversion is costly	1
example, the latest version of	1
example, the Boost collection contains	1
example, the DelayFiveSeconds function will	1
example, a = b *	1
example, a compiler may change	1
example, a loop that does	1
example, a double takes 8	1
example, a library of math	1
example, a branch that chooses	1
example, a programmer may prefer	1
example, a 128-bit XMM register	1
example, a heavy graphics application	1
example, a Core i7 processor	1
example, a FIFO queue should	1
example, to test the sign	1
example, to go one way	1
example, to convert float to	1
example, in the case a	1
example, in the expression a	1
example, in a word processor	1
example, in Windows, you may	1
example, in interpreted script languages,	1
example, for (i=0; i<n; i++)	1
example, that a is true	1
example, it may be convenient	1
example, it may take 3	1
example, if the number of	1
example, if the clock frequency	1
example, if a and b	1
example, if a program has	1
example, if a loop repeats	1
example, if you want to	1
example, if each bit of	1
example, if multiple threads are	1
example, if we want to	1
example, x = *(p++) is	1
example, x = array[i++] is	1
example, you can double the	1
example, you may want to	1
example, you should multiply it	1
example, you want to find	1
example, you get four float	1
example, this is not an	1
example, use AVX only when	1
example, when a pointer to	1
example, then all five values	1
example, only one of the	1
example, which calculates the sum	1
example, all good compilers will	1
example, but the point is	1
example, one tread can take	1
example, compilers cannot reduce the	1
example, using Intel vector classes	1
example, using Agner vector classes	1
example, many programmers do not	1
example, we are using 8-bit	1
example, some programmers use a	1
example, a, b and c	1
example, #define ABC 123 and	1
example, vectorized with SSE4.1 //	1
example, let's look at the	1
example, f(x) or g(x) is	1
example, b*2.0/3.0 will be calculated	1
bit is kept in the	1
bit of a 32-bit integer	1
bit of x The syntax	1
bit of x by using	1
bit of i in order	1
bit of i into the	1
bit of i ; i	1
bit of f is set	1
bit of f cout <<	1
bit of ebx. The next	1
bit of u.f We can	1
bit to zero We can	1
bit to compare absolute values:	1
bit to zero: // Example	1
bit and 32 bit offsets).	1
bit in the above example	1
bit in Day for signifying	1
bit in nn ifbit=1 bitofn	1
bit are zero. Zero can	1
bit can be saved either	1
bit // u.d is negative	1
bit code 64 bit code	1
bit code Static linking (multithreaded)	1
bit at a time. Do	1
bit vector of two double.	1
bit vector of four float.	1
bit vector registers when compiling	1
bit vector containing integers. It	1
bit instruction set supports self-relative	1
bit which is 0 for	1
bit integer and double vectors	1
bit integer vectors FMA3 floating	1
bit float and double vectors	1
bit float vectors SSE2 128	1
bit float vectors) /arch:SSE -msse	1
bit version for the sake	1
bit so that the remaining	1
bit systems have the following	1
bit systems have several advantages	1
bit operations and shift operations	1
bit must be saved from	1
bit Windows and Mac programs	1
bit Linux The procedure to	1
bit Linux Shared objects are	1
bit }; The values of	1
bit mode and mostly relative	1
bit mode if the image	1
bit mode than in 32	1
bit mode SSE 128 bit	1
bit platform not _WIN64 not	1
bit platform _WIN64 _LP64 _WIN64	1
bit platform __GNUC__ and not	1
bit x86 instruction set has	1
bit mode. The latter is	1
bit mode. Some 64-bit compilers	1
bit mode, where it still	1
bit mode, we encounter another	1
bit scan instruction is executed	1
bit scan instruction and have	1
bit scan instruction and expect	1
bit scan instructions. My recommendation	1
bit scan instruction. Programmers that	1
bit systems: The number of	1
bit systems: Pointers, references, and	1
bit manipulation tricks Michael Abrash:	1
bit -fno-builtin Gnu 32-bit -fno-builtin	1
bit offsets). Example: // Example	1
bit indicates a specific CPU	1
bit set). We can shift	1
operating systems and programs compiled	1
operating systems and fourteen integer	1
operating systems and sixteen in	1
operating systems that do not	1
operating systems that allows bigger	1
operating systems are not always	1
operating systems are not backwards	1
operating systems are most efficient	1
operating systems are using the	1
operating systems are common, and	1
operating systems can also be	1
operating systems need better support	1
operating systems available today. You	1
operating systems give almost identical	1
operating systems Windows, Linux, Mac	1
operating systems DOS and Windows	1
operating systems lack the necessary	1
operating systems disappears when running	1
operating systems (but not in	1
operating system is often more	1
operating system is based on	1
operating system to avoid running	1
operating system to generate an	1
operating system to swap memory	1
operating system and CPU hardware.	1
operating system and choose the	1
operating system for support of	1
operating system can be time	1
operating system can be particularly	1
operating system or libraries that	1
operating system if the array	1
operating system may not load	1
operating system may have a	1
operating system may supply such	1
operating system this is the	1
operating system has support for	1
operating system functions (e.g. GetLogicalProcessorInformation	1
operating system which redirects it	1
operating system rather than by	1
operating system (see page 107).	1
operating system thread scheduler. This	1
operating system All newer microprocessors	1
operating system running in 32-bit	1
operating system API and the	1
operating system kernel in the	1
operating system standards. Such schemes	1
operating systems. The 64 bit	1
operating systems. Some compilers have	1
operating systems. 10 Gnu This	1
operating systems. 3 The latest	1
operating systems, and API's. Memory	1
operating systems, though these operating	1
operating system. The best performance	1
operating system. This is very	1
operating system. It will crash	1
operating system. See page 122	1
operating system. See page 29	1
operating system. AVX is supported	1
operating system, and therefore the	1
operating system, and 512 bits	1
operating system, not by the	1
operating system, this requires static	1
operating system, but you can	1
operating systems". The parameters a	1
operating systems". For this reason,	1
operating systems". 7.16 Function return	1
operating systems"). An application with	1
operating system......................................................................................... 6 2.4 Choice	1
operating systems" for details on	1
unsigned in order to make	1
unsigned The same rules apply	1
unsigned for fast division c	1
unsigned // Faster if divisor	2
unsigned if you are sure	1
unsigned int in 16-bit systems:	1
unsigned int or by type-casting	1
unsigned int one : 1;	1
unsigned int before dividing by	1
unsigned int 64 Is32vec2 32	1
unsigned int 16 0 65535	1
unsigned int i; } u,	1
unsigned int i; const int	1
unsigned int 128 Iu32vec4 Vec4ui	1
unsigned int sign : 1;	1
unsigned int sign :1;//signbit };	2
unsigned int exponent : 8;	1
unsigned int exponent : 15;	1
unsigned int exponent : 11;	1
unsigned int u; double d;	3
unsigned int fraction : 23;	1
unsigned int fraction : 52;	1
unsigned int fraction : 63;	1
unsigned int n) { double	1
unsigned int N> class SafeArray	1
unsigned int dummy; double a[arraysize],	1
unsigned int absvalue, largest_abs =	1
unsigned int u[2]} a[size]; unsigned	1
unsigned integer to a signed	1
unsigned integer and this will	1
unsigned integer takes longer time.	1
unsigned integer type size_t is	1
unsigned variable produces a low	1
unsigned 2 2 int, signed	1
unsigned You can take advantage	1
unsigned long int 64 0	1
unsigned long long or uint64_t	1
unsigned long 32 0 232-1	1
unsigned 4 4 64-bit integer,	1
unsigned 8 8 pointer or	1
unsigned short int in 16-bit	1
unsigned short int 64 Iu16vec4	1
unsigned short int 128 Iu16vec8	1
unsigned integers is ambiguous and	1
unsigned integers is costless. It	1
unsigned integers to floating point	1
unsigned integers to signed integers	1
unsigned integers in comparisons, such	1
unsigned integers - they are	1
unsigned integers int a, b;	1
unsigned integers In most cases,	1
unsigned integers (see page 142).	1
unsigned integers simply makes the	1
unsigned 1 1 short int,	1
unsigned 256 int int64_t 256	1
unsigned 256 short int int	1
unsigned conversion // Example 7.20	1
unsigned char 8 0 255	1
unsigned char 64 Iu8vec8 16	1
unsigned char short int 832	1
unsigned char 128 Iu8vec16 Vec16uc	1
unsigned variables. A positive overflow	1
unsigned integers. But there are	1
unsigned __int64 64-bit Linux: unsigned	1
unsigned Examples: // Example 14.10	1
first the runtime polymorphism: //	1
first and foremost, in the	1
first in a series of	1
first in an || expression.	1
first // 4 unused bytes	1
first // 4 bytes. first	1
first // 6 unused bytes	1
first time the function is	2
first time int CriticalFunction_Dispatch(int parm1,	1
first time you activate a	1
first time because it needs	1
first time Func is executed.	1
first when you are using	1
first data member or after	1
first two integer parameters are	1
first two (three on CodeGear	1
first two suggested improvements). //	1
first object to the vector.	1
first way is to insert	1
first way and three times	1
first call to the critical	1
first call // Header file	1
first call it will point	1
first call it points to	1
first call method using InstructionSet():	1
first time. This is because	1
first processors that supported 128-bit	1
first processors that supported 256-bit	1
first processors with the AVX-512	1
first result is stored in	1
first compiled to an intermediate	1
first element is stored (or	1
first element is stored? If	1
first element of the array	1
first 128 bytes then put	1
first 128 bytes. 7.19 Class	1
first four parameters are transferred	1
first eight floating point parameters	1
first eight elements in row	1
first count is usually higher	1
first count and the subsequent	1
first program. An optimizing compiler	1
first application if dynamic linking	1
first byte of zero within	1
first byte of zero. A	1
first byte at 0, last	2
first byte at 8, last	1
first byte at 12, last	1
first byte at 400, last	1
first look up the address	1
first algorithm that comes to	1
first operand of && is	1
first operand of || is	1
first operand determines whether the	1
first convert the unsigned integer	1
first thing to do when	1
first thing we notice is	1
first generation of processors that	1
first generation class (CGrandParent) contains	1
first call. The function is	1
first six integer parameters and	1
first manual. The subsequent manuals	1
first PC's had an interpreter	1
first sum, then f is	1
first sub-vector. A long dependency	1
first dimension may preferably be	1
register the object has no	1
register is a small piece	1
register is 128 bits (XMM)	1
register is volatile. The volatile	1
register to zero that is	1
register to temp even though	1
register to hold the value	1
register and prevents all optimizations	1
register for the class Vec16s	1
register for more than one	1
register for computing i/2+r. The	1
register for both, while the	1
register that appears in the	1
register can be used for	1
register can be organized as	1
register if its address is	1
register because their live ranges	2
register which can be fed	1
register size is handled at	1
register size in the future.	1
register size only when the	1
register size comes only in	1
register into the carry and	1
register variable in example 11.3	1
register variable in eax. The	1
register variables is eight in	1
register variables is approximately six	1
register variables in 32-bit systems	1
register variables in 32-bit mode	1
register variables are temporary intermediates,	1
register variables because of the	1
register less so that it	1
register rather than on the	1
register available for other purposes.	1
register stack is used. It	1
register stack is organized. Floating	1
register stack also has disadvantages:	1
register stack are: All calculations	1
register stack versus XMM registers.	1
register (see below) then it	1
register allocation and parameter transfer	1
register keyword is only a	1
register keyword can be added	1
register size. In other words,	1
register size. Vectorized code is	1
register variables. This includes pointers	1
register variables. Vector operations are	1
register variables. 9.5 Alignment of	1
register temp in one iteration	1
register variable. The register keyword	1
register variable. The union forces	1
register stack. These registers have	1
register containing (2,2,2,2), and store	1
register sizes to 1024 bits	1
register temp; for (i =	1
register except in the simplest	1
register storage. The same register	1
register storage. Live range analysis	1
register variables, but will save	1
register parameters. In 64-bit Windows,	1
register renaming and doing multiple	1
register use, as explained in	1
register left for transferring additional	1
register usage convention says that	1
register renaming. The CPU can	1
register keyword. The CodeGear compiler	1
register state. This penalty should	1
64 and IA-32 Architectures Optimization	1
64 or 0x40 bytes from	1
64 If you make your	1
64 2 32 8 64	1
64 2 128 SSE2 float	1
64 2 128 SSE2 char	1
64 2 int64_t 128 I64vec2	1
64 2 uint64_t 128 Vec2uq	1
64 4 unsigned 256 short	1
64 4 64 4 32	1
64 4 32 4 64	1
64 4 256 AVX int	1
64 4 256 AVX2 float	1
64 8 512 AVX512 float	1
64 8 512 AVX512 Table	1
64 bit code Static linking	1
64 bit instruction set supports	1
64 bit systems have the	1
64 bit systems have several	1
64 bit Windows and Mac	1
64 bit Linux The procedure	1
64 bit mode if the	1
64 bit mode than in	1
64 bit platform _WIN64 _LP64	1
64 bit mode. The latter	1
64 bit mode, we encounter	1
64 bit -fno-builtin Gnu 32-bit	1
64 64 32 16.4 65	1
64 64 matrix on a	1
64 64 matrix size causes	1
64 64 14.0 80.8 65	1
64 32 16.4 65 65	1
64 bits in 64-bit systems.	1
64 bits are less efficient.	1
64 bits rather than 32	1
64 bits total size, because	1
64 bits wide, should be	1
64 bits each. The type	1
64 bits (MMX), 128 bits	1
64 0 264-1 uint64_t Table	1
64 bytes on contemporary processors.	1
64 matrix on a Pentium	1
64 matrix size causes misses	1
64 1 64 MMX char	1
64 1 int64_t 64 I64vec1	1
64 consecutive bytes of memory.	1
64 bytes. This makes sure	1
64 bytes. Each line covers	1
64 bits. The vector instructions	1
64 bits. This is only	1
64 MMX int 32 2	1
64 MMX long long 64	1
64 MMX short int 16	1
64 MMX char 8 16	1
64 bits, but 32-bit systems	1
64 Kbytes and a level-2	1
64 Iu32vec2 64 1 int64_t	1
64 -263 263-1 int64_t 29	1
64 14.0 80.8 65 65	1
64 Iu8vec8 16 4 short	1
64 kbytes. This is quite	1
64 Is32vec2 32 64 Iu32vec2	1
64 Is8vec8 8 8 unsigned	1
64 Is16vec4 16 4 unsigned	1
64 kb. This corresponds to	1
64 Iu16vec4 32 2 2	1
64 I64vec1 8 16 char	1
take the same time to	1
take the same time regardless	1
take the integer factorial function	1
take the elements from row	1
take the absolute value by	1
take the hint, but it	1
take a long time to	1
take a long time in	1
take a lot of cache	1
take a lot of time.	1
take a whole workday or	1
take more than a hundred	1
take more than a minute	1
take more than an hour.	1
take more time to calculate	1
take more time to load.	1
take more time than the	1
take more time than normal	1
take more resources than non-virtual	1
take memory space where a	1
take only one clock cycle	1
take only one clock cycle.	1
take only 256 clock cycles.	1
take only 5 s on	1
take no more time than	1
take no extra time when	1
take no extra time. There	1
take most time. Uses debug	1
take into account that each	1
take into account when optimizing	1
take any extra time. This	1
take branch prediction into account	1
take up to 4 clock	1
take up cache space and	1
take up cache space. The	1
take extra precautions to account	1
take much more resources than	1
take several seconds to access	1
take several years before your	1
take several minutes to start	1
take advantage of this by	1
take advantage of this fact	1
take advantage of this capability:	1
take advantage of vector operations,	1
take advantage of 64-bit integer	1
take advantage of 64-bit integers.	1
take advantage of these guidelines	1
take advantage of out-of-order execution,	1
take quite a long time	1
take quite a long time.	1
take longer time than normally.	1
take longer time. It is	1
take longer time. It can	1
take longer time. Integer multiplication	1
take 10 clock cycles even	1
take installation time and compatibility	1
take special precautions for speeding	1
take maximum advantage of out-of-order	1
take 3 - 5 clock	1
take approximately 500 clock cycles.	1
take care of the user	1
take care of all cleanup	1
take care of some of	1
take care of communication with	1
take 1000 * 100 *	1
take microseconds to execute then	1
take precedence, not only when	1
often the case in loops.	1
often a part of the	1
often a lot to gain	1
often a disadvantage for the	1
often be optimized by using	1
often be made smaller by	1
often be C or C++.	1
often be executed faster in	1
often as a result of	1
often an obstacle to vectorization.	1
often have execution units, memory	1
often have exploited. A good	1
often use position-independent code everywhere	1
often more efficient to allocate	1
often more reliable than third	1
often because the block size	1
often used for calculating the	1
often used by default anyway	1
often used as buffers for	1
often used data members come	1
often used functions separate from	1
often used variables in a	1
often used members in the	1
often possible to make a	1
often possible to insert a	1
often takes no extra time	1
often takes much more time	1
often faster to use the	1
often faster than the intrinsic	1
often take several years before	1
often useful to put time-consuming	1
often necessary to do experiments	1
often necessary to check if	1
often much more than the	1
often implemented as a linked	1
often contains a lot of	1
often contains writeable data. Therefore,	1
often write expressions that can	1
often optimize the code further	1
often replace integer multiplication by	1
often requires that all software	1
often gives more reliable results.	1
often inlined automatically by the	1
often true last in an	1
often fail to keep their	1
often easier to use vector	1
often easier said than done	1
often happen that a low-priority	1
often inefficient. Objects of a	1
often determined by considerations such	1
often waiting for each other	1
often belong to one of	1
often preferable to make a	1
often inserts built-in code instead	1
often suffer from poor branch	1
often conflicting with the requirements	1
often reveal things that can	1
often mispredicted. A branch that	1
often underestimate this time lag.	1
often reorganized in such a	1
often seen, is certainly a	1
often abusing the update mechanism	1
often fluctuating and it may	1
often excessively so. These containers	1
often unreliable. They sometimes give	1
often disturb the users with	1
rather than the variable m.	1
rather than the complicated address	1
rather than the parts of	1
rather than the throughput (see	1
rather than the equivalent if(!(a	1
rather than the product makes	1
rather than the external clock.	1
rather than the heap. The	1
rather than a function template	1
rather than a function parameter	1
rather than a small piece	1
rather than a hardware implementation	1
rather than a dedicated test	1
rather than in a register	1
rather than in a register.	1
rather than in memory. Function	1
rather than by the loop	1
rather than by the processing	1
rather than by the latency	1
rather than by pointers or	1
rather than by 16. This	1
rather than by individual installation	1
rather than on the stack	1
rather than on the stack.	3
rather than on the stack).	1
rather than as b*(2.0/3.0) unless	1
rather than at runtime if	1
rather than at runtime. Example	1
rather than CPU time. Another	1
rather than each time the	2
rather than using a ready-made	1
rather than double if the	1
rather than two 32-bit integers	1
rather than pointers are: The	1
rather than 32 bits. This	1
rather than dynamic linking are:	1
rather than type casting of	1
rather than making a new	1
rather than its brand, family	1
rather than processor features. The	1
rather than Boolean expressions. There	1
rather than references are: When	1
rather than reading or writing	1
rather than future processors. Consider	1
rather than seconds or microseconds	1
rather than two. Some compilers	1
rather than moving each object	1
rather than allocating more space	1
rather than allocating piecewise or	1
rather than "what works best	1
rather than generating denormal numbers	1
rather than rounding. This is	1
rather than loops, etc. Optimizing	1
rather than 1.23456. The conclusion	1
rather than sequences of operations.	1
rather than 20. The fact	1
rather than nine, even though	1
rather than 200. Next, we	1
rather than -156. Surprisingly, we	1
rather than isolating a single	1
rather than self-styled hacks and	1
rather unconventional manner by returning	1
optimization is to save time	1
optimization is to join all	1
optimization is needed. The C++	1
optimization is enabled. A more	1
optimization is requested. See page	1
optimization of C++ and assembly	2
optimization of C++ and Fortran	1
optimization of performance has high	1
optimization are discussed below. Cannot	1
optimization can sometimes be obtained	1
optimization or for combining multiple	1
optimization it may be useful	1
optimization by compiler There are	1
optimization by compiler ....................................................................... 77	1
optimization by CPU Modern CPUs	1
optimization by executing instructions out	1
optimization by CPU.............................................................................81 8.5 Compiler	1
optimization than to use this	1
optimization more difficult. On the	1
optimization cannot be used for	1
optimization instructions at specific places	1
optimization Some compilers have an	1
optimization option available. Some compilers	1
optimization unless the function can	1
optimization Integer algebra reductions: a+b	1
optimization automatically in simple cases.	1
optimization methods and algebraic reductions	1
optimization options and the options	1
optimization options that you can	1
optimization options are incompatible with	1
optimization options All C++ compilers	1
optimization options turned on, the	1
optimization options turned on, including	1
optimization options turned on. Most	1
optimization options ................................................................................... 81 8.6	1
optimization features of Intel C++	1
optimization features and for code	1
optimization manuals are used by	1
optimization capabilities for 32-bit and	1
optimization effort is concentrated on	2
optimization effort on that particular	1
optimization manuals. I am always	1
optimization MS compiler Windows Gnu	2
optimization options. Supports parallel processing,	1
optimization are. Dynamic memory allocation	1
optimization guide for assembly programmers	1
optimization guide for x86 platforms.	1
optimization guide for Windows, Linux	2
optimization Intel: "Intel 64 and	1
optimization explicitly. Divisions can sometimes	1
optimization Whole program optimization Integer	1
optimization topics ......................................................................................... 132 14.1	1
optimization topics 14.1 Use lookup	1
optimization report /Qopt-report -opt-report Table	1
optimization issue. But it is	1
optimization efforts on the time	1
optimization /GL --combine -fwhole- program	1
optimization hints as pragmas in	1
optimization /Og Whole program optimization	1
optimization job. You have to	1
libraries is more difficult. The	1
libraries of predefined vector classes	1
libraries and short vector libraries.	1
libraries and see which one	1
libraries and drivers differ a	1
libraries and compiler-generated code by	1
libraries and frameworks, rather than	1
libraries in this format. Other	1
libraries for many of these	1
libraries for many common purposes	1
libraries for many standard tasks	1
libraries for special purposes are	1
libraries for computing mathematical functions	1
libraries that are used in	1
libraries that are intended for	1
libraries that come with compilers	1
libraries are not always fully	1
libraries are not well documented.	1
libraries are not fully optimized	1
libraries are used with other	1
libraries are also available, such	1
libraries are less efficient in	1
libraries are useful for vectorizing	1
libraries are available in both	1
libraries are loaded at round	1
libraries are loaded into memory	1
libraries are discussed below. Many	1
libraries are highly optimized for	1
libraries are highly optimized, using	1
libraries can be implemented either	2
libraries or shared objects), resource	1
libraries it is never used.	1
libraries with internal multi-threading, e.g.	1
libraries have the best and	1
libraries have CPU dispatching 125	1
libraries have very good performance	1
libraries have features for automatic	1
libraries use dynamic memory allocation	1
libraries when running on the	1
libraries It is not recommended	1
libraries do not use the	1
libraries do not always work	1
libraries where only few of	1
libraries need to be distributed	1
libraries without the need to	1
libraries available use excessive loop	1
libraries Some applications spend most	1
libraries Function libraries can be	1
libraries support 32-bit and 64-bit	1
libraries available. The most important	1
libraries included with the Gnu	1
libraries distributed as object or	1
libraries slower than static link	1
libraries Test Processor memcpy 16kB	1
libraries (*.dll or *.so) that	1
libraries named MKL, VML and	1
libraries (*.lib, *.a) or dynamic	2
libraries contend for the same	1
libraries 113 Number of simultaneous	1
libraries (.dll or .so). There	1
libraries (.lib or .a), but	1
libraries published by Intel have	1
how the if branch in	1
how the microprocessor handles this	1
how the development process can	1
how a cache is organized	1
how a piece of program	1
how to use the AVX	1
how to use the lrint	1
how to use induction variables	1
how to use SafeArray: //	1
how to make the SelectAddMul	1
how to make a variable-size	1
how to make a sensible	1
how to make this work	1
how to make different objects	1
how to make aligned arrays	1
how to do the conversion.	1
how to do this. Unfortunately,	1
how to take advantage of	1
how to test a software	1
how to test for the	1
how to avoid dynamic memory	1
how to avoid them. Some	1
how to avoid hard-to-find errors,	1
how to speed up multiplications	1
how to check for the	1
how to store strings in	1
how to align dynamically allocated	1
how to align arrays. //	1
how to implement the dispatch	1
how to break a dependency	1
how to identify and isolate	1
how to overcome the dangers	1
how to overcome this limitation).	1
how to overcome these disadvantages	1
how to recover in the	1
how you can use it	1
how you can make arrays	1
how this can be implemented	1
how this works and suggests	1
how this works, here's an	1
how compilers and microprocessors work.	1
how compilers work. The C++	1
how efficient the calculation of	1
how many times the function	1
how many times an interrupt	1
how many times each function	1
how many times each part	1
how variables are stored. The	1
how long time it takes.	1
how often a part of	1
how they are declared in	1
how big a structure or	1
how much time it takes.	1
how much time it uses.	1
how much time each part	1
how much memory a function	1
how advantageous vectorization is. Factors	1
how well the compiler optimizes	1
how well the microprocessor can	1
how well it optimizes the	1
how metaprogramming can be used	1
how predictable the branch inside	1
how caches work can be	1
how tortuous and convoluted template	1
code. The library has preprocessing	1
code. The best function libraries	1
code. The name "position-independent code"	1
code. The reason for using	1
code. The second way is	1
code. The bigger vectors do	1
code. The main focus is	1
code. The 128-bit XMM vectors	1
code. The third thing that	1
code. The history of programming	1
code. // Example 8.26a void	1
code. This is not an	1
code. This can be necessary	1
code. This can lead to	1
code. This framework typically uses	1
code. A test setup may	1
code. It is more safe	1
code. It is also possible	1
code. It is therefore a	1
code. It is simply a	1
code. If the number of	1
code. If the latter function	1
code. If you do use	1
code. If you consider making	1
code. In this chapter, I	1
code. In general, there is	1
code. There are two different	1
code. You can assume that	1
code. See ISO/IEC TR18015 Technical	1
code. For example, in interpreted	1
code. For example, many programmers	1
code. For my own research,	1
code. Example: // Example 7.28	1
code. Example: // Example 8.21	1
code. Example: // Example 7.3.	1
code. Example: // Example 8.8a	1
code. Some profilers require that	1
code. An interrupt service routine	1
code. But many programs use	1
code. These workaround methods depend	1
code. All addresses in the	1
code. However, we still want	1
code. Most implementations of C++,	1
code. Each compiler does some	1
code. Many of these directives	1
code. Dynamic memory allocation is	1
code. Dynamic cast The dynamic_cast	1
code. #if is more efficient	1
code. Register ebx is pushed	1
code. Intrinsic functions are primitive	1
code. System code should be	1
code. Compilers and IDE's for	1
code. Furthermore, most C++ compilers	1
code. Metaprogramming can be useful	1
code. Let's look at the	1
code. Storing something in static	1
code. Sometimes the compiler does	1
code. C#, managed C++, and	1
code. Let me explain the	1
code. 7.32 Preprocessing directives Preprocessing	1
code. Inserting your own profiling	1
code. Compiled languages include C,	1
code. 147 14.12 Position-independent code	1
code. (Compile without the Common	1
time. The function library at	1
time. The code in the	1
time. The code cache works	1
time. The time it takes	1
time. The program uses a	1
time. The objects are not	1
time. The expression a &&	1
time. The storage of text	1
time. The delay is significant	1
time. // Example 15.1a. Calculate	1
time. This is a useful	1
time. This is because the	1
time. This is faster if	1
time. This is called square	1
time. A code that does	1
time. A loop counter should	1
time. A variable number of	1
time. A template instance has	1
time. A user interface library	1
time. A part of memory	1
time. A simple way of	1
time. A for-loop or while-loop	1
time. It is more efficient	1
time. It is possible to	1
time. It is faster to	1
time. It can therefore be	1
time. It simply stores the	1
time. There are intrinsic instructions	1
time. There are three ways	1
time. You can avoid the	1
time. You may mirror the	1
time. 4 2 Choosing the	1
time. 4 Performance and usability	1
time. For example, all good	1
time. For example: // Example	1
time. Example: // Example 9.2a	1
time. Some compilers are able	1
time. An experiment where 10	1
time. But this solution can	1
time. These conversions can be	1
time. Integer multiplication takes 11	1
time. Integer division by a	1
time. Therefore, both the executable	1
time. Each code version is	1
time. Loop unrolling In some	1
time. No memory will be	1
time. No universal solution is	1
time. Do not read or	1
time. Optimizing less critical parts	1
time. Another disadvantage of complicated	1
time. Other programs use time	1
time. Shared objects in Unix-like	1
time. Templates make the source	1
time. Dispatch on first call.	1
time. Are objects accessed in	1
time. Text strings and similar	1
time. Single precision division, square	1
time. Interpreted languages are out	1
time. Four typical uses of	1
time. (Of course there is	1
time. (Examples can be found	1
time. Uses debug version of	1
time. Newer processors are sometimes	1
template is a class template	1
template is calling itself in	1
template is similar to a	1
template to get x to	1
template for x to the	1
template function is faster than	1
template function for each different	1
template with many instances makes	1
template has only one instance	1
template because partial template specialization	1
template class is more efficient	1
template class is declared by	1
template class can be used	1
template class which gets information	1
template library (STL) is a	1
template library (STL) if the	1
template rather than a function	1
template template <typename T> static	1
template parameters are always resolved	1
template parameters are replaced by	1
template parameters are exactly the	1
template parameters then the code	1
template parameters differ then you	1
template parameter is always resolved	1
template parameter can also be	1
template parameter should be a	1
template parameter rather than a	1
template feature was never designed	1
template function, m is replaced	1
template instance has its parameters	1
template metaprogramming is the only	1
template metaprogramming // Template for	1
template metaprogramming so complicated? Because	1
template metaprogramming is. // Example	1
template parameter. The order of	1
template parameter. It can call	1
template parameter. If MultiplyBy in	1
template parameter. In other words,	1
template parameter. There is no	1
template parameter. No time is	1
template parameter. Templates may be	1
template parameters. A template with	1
template instances will be joined	1
template method. 7.29 Threads Threads	1
template specialization is allowed only	1
template specialization for N a	1
template specialization for N =	2
template parameters, as example 7.15b	1
template <int N> class powN<true,N>	1
template <int N> static inline	1
template <int m> int MultiplyBy	1
template metaprogramming. Don't panic if	1
template metaprogramming, but this method	1
template metaprogramming, loops are implemented	1
template <typename T, unsigned int	1
template <typename T> static inline	1
template <typename MyChild> class CParent	1
template parameter: // Example 7.42	1
template parameter: template <typename MyChild>	1
template specialization. This is how	1
template specialization, not with a	1
template <bool IsPowerOf2, int N>	1
registers is a scarce resource.	1
registers is very limited. There	1
registers is doubled. This makes	1
registers is extended to 64	1
registers is limited. Example: //	1
registers to test 16 bytes	1
registers and correspondingly two different	1
registers in the CPU. If	1
registers in 64-bit systems. The	1
registers in 64-bit systems. Floating	1
registers The first processors with	1
registers The 128-bit XMM registers	1
registers for the same variables.	1
registers for floating point calculations	1
registers that have to be	1
registers are available in all	1
registers are available in 64-bit	1
registers are available if the	1
registers are accessed very fast.	1
registers are supported by the	1
registers are used. a and	1
registers are used. See page	2
registers are used. Do not	1
registers are used. Conversions of	1
registers are used, there is	1
registers are used, while the	1
registers are extended to 256-bit	1
registers can hold e.g. four	1
registers can benefit from setting	1
registers by default in 64-bit	1
registers by 64, but the	1
registers have long double precision	1
registers when compiling for a	1
registers then the pointer has	1
registers has been increased from	1
registers has been doubled. Thin	1
registers only in the simplest	1
registers rather than in memory.	1
registers rather than on the	4
registers available in 32-bit operating	1
registers available for general purposes	1
registers (see page 105). If	1
registers (see page 27). The	1
registers used. Conversion of an	1
registers instead of main memory.	1
registers are: It is easy	1
registers organized as a register	1
registers had in fact only	1
registers eax, ecx and edx	1
registers anyway. Pure function. __attribute__((const))	1
registers named YMM in the	1
registers ................................................................. 107 12.2 AVX-512	1
registers (6 integer and 8	1
registers (8 float or double	1
registers .......................................................... 107 12.3 Automatic	1
registers (XMM or YMM) which	1
need the next element. I	1
need the updates if the	1
need the 'this' pointer. You	1
need the "override" feature. This	1
need a CPU with the	1
need a smart pointer. If	1
need a 'this' pointer. It	1
need a constructor. A default	1
need to be initialized when	1
need to be converted to	1
need to be distributed to	1
need to be cleaned up	1
need to be cleaned up,	1
need to be deleted. User	1
need to be resized in	1
need to use a container	1
need to use assembly code	1
need to do searches of	1
need to call a polymorphic	1
need to take branch prediction	1
need to take special precautions	1
need to test on several	1
need to check if the	1
need to store intermediate results	1
need to load more than	1
need to link with external	1
need to divide the work	1
need to update the program	1
need to remove all disturbing	1
need to break down dependency	1
need to split up the	1
need to lock a thread	1
need to organize data to	1
need to deallocate the space	1
need for the first two	1
need for special position-independent code	1
need for garbage collection. The	1
need not be passed as	1
need an error message if	1
need only read this first	1
need any non-static access. 7.20	1
need any patch. 131 Note	1
need extra overhead to prevent	1
need assembly code to access	1
need assembly language. C++ takes	1
need separate storage. No function	1
need induction variables to calculate	1
need better support for hard	1
need better backup features, and	1
need conversions between integers and	1
need it. In C++ template	1
need initialization. A copy constructor	1
need modification to compensate for	1
need modification if implemented on	1
need updating in the likely	1
need metaprogramming. The next example	1
need metaprogramming. None of the	1
need relocation. All public functions	1
need relocation, but only self-	1
need relocation at load time.	1
pointers is to make sure	1
pointers of different types cannot	2
pointers to the different versions	1
pointers to the same object.	1
pointers to data in the	1
pointers to data through function	1
pointers to different dynamically allocated	1
pointers to all allocated objects	1
pointers to its variables called	1
pointers to its functions, called	1
pointers to zero whenever the	1
pointers to zero, by setting	1
pointers to objects) are possible	1
pointers and the texts they	1
pointers and for information stored	1
pointers and virtual functions or	1
pointers and addresses in the	1
pointers and references in the	1
pointers and references. Most importantly,	1
pointers and references. Arrays are	1
pointers and references, which can	1
pointers and non-constant references require	1
pointers in one way or	1
pointers that are impossible with	1
pointers are used only for	1
pointers are auto_ptr and shared_ptr.	1
pointers are implemented. Use the	1
pointers are type-casted to a	1
pointers can be useful in	1
pointers can be avoided by	1
pointers or addresses that need	1
pointers or references then tell	1
pointers or references. It is	1
pointers or references: If the	1
pointers if it has incomplete	1
pointers if there are many	2
pointers may be replaced by	1
pointers may not work on	1
pointers A smart pointer is	1
pointers It is rarely possible	1
pointers because in most cases	1
pointers because it cannot rule	1
pointers because this method is	1
pointers do not alias, if	1
pointers In simple cases, a	1
pointers so that the alignment	1
pointers makes it more clear	1
pointers less efficient. Most C++	1
pointers rather than references are:	1
pointers unless they are wrapped	1
pointers requires a division, which	1
pointers requires only an integer	1
pointers are: The syntax is	1
pointers efficient, and that's what	1
pointers ...................................................................................................... 37 7.8 Member	1
pointers Calling a function through	1
pointers .......................................................................................................... 38 7.10 Arrays	1
pointers /vms Fastcall functions /Gr	1
test the different versions alternatingly	1
test the performance under the	1
test the sign of a	1
test the response time under	1
test a software module for	1
test and setting the priority	1
test in the test program	1
test for the availability of	1
test that measures the speed	1
test // Time difference for	1
test // Critical function to	1
test // (time after) -	1
test // Repeat NumberOfTests times	1
test or manipulate all the	1
test on several different CPUs	1
test this is to make	1
test when software uses CPU	1
test data and measure how	1
test data should contain a	1
test data instead of user	1
test program is likely to	1
test program that can call	1
test program that calls the	1
test program itself and recompile	1
test because the total amount	1
test all branches for correctness.	1
test but also the time	1
test should be performed with	1
test should preferably be done	1
test should include not only	1
test each function or class	1
test 16 bytes at a	1
test bits 0 - 30	1
test several different algorithms in	1
test run with a profiler	1
test sign bit // u.d	1
test their functionality. This will	1
test data. The test data	1
test data. That being said,	1
test feature into the code	1
test feature called performance monitor	1
test loop. The time that	1
test purposes. The const keyword	1
test purposes. If the code	1
test situations to avoid that	1
test tool for using the	1
test tool for details (www.agner.org/optimize/testp.zip).	1
test tool can be used	1
test tool can set up	1
test tool supports both Intel,	1
test () { C1 Object1;	1
test () { CChild1 Object1;	1
test () { __declspec(__align(64)) double	1
test server. Use large data	1
test examples. The table can	1
test examples. You cannot expect	1
test setup may look like	1
test setup but slow or	1
test theory. Advice on how	1
test finishes in a short	1
new and return a pointer	1
new and better processor appears	1
new and delete is to	1
new and delete to allocate	1
new and delete or with	1
new and delete or malloc	1
new and delete (or malloc	1
new and delete, and often	1
new and delete, or malloc	1
new or malloc is typically	1
new or malloc. Handles to	1
new or malloc) is necessarily	1
new compiler which is similar	1
new memory block every time	2
new vector size often have	1
new instruction set opens the	1
new cache line in both	1
new floating point addition every	1
new object is not necessarily	1
new object of a class	1
new version of the library.	1
new version for marketing reasons.	1
new version without the need	1
new version causes problem that	1
new value of i which	1
new value of temp before	1
new objects can be added	1
new software project, it is	1
new branch of code is	1
new branch only when a	1
new register size only when	1
new register size comes only	1
new instructions to the instruction	1
new instructions can make certain	1
new function. The stack is	1
new versions of their 23	1
new processor enters the market	1
new element in the list	1
new model comes on the	1
new addition before the preceding	1
new bigger memory block is	1
new bigger memory block and	1
new bigger memory block. This	1
new relevant information. 1.1 The	1
new instance of the data	1
new instance of the template	1
new generation of CPUs increased	1
new features to each new	1
new block. Any pointers to	1
new update or even telling	1
new one. The existing object	1
new one. I have provided	1
new physical register to temp	1
new features. User feedback should	1
new features. Take user feedback	1
new context. It is possible	1
new today will be mainstream	1
new insight can lead to	1
systems and a 64-bit version	1
systems and in 32-bit systems	1
systems and 8 bytes in	1
systems and 64 bits in	1
systems and programs compiled for	1
systems and fourteen in 64-bit	1
systems and fourteen integer registers	1
systems and sixteen in 64-bit	2
systems that have floating point	1
systems that do not support	1
systems that allows bigger segments	1
systems are not always avoiding	1
systems are not backwards compatible	1
systems are most efficient for	1
systems are using the same	1
systems are common, and there	1
systems can also be used	1
systems can improve the performance	1
systems or 64-bit integers in	1
systems if the program uses	1
systems by using a 64-bit	1
systems with only one CPU	1
systems with multiple CPU cores	1
systems with big-endian storage. Example	1
systems with big-endian storage. Optimizing	1
systems than it is on	1
systems may have big endian	1
systems you have to replace	1
systems have the following disadvantages	1
systems have a graphics processing	1
systems have several advantages over	1
systems use position-independent code by	1
systems use segmentation of the	1
systems when the SSE2 or	1
systems will dominate in the	1
systems because of the needs	1
systems should be tested in	1
systems do not have inherent	1
systems also have a dedicated	1
systems also have a physics	1
systems we can use 64-bit	1
systems often use position-independent code	1
systems need better support for	1
systems available today. You may	1
systems unless the SSE2 (or	1
systems give almost identical performance	1
systems Windows, Linux, Mac Windows,	1
systems gives rise to some	1
systems allow you to define	1
systems allow up to fourteen	1
systems allow lazy binding of	1
systems normally use the so-called	1
systems DOS and Windows 3.x.	1
systems lack the necessary functions	1
systems ............................................................................. 158 18 Overview	1
systems disappears when running in	1
systems Microcontrollers used in small	1
systems (but not in some	1
user is likely to experience.	1
user is far from the	1
user is waiting for response.	1
user to turn off the	1
user to restart the computer	1
user and a waste of	1
user and prevent legitimate backup	1
user can see the delay.	1
user if such a response	1
user may not need the	1
user will be unable to	1
user will have an up-to-date	1
user has a virus scanner	1
user has to turn off	1
user has to reinstall a	1
user but only show a	1
user access rights. Software should	1
user must install a large	1
user never uses the new	1
user data. A database can	1
user actually has to wait	1
user interface is not in	1
user interface is obtained by	1
user interface and use a	1
user interface and other system-	1
user interface can use a	1
user interface than on the	1
user interface library for Windows	1
user interface library can be	1
user interface library may be	1
user interface elements that come	1
user interface framework must be	1
user interface framework Most of	1
user interface etc., can be	1
user interface framework........................................................................... 14 2.8	1
user interface (OnIdle in Windows	1
user might experience unacceptably long	1
user input in order to	1
user input or network resources.	1
user input or reading disk	1
user input never exceeds an	1
user who has to invest	1
user gets the latest version	1
user input. The time used	1
user input. Many programs spend	1
user input. (In Windows you	1
user interface. A console mode	1
user interface. It is 102	1
user interface. Applications that are	1
user interface. Otherwise the program	1
user interfaces and interfaces to	1
user interfaces from scratch. This	1
user feedback seriously. User complaints	1
user expects an immediate response	1
user expects immediate responses to	1
user settings are lost. It	1
user friendly compiler with many	1
user interface, another thread can	1
user friendly. It is free	1
these and handle text strings	1
these are hardly relevant to	1
these are incompatible with floating	1
these time consuming updates may	1
these functions is higher for	1
these functions are missing in	1
these functions have no check	1
these instruction sets. The program	1
these instruction sets. Most compilers	1
these cache lines belong to	1
these integer operations do not	1
these example containers in cases	1
these compilers that a user-defined	1
these compilers can be used	1
these two functions are unrelated	1
these two versions and turn	1
these two values is closest	1
these two gives the chosen	1
these also treat non-Intel CPUs	1
these variables to zero and	1
these table lookup operations slow	1
these elements with column 28	1
these address calculations are done	1
these operating systems can also	1
these libraries have very good	1
these operations are very fast.	1
these instructions require that the	1
these eight elements will go	1
these addresses to function names.	1
these problems is quite simple	1
these problems are usability issues,	1
these methods to improve efficiency.	1
these methods are time consuming.	1
these methods are based on	1
these methods then the critical	1
these examples are optimized for	1
these examples we are using	1
these data. It is very	1
these types to integers of	1
these directives are compiler-specific. You	1
these directives do not always	1
these languages have the disadvantage	1
these variables. The negative effects	1
these conditions is not met	1
these calculations. Division of a	1
these classes. Size of each	1
these purposes. This memory space	1
these purposes. Unfortunately, the standard	1
these instructions. Function Assembly name	1
these problems. More details about	1
these disadvantages when C++ is	1
these manuals are always available	1
these manuals can be used	1
these guidelines by using a	1
these obstacles and to know	1
these methods. If you are	1
these reasons, the preferred language	1
these considerations. It is discussed	1
these categories: File input/output Graphics	1
they are in fact doing	1
they are in fact represented	1
they are not necessary if	1
they are not able to	1
they are used in so	1
they are no longer used.	1
they are often mispredicted. A	1
they are sure to have	1
they are sure to point	1
they are integers or floating	1
they are used. It is	1
they are used. Example: //	1
they are used. Such variables	1
they are members of the	1
they are never used at	1
they are declared in a	1
they are declared whenever an	1
they are predicted most of	1
they are executed. However, the	1
they are equally efficient. If	1
they are resolved before the	1
they are available, i.e. in	1
they are deallocated when the	1
they are needed, or they	1
they are running. Such frameworks	1
they are guaranteed to wrap	1
they are long. This is	1
they are disabled will crash	1
they are uninitialized or come	1
they are created. Far Systems	1
they are wrapped into a	1
they are unavoidable. It may	1
they are uninitialized, if pointer	1
they can be signed or	1
they can block the execution	1
they may be swapped to	1
they have put the whole	1
they point to are constant.	1
they point to become invalid,	1
they do not use branches,	1
they cannot be mixed with	1
they cannot be ruled out	1
they cannot use the same	1
they cannot make algebraic reductions	1
they cannot do. All the	1
they always keep up with	1
they always evaluate both operands.	1
they must be inside the	1
they don't need any non-static	1
they were able to do	1
they fail to eliminate common	1
they come from operators that	1
they waste a lot of	1
they contain is provided as	1
they appear in the class	1
they appear in the source	1
they are. However, there are	1
they are. Declare the function	1
they otherwise would be predicted	1
without the static keyword: //	1
without the register keyword. The	1
without the need to store	1
without the need to load	1
without the need to update	1
without the SSE2 instruction set,	1
without the sign bit. The	1
without the risk of losing	1
without the -fpic option. Then	1
without the Common Language Runtime,	1
without the FMA4 instruction set.	1
without an operating system this	1
without an IDE. Free trial	1
without CPU dispatching. Test if	1
without cache MOVNTQ _mm_stream_pi SSE	1
without cache MOVNTDQ _mm_stream_si128 SSE2	1
without cache MOVNTPD _mm_stream_pd SSE2	1
without cache MOVNTPS _mm_stream_ps SSE	1
without cache MOVNTI _mm_stream_si32 SSE2	1
without using the virtual table.	1
without using the normal return	1
without using exceptions is to	1
without using exceptions. The function	1
without any of these instruction	1
without any option that limits	1
without any cost in performance.	1
without SSE2 typically takes 40	1
without dynamic memory allocation. Dynamic	1
without AVX using CPU dispatching	1
without AVX support then call	1
without AVX support. There is	1
without information about function names	1
without problems if the necessary	1
without caching is advantageous if,	1
without position-independent code when you	1
without checking all the array	1
without adding any extra code.	1
without loading a cache line.	1
without loading a cache line:	1
without help of the compiler	1
without -fpic is much faster,	1
without -fpic in 32-bit Linux	1
without -fpic in 64 bit	1
without -fpic because the relocations	1
without polymorphism or with compile-time	1
without specifying the size. Integers	1
without reducing the performance because	1
without invoking the overhead of	1
without generating overflow. Likewise, it	1
without AVX, as explained on	1
without worrying too much about	1
without restrictions. A GNU Free	1
without effectively preventing illegitimate copying.	1
without jeopardizing safety, you may	1
without taking cache effects into	1
without paying the performance costs.	1
without returning. F1 is prevented	1
without discriminating between CPU brands	1
useful to make the most	1
useful to make a variable	1
useful to copy the table	1
useful to put file access	1
useful to put time-consuming tasks	1
useful to know how a	1
useful to turn off the	1
useful to roll out a	1
useful to study the code	1
useful to isolate the hot	1
useful in the situation where	1
useful in some cases, for	1
useful in test situations to	1
useful in compiled languages such	1
useful in programs with many	1
useful in situations where the	1
useful in situations where automatic	1
useful in situations like example	1
useful in 32- bit mode,	1
useful for the programmer to	1
useful for library functions. The	1
useful for many different purposes.	1
useful for making data more	1
useful for making plug-ins that	1
useful for large libraries where	1
useful for copy constructors and	1
useful for optimizing code, as	1
useful for Boolean vector operations.	1
useful for calling from other	1
useful for checking how well	1
useful for testing multiple conditions	1
useful for finding the hot	1
useful for finding the numerically	1
useful for finding problems that	1
useful for random number generators.	1
useful for supporting multiple platforms	1
useful for preventing program errors	1
useful for assigning different priorities	1
useful for investigating performance problems.	1
useful for vectorizing mathematical code.	1
useful for identifying hot spots	1
useful if the library is	1
useful if the subexpression c+b	1
useful on servers that run	1
useful when the number of	1
useful when the amount of	1
useful when doing calculations on	1
useful when testing which version	1
useful because it gives more	1
useful performance monitor counter in	1
useful way of making sure	1
useful way to keep track	1
useful methods for exploiting fine-grained	1
useful mathematical functions. A lot	1
useful source of such container	1
useful whenever a function of	1
useful discussions about code optimization.	1
even the same level-1 cache.	1
even the smallest list of	1
even a single constant with	1
even a linear search, is	1
even a thousand times lower;	1
even of functions that are	1
even in the most critical	1
even for double precision. You	1
even for simple tasks. Sometimes	1
even for arrays bigger than	1
even for programs implemented in	1
even be a million times	1
even be used on completely	1
even if the program is	1
even if the CPU clock	1
even if the variable is	1
even if the user never	1
even if the processor is	1
even if the dispatched function	1
even if a and b	1
even if no exception ever	1
even if they are never	1
even if they otherwise would	1
even if a, b, c	1
even on such small devices,	1
even have a false vendor	1
even have an operating system.	1
even more important to economize	1
even more powerful solution is	1
even when the function or	1
even when it is not	1
even when it has not	1
even when it would be	1
even when accessed from the	1
even when shared objects are	1
even when their live ranges	1
even when just a single	1
even integer is returned. There	1
even faster to make log2	1
even faster way to limit	1
even without the register keyword.	1
even add dummy elements at	1
even smaller by declaring it	1
even compatible with different versions	1
even though the logical register	1
even though the latter has	1
even though the rules of	1
even though the CPU-type is	1
even though it is doing	1
even though it could free	1
even allocate more memory blocks	1
even swapped to disk. Software	1
even worse, it can overwrite	1
even temporarily. This is intended	1
even telling the user to	1
even matters, which few programs	1
even worse kind of error	1
sure the code has no	1
sure the compiler recognizes it	1
sure the object is deleted	1
sure the value of the	1
sure the variable is stored	1
sure the file is closed.	1
sure the arrays are sufficiently	2
sure the result is valid.	1
sure the information is utilized	1
sure the startup code and	1
sure to be loaded at	1
sure to have the same	1
sure to make a misprediction	1
sure to point to a	1
sure to work on all	1
sure to produce the same	1
sure to distinguish these two	1
sure that the code is	1
sure that the compiler takes	1
sure that the CPU supports	1
sure that the most critical	1
sure that the pointer does	1
sure that the table is	1
sure that the elements are	1
sure that the response time	1
sure that the beginning of	1
sure that the declaration class	1
sure that the original object	1
sure that a value is	1
sure that a variable is	1
sure that it will not	1
sure that functions which are	1
sure that all destructors for	1
sure that all destructors are	1
sure that one function can	1
sure that no object is	1
sure that no variable or	1
sure that no overflow can	1
sure that variables that are	1
sure that they always keep	1
sure that they are. Declare	1
sure that overflow never occurs,	1
sure that certain calculations are	1
sure that everything that has	1
sure it is only calculated	1
sure it is initialized or	1
sure it works well on	1
sure not to mix signed	1
sure you are using the	1
sure you need it. In	1
sure you know what you	1
sure its size is a	1
sure allocated resources are cleaned	1
sure whether the arrays are	1
sure everything that is allocated	1
method is to wrap the	1
method is that the microprocessor	1
method is faster if the	1
method is faster because the	1
method is useful for random	1
method is useful for preventing	1
method is useful if the	1
method is explained on page	1
method is advantageous if the	1
method is likely to work	1
method is described in more	1
method is described below. Make	1
method is fastest on different	1
method is inefficient, however, when	1
method is illustrated in example	1
method is extremely complicated and	1
method is somewhat more complicated	1
method is safer. Type casting	1
method of doing floating point	2
method of induction variables can	1
method of bounds checking is	1
method of storing data without	1
method of storing strings in	1
method to use depends on	1
method in example 14.28 can	1
method in 32-bit mode so	1
method for all unknown processors	1
method for transferring composite objects	1
method that is used is	1
method that gives the simplest	1
method that delays execution by	1
method can be used to	1
method can be used for	1
method can be used if	1
method can be extended to	1
method if memory access is	1
method with multiple memory blocks	1
method may be at a	1
method may be faster than	1
method you use is a	1
method only for big objects	1
method used in example 15.1b	1
method used here is the	1
method should be longer than	1
method using InstructionSet(): // Example	1
method also involves the risk	1
method doesn't work for class	1
method works with all compilers.	1
method works only for powers	1
method Function inlining x-xxxx--x Constantfolding	1
method requires that you can	1
method requires OS support and	1
method described above can still	1
method currently used for calculating	1
method unfavorable, unless the value	1
always the same. The maximum	1
always to tell the compiler	1
always to specify the compiler	1
always for application-specific code. If	1
always be a power of	1
always as good as expected.	1
always use the safe formula	1
always use this number of	1
always use standardized installation tools.	1
always has the value it	1
always possible to access a	1
always takes memory space, even	1
always stored together in an	1
always 0 or 1 and	1
always available from www.agner.org/optimize. Copyright	1
always work well on AMD	1
always calls the same version	1
always calculated with the same	1
always advantageous to use vector	1
always run slower than a	1
always 1 if nonzero and	1
always able to predict correctly	1
always end with a non-recursing	1
always transferred as pointers unless	1
always goes the same way	1
always points to an object	1
always #pragma vector always Optimize	1
always rely on the compiler	1
always position-independent because this is	1
always inlined even when it	1
always true or always false:	1
always keep up with the	1
always apply to arrays that	1
always fully optimized. Library functions	1
always resolved at compile time	1
always resolved at compile time.	1
always evaluate both operands. Nevertheless,	1
always avoiding this. The Intel	1
always select the most efficient	1
always belong to the thread	1
always enabled in 64-bit mode.	1
always true. The program may	1
always one, and only one,	1
always chooses the least recently	1
always work. Data alignment. __declspec(align(16))	1
always behave according to the	1
always Optimize function #pragma optimize(...)	1
always accurate, however, and it	1
always comparable to a clock	1
always true/false Loopunrolling x-xxxx--x Profile-guided	1
always sequential, and you cannot	1
always compete for the same	1
always false: // Example 8.10a	1
always normalized, if possible, so	1
always optimal, though. In some	1
always happy to receive new	1
access the data object through	1
access the system database in	1
access the file until the	1
access the saved variable members	1
access is the biggest time-consumer	1
access is a bottleneck. Organize	1
access is more important than	1
access is faster if the	1
access a floating point variable	1
access a variable in parts,	1
access a file that has	1
access a public data object:	1
access a multidimensional array sequentially.	1
access to the same resource	1
access to the most used	1
access to the sign bit,	1
access to the container. Can	1
access to a file is	1
access to all of these	1
access to array elements. The	1
access to hardware interfaces and	1
access to individual array elements	1
access to virus attacks and	1
access to low-level optimizations. Most	1
access and you want to	1
access and memory access are	1
access and cache size. If	1
access and network access in	1
access in a separate thread	1
access in separate threads so	1
access are critical time consumers.	1
access can be arranged in	1
access or cache access rather	1
access it the first time.	1
access by each thread. Pointers	1
access an object after it	1
access an element in list,	1
access x as an integer.	1
access may be fast in	1
access any non-static data members	2
access rather than CPU time.	1
access these instructions. Function Assembly	1
access part of a variable,	1
access times cannot be controlled.	1
access Some application programs use	1
access non-sequential which makes the	1
access Reading or writing a	1
access Accessing data from RAM	1
access internal variables and internal	1
access ............................................................................................. 87 9.1 Caching	1
access ...................................................................................................... 21 3.13 Memory	1
access 9.1 Caching of code	1
access patterns containing multiple streams	1
access rights. Software should use	1
access patterns. This can cause	1
void test () { C1	1
void test () { CChild1	1
void test () { __declspec(__align(64))	1
void SomeFunction (int n) {	1
void Func () { static	1
void SelectAddMul(short int aa[], short	6
void Disp() { cout <<	4
void StoreVector(void * d, __m128i	3
void Func1 (int a[], int	1
void CriticalFunction(); ... // Use	1
void CriticalInnerFunction () { //	1
void TransposeCopy(double a[SIZE][SIZE], double b[SIZE][SIZE])	2
void transpose(double a[SIZE][SIZE]) { //	2
void Plus2 (int * p)	1
void FuncA (int * p)	1
void F1() { C1 x;	1
void F1() throw(); This allows	1
void f(); }; class C1	1
void f(); }; void g()	1
void Func(int a[], int &	2
void Func2() { int list[100];	1
void Hello() { cout <<	2
void Disp(); void Hello() {	1
void NotPolymorphic(); virtual void Disp();	1
void NotPolymorphic(); }; // Any	1
void F3(bool y) { if	1
void F3(bool y) { union	1
void FuncB (int & r)	1
void g() { C1 obj1;	1
void F0() { try {	1
void AddTwo(int * __restrict aa,	1
void SelectAddMul_dispatch(short int aa[], short	1
void F2(float x[]); void F3(bool	1
void StoreNTD(double * dest, double	1
void StoreVectorA(void * d, __m128i	1
void F1(int x[]); void F2(float	1
void MathLoop() { const int	1
void FUNCNAME(short int aa[], short	1
void FuncType(short int aa[], short	1
void xplus2() { The effect	1
void Func() { S1 x,	1
void DelayFiveSeconds() { seconds =	1
16 is actually hidden behind	1
16 is required. The Intel	1
16 to the integer value	1
16 to fit the biggest	1
16 in column 28, the	1
16 for a discussion of	1
16 for SSE2, preferably 32	1
16 or 32 bits (rarely	1
16 will not only be	1
16 float Exp(float x) {	1
16 clock cycles, depending on	1
16 4 unsigned short int	1
16 4 64 MMX int	1
16 4 short int 64	1
16 8 or 16 Table	1
16 8 unsigned short int	1
16 8 short int 128	1
16 8 128 SSE2 int	1
16 bit platform __GNUC__ and	1
16 unsigned char 128 Iu8vec16	1
16 16 32 8 32	1
16 16 256 AVX2 int	1
16 16 256 Vec32uc Vec16s	1
16 32 8 32 8	1
16 bits of the 32-bit	1
16 bits of the result.	1
16 bits each, four integers	1
16 bits wide, while an	1
16 0 65535 uint16_t unsigned	1
16 (see below). The 256-bit	1
16 bytes by adding one	1
16 bytes at a time	1
16 bytes should be stored	1
16 bytes without cache MOVNTDQ	1
16 bytes without cache MOVNTPD	1
16 bytes without cache MOVNTPS	1
16 128 SSE2 short int	1
16 1 byte = char	1
16 256 AVX2 int 32	1
16 256 Vec32uc Vec16s Vec16us	1
16 char 128 Is8vec16 Vec16c	1
16 Table 7.2. Alignment of	1
16 512 AVX512 double 64	1
16 512 AVX512 long long	1
16 lines in a 512	1
16 bytes. Some CPUs have	1
16 Testing speed Testing the	1
16 Testing speed.............................................................................................................. 153 16.1	1
16 __declspec( align(16)) __attribute(( aligned(16)))	1
16 SSSE3 _mm_perm_epi8 32 1	1
16 3.2 Use a profiler	1
16 3.3 Program installation ..................................................................................................	1
16 3.1 How much is	1
16 -32768 32767 int16_t int	1
16 XOP, AMD only _mm_permutevar_ps	1
SSE2 is the minimum supported	1
SSE2 is always enabled in	1
SSE2 is available: // Example	1
SSE2 and later instruction sets.	1
SSE2 // SSE4.1 // AVX2	1
SSE2 or later instruction set	3
SSE2 or later instruction set.	1
SSE2 or x64 141 #include	1
SSE2 or later. Example: //	1
SSE2 not supported"); return; }	1
SSE2 int 32 4 128	1
SSE2 instruction set is not	1
SSE2 instruction set is supported	2
SSE2 instruction set is used.	1
SSE2 instruction set is particularly	1
SSE2 instruction set is enabled.	3
SSE2 instruction set is available.	2
SSE2 instruction set is available,	1
SSE2 instruction set is enabled	1
SSE2 instruction set is enabled:	1
SSE2 instruction set if possible.	1
SSE2 instruction set makes floating	1
SSE2 instruction set (or higher)	1
SSE2 instruction set (requires a	1
SSE2 instruction set (128 vectors	1
SSE2 instruction sets have certain	1
SSE2 instruction set, and a	1
SSE2 instruction set, as listed	1
SSE2 instruction set, but it	1
SSE2 instruction set, one for	1
SSE2 instruction set: // Example	1
SSE2 float 32 4 128	1
SSE2 version of most library	1
SSE2 version int CriticalFunction_SSE2(int parm1,	2
SSE2 long long 64 2	1
SSE2 short int 16 8	1
SSE2 128 bit integer and	1
SSE2 supported return &CriticalFunction_SSE2; }	1
SSE2 supported CriticalFunction = &CriticalFunction_SSE2;	1
SSE2 typically takes 40 clock	1
SSE2 intrinsic functions // Function	1
SSE2 #include <emmintrin.h> // Define	1
SSE2 char 8 32 256	1
SSE2 Table 9.2. Cache control	1
SSE2 Store 8 bytes without	1
SSE2 Store 16 bytes without	1
SSE2 (or later) instruction set	1
SSE2 emmintrin.h SSE3 pmmintrin.h Suppl.	1
out the loop and reorganize:	1
out the loop by the	1
out the loop by two	1
out the loop by n	1
out the loop by four,	1
out the calculation of the	1
out the sign bit to	1
out the sign bit so	1
out the possibility that the	1
out the possibility that a	1
out the theoretical possibility that	1
out a loop if this	1
out a big loop then	1
out of the innermost loop	1
out of the loop. Example	1
out of the question when	1
out of a function in	1
out of a loop if	1
out of a function. Avoid	1
out of order or do	1
out of range is possibly	1
out of range and we	1
out of range } }	1
out of range (see page	1
out of range printf(Greek[n]); }	1
out of F1 without returning.	1
out of order. See page	1
out of order. Long dependency	1
out of range"; } else	1
out of range"; 134 }	1
out of range. The next	1
out of range. This may	1
out of range"); or better,	1
out to be too small.	1
out to be too small,	1
out or if there is	1
out if exceptions can be	1
out by the program logic.	1
out by 4 float a[100];	1
out by 2. (See page	1
out with all relevant optimization	1
out loop by 16 to	1
out loop by eight to	4
out which one is fastest.	1
out multiple bits with the	1
out some typical sources of	1
out whether it is advantageous	1
out sign bit: absvalue =	1
out results printf("\n%2i %10I64i", i,	1
out aliasing (see page 78).	1
out loop-invariant code containing pure	1
out independently of other tasks	1
following compiler versions were tested:	1
following example shows the same	1
following example shows the principle	1
following example shows a code	1
following example shows first the	1
following example shows how to	6
following example shows what the	1
following example illustrates the difference	1
following example illustrates such a	1
following example illustrates how to	1
following example illustrates this. My	1
following example explains why bookkeeping	1
following example transposes a matrix	1
following example converts a zero-terminated	1
following table lists the available	1
following table summarizes the different	1
following example, which calculates the	1
following assembly code from example	2
following list points out some	1
following methods may be used	1
following methods could possibly be	1
following examples explain how metaprogramming	1
following example: // Example 8.17	1
following algorithm is used inside	1
following conditions are met: the	1
following conditions are satisfied: 1.	1
following way. The first count	1
following way. If the first	1
following way. First you compile	1
following explanation if you are	1
following sections describe some of	1
following table. Type size, bytes	1
following disadvantages compared to 32	1
following guidelines can be used	1
following considerations should be taken	1
following techniques can be considered	1
following reasons: The function call	1
following reasons: The size of	1
following reasons: Each object is	1
following way: // Example 7.40b	1
following way: There are two	1
following way: bool a, b,	1
following cases: If part of	1
following alternatives: Make the function	1
following steps to access a	1
following work-around can be used:	1
following features: The code section	1
following sections. 3.3 Program installation	1
following solutions, depending on what	1
system is often more reliable	1
system is likely to fail	1
system is based on BSD,	1
system to avoid running two	1
system to generate an interrupt,	1
system to swap memory to	1
system and CPU hardware. Porting	1
system and choose the appropriate	1
system for support of the	1
system can be time consuming	1
system can be particularly time	1
system or libraries that come	1
system if the array element	1
system with only one logical	1
system code is not separated	1
system code is critical when	1
system code or in a	1
system may not load all	1
system may have a function	1
system may store the information	1
system may supply such a	1
system this is the job	1
system has support for XMM	1
system functions (e.g. GetLogicalProcessorInformation in	1
system which redirects it to	1
system performance options. I don't	1
system makes sure that all	1
system call (e.g. GetProcessAffinityMask in	1
system rather than by individual	1
system code. In this chapter,	1
system code. Dynamic memory allocation	1
system code. System code should	1
system (see page 107). Agner's	1
system calls (e.g. IsProcessorFeaturePresent in	1
system thread scheduler. This can	1
system All newer microprocessors in	1
system running in 32-bit or	1
system resources .......................................................................................... 21 3.12	1
system resources Writes to a	1
system instead of using exception	1
system core and high-priority threads	1
system database in Windows. It	1
system calls. These are of	1
system devices and using advanced	1
system programming, but in applications	1
system modules. 3.12 Network access	1
system API and the application	1
system database, and other extra	1
system kernel in the so-called	1
system color settings and different	1
system crash. Furthermore, it is	1
system forbids the user to	1
system standards. Such schemes are	1
system dependent and therefore not	1
system breakdown. Many copy protection	1
32 and the 512-bit ZMM	1
32 and 64 bits are	1
32 for an explanation of	1
32 for AVX. 5. The	1
32 = 28. This means	1
32 with j << 5.	1
32 instruction set is supported	1
32 2 2 int unsigned	1
32 2 64 MMX long	1
32 4 int 128 Is32vec4	1
32 4 unsigned int 128	1
32 4 64 2 32	1
32 4 128 SSE2 long	1
32 4 128 SSE double	1
32 8 64 4 unsigned	1
32 8 64 4 64	1
32 8 32 8 64	1
32 8 256 AVX double	1
32 8 256 AVX2 long	1
32 bit code 64 bit	1
32 bit Linux Shared objects	1
32 bit mode and mostly	1
32 bit mode SSE 128	1
32 bit platform not _WIN64	1
32 bit mode. Some 64-bit	1
32 bit systems: The number	1
32 bit systems: Pointers, references,	1
32 bit offsets). Example: //	1
32 64 Iu32vec2 64 1	1
32 16 512 AVX512 double	1
32 16 512 AVX512 long	1
32 bits of a double	1
32 bits of a 64-bit	2
32 bits of a[i] and	1
32 bits in 32-bit systems	1
32 bits in x86 systems).	1
32 bits at a time,	1
32 bits while a double	1
32 bits each, or two	1
32 bits (rarely 64). You	1
32 0 232-1 uint32_t unsigned	1
32 1 byte = char	1
32 sets can be used,	1
32 sets 4 ways. This	1
32 256 AVX2 short int	1
32 char 256 Vec32c unsigned	1
32 results when applied to	1
32 bits. This makes data	1
32 bits, so you can	1
32 7.4 Enums ...................................................................................................................... 33	1
32 AND-operations in just one	1
32 bytes). This has a	1
32 16.4 65 65 33	1
32 -231 231-1 int32_t long	1
file is faster than random	1
file is closed. The same	1
file is closed. The file	1
file of every version. For	1
file to a floppy disk.	1
file and the derived class	1
file and all the dynamic	1
file and one or more	1
file and compiled for the	1
file and copies them into	1
file in a memory buffer	1
file in simple cases. Database	1
file in exclusive mode, and	1
file for the instruction set	1
file for a higher instruction	1
file for each line written.	1
file for InstructionSet() #include "asmlib.h"	2
file that has been accessed	1
file can be wrapped into	1
file by calling WritePrivateProfileString, which	1
file on a hard disk	1
file than in the big	1
file when static linking is	1
file will give you access	1
file will remain locked after	1
file from the linker. The	1
file has been copied to	1
file access is more important	1
file access and network access	1
file access in a separate	1
file access or cache access	1
file needs to be distributed	1
file until the computer is	1
file containing numerical data is	1
file includes the addresses of	1
file input and output should	1
file MMX mmintrin.h SSE xmmintrin.h	1
file tells the address of	1
file format. The intermediate files	1
file format is not standardized.	1
file format instead of the	1
file level, and the Digital	1
file input/output operations. It can	1
file stdint.h or inttypes.h is	1
file formats should be used.	1
file timingtest.h from www.agner.org/optimize/testp.zip or	1
file dvec.h vectorclass.h Supported compilers	1
file mathimf.h that come with	1
file stub. If different versions	1
file disassembler. Note that the	1
file http://www.agner.org/optimize/asmlib.zip contains complete code	1
file level. My recommendation for	1
file /Fm Generate optimization report	1
file formats. Comments All of	1
programming is so complicated that	1
programming are dominating. At least,	1
programming can be an efficient	1
programming as a means of	1
programming will typically get the	1
programming without paying the performance	1
programming error known as memory	1
programming work automatically. The development	1
programming language is a compromise	1
programming language is best suited	1
programming language is implemented. The	1
programming language and a basic	1
programming language and development tool	1
programming language and interface frameworks.	1
programming language that can be	1
programming language when the optimization	1
programming language defines an algorithm	1
programming language Before starting a	1
programming language ............................................................................... 8 2.5	1
programming are: Non-static member functions	1
programming errors that would otherwise	1
programming errors associated with dynamic	1
programming languages and their implementations	1
programming languages that do not	1
programming languages are implemented with	1
programming languages can be quite	1
programming languages as well. This	1
programming languages use an intermediate	1
programming style that doesn't automatically	1
programming style if it is	1
programming style has both positive	1
programming manuals from Intel: "IA-32	1
programming principles in order to	1
programming .......................................................................................... 150 15 Metaprogramming	1
programming languages, but also less	1
programming languages, such as Java,	1
programming languages, operating systems, and	1
programming languages, profiling and debugging.	1
programming languages. This section discusses	1
programming languages. www.yeppp.info And here	1
programming style. The time consumption	1
programming style. The advantages of	1
programming style. It is often	1
programming style. Some compilers make	1
programming error. The allocated memory	1
programming language, e.g. C++, and	1
programming questions to me. You	1
programming questions if you cannot	1
programming experience before trying the	1
programming constructs are costly and	1
programming textbooks recommend that every	1
programming textbooks recommend object oriented	1
programming nowadays stress the importance	1
programming practice, of course, because	1
programming Device drivers, interrupt service	1
dynamic memory allocation is used,	1
dynamic memory allocation is negligible	1
dynamic memory allocation in an	1
dynamic memory allocation for all	1
dynamic memory allocation can be	1
dynamic memory allocation with new	1
dynamic memory allocation when the	1
dynamic memory allocation using new/delete	1
dynamic memory allocation are: The	1
dynamic memory allocation are: int	1
dynamic memory allocation (new and	1
dynamic memory allocation. This method	1
dynamic memory allocation. There is	1
dynamic memory allocation. You should	1
dynamic memory allocation. See page	1
dynamic memory allocation. Some programming	1
dynamic memory allocation. Dynamic memory	1
dynamic memory allocation. Do not	1
dynamic memory allocation. Container classes	1
dynamic library is loaded cannot	1
dynamic library is resolved when	1
dynamic library can be called	1
dynamic library can be useful	1
dynamic library can be updated	1
dynamic library can change the	1
dynamic library than in a	1
dynamic library requiring the same	1
dynamic array of n floats:	1
dynamic libraries are loaded at	1
dynamic libraries are loaded into	1
dynamic libraries need to be	1
dynamic libraries without the need	1
dynamic libraries Function libraries can	1
dynamic libraries (*.dll or *.so)	1
dynamic libraries contend for the	1
dynamic libraries (.dll or .so).	1
dynamic allocation and deallocation of	1
dynamic linking is used, but	1
dynamic linking makes the entire	1
dynamic linking cannot be avoided,	1
dynamic linking are: Static linking	1
dynamic linking are: 146 Multiple	1
dynamic link library (*.dll or	2
dynamic link library (DLL) which	1
dynamic link libraries slower than	1
dynamic link libraries, also called	2
dynamic libraries. The dynamic libraries	1
dynamic allocation. The heap can	1
dynamic versions. It is recommended	1
dynamic linker. The delay on	1
dynamic linking. The file http://www.agner.org/optimize/asmlib.zip	1
dynamic libraries............................................................................ 146 14.12 Position-independent	1
part of the code is	1
part of the code to	1
part of the code and	1
part of the code can	4
part of the code together	1
part of the code still	1
part of the code only.	1
part of the memory is	1
part of the program is	2
part of the program that	1
part of the program are	1
part of the program -	1
part of the program then	1
part of the program has	1
part of the program contains	1
part of the program happen	1
part of the instruction code.	1
part of the library that	1
part of the operating system	1
part of the optimization job.	1
part of the code. It	1
part of the memory. The	1
part of the program. The	1
part of the program. This	2
part of the code, then	1
part of the code, which	1
part of the program, it	1
part of the fraction. For	1
part of the Xnu project.	1
part of a code then	1
part of a program is	1
part of a program and	1
part of a program then	1
part of a program has	1
part of a critical dependency	1
part of a shared object	1
part of a program. This	1
part of a program. Avoid	1
part of a program, especially	1
part of a variable, for	1
part of memory that is	1
part of memory called the	1
part of it). This can	1
part of it) load into	1
part can run optimally on	1
part unsigned int exponent :	2
part takes. See page 153	1
part 142 unsigned int one	1
bits is likely in a	1
bits of the integer in	1
bits of the number and	1
bits of the 32-bit integer.	1
bits of the result. You	1
bits of a double which	1
bits of a 64-bit double	1
bits of a 64-bit double,	1
bits of an integer in	1
bits of its binary representation	1
bits of a[i] and shift	1
bits to zero. 14.3 Use	1
bits in a different way	1
bits in a single operation	1
bits in a non-sequential manner.	1
bits in an integer, usually	1
bits in 64-bit systems. It	1
bits in 32-bit systems and	1
bits in x86 systems). 42	1
bits for Tuesday, Wednesday or	1
bits for holding the pointer.	1
bits are less efficient. In	1
bits with the & operator;	1
bits with the ^ operator.	1
bits than a float. (Both	1
bits when the AVX512 instruction	1
bits at a time, then	1
bits rather than 32 bits.	1
bits 0 - 30 //	1
bits while a double uses	1
bits total size, because these	1
bits except the sign bit	1
bits except the sign bit:	1
bits Vector class, Intel Vector	1
bits Instruction set char 8	1
bits Number of elements in	1
bits Number of elements Total	1
bits each, or two integers	1
bits each, four integers of	1
bits each, eight integers of	1
bits represent a monotonically increasing	1
bits differently. A negative integer	1
bits minimum value maximum value	1
bits wide, should be avoided	1
bits wide, while an int	1
bits each. The type __m128	1
bits (MMX), 128 bits (XMM),	1
bits (XMM), 256 bits (YMM),	1
bits (YMM), and soon also	1
bits 32-62. This can be	1
bits (rarely 64). You may	1
bits (YMM) if the AVX	1
bits (ZMM). Vector operations are	1
bits (XMM) if the SSE2	1
operations is more advantageous the	1
operations of modern CPUs, as	1
operations to finish. 3.8 System	1
operations and before any floating	1
operations and choose the type	1
operations and shift operations take	1
operations in the sense that	1
operations in order to divide	1
operations for manipulating floating point	2
operations for incrementing a loop	1
operations are not used). You	1
operations are very fast. This	1
operations are faster than floating	1
operations are useful when doing	1
operations are available for doing	1
operations are done with single	1
operations are therefore as fast	1
operations are fast in most	1
operations are particularly fast on	1
operations are generally very fast.	1
operations can be made much	1
operations can be carried out	1
operations with other calculations to	1
operations with Boolean variables as	1
operations with pointers. The advantages	1
operations on all data in	1
operations on all elements of	1
operations on vectors and matrixes.	1
operations on contemporary 106 CPUs	1
operations than to write the	1
operations use a set of	1
operations use different execution units.	1
operations when the SSE2 or	1
operations when alignment by 16	1
operations do not add to	1
operations into two 128-bit reads.	1
operations such as addition, subtraction,	1
operations where there is no	1
operations so that there was	1
operations take only one clock	1
operations without reducing the performance	1
operations An integer may be	1
operations automatically in cases where	1
operations require that the arrays	1
operations slow down the execution	1
operations outside the loop: //	1
operations mentioned in chapter 12.	1
operations involves eight or sixteen	1
operations involves eight floating point	1
operations (chapter 12) are more	1
operations in-between the floating point	1
operations Today's microprocessors have vector	1
operations (addition, multiplication, etc.) inside	1
0 is true, and all	1
0 a & -1 =	1
0 a ^ ~a =	1
0 to 12. Higher inputs	1
0 to 15. If i	1
0 and the other is	1
0 and i >= size	1
0 and generate a bit-mask:	2
0 and 1. The reason	1
0 and 1. Note that	1
0 in this column. Number	1
0 for positive and 1	1
0 for false and 1	1
0 that r points to.	1
0 // This is used	1
0 // this function can	1
0 = a a |	1
0 = a - n.a.	1
0 = 0, (a&b) |	1
0 or 1 and that	1
0 or 1 by XOR'ing	1
0 or 1 (see page	1
0 or 1. The AND	1
0 or 1. This makes	1
0 or 1. See page	1
0 or 1. Writing a	1
0 or 1, but operators	1
0 if out of range	1
0 - n.a. - x	3
0 - n.a. x x	1
0 - n.a. a*1 =	1
0 - n.a. a+0 =	1
0 - 2 clock cycles	1
0 - Divide by constant	1
0 - 30 // f	1
0 - a*1 = a	1
0 - a+0 = a	1
0 because this would be	1
0 rather than 1.23456. The	1
0 || i >= size)	1
0 ? c + 2	2
0 <= n < 223	1
0 n! 117 A C++	1
0 a+0=a a*0=0 a*1=a (-a)*(-b)=a*b	1
0 264-1 uint64_t Table 7.1.	1
0 65535 uint16_t unsigned int	1
0 255 uint8_t unsigned short	1
0 232-1 uint32_t unsigned long	1
type is more complex and	1
type is most efficient if	1
type of a function should	1
type of an object It	1
type of data elements, as	1
type of CPU that each	1
type of object pointed to	1
type of objects they contain	1
type of registers used. Conversion	1
type of parameters then make	1
type of storage is determined	1
type of vector, such as	1
type of microprocessor. These algorithms	1
type to avoid this. See	1
type and size as template	1
type and its parameters. This	1
type in the values because	1
type that is optimal for	1
type can be returned in	1
type by type-casting its address:	1
type with desired parameters typedef	1
type has advantages and disadvantages.	1
type such as a structure	1
type short int in one	1
type __m128i defines a 128	1
type conversion // C-style type	1
type conversion A pointer can	1
type conversion takes zero or	1
type conversion generates no extra	1
type conversions is discussed below.	1
type identification adds extra information	1
type identification (RTTI) If any	1
type identification (RTTI) Runtime type	1
type identification (RTTI) /GR -fno-rtti	1
type identification (RTTI) ........................................................................... 54	1
type identification (RTTI). See page	1
type identification (RTTI), which affects	1
type T is a class	1
type T // Constructor //	1
type casting of pointers because	1
type casting // C++ casting	1
type casting // Constructor-style type	1
type casting operator that specifies	1
type int. Therefore, it is	1
type holds a precision of	1
type typedef void FuncType(short int	1
type __m128 defines a 128	1
type size_t is 32 bits	1
type conversions: // Example 7.19	1
type casting. Linked lists and	1
type casting, but also safer.	1
type __m128d defines a 128	1
case the function is never	1
case the code is later	1
case the array index is	1
case the reading of x	1
case is a branch that	1
case is a sum of	1
case is to divide the	1
case is faster when columns	1
case a = ++b; the	1
case of the simple function,	1
case of the Gnu compiler,	1
case of an error then	1
case of an exception or	1
case of an exception without	1
case of an exception. A	1
case of an error; and	1
case of data decomposition, we	1
case of large arrays if	1
case of overflow is "undefined".	1
case of overflow and redo	1
case of Boolean algebra, it	1
case of overflow. The exception	1
case of error. The calculations	1
case of mispredictions (see page	1
case of underflow: // Example	1
case and make a complicated	1
case in loops. Consider the	1
case that the microprocessor has	1
case that the next generation	1
case it may be smaller	1
case it will recognize that	1
case it doesn't matter if	1
case if alternative implementations are	1
case with programs written in	1
case x can be read	1
case you have to do	1
case then the optimal version	1
case memory re-allocation is needed.	1
case there is an advantage	1
case where you want to	1
case we may need metaprogramming.	1
case we need to split	1
case so we don't get	1
case situation is a waste	1
case situation of the maximum	1
case 3: printf("Delta"); break; }	1
case 2: printf("Gamma"); break; case	1
case conditions. For example, if	1
case 1: printf("Beta"); break; case	1
case labels follow a sequence	1
case F2 actually throws an	1
case 0: printf("Alpha"); break; case	1
cases the compiler can automatically	1
cases the SSE2 instruction set	1
cases the microprocessor is able	1
cases of program flow. Failure	1
cases of floating point division.	1
cases of stack unwinding The	1
cases of stack unwinding ..............................................................................	1
cases to use the high	1
cases and it makes it	1
cases for different microprocessors, different	1
cases be advantageous to do	1
cases be linked into projects	1
cases be determined by the	1
cases are usually dealt with	1
cases it is also recommended	1
cases it is possible to	3
cases it can be an	1
cases it can be useful	1
cases it might not be	1
cases on Windows platforms. The	1
cases you can rely on	1
cases you may have to	1
cases this multiplication will be	1
cases when the 145 SSE2	1
cases should definitely be avoided.	1
cases such as multiple inheritance	1
cases In most cases, the	1
cases where the compiler is	1
cases where the data are	1
cases where the size doesn't	1
cases where the number of	1
cases where the performance of	1
cases where the chosen compiler	1
cases where the parallelism is	2
cases where a particular code	1
cases where it is not	1
cases where it is more	1
cases where it makes sense	1
cases where it matters: Division	1
cases where we are writing	1
cases where they cannot be	1
cases where dynamic linking cannot	1
cases cannot be vectorized automatically.	1
cases take memory space where	1
cases they are sure to	1
cases even the same level-1	1
cases like these, it is	1
cases described in the sections	1
cases ignore a request for	1
short in duration compared with	1
short or common names. Use	1
short int is 16 bits	1
short int in one vector,	1
short int in 16-bit systems:	2
short int int 256 unsigned	1
short int 64 Is16vec4 16	1
short int 64 Iu16vec4 32	1
short int 16 4 64	1
short int 16 8 128	1
short int 16 16 256	1
short int 128 Is16vec8 Vec8s	1
short int 128 Iu16vec8 Vec8us	1
short int instead of int.	1
short int a; // 2	1
short int a; double b;	1
short int bb[], short int	9
short int cc[]) { for	1
short int cc[]) { //	6
short int cc[]) { Vec16s	1
short int a[100]; int i,	1
short int s; s =	1
short int s; 40 i	1
short int (16 bits), unless	1
short int bb[size] ); Alignd	1
short int cc[size] ); //	1
short int aa[size] ); //	1
short int 832 256 16	1
short int cc[]); // function	1
short time then the sampling	1
short vector method may be	1
short vector math library (SVML).	1
short vector math libraries: Intel	1
short vector libraries. To explain	1
short vector library, you divide	1
short int, signed or unsigned	1
short int, float. Similar operations	1
short int) are only slightly	1
& a = a, a	1
& b if b is	1
& 0 = 0, (a&b)	1
& a, T const &	1
& b; will make 32	1
& b; d = a	1
& 1 is certain to	1
& unless you expect the	1
& operator is also useful	1
& operator forces the compiler	1
& operator (bitwise and) will	1
& x) { // polynomial(x)	1
& x) { _mm_storeu_si128((__m128i *)d,	3
& x) { __m128 s;	1
& x) { _mm_store_si128((__m128i *)d,	1
& later __svml_expf4 __svml_exp2 Intel	1
& b) { return a	1
& operation will be non-zero,	1
& -1 = a, a	2
& ~a = 0 a	1
& ~a = 0 -	1
& enum Weekdays { Sunday	1
& r) { int i;	2
& r) { r =	1
& r) {return r.a +	1
& earlier vmlsExp4 vmldExp2 Intel	1
& a) { return vector(x	1
& operator; and you can	1
& (Tuesday | Wednesday |	1
& 3) << 4) |	1
& 3) <<6 ); 7.26	1
& obj1; p->f(); // Virtual	1
& 0x7FFFFFFF) { // test	1
& 0x7FFFFFFF) { // check	1
& operation, which is very	1
& N-1)==0 if N is	1
& source) { _mm_stream_pi((__m64*)dest, *(__m64*)&source);	1
& operator[] (unsigned int if	1
& 1) y *= x;	1
& (N-1)) return powN<(N1&(N1-1))==0,N1>::p(x) *	1
& 15] += 1.0f; This	1
& 0x7FFFFF) | 0x3F800000; //	1
& 0= 0 - n.a.	1
& 0x0F) | ((B &	1
& a= a a &	1
& N-1)==0,N>::p(x); } // Use	1
& 1]; Here, I have	1
simple to develop. It is	1
simple in most cases: The	1
simple function with a pointer	1
simple function because the compiler	1
simple integer with vector integer	1
simple integer calculations in floating	1
simple integer counter. A microprocessor	1
simple class containing the members	1
simple pointer or a smart	1
simple array is the most	1
simple array can be used.	1
simple variables into a union	1
simple way of solving the	1
simple test setup but slow	1
simple type casting, but also	1
simple cases where the parallelism	1
simple processors and vector processors	1
simple solution to this problem	1
simple standard operations. All you	1
simple cases, the compiler may	1
simple cases, a data member	1
simple types because the CPU	1
simple types such as int,	1
simple constructor may be inlined	1
simple function, the compiler doesn't	1
simple function, m is transferred	1
simple things like a mouse	1
simple reductions on integer code.	1
simple cases. The explicit use	1
simple cases. 7.28 Templates A	1
simple cases. Database queries can	1
simple algorithm can do the	1
simple tasks like pressing a	1
simple variable. Most compilers will	1
simple variable. Using pointers makes	1
simple algebraic expressions using the	1
simple algebraic reductions such as	1
simple alternative is to run	1
simple expressions. Operations that are	1
simple variables, loop counters, etc.	1
simple variables, arrays and objects.	1
simple method. // This is	1
simple regular pattern, while Pentium	1
simple index. A good compiler	1
simple tasks. Sometimes it is	1
simple periodic pattern can also	1
simple periodic pattern can be,	1
simple periodic pattern or if	1
simple type, a pointer, a	1
simple solution, but it increases	1
simple actions like a key	1
instructions to the instruction set.	1
instructions in the CPU and	1
instructions for the sake of	1
instructions for integer division in	1
instructions for address calculation in	1
instructions for fast access to	1
instructions for mathematical functions such	1
instructions for high precision math.	1
instructions for converting the data	1
instructions that are coded in	1
instructions that can be coded	1
instructions that may be used	1
instructions that use the zero	1
instructions that make it possible	1
instructions that take only one	1
instructions that allow you to	1
instructions are not suitable for	1
instructions are not optimal. There	1
instructions are one byte longer	1
instructions are less likely to	1
instructions are summarized below. Intrinsic	1
instructions are fetched and decoded	1
instructions are accessible from compilers	1
instructions can make certain kinds	1
instructions or small sequences of	1
instructions than the ones mentioned	1
instructions have very few restrictions	1
instructions at specific places in	1
instructions which can be quite	1
instructions where the carry bit	1
instructions cannot multiply integers of	1
instructions rather than nine, even	1
instructions without help of the	1
instructions out of order or	1
instructions out of order. Long	1
instructions (see page 105). Using	1
instructions AVX 256 bit float	1
instructions add ebx, eax /	1
instructions write directly to memory	1
instructions becomes noticeable. The following	1
instructions were splitting 256-bit read	1
instructions require that the microprocessor	1
instructions mov ebx,eax / shr	1
instructions during this time has	1
instructions SSE4.1 some more vector	1
instructions sets. The different versions	1
instructions listed in table 9.2.	1
instructions SSE4.2 string search instructions	1
instructions MOVNTPS, MOVNTPD and MOVNTDQ	1
instructions (MOVNT) are designed to	1
instructions executed, cache misses, branch	1
processors is not optimal from	1
processors is called core clock	1
processors is better. Whenever a	1
processors and the number of	1
processors and on Intel Atom	1
processors and vector processors are	1
processors and instruction sets. Likewise,	1
processors and FPGA soft cores	1
processors and earlier Intel processors	1
processors that have a special	1
processors that support the necessary	1
processors that support a new	1
processors that support it. There	1
processors that supported 128-bit vector	1
processors that supported 256-bit instructions	1
processors that were unknown at	3
processors are not supported at	1
processors are used in the	1
processors are sure to make	1
processors are sometimes able to	1
processors are preferred because of	1
processors are becoming increasingly blurred	1
processors are covered in manual	1
processors can be improved by	1
processors can have any brand	1
processors can calculate a vector	1
processors with the AVX-512 instruction	1
processors with a micro-op cache	1
processors with this instruction set?".	1
processors with low power consumption	1
processors with CISC instruction sets	1
processors on the same machine.	1
processors on a graphics accelerator	1
processors on which it is	1
processors have to be designed	1
processors will support the ADX	1
processors because this brand was	1
processors but eight logical processors.	1
processors rather than future processors.	1
processors without the SSE2 instruction	1
processors available in the system.	1
processors available can be determined	1
processors (see page 130 for	1
processors requires a big floating	1
processors usually share the same	1
processors prefetch data automatically thanks	1
processors (0, 2, 4, etc.).	1
processors (when vector operations are	1
processors properly. Many CPU dispatchers	1
available to the function through	1
available to fit specific needs.	1
available in the function library	2
available in the system. The	1
available in the future. If	1
available in different versions for	1
available in all systems that	1
available in 64-bit systems and	1
available in 32-bit operating systems	1
available in both static and	1
available in newer versions of	1
available in 2015 or 2016.	1
available for the commercial compilers.	1
available for other purposes. This	1
available for 64-bit Linux and	1
available for many different purposes.	1
available for many platforms, including	1
available for Linux systems. The	1
available for doing parallel calculations	1
available for general purposes in	1
available for free in the	1
available for free. Visual Studio	1
available can be determined by	1
available if the AVX 32	1
available if supported by the	1
available with vector operands: minimum,	1
available as an appendix to	1
available use excessive loop unrolling	1
available then it is recommended	1
available then each vector can	1
available from the IDE on	1
available from a number of	1
available from a website. 5	1
available from www.intel.com. (See also	1
available from www.intel.com. Manual on	1
available from www.agner.org/optimize. Copyright conditions	1
available from Intel. See Intel	1
available from www.agner.org/optimize/testp.zip. This tool	1
available at compile time. (Of	1
available vector classes. Including the	1
available because the interpreted version	1
available instruction set. The most	1
available instruction set. The newer	1
available which are useful for	1
available register size. In other	1
available registers is limited. Example:	1
available options for the compiler	1
available information. They have worked	1
available today. You may choose	1
constant is a power of	1
constant is faster // Still	2
constant is faster if the	2
constant is faster than division	2
constant a value that is	1
constant to the preceding one	1
constant to the previous value.	1
constant and then convert the	1
constant and known to the	1
constant that is divisible by	1
constant can be avoided by	1
constant can be propagated through	1
constant = shift and add	1
constant = multiply and shift	1
constant = multiply by -	1
constant = multiply by xx-xx--x-	1
constant with a combination of	1
constant with a decimal point	1
constant with its value. However,	1
constant data // constructor initializes	1
constant data from static memory	1
constant vector (1,2,3,4), and store	1
constant should be done by	1
constant const int ArraySize =	1
constant 8 rather than the	1
constant always takes memory space,	1
constant (see page 137). This	1
constant single precision or by	1
constant known at compile time.	1
constant needs to be stored.	1
constant reference instead: // Example	1
constant references accept expressions as	1
constant plus an index multiplied	1
constant propagation is not possible	1
constant propagation and other optimizations.	1
constant propagation and reduce a	1
constant propagation An expression or	1
constant 5. But the compiler	1
constant divisor that is a	1
constant n, then we need	1
constant N1 could have been	1
constant 3.5 will be stored	1
constant (2n / b) is	1
constant subexpression. A constant can	1
constant propagation, and loop-invariant code	1
constant propagation, etc. Whether you	1
constant 2.5, which is double.	1
up the function address in	1
up the data into multiple	1
up the CPU by giving	1
up the loop buffer that	1
up the performance monitor counters	1
up the address of the	2
up the calculation of the	1
up the stack. This behaviour	1
up the factors that decide	1
up the queue of pending	1
up a function into multiple	1
up a function just because	1
up a stack frame, saving	1
up a program. Whole program	1
up to some positive value,	1
up to 4 clock cycles.	1
up to cause seven memory	1
up to count certain events,	1
up to 5 times faster	1
up to five or ten	1
up to fourteen register parameters.	1
up to fourteen parameters to	2
up to date. A more	1
up to date. Mac The	1
up to date): Microsoft Visual	1
up and calling any necessary	1
up and enable one or	1
up and down. Remember to	1
up in a virtual table	1
up in case of an	2
up if the threads use	1
up with the expected real-time	1
up with the ever bigger	1
up with the correct result	1
up more space in the	1
up then it must return	1
up because it has been	1
up one register. Registers are	1
up cache space and are	1
up cache space. The syntax	1
up into multiple functions. I	1
up 64-bit shared objects in	1
up everything in case of	1
up significantly just by turning	1
up multiplications and divisions are	1
up spaces that are no	1
up include: Memory allocated with	1
error is to access an	1
error is not detected until	1
error is easy to trace	1
error is lower than a	1
error and compare it to	1
error in the oldest Pentium	1
error for each iteration is	1
error that hackers often have	1
error can return with an	1
error // Return reference to	1
error if the index is	1
error by avoiding any public	1
error code if possible, or	1
error code may be stored	1
error code which the calling	1
error then there is no	1
error has occurred anywhere in	1
error return a[i]; // Return	1
error code. If the latter	1
error without using exceptions is	1
error doesn't occur, but unfortunately	1
error known as memory leak.	1
error known as memory leaks.	1
error simply by performing an	1
error handling in the end	1
error handling system instead of	1
error handling Exception handling is	1
error handling ................................................................................ 61 7.31	1
error conditions in a graceful	1
error message is provoked here	1
error message and then calls	1
error message and stop the	1
error message in a protected	1
error message in this case.	1
error message if it is.	1
error message when it sees	1
error message function. The following	1
error condition terminates the program	1
error handling. You have to	1
error handler calls exit(), abort(),	1
error condition. Replacing two comparisons	1
error condition. Things that may	1
error prone. The vectorized code	1
error prone. A discussion of	1
error prone. All these problems	1
error messages to the user.	1
error message. It is recommended	1
error reporting here: return *(T*)0;	1
error reporting. For example, in	1
I have used the trick	1
I have used char (or	1
I have no specific recommendation	1
I have no explanation why	1
I have done a good	1
I have implemented a collection	1
I have made a series	1
I have tested the capability	1
I have tested can convert	1
I have tested were able	1
I have tested implement OneOrTwo5[b!=0]	1
I have tested seem to	1
I have described some of	1
I have added a bounds	1
I have provided several examples	1
I have seen many examples	1
I have AND'ed b with	1
I have ever seen can	1
I have supplied in the	1
I have developed a test	1
I have studied do not	1
I have confirmed this by	1
I have tested. The reason	1
I have tried. The Microsoft,	1
I will make a few	1
I will call this distance	1
I will conclude this section	1
I want to thank the	1
I must warn against overkill.	1
I simply don't have the	1
I write that something takes	2
I don't know if this	1
I don't think that programmers	1
I consider it unwise to	1
I once made a Windows	1
I am not making any	1
I am not going to	1
I am using this for	1
I am using CPU clock	1
I am always happy to	1
I am giving this example	1
I think that it is	1
I believe that the portability	1
I believe that software performance	1
I die. See www.gnu.org/copyleft/fdl.html. 164	1
I tried to make the	1
I guess, that compiler makers	1
I disagree with this rule.	1
making the code size or	1
making the data more random	1
making the most critical parts	1
making the number of columns	1
making the constant single precision	1
making the arrays very big	1
making the container expandable, but	1
making the structure in example	1
making the dispatch decision at	1
making the full declaration of	1
making the entire program in	1
making a and b double	1
making a new one. The	1
making a common denominator: //	1
making a shared object. It	1
making a separate thread in	1
making a pointer. The pointer	1
making a debug version and	1
making a non-inlined copy of	1
making it count up to	1
making an induction variable unless	1
making an unused copy of	1
making an additional floating point	1
making an explicit induction variable.	1
making data more compact. Accessing	1
making floating point register variables	2
making i an unsigned int	1
making multiple versions of a	1
making two threads where one	1
making objects inside the derived	1
making any pointer or reference	1
making any specific recommendation about	1
making software in a high-level	1
making software more clear and	1
making critical functions inline or	1
making sure that functions which	1
making sure that one function	1
making sure that variables that	1
making another function with the	1
making programs that have big	1
making branches that are fine-tuned	1
making longer time slices. This	1
making optimizations that rely on	1
making optimizations across function calls.	1
making them static if they	1
making clear and well-structured code	1
making highly optimized code with	1
making plug-ins that add functionality	1
times the function is called	1
times the other way is	1
times the other way, etc.	1
times the first way and	1
times to test // Time	1
times to simple things like	1
times to keyboard and mouse	1
times and the other way	1
times and the speed will	1
times and that there are	1
times and make parts of	1
times and calls alternately FuncA	1
times and cause delays in	1
times and stores the time	1
times in the final program	1
times in a loop where	1
times in order to make	1
times in order to find	1
times for user input. (In	1
times for simple tasks like	1
times for network resources cannot	1
times // Time before test	1
times with a suitable set	1
times with four numbers at	1
times as long time to	1
times an interrupt occurs in	1
times may be enough to	1
times when a user is	1
times then the loop control	1
times then we have an	1
times because the value pointed	1
times because of lazy loading	1
times because it is evicted	1
times one way, then many	1
times each function is called	1
times each function and branch	1
times each part of the	1
times faster than example 12.4a,	1
times faster than any non-vector	1
times faster either by making	1
times cannot be controlled. The	1
times before the performance even	1
times less than in a	1
times rather than 20. The	1
times per matrix cell for	1
times CriticalFunction is called in	1
times faster. The logic of	1
times 24 dramatically for very	1
times lower; and the amount	1
stack is the most efficient	1
stack is a part of	1
stack is a waste of	1
stack is used. It takes	1
stack is organized. Floating point	1
stack and are in fact	1
stack and reading them again	1
stack in the debugger to	1
stack in 32-bit mode. Storing	1
stack in 32-bit systems, but	1
stack for all these purposes.	1
stack can be allocated dynamically.	1
stack when CriticalInnerFunction is called.	1
stack memory at the start	1
stack memory which is contiguous	1
stack memory outside the innermost	1
stack at address esp+8 and	1
stack also has disadvantages: It	1
stack before the function returns.	1
stack before it is used	1
stack rather than the heap.	1
stack registers are available in	1
stack registers are used. Do	1
stack registers are used. Conversions	1
stack always belong to the	1
stack ; return ; align	1
stack ; ecx = a	1
stack (see above, p. 26).	1
stack memory. Copying constant data	1
stack are: All calculations are	1
stack pointer. Likewise, all non-static	1
stack frame is used for	1
stack frame makes function calls	1
stack frame unless your program	1
stack frame /Oy -fomit- frame-	1
stack Variables and objects declared	1
stack unwinding The preceding paragraph	1
stack unwinding that is used	1
stack unwinding information can be	1
stack unwinding mechanism is also	1
stack unwinding mechanism may be	1
stack unwinding .............................................................................. 65 7.32	1
stack versus XMM registers. Example:	1
stack (three parameters on CodeGear	1
stack frame, saving and restoring	1
stack frame" or "frame pointer".	1
stack entries use 64 bits	1
stack unwinding. All functions have	1
want the function to work	1
want the code to be	1
want the program to issue	1
want the CPU to start	1
want the executable to be	1
want a number to be	1
want to be able to	1
want to use the well	1
want to make the function	1
want to make one version	1
want to make sure that	2
want to make their software	1
want to call the library	1
want to avoid the overhead	1
want to compile for. The	1
want to get as much	1
want to get rid of	1
want to check whether an	1
want to calculate the same	1
want to optimize a piece	1
want to optimize for several	1
want to see the result	1
want to read from memory	1
want to improve speed without	1
want to know how this	1
want to generate a piece	1
want to go deeper into	1
want to find out which	1
want to find out whether	1
want to prevent cache contention.	1
want to keep together on	1
want to vectorize the loop	1
want to measure // Number	1
want to roll out the	1
want to compare the performance	1
want to 155 test. You	1
want to flip the sign	1
want to thank the many	1
want to optimize, and reading	1
want it to do. It	1
want it to. It is	1
want as static arrays in	1
want this to be a	1
want this initialization, or if	1
want when the program 153	1
want vectorization then follow the	1
want them to apply to.	1
Example: // Example 14.9 struct	1
Example: // Example 14.8 const	1
Example: // Example 12.2 __declspec(align(16))	1
Example: // Example 14.6 float	1
Example: // Example 7.2 a	1
Example: // Example 7.1 float	1
Example: // Example 8.7 int	1
Example: // Example 7.12 void	1
Example: // Example 11.3 const	1
Example: // Example 7.23 int	1
Example: // Example 7.24 float	1
Example: // Example 7.28 class	1
Example: // Example 9.4 const	1
Example: // Example 8.15a struct	1
Example: // Example 12.1a. Automatic	1
Example: // Example 8.21 void	1
Example: // Example 7.40a struct	1
Example: // Example 14.3a int	1
Example: // Example 8.9a int	1
Example: // Example 7.34a. Use	1
Example: // Example 8.5a void	1
Example: // Example 8.13a int	1
Example: // Example 8.11a int	1
Example: // Example 8.1a float	1
Example: // Example 8.16 float	1
Example: // Example 8.2a double	1
Example: // Example 8.25 void	1
Example: // Example 8.20 module1.cpp	1
Example: // Example 8.22 #ifdef	1
Example: // Example 7.32a double	1
Example: // Example 14.22a unsigned	1
Example: // Example 14.18a float	1
Example: // Example 9.2a void	1
Example: // Example 8.6a int	1
Example: // Example 14.7a. Testing	1
Example: // Example 7.26a float	1
Example: // Example 8.19. Devirtualization	1
Example: // Example 7.30a int	1
Example: // Example 7.3. Explain	1
Example: // Example 7.39 union	1
Example: // Example 7.36 class	1
Example: // Example 8.12a int	1
Example: // Example 14.12a int	1
Example: // Example 8.14a int	1
Example: // Example 7.33a const	1
Example: // Example 8.8a double	1
Example: // Example 14.17a double	1
Example: // Example 7.41a class	1
Gnu and PathScale compilers. Intel	1
Gnu and PathScale compilers. 8.3	1
Gnu and Clang compilers. The	1
Gnu or Intel compiler. Use	1
Gnu function libraries are not	1
Gnu This is one of	1
Gnu compiler is a very	1
Gnu compiler and the Intel	1
Gnu compiler in many respects	1
Gnu compiler for Mac OS	1
Gnu compiler for Windows, while	1
Gnu compiler can use this	2
Gnu compiler // Same as	1
Gnu compiler on the Mac	1
Gnu compiler A feature called	1
Gnu compiler will make only	1
Gnu compiler will convert example	1
Gnu compiler often inserts built-in	1
Gnu compiler Linux Intel compiler	3
Gnu compiler allows "__attribute__((visibility("hidden")))". Use	1
Gnu compiler mechanism because it	1
Gnu compiler reduced 15.1b to	1
Gnu compiler manual. This option	1
Gnu compiler ......................................................................... 128 13.7	1
Gnu compilers are actually reducing	1
Gnu compilers without problems if	1
Gnu Intel Borland Microsoft Constant	1
Gnu C++ compiler is available	1
Gnu C++ v. 4.1.0, 2006	1
Gnu 32-bit Mac Intel CodeGear	1
Gnu 32-bit -fno-builtin Gnu 32-bit	1
Gnu 64 bit -fno-builtin Gnu	1
Gnu libraries support 32-bit and	1
Gnu manual currently doesn't works	1
Gnu mechanism stores a pointer	1
Gnu compilers. // Example 14.19	1
Gnu compilers. See www.openmp.org and	1
Gnu directives work on the	1
Gnu compiler. Not optimized as	1
Gnu C function library for	1
Gnu C library. It requires	1
Gnu compiler, the assumption that	1
Gnu compiler, etc. #define Alignd(X)	1
Gnu Comes with the Gnu	1
Gnu utilities in 2010. This	1
Some of the most important	1
Some functions are optimized well,	1
Some other compilers (Microsoft, Intel)	1
Some compilers are able to	1
Some compilers can reduce some	1
Some compilers have a feature	1
Some compilers have an option	2
Some compilers have efficient table-based	1
Some compilers have many keywords	1
Some compilers have support for	1
Some compilers have difficulties making	2
Some compilers will use different	1
Some compilers will replace the	1
Some compilers will unroll loops	1
Some compilers will align large	1
Some compilers make Sum1 slightly	1
Some compilers offer profile-guided optimization.	1
Some 64-bit compilers are inferior	1
Some software development models have	1
Some systems have a graphics	1
Some systems also have a	2
Some systems allow lazy binding	1
Some programming languages, such as	1
Some programming textbooks recommend that	1
Some instructions are one byte	1
Some important obstacles to optimization	1
Some CPUs have particularly slow	1
Some versions of Intel microprocessors	1
Some common function libraries are	1
Some common compilers are mentioned	1
Some common problems with profilers	1
Some copy protection schemes are	1
Some programs search for updates	1
Some application programs use internet	1
Some applications require that data	1
Some applications (e.g. in linear	1
Some applications spend most of	1
Some modules may be loaded	1
Some STL templates, such as	1
Some implementations of Java are	1
Some implementations use just-in-time compilation.	1
Some developers feel that a	1
Some profilers require that the	1
Some guidelines are provided below,	1
Some early implementations of Pascal	1
its time in library functions	1
its time on processors that	1
its time waiting for user	1
its data members can be	1
its size is a power	1
its pointer set to NULL.	1
its b member by 8.	1
its many optimization features and	1
its possible exception handling support	1
its value is multiplied by	1
its value at compile time	1
its variables called global offset	1
its return value depends only	1
its address is taken, i.e.	1
its parameters replaced by their	1
its members are then you	1
its name at the time	1
its own memory block and	1
its own data structure and	1
its own CPU core. There	1
its own set of performance	1
its own address through a	1
its own allocated memory block.	1
its own block of data.	1
its own stack. Alternatively, you	1
its own IDE. It is	1
its own caller, and so	1
its binary representation is particularly	1
its functions, called procedure linkage	1
its final destination, but don't	1
its child class by type-casting	1
its child class through a	1
its child class. This is	1
its address. The address of	1
its 'this' pointer to a	1
its value. However, the const	1
its family and model number.	1
its parameters. This is called	1
its body is defined inside	1
its mirror position above the	1
its limit, etc. In most	1
its brand, family and model	1
its arguments. This closely follows	1
its out-of- order calculation capabilities.	1
its reputation. The compactness of	1
its simplicity. But a sorted	1
its address: // Example 7.27	1
its API. In some cases,	1
about the function type and	1
about the only situation where	1
about the class that the	1
about the class c1 other	1
about the performance of the	1
about the sign bit. We	1
about the costs if it	1
about the destructor to call	1
about the possibility of algebraic	1
about the chain of function	1
about the third generation class	1
about the dimensions of the	1
about a variable, pointer or	1
about in my blog. Here,	1
about function names and variable	1
about code optimization. See www.agner.org/optimize	1
about an unknown CPU based	1
about this condition. In general,	1
about memory caching. 3.14 Context	1
about data storage and page	1
about functions in other modules	1
about instruction latencies are listed	1
about which software development process	1
about which implementation is best.	1
about which platforms and operating	1
about no pointer aliasing. The	1
about pointer alignment and aliasing.	1
about branch prediction. A Pentium	1
about register use, as explained	1
about how the development process	1
about how to speed up	1
about how caches work can	1
about its child class through	1
about overflow and underflow except	1
about Linux also applies to	1
about supported instruction sets, cache	1
about whether the positive or	1
about mathematical functions. 7.4 Enums	1
about name mangling are explained	1
about it. Possible solutions are:	1
about loss of precision. Let's	1
about increment operators also applies	1
about them. You should therefore	1
about Func1 when compiling module2.cpp.	1
about rounding. Pointer type conversion	1
about division). The object pointed	1
about bugs, compatibility problems, usability	1
about investigation of the problems	1
important to the end user.	1
important to have a strategy	1
important to make sure it	1
important to do something about	2
important to optimize the parts	1
important to consider which method	1
important to economize the use	2
important to economize the resource	1
important to economize resource use	1
important to understand how variables	1
important to distinguish between coarse-grained	1
important to study the available	1
important to focus the optimization	1
important to decide which programming	1
important to note that this	1
important to weigh the advantages	1
important to remember that your	1
important to realize that such	1
important to ignore, then the	1
important and generally used that	1
important for the programmer to	1
important for tasks such as	1
important that the integer has	1
important that the user interface	1
important that all allocated objects	1
important or critical parts of	1
important it is to choose	1
important if you have big	1
important on most newer processors.	1
important on small devices with	1
important than it used to	1
important than optimizing CPU use	1
important than speed. This includes	1
important functions are included in	1
important new update or even	1
important method that is used	1
important part of the optimization	1
important disadvantage of the Intel	1
important disadvantage of C++ relates	1
important addition to the instruction	1
important thing is to avoid	1
important usability problems that software	1
important obstacles to optimization are	1
important work. The updating mechanism	1
important distinction between the latency	1
important remedy is memory pooling.	1
accessed in the order a[0],	1
accessed in a non-sequential order.	3
accessed in a non-sequential manner	1
accessed in a random manner.	1
accessed in a FIFO manner?	1
accessed in a FILO manner?	1
accessed in more than one	1
accessed in sequential order and	1
accessed in non- sequential order.	1
accessed by any other modules.	2
accessed by several different functions	1
accessed with the last index	1
accessed with a square brackets	1
accessed with an offset that	1
accessed on a First-In-Last- Out	1
accessed on a First-In-First- Out	1
accessed from the shared object.	1
accessed from any function. Global	1
accessed from main through an	1
accessed from within the same	1
accessed most efficiently if it	1
accessed very fast. All optimizing	1
accessed much faster. There may	1
accessed through the implicit pointer	1
accessed through a pointer stored	1
accessed through a pointer. It	1
accessed through pointers in one	1
accessed through pointers or references	1
accessed through pointers or references:	1
accessed through pointers so that	1
accessed through pointers, e.g.: //	1
accessed quite fast. The lesson	1
accessed after it has been	1
accessed approximately two clock cycles	1
accessed equally fast. In general,	1
accessed backwards and much less	1
accessed sequentially in memory if	1
accessed consecutively and can calculate	1
accessed sequentially. The opposite order	1
accessed sequentially. It works somewhat	1
accessed recently than to access	1
accessed non-sequentially because it may	1
accessed column-wise. Assume now that	1
accessed row-wise, then the mirror	1
CPUs is not needed. Even	1
CPUs is increasing faster than	1
CPUs to verify that all	1
CPUs and operating systems available	1
CPUs and operating systems. The	1
CPUs in a suboptimal way	1
CPUs in a suboptimal way.	1
CPUs for executing the same	1
CPUs that are up to	1
CPUs that support this instruction	1
CPUs are so fast that	1
CPUs are actually able to	1
CPUs are capable of register	1
CPUs can be increased by	1
CPUs can do a lot	1
CPUs can change their clock	1
CPUs can execute instructions out	1
CPUs or a CPU with	1
CPUs or CPU cores, we	1
CPUs or multi-core CPUs, as	1
CPUs if the data fit	1
CPUs if you want to	1
CPUs with a slow bit	1
CPUs with only the SSE2	1
CPUs with execution units same	1
CPUs with execution units smaller	1
CPUs with slow bit scan	1
CPUs with full-size execution units.	1
CPUs have a built-in test	1
CPUs have only one floating	1
CPUs have two or more	1
CPUs have particularly slow implementations	1
CPUs have family number 6!	1
CPUs use Intel VTune, for	1
CPUs use AMD CodeAnalyst. Unfortunately,	1
CPUs which may cause slight	1
CPUs such as AMD and	1
CPUs cannot be tolerated. PGI	1
CPUs without the FMA4 instruction	1
CPUs was more than doubled	1
CPUs unless you are overriding	2
CPUs (See manual 3: "The	1
CPUs increased the available instruction	1
CPUs (Intel Atom). The following	1
CPUs optimally. The speed for	1
CPUs unequally can become a	1
function. The function may return	1
function. The } 59 third	1
function. The static keyword also	1
function. The following example illustrates	1
function. The stack is the	1
function. The assembly listing reveals	1
function. The automatic dispatching can	1
function. The string length function	1
function. The overhead of parameter	2
function. The PLT entry initially	1
function. The initialization routine sets	1
function. The branching is done	1
function. This is efficient, but	1
function. This will make any	1
function. This has the advantage	2
function. This fragmentation of the	1
function. A leaf function is	2
function. If the version changes	1
function. In the simple function,	1
function. In some cases, the	1
function. There are so many	1
function. See page 53. 7.24	1
function. Example: // Example 8.1a	1
function. Example: // Example 8.22	1
function. But in the template	1
function. But there are special	1
function. Function inlining can open	1
function. However, the short vector	1
function. Using an overloaded operator	1
function. Do not make a	1
function. When the program is	1
function. Avoid the use of	1
function. 12.2 AVX-512 instruction set	1
function. Global variables are stored	1
function. Copying the table takes	1
function. 7.12 Branches and switch	1
function. Compile once for each	1
function. Provoke branch mispredictions by	1
function. Switch between different parts	1
function. Sometimes, functions are kept	1
function. __attribute__((const)) (Linux only). Specifies	1
function. typeof(CriticalFunction) * CriticalFunctionDispatch(void) __asm__	1
function. Leaf functions are more	1
function. 154 // Print heading	1
extra function calls because the	1
extra code to check that	1
extra code and doesn't take	1
extra code for actually making	1
extra code at each function	1
extra code at all. This	1
extra time if it is	1
extra time as long as	1
extra time may be justified	1
extra time when the floating	1
extra cache for the hardware	1
extra software layers and frameworks	1
extra register to hold the	1
extra register available for other	1
extra code. It is simply	1
extra code. Example: // Example	1
extra code. Dynamic cast The	1
extra time. The delay is	1
extra time. This is a	1
extra time. It simply stores	1
extra time. There are intrinsic	1
extra time. These conversions can	1
extra operations outside the loop:	1
extra instructions for address calculation	1
extra instructions for converting the	1
extra work needed for calculating	1
extra element zero. It is	1
extra check on b can	1
extra information to all class	1
extra cost is seen in	1
extra cost to accessing an	1
extra cost whenever a smart	1
extra framework can consume a	1
extra overhead of the iterator	1
extra overhead to prevent such	1
extra overhead in the program	1
extra overhead which consumes CPU	1
extra resources. Each graphics operation	1
extra time, of course, but	1
extra iteration that has to	1
extra level of abstraction which	1
extra jump through a pointer	1
extra bits. The unsigned integer	1
extra precautions to account for	1
extra dummy element to list	1
extra complications. A double is	1
extra layer of a third-party	1
does the same as the	1
does the same as C-	1
does the same without discriminating	1
does the same thing as	1
does the same thing. An	1
does the necessary initialization. The	1
does not have to unroll	1
does not have its own	1
does not use runtime type	1
does not make the program	1
does not need to be	1
does not need any patch.	1
does not need updating in	1
does not always apply to	1
does not work in example	1
does not check for overflow	1
does not check if XMM	1
does not cost anything here	1
does not give the full	1
does not require a multiplication	1
does not produce any extra	2
does not fit into a	1
does not allow vector objects	1
does not apply to floating	1
does not apply to very	1
does not spend time on	1
does not necessarily stay in	1
does not alias any elements	1
does not alias anything by	1
does not cover graphics processors.	1
does not solve all the	1
does not occur. See page	1
does not throw exceptions throw()	1
does have some disadvantages that	1
does this by assigning a	1
does It can be very	1
does floating point calculations will	1
does floating point calculations should	1
does some things very smart	1
does some funny things with	1
does so in a suboptimal	1
does quite ingenious things to	1
does what you want it	1
does not, and therefore fail	1
does ............................................................................. 84 9 Optimizing	1
does incredibly stupid things. Looking	1
assembly or easy linking to	1
assembly on all platforms and	1
assembly code to access these	1
assembly code to give the	1
assembly code for Intel CPUs.	1
assembly code for AMD CPUs.	1
assembly code or use objconv	1
assembly code from example 8.26a	1
assembly code from example 8.26b:	1
assembly instruction for interrupt 3.	1
assembly code. Register ebx is	1
assembly code. Let me explain	1
assembly instructions or small sequences	1
assembly language is provided as	1
assembly language and the rest	1
assembly language and automatic CPU-dispatching	1
assembly language for CPU-intensive code,	1
assembly language has full metaprogramming	1
assembly language because a good	1
assembly language Use intrinsic functions	1
assembly language modules when the	1
assembly language programming, compiler technology,	1
assembly language output. On most	1
assembly language output, which is	1
assembly syntax in both Windows	1
assembly output of a compiler	1
assembly output more readable but	1
assembly output option is also	1
assembly output option then use	1
assembly output listing to see	1
assembly output (/FAs or -fsource-asm).	1
assembly programmers and compiler makers.	1
assembly language. It is important	1
assembly language. C++ takes only	1
assembly language. In fact, you	1
assembly language. See page 141	1
assembly language. Here are some	1
assembly names. The details about	1
assembly listing reveals three things	1
assembly listing /FA -S -	1
assembly output. The assembly output	1
assembly language". The method is	1
assembly language". While we are	1
assembly listing. Use the "generate	1
assembly language", section 17.9: "Moving	1
assembly language: An optimization guide	1
large to handle the strings	2
large for the stack can	1
large that we do not	1
large or if different versions	1
large or constant. If the	1
large then it obviously takes	1
large memory model is hardly	1
large memory model where the	1
large memory blocks, or if	1
large data files and databases	1
large data sets where the	1
large data structures It is	1
large data structures ............................................................. 96	1
large data sets. However, the	1
large data sets. Covers PC's,	1
large data bases, but there	1
large because the insertion of	1
large number of bits. This	1
large static arrays automatically but	1
large array can be allocated	1
large objects and arrays by	1
large libraries where only few	1
large part of it) load	1
large arrays and where the	1
large arrays if it can	1
large shared object where most	1
large block containing many objects	1
large cost to creating and	1
large runtime framework for interpreting	1
large runtime framework that must	1
large expressions when not selected.	1
large graphics frameworks, interpreters, just-in-time	1
large positive number when i	1
large positive number when converted	1
large overhead of managing a	1
large overhead cost to memory	1
large libraries. The memory address	1
large delay due to the	1
large fraction of the time	1
large arrays. Array size divisible	1
large applications. The string classes	1
large object, unless there is	1
large arrays, it may be	1
large amounts of memory will	1
large delays. The easiest way	1
must be a compromise between	1
must be called when the	1
must be called before the	1
must be done manually by	1
must be inside the innermost	1
must be read into one	1
must be aligned by 16,	1
must be declared volatile. This	1
must be divisible by TILESIZE	1
must be loaded every time	1
must be dynamically created by	1
must be saved from one	1
must be found elsewhere. 13.5	1
must be multiplied by the	1
must be placed immediately before	1
must be careful when swapping	1
must be added. This method	1
must be adjusted if you	1
must be emphasized that the	1
must be followed by an	1
must be reversed if c	1
must have a high priority.	1
must have a destructor to	1
must have extern "C" declaration	1
must use a function library,	1
must use thread-safe functions. A	1
must then check for the	1
must make sure that the	1
must make your program exception	1
must do the extra operations	1
must return to its own	1
must always end with a	1
must check if it has	1
must calculate its address. The	1
must go through a second	1
must rely on instructions that	1
must convert it to a	1
must consider that the bit	1
must consider if intermediate calculations	1
must wait until a few	1
must install a large runtime	1
must clean up everything in	1
must begin at an address	1
must compute (FuncRow(i)*columns + FuncCol(i))	1
must warn against overkill. Don't	1
must bear in mind, that	1
while the program is running.	2
while the type conversion generates	1
while the Gnu mechanism stores	1
while the speed of addition,	1
while the multiplication is exact.	1
while the expression a =	1
while the expression that is	1
while the runtime address calculations	1
while the Borland and Digital	1
while a function that doesn't	1
while a double uses 64	1
while in the former case	1
while it is more complicated	1
while if is resolved at	1
while an int is 32	1
while you can only have	1
while data that are modified	1
while other functions can not.	1
while other compilers have inefficient	1
while other compilers will make	1
while loop is to resume	1
while loop in example 15.1b.	1
while loop because nothing inside	1
while all newer Intel CPUs	1
while most of the Gnu	1
while multiple statements within each	1
while many reductions involving division	1
while less than 1% goes	1
while pointers and non-constant references	1
while dynamic linking makes the	1
while execution speed, memory economy,	1
while another thread is waiting	1
while (i < arraysize) {	1
while Pentium 4 and AMD	1
while seconds count to 5	1
while waiting for disk operations	1
while (n != 0) {	1
while simultaneously prefetching the code	1
while high-level languages are good	1
while loop, the if statement	1
while loops, then the transformation	1
while (*p != 0) *(p++)	1
while (seconds < 5) {	1
while (0 < 5) {}	1
while he or she is	1
; a ; r ;	1
; Example 8.26a compiled to	1
; Example 8.26b compiled to	1
; point to a[i+2] ;	1
; double Func2(double x) {	1
; i + sign(i) ;	1
; i < arraysize; i++)	1
; return from Func 87	1
; return ; align ;	1
; add what r points	1
; store result in array	1
; parameter 2: 12 $B1$1:	1
; parameter 1: 4 +	1
; parameter 1: 8 +	1
; parameter $B1$1: mov mov	1
; r ; unused label	1
; a[i] = Induction; ;	1
; start of Func ;a	1
; unused label ; return	1
; unused label ; save	1
; unused label ; restore	1
; unused label ;eax=addressofa ;edx=addressinr	1
; shift right = divide	1
; shift down sign bit	1
; save ebx on stack	1
; repeat loop if true	1
; align by 4 ;	1
; align ; mark end	1
; eax = i =	1
; ecx = a ;	1
; ecx = Induction ;	1
; jump to top of	1
; edx = point to	1
; edx = r ebx,	1
; compare with end of	1
; top of loop ;	2
; compute i/2 in ebx	1
; a[i+1] = Induction; ;	1
; Induction++; ; point to	1
; i++ ;checkifi<100 ; repeat	1
; mangled function name ;	1
; mangled function name ;startofFunc	1
; restore ebx from stack	1
; mark end of procedure	1
; mark_end; This solution is	1
arrays is fast and efficient,	1
arrays of different types with	1
arrays of variable size. The	1
arrays of structure or class	1
arrays and other big objects	1
arrays and where the size	1
arrays and want to get	1
arrays and big structures by	1
arrays and objects. Storage on	1
arrays and structures. Useful for	1
arrays in the final program.	1
arrays in C and C++	1
arrays that are bigger than	1
arrays that you want to	1
arrays are faster than linked	1
arrays are accessed through pointers	2
arrays are accessed through pointers,	1
arrays are aligned or not.	1
arrays are aligned by 16,	1
arrays are sufficiently large to	2
arrays are properly aligned or	1
arrays are aligned, and make	1
arrays can be allocated dynamically	1
arrays // Define macro for	1
arrays or structures are accessed	1
arrays if it can save	1
arrays by the cache line	1
arrays by well-tested container classes.	1
arrays with vector access. 12.9	1
arrays with bounds checking and	1
arrays with alloca. This is	1
arrays as required, but in	1
arrays It may not be	1
arrays should be accessed with	1
arrays should be declared inside	1
arrays very big to cover	1
arrays even if they are	1
arrays inside the function that	1
arrays automatically but you may	1
arrays bigger than 2 GB.	1
arrays require a few extra	1
arrays Alignd ( short int	1
arrays forwards, not backwards. Copying	1
work the same way as	1
work to do immediately before	1
work to take a whole	1
work in example 9.6b. The	1
work in both Windows and	1
work for class member functions	1
work for very long on	1
work that the processor can	1
work that needs to be	1
work can be found in	1
work // Re-do the calculation	1
work it has done by	1
work with any type of	1
work with member functions, where	1
work with both static and	1
work on the Intel compiler	1
work on the PathScale and	1
work on a Linux compiler,	1
work on all C++ compilers	1
work on all compilers. Some	1
work on compilers that rely	1
work on non-Intel processors). It	1
work as a learning process	1
work as possible. Typically it	1
work int i = 0;	1
work when Intel libraries are	1
work only on Intel/x86-compatible microprocessors.	1
work into each thread. This	1
work into multiple threads. The	1
work into multiple threads. There	1
work cannot be ignored if	1
work best on future processors,	1
work well on AMD and	1
work well on non-Intel machines?	1
work needed for calculating row	1
work load is high and	1
work load is low in	1
work around this limitation and	1
work efficiently on all sizes	1
work automatically. The development time	1
work better. If the problem	1
work better. Remember again, that	1
work load. The clock frequency	1
work correctly. The speed test	1
work evenly between the different	1
(see page 130 for how	1
(see page 134 on bounds	1
(see page 107). The Gnu	1
(see page 107). Agner's vector	1
(see page 16) shows that	1
(see page 71). In this	1
(see page 73). It is	1
(see page 73). Current compilers	1
(see page 78). A matrix	1
(see page 78). Adding the	1
(see page 137). This also	1
(see page 43). The Boolean	1
(see page 87). Data caching	1
(see page 105). If the	1
(see page 105). Using the	1
(see page 140). The SSE2	1
(see page 140). Mathematical functions	1
(see page 51). The order	1
(see page 27). The maximum	1
(see page 103) will be	1
(see page 107), OpenMP and	1
(see page 122) for the	1
(see page 53). No general	1
(see page 93). All common	1
(see page 96). Virtual functions	1
(see page 103), but the	1
(see page 142). 30 Overflow	1
(see page 84). The compiler	1
(see page 134) return FactorialTable[n];	1
(see page 135). This extra	1
(see page 38). Is the	1
(see page 72). The compiler	1
(see page 73) automatically then	1
(see page 70). The programmer	1
(see p. 43). There is	1
(see p. 87). There is	1
(see p. 104). The table	1
(see p. 22). 159 18	1
(see p. 57). It is	1
(see above, page 87) is	1
(see above, p. 26). Variables	1
(see below) then it may	1
(see below) 16.1 Using performance	1
(see below). The 256-bit YMM	1
(see below). A variable cannot	1
Windows and the Gnu compiler	1
Windows and to Eclipse when	1
Windows and C++ is Microsoft	1
Windows and 32-bit and 64-bit	1
Windows and 32-bit Linux with	1
Windows and Linux operating systems	1
Windows and Mac programs but	1
Windows and Linux, 32-bit and	1
Windows and Linux. The compiler	1
Windows and Linux. Asmlib My	1
Windows and Mac. The Gnu	1
Windows in this respect. 7.15	1
Windows are fully compatible on	1
Windows if functions have more	1
Windows by transferring 'this' in	1
Windows compiler to work on	1
Windows may be mitigated by	1
Windows you can increase the	1
Windows program that created a	1
Windows Intel compiler Linux Align	1
Windows Intel compiler Linux Optimize	1
Windows version is currently not	1
Windows operating system, this requires	1
Windows Gnu compiler Linux Intel	3
Windows Linux __INTEL_COMPILER __INTEL_COMPILER n.a.	1
Windows allows a maximum of	1
Windows allows only four function	1
Windows platform _WIN32 _WIN32 Linux	1
Windows platforms. The Microsoft and	1
Windows platforms. The Clang compiler	1
Windows platforms. This library has	1
Windows syntax or See page	1
Windows (See page 49 and	1
Windows Library (OWL). Several graphical	1
Windows system. Note that the	1
Windows applications. The choice of	1
Windows Template Library (WTL). A	1
Windows Template Library (WTL): //	1
Windows 7 and Windows Server	1
Windows DLLs use relocation. The	1
Windows 3.x. These systems use	1
Windows Server 2008 R2 as	1
Windows MFC). This method may	1
calls the function is replaced	1
calls the same version of	1
calls the critical function many	1
calls the critical function ten	1
calls the dispatcher function and	1
calls is the same as	1
calls a function in a	1
calls a device driver. A	1
calls to the copy constructor	1
calls to a pure function	1
calls to check for all	1
calls to frame functions then	1
calls to frame functions. While	1
calls to memset and memcpy,	1
calls to CriticalFunction. If your	1
calls to log, and logarithms	1
calls and it can move	1
calls and it needs to	1
calls and branches in a	1
calls and branches. The following	1
calls in the most critical	1
calls in the critical part	2
calls in the innermost loop	1
calls are saved in a	1
calls can be mispredicted for	1
calls may run slightly faster	1
calls may slow down a	1
calls more efficient. The size	1
calls at least one other	1
calls because the CPU can	1
calls other functions is called	1
calls faster and makes an	1
calls faster in 32-bit mode.	1
calls rather than self-styled hacks	1
calls another function which in	1
calls another function F2 that	1
calls another function, etc., and	1
calls another dispatched function then	1
calls it. A dynamic library	1
calls (e.g. IsProcessorFeaturePresent in Windows).	1
calls directly to the CPU-specific	1
calls exit. Calling exit may	1
calls exit(), abort(), _endthread(), etc.	1
calls alternately FuncA and FuncB,	1
calculations of loop iterations are:	1
calculations of (2n / b)	1
calculations to save time. The	1
calculations and the loop counter	1
calculations in a safe way	1
calculations in floating point variables	1
calculations in parallel if certain	1
calculations in parallel. Modern CPUs	1
calculations are available at compile	1
calculations are done with long	1
calculations are done at compile	1
calculations are done only once,	1
calculations are just as fast	1
calculations can cause overflow. For	1
calculations or turn off requirements	1
calculations with memory access. 12	1
calculations on the first sub-vector.	1
calculations on the data. This	1
calculations on the second sub-vector	1
calculations on large data sets	1
calculations on vectors of two	1
calculations as long as you	1
calculations may take more time	1
calculations have to be done	1
calculations will typically use integer	1
calculations then you have to	1
calculations at compile time rather	1
calculations should therefore preferably have	1
calculations into a separate thread	1
calculations so that the final	1
calculations take no more time	1
calculations without the need to	1
calculations while another thread is	1
calculations while simultaneously prefetching the	1
calculations inside the loop is	1
calculations inside the loop are	1
calculations inside the loop. The	1
calculations unless the strictness is	1
calculations piece by piece in	1
calculations usually take the same	1
calculations go outside the bounds	1
calculations including linear algebra and	1
calculations whenever they are available,	1
calculations simultaneously or out of	1
calculations forms a long dependency	1
versions of the same function,	1
versions of the same compiler.	1
versions of the CPU detection	1
versions of the most critical	2
versions of the library functions.	1
versions of the critical code	1
versions of the virtual functions.	1
versions of the polymorphic functions.	1
versions of the strlen function	1
versions of the user-written code	1
versions of a function for	1
versions of a program executable:	1
versions of a critical function	1
versions of an overloaded function	1
versions of memory and string	1
versions of Intel microprocessors are	1
versions of these manuals are	1
versions of common string functions	1
versions of Linux and perhaps	1
versions of their 23 software.	1
versions of CriticalFunction in example	1
versions and turn off debugging	1
versions for different instruction sets	1
versions for different instruction sets...........................	1
versions for different processors and	1
versions for different compilers. This	1
versions for different CPUs. This	1
versions for different CPUs. (See	1
versions are available for the	1
versions are produced regularly. Intel:	1
versions are produced regularly. AMD:	1
versions with and without AVX	1
versions have to be compiled	1
versions should be used only	1
versions should be linked into	1
versions without an IDE. Free	1
versions even of functions that	1
versions work correctly. The speed	1
versions #include "instrset_detect.cpp" // instrset_detect	1
versions were tested: Microsoft C++	1
versions tested (not up to	1
versions 7 through 14, with	1
versions alternatingly several times in	1
versions instead. The Gnu libraries	1
execution is no doubt obtained	1
execution of everything else. This	1
execution of everything else. System	1
execution of CriticalFunction. You cannot	1
execution to the point where	1
execution and advanced prediction mechanisms.	1
execution by causing return addresses	1
execution may be caused by	1
execution time on executing library	1
execution time when code and	1
execution time because the memory	1
execution time because the cache	1
execution then it is preferable	1
execution time. 4 2 Choosing	1
execution time. Loop unrolling In	1
execution time. No universal solution	1
execution times per matrix cell	1
execution speed to using templates.	1
execution speed to using namespaces.	1
execution speed and for minimizing	1
execution speed in any of	1
execution speed or program size,	1
execution All modern x86 CPUs	1
execution mechanism can prefetch the	1
execution mechanism works automatically. However,	1
execution core of modern microprocessors	1
execution units. The size of	1
execution units. The problem is	1
execution units. If any of	1
execution units. For example, a	1
execution units. Each 128-bit operation	1
execution units. Any floating point	1
execution units. Typically, there are	1
execution units and hence higher	1
execution units in the CPU.	1
execution units same size as	1
execution units rather than by	1
execution units smaller than the	1
execution units, memory ports, etc.	1
execution (chapter 11) and vector	1
execution ................................................................................................. 103 12 Using	1
execution unit. For example, it	1
execution speed, memory economy and	1
execution speed, memory economy, cache	1
execution considerably. Another serious burden	1
avoid the loop overhead. Example:	1
avoid the large graphics frameworks,	1
avoid the calls to the	1
avoid the problem that the	1
avoid the multiplication by changing	1
avoid the overhead of transferring	1
avoid the conversions and make	1
avoid the inefficient virtual function	1
avoid the time- consuming features	1
avoid the burdensome position-independent code	1
avoid that the critical stride	1
avoid that some expression is	1
avoid an excessive number of	1
avoid this in a protected	1
avoid this by using an	1
avoid this method if memory	1
avoid this error by avoiding	1
avoid this problem by bypassing	1
avoid this wasteful copying of	1
avoid multiple threads writing to	1
avoid multiple inheritance by making	1
avoid any use of floating	1
avoid long dependency chains. A	1
avoid long dependency chains. Another	1
avoid these and handle text	1
avoid these problems. More details	1
avoid dynamic memory allocation (new	1
avoid dynamic memory allocation. See	1
avoid dynamic memory allocation. Do	1
avoid making any pointer or	1
avoid virtual functions then you	1
avoid running the advanced version	1
avoid running two threads with	1
avoid global variables or hide	1
avoid conversions from integer to	1
avoid conversions from float or	1
avoid it. Global variables may	1
avoid powers of 2 if	1
avoid this. See page 140	1
avoid this. (In Windows, SetThreadAffinityMask,	1
avoid them. Some important obstacles	1
avoid macros with short or	1
avoid modulo operations: // Example	1
avoid hyperthreading by using only	1
avoid hard-to-find errors, and some	1
result is the same as	1
result is that x is	1
result is stored in x,	1
result is stored in y.	1
result is known to be	2
result is valid. Re-interpreting the	1
result of the & operation	1
result of the expression is	1
result of the preceding one	1
result of the preceding addition	1
result of the preceding one.	2
result of the previous iteration	1
result of other optimizations such	1
result of each step of	1
result of macro expansions. Programmers	1
result of full optimization. It	1
result of comparing signed with	1
result to see if it	1
result in a vector register	1
result in a different array.	1
result in array ; i++	1
result in x. The compiler	1
result in a[i]. Note how	1
result can be calculated using	1
result // Update induction variable	1
result = b > 0	2
result if we change the	1
result by using intrinsic functions	1
result will be 2. The	1
result will be infinity or	1
result will be misleading reports	1
result then we will consider	1
result vector in eight consecutive	4
result because the overflow and	1
result 100 rather than -156.	1
result ebx is then stored	1
result back to single precision.	1
result -56 rather than 200.	1
result (b+c) can be avoided	1
processor the user expects an	1
processor is not an advantage	1
processor is not an Intel,	1
processor is an Intel before	1
processor is much slower than	1
processor is compatible with a	1
processor to give higher priority	1
processor and the operating system.	1
processor and the type of	1
processor and a Windows, Linux,	1
processor for calculating the physical	1
processor that you optimized for	1
processor can do while waiting	1
processor with four cores can	1
processor may be able to	1
processor may be given a	1
processor may have a reduced	1
processor will have an extra	1
processor has a particular weakness	1
processor has four physical processors	1
processor has hyperthreading. If so,	1
processor makes the dispatcher signal	1
processor model is going to	1
processor model will work better.	1
processor model numbers form a	1
processor model N supports a	1
processor core on multi-core CPUs,	1
processor models to avoid running	1
processor models to run the	1
processor models on which a	1
processor models on which this	1
processor models rather than processor	1
processor core. Unfortunately, contemporary operating	1
processor core. Two threads running	1
processor core. Try to allocate	1
processor cores. Each thread should	1
processor performs better on very	1
processor appears on the market.	1
processor features. The programmer typically	1
processor model. You may ignore	1
processor X" is simply not	1
processor enters the market for	1
processor X?" rather than "what	1
processor activates critical application- specific	1
compiled to an intermediate file	1
compiled to binary code and	1
compiled to assembly: ALIGN 4	2
compiled and distributed as binary	1
compiled in multiple versions with	1
compiled for the instruction set	1
compiled for the specific instruction	1
compiled for the AVX instruction	1
compiled for the desired instruction	1
compiled for a particular instruction	1
compiled for 64-bit operating systems	1
compiled for AVX or later	1
compiled for old processors without	1
compiled with the option -fpic	1
compiled with and without AVX	1
compiled with different compilers then	1
compiled with different compilers. Dispatch	1
compiled with AVX support and	1
compiled with AVX support calls	1
compiled with -fpic and it	1
compiled on a PC and	1
compiled code and intermediate code	1
compiled code may run with	1
compiled code big and uses	1
compiled as a dynamic link	1
compiled as position-independent has the	1
compiled when it is executed.	1
compiled into an intermediate code,	1
compiled C++ or assembly language	1
compiled version is preferred when	1
compiled code. In general, there	1
compiled code. Compiled languages include	1
compiled code. (Compile without the	1
compiled without any option that	1
compiled without AVX support then	1
compiled without -fpic is much	1
compiled without -fpic because the	1
compiled without AVX, as explained	1
compiled programming languages as well.	1
compiled versions #include "instrset_detect.cpp" //	1
compiled three times, one for	1
compiled languages such as C++	1
compiled C++. This typically happens	1
An integer is converted to	1
An integer may be used	1
An integer overflow will make	1
An example is Perl. Several	1
An object of a derived	1
An object of a class,	1
An object cannot be stored	1
An efficient solution in this	1
An array is implemented simply	1
An array can be initialized	1
An array using the above	1
An array overflow can cause	1
An array initialized by a	1
An optimization guide for assembly	1
An optimization guide for x86	1
An optimization guide for Windows,	2
An even more powerful solution	1
An even worse kind of	1
An error message is provoked	1
An important disadvantage of C++	1
An allocated array may need	1
An overflow of an unsigned	1
An inline function is expanded	1
An optimizing compiler can use	1
An optimizing compiler can bypass	1
An optimizing compiler may try	1
An optimizing compiler might store	1
An application with many function	1
An expression that is a	1
An expression or subexpression containing	1
An expression with multiple overloaded	1
An implementation of the lrint	1
An overloaded operator is equivalent	1
An alternative is to keep	1
An alternative solution is to	1
An interrupt service routine should	1
An OR combination of these	1
An enum is simply an	1
An appendix to this manual	1
An uncached write is more	1
An inferior version of the	1
An experiment where 10 elements	1
An uncaught overflow condition will	1
Use the call stack in	1
Use the option for "assume	1
Use the option that gives	1
Use the latest version of	1
Use the "generate map file"	1
Use a compiler that supports	1
Use a reference or pointer	1
Use a profiler to find	2
Use a "move constructor" to	1
Use function libraries with internal	1
Use an old computer with	1
Use an antivirus program that	1
Use different executables. This method	1
Use 64-bit mode or enable	1
Use 64-bit mode Parameter transfer	1
Use template to get x	1
Use these example containers in	1
Use simple method. // This	1
Use Gnu or Intel compiler.	1
Use CPUs with execution units	1
Use assembly language Use intrinsic	1
Use large data files and	1
Use another function library that	1
Use inline functions An inline	1
Use intrinsic functions Use predefined	1
Use signed when converting to	1
Use automatic parallelization. The Gnu,	1
Use lookup tables Reading a	1
Use lookup tables ................................................................................................. 132	1
Use appropriate compiler options to	1
Use whole program optimization Some	1
Use macro as inline function	1
Use square blocking: int r1,	1
Use bitwise operators for checking	2
Use OpenMP directives. OpenMP is	1
Use 12 option -fno-builtin to	1
Use rounding instead of truncation	1
Use macros instead of functions	1
Use mask to choose between	1
Use ReadTSC() from library asmlib..	1
Use fastcall functions The keyword	1
Use predefined vector classes Fortunately,	1
bytes is slightly less compact.	1
bytes of memory. One kilobyte	1
bytes of storage space. It	1
bytes of code). If the	1
bytes to find the first	1
bytes in the end. The	1
bytes in a structure or	1
bytes in 64-bit systems. If	1
bytes in 32-bit systems and	1
bytes can be reduced to	1
bytes // 8 bytes. first	1
bytes = int 4 AVX2	1
bytes = int 8 AVX2	1
bytes = double 2 AVX2	1
bytes = double 4 AVX2	1
bytes = float or int	2
bytes = float 4 AVX2	1
bytes = float 8 AVX2	1
bytes = 4 rows. Let's	1
bytes = int64_t 2 AVX2	1
bytes = int64_t 4 AVX2	1
bytes or more then the	1
bytes by adding one more	1
bytes on contemporary processors. The	1
bytes then put the most	1
bytes from address 0x2700 to	1
bytes at a time and	1
bytes should be stored at	1
bytes Intel Core 2 0.77	1
bytes between a and b	1
bytes without cache MOVNTQ _mm_stream_pi	1
bytes without cache MOVNTDQ _mm_stream_si128	1
bytes without cache MOVNTPD _mm_stream_pd	1
bytes without cache MOVNTPS _mm_stream_ps	1
bytes without cache MOVNTI _mm_stream_si32	1
bytes AMD Opteron K8 1.09	1
bytes byte at 0, last	1
bytes smaller and the array	1
bytes S1 ArrayOfStructures[100]; This reordering	1
bytes bool 1 1 char,	1
bytes smaller. Structure and class	1
bytes each. The critical stride	1
bytes alignment, bytes bool 1	1
big a structure or each	1
big to cover the worst	1
big and is called from	1
big and uses more cache	1
big in order to cover	1
big for the stack. Is	1
big that overflow can occur	1
big that caching becomes a	1
big memory block than to	1
big memory blocks is more	1
big data structures with non-sequential	1
big data structures. For example,	1
big data structures. On the	1
big program when the program	1
big loop then you cannot	1
big floating point library which	1
big objects that take a	1
big objects come last in	1
big software companies often fail	1
big before multiplying them. This	1
big file containing numerical data	1
big arrays and other big	1
big arrays and want to	1
big matrix happen to be	1
big problem if the user	1
big program. Frequent context switches	1
big block of memory for	1
big difference in performance between	1
big runtime frameworks, intermediate code,	1
big structures by 16 for	1
big problem. Whenever the code	1
big enough to hold the	1
big enough for the specific	1
big enough for a specific	1
big waste of resources. For	1
big blocks is faster than	1
big blocks rather than a	1
big endian systems you have	1
big endian storage (e.g. PowerPC).	1
big endian storage. If you	1
big arrays, then it is	1
big mainframe computer. Big supercomputers	1
big mainframe computers. Today, the	1
big registration database in the	1
doesn't have the necessary information	1
doesn't have the line number	1
doesn't have to save recovery	1
doesn't have to push and	1
doesn't have to obey any	1
doesn't have an assembly output	1
doesn't have information about functions	1
doesn't make such an assumption	1
doesn't call any other function	1
doesn't call any other function.	1
doesn't take any extra time.	1
doesn't need the 'this' pointer.	1
doesn't need a 'this' pointer.	1
doesn't need a constructor. A	1
doesn't need induction variables to	1
doesn't need initialization. A copy	1
doesn't work for class member	1
doesn't work // Re-do the	1
doesn't work with member functions,	1
doesn't work int i =	1
doesn't work well on non-Intel	1
doesn't cause overflow in the	1
doesn't cause overflow. Example: //	1
doesn't works (gcc v. 4.5.2,	1
doesn't add or remove any	1
doesn't automatically check for array	1
doesn't give the 124 necessary	1
doesn't know the value of	1
doesn't know in advance which	1
doesn't know what class of	1
doesn't generate any extra code	1
doesn't prevent two threads from	1
doesn't handle current CPUs optimally.	1
doesn't occur has the unfortunate	1
doesn't delay the subsequent instructions.	1
doesn't matter and there is	1
doesn't matter if the size	1
doesn't depend on system-specific graphical	1
doesn't compromise safety is to	1
doesn't mean atomic. It doesn't	1
doesn't occur. In the case	1
doesn't occur, but unfortunately this	1
doesn't support, and the program	1
doesn't provide the best optimization	1
threads is discussed on page	1
threads is minimized. For example,	1
threads and put an equal	1
threads in the same processor	2
threads in a multithreaded program,	1
threads in each core. For	1
threads that run in parallel.	1
threads that jump between multiple	1
threads are often waiting for	1
threads are doing different kinds	1
threads are competing for the	1
threads are sharing the same	1
threads are areas where speed	1
threads can share the same	1
threads can add, remove or	1
threads with the same priority	2
threads with different priorities then	1
threads with low priority. In	1
threads with lower priority. If	1
threads with widely different priority	1
threads on a system with	1
threads have each their stack.	1
threads have access to the	1
threads have finished the time-consuming	1
threads use different memory areas,	1
threads will invalidate each other's	1
threads from attempting to write	1
threads should rely on static	1
threads where one thread is	1
threads so that one thread	1
threads need separate storage. No	1
threads must be declared volatile.	1
threads write to the same	1
threads running in the same	1
threads becomes faster and that	1
threads writing to the same	2
threads share the same cache.	1
threads simultaneously. This processor has	1
threads simultaneously. If the microprocessor	1
threads Parallelization by OpenMP directives	1
best and most up-to-date solution.	1
best for all applications. 2.8	1
best function libraries are highly	1
best if the following conditions	1
best on the newest CPU	1
best on a typical set	1
best on processors with this	1
best on processor X?" rather	1
best on future processors, and	1
best compiler and call it	1
best when the loop count	1
best at doing equivalent reductions	1
best compilers use the software	1
best into the algorithm in	2
best possible instruction set when	1
best possible version of the	1
best possible branch if it	1
best possible version. See the	1
best performance is obtained if	1
best performance is obtained by	1
best performance is obtained with	1
best way to avoid the	1
best way to check the	1
best way to prevent memory	1
best way to fully utilize	1
best way to identify performance	1
best optimization it may be	1
best optimized function libraries available	1
best optimized math function libraries	1
best solution is to compile	1
best optimizing compilers available, though	1
best implementation for a given	1
best cases. It is best	1
best algorithm than by optimizing	1
best performance. The Windows and	1
best under this unit-test may	1
best Java machines use just-in-time	1
best Java implementations. However, these	1
best job optimizing a particular	1
best suited for the project	1
best optimizer. Borland/CodeGear/Embarcadero C++ builder	1
best algorithm. The choice of	1
necessary to have many different	1
necessary to use 64-bit systems	1
necessary to use assembly language.	1
necessary to do the algebraic	1
necessary to do this manually.	1
necessary to do optimizations such	1
necessary to do experiments in	1
necessary to first look up	1
necessary to test the different	1
necessary to check if an	1
necessary to optimize anything else	1
necessary to replace the CPU	1
necessary to look up the	1
necessary to load several files	1
necessary to unroll a loop	1
necessary to convert b from	1
necessary to modify the program	1
necessary to allocate a new	1
necessary to compromise on the	1
necessary to reload *p and	1
necessary to query certain operating	1
necessary to adhere to certain	1
necessary in the following cases:	1
necessary for your application then	1
necessary for verifying the functionality	1
necessary if the objects stored	1
necessary if you can use	1
necessary when no attempt is	1
necessary then it may be	1
necessary because the factorials don't	1
necessary functions for distinguishing between	1
necessary instruction set. It is	1
necessary library files are also	1
necessary (see page 96). Virtual	1
necessary calculations of (2n /	1
necessary information about which implementation	1
necessary information about Func1 when	1
necessary here to draw the	1
necessary destructors after jumping out	1
necessary communication between threads is	1
necessary cleanup jobs to do.	1
necessary initialization. The compiler may	1
necessary support. Hardware updating. The	1
element is stored (or if	1
element is accessed, and this	1
element is stored? If the	1
element of the array a	1
element to list and make	1
element to x?" or "how	1
element in the list causes	1
element in the arrays: //	1
element in a matrix for	1
element in a linked list	1
element in an array, or	1
element in vector c __m128i	2
element in vector c2 with	1
element in vector bc with	1
element in b to 0	2
element in order to calculate	1
element in list, the compiler	1
element for a 512 512	1
element if the address can	1
element } An array initialized	1
element then use a smart	1
element Example 9.6a Time per	1
element Example 9.6b 64 64	1
element has to wait for	1
element number 16 in column	1
element number i. The size	1
element 0 in this column.	1
element addresses for one array	1
element __m128i a = _mm_blendv_epi8(bc,	1
element a[i] is ecx+eax*4. The	1
element outside the loop or	1
element level 9. Avoid table	1
element level 108 You may	1
element Instruction set needed _mm_shuffle_epi8	1
element zero. It is not	1
element 63 63 31 11.6	1
element matrix[r][c] is swapped with	1
element matrix[r][c] below the diagonal	1
element matrix[c][r] at its mirror	1
element (approximately): if (absvalue >	1
element matrix[c][r]. // Example 9.5a	1
language is a compromise between	1
language is that the software	1
language is best suited for	1
language is chosen as the	1
language is provided as an	1
language is portable in the	1
language is implemented. The highest	1
language is inherently parallel because	1
language and the rest of	1
language and a basic understanding	1
language and development tool is	1
language and automatic CPU-dispatching (see	1
language and interface frameworks. This	1
language in the same chip	1
language for CPU-intensive code, as	1
language that can be cross-	1
language that allows direct access	1
language that requires compilation or	1
language with a wealth of	1
language as a subset, giving	1
language when the optimization of	1
language will often be C	1
language has full metaprogramming features,	1
language because a good compiler	1
language also includes the low-level	1
language elements in order to	1
language need only read this	1
language Use intrinsic functions Use	1
language allows compile-time if statements	1
language runtime of the .NET	1
language based on intermediate code	1
language modules when the highest	1
language defines an algorithm of	1
language defines hardware circuits consisting	1
language programming, compiler technology, and	1
language 11 programming, etc. In	1
language While C++ has many	1
language output. On most compilers	1
language Before starting a new	1
language relates to security. Standard	1
language ............................................................................... 8 2.5 Choice	1
language gained remarkably in popularity	1
language output, which is useful	1
But the compiler doesn't have	1
But the same errors can	1
But the C++ language also	1
But the software implementation is	1
But the & operator forces	1
But the cost of fine-tuning,	1
But a solution where a	1
But a highly optimized program	1
But a sorted list can	1
But in the template function,	1
But in more complex cases	1
But it is the responsi-	1
But it is possible to	1
But it is certainly something	1
But it can be a	1
But it may be a	1
But if the program had	1
But if the loop is	1
But if the software contains	1
But if a large fraction	1
But if all the additions	1
But if I write that	1
But not if the loop	1
But an optimizing compiler will	1
But this language gained remarkably	1
But this solution can still	1
But when the result of	1
But program loading can be	1
But each member function has	1
But most of the Microsoft	1
But there is an extra	1
But there are a few	1
But there are special cases	1
But many programs use more	1
But we will not get	1
But we do have to	1
But these eight elements will	1
But what if an exception	1
But lazy binding definitely degrades	1
But implementing a matrix in	1
But beware of the pitfalls	1
But beware that these functions	1
But beware that macro parameters	1
speed is many times faster	1
speed is relevant when CPU	1
speed is particularly critical. A	1
speed is critical. The fastest	1
speed is important. This can	1
speed is important. Some systems	1
speed is important. An important	1
speed of a program is	1
speed of functions with integer	1
speed of each version of	1
speed of CPUs is increasing	1
speed of modern microprocessors is	1
speed of RAM memory. Efficient	1
speed of addition, subtraction, multiplication,	1
speed to using templates. Two	1
speed to using namespaces. 65	1
speed and for minimizing memory	1
speed in any of the	1
speed for certain tasks on	1
speed or not at all	1
speed or program size, while	1
speed or size. Today, it	1
speed or full speed. A	1
speed or not. There are	1
speed if the bottleneck is	1
speed by using a particular	1
speed by using short int	1
speed by using vectors if	1
speed on non-Intel CPUs was	1
speed will be improved by	1
speed because of cache evictions	1
speed between using signed and	1
speed between single and double	1
speed between rounding and truncation.	1
speed test should preferably be	1
speed without jeopardizing safety, you	1
speed up the calculation of	1
speed up multiplications and divisions	1
speed advantage in using the	1
speed here is likely to	1
speed Testing the speed of	1
speed exceeding that of yesterday's	1
speed /O2 or /Ox -O3	1
specific to Microsoft compilers. //	1
specific functions have names with	1
specific CPU model and then	1
specific CPU feature on Intel	1
specific CPU core by setting	1
specific CPU core during time	1
specific CPU models if the	1
specific CPU brands or specific	1
specific CPU models. However, we	1
specific instruction set. 13.6 CPU	1
specific instruction set, e.g. /arch:SSE2.	1
specific size is different for	1
specific pointer does not alias	1
specific version of the function.	1
specific order but are identified	1
specific optimization instructions at specific	1
specific instructions that are coded	1
specific processor models rather than	1
specific advantage to obtain, such	1
specific parts of the code	1
specific optimizations in precompiled code.	1
specific graphics framework is used.	1
specific load address. If this	1
specific calling conventions for functions	1
specific advantages that can be	1
specific size. Integer operations are	1
specific models then you will	1
specific purpose in order to	1
specific places in the code.	1
specific profiler. For Intel CPUs	1
specific event it is servicing.	1
specific recommendation of which one	1
specific recommendation about which platforms	1
specific bottleneck or any particularly	1
specific purpose. It is possible	1
specific needs. 9.8 Strings Text	1
specific literature for more complicated	1
specific model. Instead, I will	1
specific purpose, you must consider	1
specific preferences for the IDE,	1
specific purpose: Contain one or	1
specific option) better: -Ofast -mveclibabi	1
specific interval. A hash map	1
c is added to the	1
c and d would all	1
c are integers, while the	1
c can share the same	1
c = a + 2	1
c = a * 2.5;	1
c = a & b;	1
c = a && b;	1
c = b + 1	1
c = b + 1;	1
c = 0; } if	1
c = 1; } else	1
c = temp / 4;	1
c = d + 3.5;	1
c = 100, y; y	1
c = LoadVector(cc + i);	3
c = (a+1) / 4;	1
c = 1.23456, y; y	1
c loop in example 9.5a	1
c + b + a;	1
c + 2 : b	2
c + d; // makes	1
c + d; This expression	1
c + 2, b *	2
c + two, b *	1
c < SIZE; c++) {	2
c < r; c++) {	2
c < 0. The division	1
c __m128i c2 = _mm_add_epi16(c,	2
c __m128i bc = _mm_mullo_epi16	2
c > b) But beware	1
c (a&&b) || (a&&b&&c) =	1
c first. b+c = 100000001.23456.	1
c x-xx----- 75 (a&&b) ||	1
much is a clock cycle?	2
much of the trivial programming	1
much on the compiler. Some	1
much as possible at compile	1
much you gain in speed	1
much time is wasted on	1
much time it takes. Debugging.	1
much time it uses. There	1
much time each part takes.	1
much more by choosing the	1
much more than the time	1
much more time than other	1
much more time than processing	1
much more efficient to have	1
much more efficient if it	1
much more complicated implementation is	1
much more resources than the	2
much more dramatic when contentions	1
much memory a function uses	1
much data for one segment	1
much data as possible into	1
much faster to access a	1
much faster than the Boolean	1
much less memory and computing	1
much less efficiently when data	1
much about the costs if	1
much about overflow and underflow	1
much space in the code	1
much longer time than addition,	2
much longer time than rounding	1
much higher than normal. This	1
much higher resolution can be	1
much faster. In the above	1
much faster. There may be	1
much faster. Division by a	1
much slower than a dedicated	1
much simpler in 64-bit mode	1
much stronger for level-2 cache	1
much faster, except perhaps for	1
single and double precision in	1
single and double precision when	1
single and double precision. Long	1
single or double precision, and	1
single function or hot spot	1
single function by adding throw()	1
single function from the library	1
single object file. This enables	2
single branch if the constants	1
single call to a graphics	1
single call to memcpy rather	1
single bit which is 0	1
single register the object has	1
single & operation, which is	1
single instructions that take only	1
single constant with a decimal	1
single function. Switch between different	1
single assembly instructions or small	1
single precision to double precision	1
single precision or by making	1
single precision or double precision,	1
single precision if you have	1
single precision than for double	1
single precision variables in the	2
single operation using the |	1
single task that consumes most	1
single precision. These conversions take	1
single precision. Using double precision	1
single precision. When the floating	1
single precision. And who would	1
single executable file when static	1
single element. The most common	1
single step rather than the	1
single result. An uncaught overflow	1
single operation. Example: // Example	1
single instruction. The CPU supports	1
single container, preferably with contiguous	1
single comparison: // Example 14.4b	1
single result, true (1) or	1
single session. But lazy binding	1
i; for (i = 0;	5
i; for (i = (int)n	1
i; if ((unsigned int)i <	1
i; int Induction = r;	1
i; } } Example 14.30	1
i; } x; x.f =	1
i; } Here, the address	1
i; } u; if (u.i	1
i; } u; int n;	2
i; } u; u.i ^=	1
i; } u; u.i &=	1
i; } u, v; if	2
i; float x; for (i	1
i; float f; f=i; f	1
i; float a[size], b[size]; //	1
i; float a[size], b[size], c[size];	1
i; float list[size]; ... if	1
i; float i2; for(i=0,i2=0; i<100;	1
i; return f; } This	1
i; long long time1; long	1
i; const int ARRAYSIZE =	1
i; short int s; s	1
i; short int s; 40	1
i; ... for (i =	2
i; ... if (i >=	1
i; ... list[i & 15]	1
i; Here, the value that	1
i; p = p +	1
i; for(i=0; i<300; i++){ list[i]	2
i; for(i=0; i<300; i+=3){ list[i]	1
i; for(i=0; i<100; i++)a[i]=2*i; The	1
i; for(i=0; i<301; i+=3){ list[i]	1
i; 45 for (i =	1
i; 84 for (i =	1
These are of course system-specific.	1
These are available as an	1
These function libraries are useful	1
These function libraries are highly	1
These may be used as	1
These different methods have exactly	1
These functions are listed in	1
These functions are highly optimized	1
These two functions are doing	1
These two books contain many	1
These table lookups are needed	1
These registers have long double	1
These new instructions can make	1
These systems use segmentation of	1
These cases are usually dealt	1
These instructions are summarized below.	1
These instructions are accessible from	1
These instructions write directly to	1
These virtual processors can have	1
These operators and functions consume	1
These addresses all belong to	1
These problems should be taken	1
These complicated cases should definitely	1
These methods are discussed in	1
These methods also work when	1
These directives are supported by	1
These conversions are not safe,	1
These conversions can be used	1
These conversions do not produce	1
These conversions take a lot	1
These lines are organized as	1
These costs are higher for	1
These costs can be justified	1
These containers should definitely be	1
These counters can be very	1
These algorithms are described in	1
These factors are explained in	1
These profilers are useful for	1
These units are used twice	1
These requirements are often conflicting	1
These suffixes are listed in	1
These workaround methods depend on	1
virtual function is called on	1
virtual function is needed. Example:	1
virtual function will be called,	1
virtual function } }; //	1
virtual function call if it	1
virtual function calls is the	1
virtual function dispatch mechanism is	1
virtual function dispatch process. This	1
virtual function tables. The static	1
virtual functions are used in	1
virtual functions or when accessing	1
virtual functions if possible. Smaller	1
virtual functions then you can	1
virtual functions class CHello {	1
virtual table is used for	1
virtual table to see whether	1
virtual table before the first	1
virtual table lookup for a	1
virtual member the object does	1
virtual member function is a	1
virtual member functions if the	1
virtual member functions then there	1
virtual member function. See page	1
virtual member functions. The following	1
virtual void Disp() { cout	2
virtual void f(); }; class	1
virtual void f(); }; void	1
virtual void Disp(); void Hello()	1
virtual processors can have any	1
virtual processors on the same	1
virtual function. If the version	1
virtual processor may be given	1
virtual processor may have a	1
virtual functions. The template parameter	1
virtual functions. This so-called virtual	1
virtual functions, and other complications	1
virtual destructor is as efficient	1
virtual table. Unfortunately, few compilers	1
virtual machine are frameworks that	1
virtual 53 function at runtime.	1
virtual machine. The best Java	1
several different functions and you	1
several different C++ compilers to	1
several different CPUs if you	1
several different ways of doing	1
several different ways of copying	1
several different CPUs. On the	1
several different purposes. All these	1
several different algorithms in order	1
several different profiling methods: Instrumentation:	1
several functions that are used	1
several other less well-known languages.	1
several clock cycles whenever it	1
several clock cycles. You cannot	1
several variables happen to be	1
several times in order to	2
several large arrays and where	1
several versions for different processors	1
several execution units. Typically, there	1
several standard PC's in a	1
several files when the program	1
several branches is not predicted	1
several applications use the same	1
several examples of suitable containers	1
several advantages over 32 bit	1
several ways to divide the	1
several seconds to access the	1
several seconds because it requires	1
several iterations of redesign. Some	1
several iterations ahead. It is	1
several factors that can make	1
several factors that can prevent	1
several hundred clock cycles if	1
several reasons. C++ is supported	1
several years before your code	1
several layers of abstraction in	1
several drivers, configuration files and	1
several minutes to write the	1
several minutes to start up,	1
several meanings depending on the	1
several stages before they are	1
several flaws: The best possible	1
through the following steps to	1
through the calculations so that	1
through the PLT and GOT.	1
through the implicit pointer known	1
through the Internet at regular	1
through the symbolic link. Use	1
through a function pointer which	1
through a function pointer typically	1
through a function call. (2)	1
through a pointer to one	1
through a pointer in an	1
through a pointer or a	1
through a pointer or reference	1
through a pointer or reference,	2
through a pointer stored in	1
through a template parameter. It	1
through a template parameter. No	1
through a linked list takes	1
through a second step of	1
through a pointer. It may	1
through a smart pointer. Accessing	1
through a linear array. No	1
through a series of calculations:	1
through a self-relative address. (3)	1
through a hidden pointer. The	1
through function pointer a =	1
through function calls. Internal references	1
through an import table or	1
through an imported pointer, but	1
through this address. Step (1)	1
through multiple function calls. The	1
through multiple layers and it	1
through array cout << list[i]	1
through pointers in one way	1
through pointers or references then	1
through pointers or references: If	1
through pointers so that the	1
through rows for (c =	1
through rows // loop columns	1
through pointers, e.g.: // Example	1
through 14, with some changes	1
common to make two versions	1
common to make container classes	1
common to exchange data or	1
common for software to add	1
common function libraries are discussed	1
common memory and string instructions.	1
common compilers are mentioned below.	1
common way of setting a	1
common programming error known as	1
common programming errors associated with	1
common programming error. The allocated	1
common error that hackers often	1
common language runtime of the	1
common cause of errors in	1
common cause of reduced performance.	1
common programs use inappropriate CPU	1
common problems with profilers are:	1
common mathematical functions such as	1
common mathematical calculations including linear	1
common source of error known	1
common string functions as well	1
common platforms with Windows, Linux,	1
common math functions such as	1
common subexpression elimination and loop-invariant	1
common subexpression elimination, constant propagation,	2
common situation where the loop	1
common implementations of string classes	1
common implementations of smart pointers	1
common purposes (www.boost.org). The "Intel	1
common names. Use fastcall functions	1
common pitfalls of CPU dispatching	1
common obstacles to efficient use	1
common entry point extern "C"	1
common time-consumers are discussed in	1
common excuse that "we don't	1
common subexpressions, and induction variables	1
common denominator can even be	1
common denominator: // Example 14.16b	1
common subexpressions that contain pure	1
common practice to test each	1
common sub-expressions. Why is template	1
a, a & 0 =	1
a, a | a =	1
a, a | 0 =	1
a, a || false =	1
a, int x[]) { int	1
a, but they are not	1
a, b and c can	1
a, float b) {x =	1
a, b; a = b	5
a, b; a = parabola	1
a, b; a = (int)d;	1
a, b; a = Multiply(10,8);	1
a, b; // everything is	1
a, b; // Critical innermost	1
a, b; double c; b	1
a, b; b = !a;	1
a, b, c and d	1
a, b, c; a =	2
a, b, c; // Define	1
a, b, c; // Roll	1
a, b, c; b =	1
a, b, c; ... //	2
a, b, c, d; a	1
a, b, c, d; if	1
a, b, c, d; c	1
a, b, c, d; };	1
a, b, c, temp; temp	1
a, b, c, d, y;	2
a, b, c, d, e,	1
a, bool b) { if	4
a, T const & b)	1
a, sizeof(b)); 47 Most compilers	1
thread is used for prefetching	1
thread is waiting for response	1
thread is terminated. The purpose	1
thread to a specific CPU	2
thread in which they are	1
thread in systems with only	1
thread that runs alone in	1
thread that shares the resources	1
thread are smaller. The lengths	1
thread can then run on	1
thread can do calculations while	1
thread can do mathematical calculations.	1
thread can take care of	1
thread can possibly block the	1
thread function so that it	1
thread if the application has	1
thread if it is short	1
thread if there is other	1
thread with lower priority than	1
thread as very time-consuming tasks	1
thread than to temporarily lock	1
thread than another. Therefore, it	1
thread may run at less	1
thread have a destructor that	1
thread will always run slower	1
thread will get time slices	1
thread will run at more	1
thread has its own stack.	1
thread should then handle its	1
thread void DelayFiveSeconds() { seconds	1
thread its own data structure	1
thread does not necessarily stay	1
thread running in the same	1
thread safe if multiple threads	1
thread priority before the test	1
thread jumps between different CPU	1
thread environment block. Thread-local storage	1
thread steals resources from a	1
thread affinity mask. Poor reproducibility.	1
thread scheduler. This can be	1
thread increments seconds. A safer	1
etc. is still the same	1
etc. is considerable. If two	1
etc. of only half the	1
etc. and the wires that	1
etc. in vectors. These function	1
etc. The C++ exception handling	1
etc. The problem here is	1
etc. The efficiency of the	1
etc. The worst case is	1
etc. for Windows, -msse2, -mavx,	1
etc. for Linux) 4. Align	1
etc. are implemented in hardware	1
etc. are defined as powers	1
etc. // Returns time stamp	1
etc. This means that all	1
etc. may have to be	1
etc. then there is no	1
etc. It is common to	1
etc. at compile time. The	1
etc. should be as standardized	1
etc. In most cases, you	1
etc. In cases where the	1
etc. In large arrays, it	1
etc. There are a few	1
etc. For example: // Example	1
etc. Use an antivirus program	1
etc. But program loading can	1
etc. But beware that these	1
etc. These counters can be	1
etc. #define Alignd(X) X __attribute__((aligned(16)))	1
etc. Optimizing database queries is	1
etc. scattered around on the	1
etc. And it is discussed	1
etc. Whether you choose to	1
etc. (Intel CPU only) (Intel	1
etc. SSSE3 a few more	1
etc. -msse3 -mssse3 -msse4.1 -mAVX	1
etc. Event-based sampling requires a	1
etc. Locked mutexes. Open database	1
etc. Accessibility guidelines should be	1
etc. Overriding the Intel CPU	1
AMD and Intel vector math	1
AMD and VIA processors. It	1
AMD and VIA processors. See	1
AMD and VIA processors. Explicit	1
AMD and VIA CPUs. 5.	1
AMD and VIA including the	1
AMD and VIA processors, and	1
AMD and VIA CPUs"). This	2
AMD and VIA CPUs"). Const	1
AMD and VIA CPUs" for	2
AMD and VIA CPUs" gives	1
AMD and VIA CPUs: An	1
AMD and VIA CPUs". A	1
AMD and VIA CPUs". 9.3	1
AMD and VIA. The next	1
AMD or VIA processor and	1
AMD only _mm_permutevar_ps 4 4	1
AMD processors and earlier Intel	1
AMD processors are sure to	1
AMD CPUs use AMD CodeAnalyst.	1
AMD CPUs (See manual 3:	1
AMD AMD Math core library	1
AMD CPUs. The Gnu compiler	1
AMD CPUs. New versions are	1
AMD math core library contains	1
AMD processors, but not on	1
AMD Math core library contains	1
AMD Core Math Library __vrs4_expf	1
AMD CodeAnalyst. There are several	1
AMD CodeAnalyst. Unfortunately, profilers are	1
AMD Opteron K8 0.24 0.25	1
AMD Opteron K8 1.09 1.25	1
AMD Opteron K8 0.38 0.44	1
AMD LIBM library. Only available	1
AMD LIBM Library amd_vrs4_expf amd_vrd2_exp	1
AMD FMA4 fma4intrin.h (Gnu) all	1
AMD SSE4A ammintrin.h AMD XOP	1
AMD XOP ammintrin.h (MS) xopintrin.h	1
AMD Family 15h Processors". www.amd.com.	1
compile the program are often	1
compile the program with profiling	1
compile the shared object without	1
compile the output of the	1
compile a shared object without	1
compile for different instruction sets	1
compile with the option -fno-pic	1
compile with the option -fpie	1
compile with -mcmodel=large, but this	1
compile time to eliminate everything	1
compile time and insert the	1
compile time or a reasonable	1
compile time or a not-too-big	1
compile time then there is	1
compile time because of the	1
compile time which version of	1
compile time so that the	1
compile time rather than at	2
compile time while if is	1
compile time here. It may	1
compile time. The function library	1
compile time. The storage of	1
compile time. // Example 15.1a.	1
compile time. A variable number	1
compile time. A template instance	1
compile time. For example, all	1
compile time. For example: //	1
compile time. Some compilers are	1
compile time. Integer division by	1
compile time. No memory will	1
compile time. Templates make the	1
compile time. Are objects accessed	1
compile time. Text strings and	1
compile time. Four typical uses	1
compile time. (Of course there	1
compile time. (Examples can be	1
compile them separately with the	1
compile time, but the program	1
compile for. The names of	1
compile time? If the number	1
exception is costly when it	1
exception is caught by the	1
exception in case of overflow	1
exception in case of overflow.	1
exception for floating point overflow:	1
exception or other error condition.	1
exception then F1 has to	1
exception so that it doesn't	1
exception without using the normal	1
exception handling is not necessary	1
exception handling is negligible because	1
exception handling and you want	1
exception handling in this example.	1
exception handling for the whole	1
exception handling for a single	1
exception handling can be expensive	1
exception handling then you cannot	1
exception handling takes no extra	1
exception handling even in the	1
exception handling system makes sure	1
exception handling option in the	1
exception handling support anyway. The	1
exception handling unless the code	1
exception handling information. Each function	1
exception handling Exception handling is	1
exception handling /EHs- No stack	1
exception safe if there are	1
exception occurs in the innermost	1
exception occurs somewhere in F1?	1
exception handling. It is recommended	1
exception handling. See the manual	1
exception handling. 8.6 Optimization directives	1
exception handling. Omitting the standard	1
exception ever happens. This is	1
exception handler to call the	1
exception handler in the program	1
exception handler needs all information	1
exception safe. In other words,	1
exception handler, even if no	1
exception handlers for cleaning up	1
allocated is also deallocated. Failure	1
allocated is also de-allocated. This	1
allocated to each task or	1
allocated and the entire contents	1
allocated and deallocated in random	2
allocated in sequence are not	1
allocated for an integer constant,	1
allocated with new or malloc	1
allocated with new or malloc.	1
allocated with alloca, because it	1
allocated memory is contiguous with	1
allocated memory may not be	1
allocated memory into a container	1
allocated memory block. A large	1
allocated memory Memory allocated with	1
allocated array may need to	1
allocated array into a container	1
allocated objects and keep track	1
allocated objects are not overlapping	1
allocated objects are also deallocated	1
allocated objects with each their	1
allocated memory. It is difficult	1
allocated memory. 9.6 Dynamic memory	1
allocated resources that need to	1
allocated resources are cleaned up	1
allocated dynamically with new and	1
allocated dynamically when the size	1
allocated dynamically when the total	1
allocated dynamically (with new or	1
allocated resources. The system is	1
allocated block. Walking through a	1
allocated object, and ownership is	1
allocated memory, using new. The	1
allocated memory, windows, mutexes, database	1
allocated resource. The C++ way	1
allocated separately. The allocation, deallocation	1
allocated dynamically. The advantages of	1
allocated dynamically. Arrays that are	1
allocated memory................................................................. 120 12.9 Aligning	1
small to cause overflow, this	1
small and always the same.	1
small and fixed repeat count	1
small and changing then the	1
small in the critical part	1
small that a binary search,	1
small that it fits into	1
small or if it is	2
small or if it opens	1
small or too long. If	1
small code size has higher	1
small as possible or when	1
small x // align table	1
small x // x^n //	1
small then a sorted list	1
small bit at a time.	1
small test program that calls	1
small part of the program.	1
small bits in a non-sequential	1
small block for each object.	1
small piece of memory inside	1
small piece at a time	1
small dynamically allocated objects with	1
small loops (less than 65	1
small fraction of the total	1
small gain in performance. There	1
small enough to justify the	1
small devices if you avoid	1
small devices with limited resources.	1
small embedded systems. Today (2013)	1
small embedded applications have less	1
small pieces of a suitable	1
small pieces of code that	1
small devices, as discussed on	1
small devices, but there are	1
small sequences of code. The	1
small microcontrollers: Smaller microcontrollers have	1
small subtasks, but it is	1
small low-power CPUs (Intel Atom).	1
overflow is another security problem.	1
overflow is needed: // Example	1
overflow is "undefined". This allows	1
overflow of the arrays. It	1
overflow of the arrays. An	1
overflow of a signed variable	1
overflow of an unsigned variable	1
overflow and works only for	1
overflow and give the result	1
overflow and negative inputs give	1
overflow and loss of precision	1
overflow and underflow except in	1
overflow and underflow neutralize each	1
overflow and underflow. The range	1
overflow and redo the calculation	1
overflow in the particular application.	1
overflow can cause unpredictable errors	1
overflow can occur in the	1
overflow can occur, but the	1
overflow or another error has	1
overflow or assume that it	1
overflow or loss of precision,	1
overflow by checking if b[i]	1
overflow with the option -ftrapv,	1
overflow on the intermediate expression	1
overflow on input data is	1
overflow will make the value	1
overflow has occurred. // Reset	1
overflow but no other exceptions:	1
overflow before it occurs, (2)	1
overflow doesn't occur has the	1
overflow Integer to float conversions	1
overflow never occurs, even for	1
overflow outside the loop without	1
overflow condition will generate the	1
overflow condition inside the loop	1
overflow checks where necessary (see	1
overflow checks where necessary. Fast	1
overflow behavior well-defined with option	1
overflow check. There are a	1
+= i / 3; }	1
+= b; In this example,	1
+= n << 23; //	1
+= x; This makes sure	1
+= x; Here, the code	1
+= 2; Common subexpression elimination	1
+= 2) { a[i] =	1
+= 2) { sum1 +=	1
+= 2) { FuncA(i); FuncC(i);	1
+= xn / nfac; xn	1
+= 4) { s0 +=	1
+= a[i]; The above code	1
+= a[i]; s1 += a[i+1];	1
+= a[i]; Converting an integer	1
+= 8) { // Load	4
+= 1.0f; This needs a	1
+= 1.0f; } The two	1
+= 1.0f; } A possible	1
+= i_div_3; } 138 A	1
+= i_div_3; list[i+1] += i_div_3;	1
+= i_div_3; list[i+2] += i_div_3;	1
+= xxn * _mm_load_ps(coef+i); //	1
+= 16) { b.load(bb+i); c.load(cc+i);	1
+= TILESIZE) { for (c1	1
+= TILESIZE) { // Loop	1
+= 2;} // add 2	1
+= list[i]; This has a	1
+= list[i]; sum2 += list[i+1];}	1
+= A2; // Table //	1
+= a[i+1]; s2 += a[i+2];	1
+= x^n/n! xxn *= xx4;	1
+= Z; Z += A2;	1
+= a[i+2]; s3 += a[i+3];	1
+= list[i+1];} sum1 += sum2;	1
+= a[i+3]; } sum =	1
+= sum2; If the microprocessor	1
+= 9; } Induction variables	1
integers is ambiguous and may	1
integers is costless. It is	1
integers of the default size	1
integers of any size other	1
integers of 8 bits each,	1
integers of 64 bits each.	1
integers of 16 bits each,	1
integers of 32 bits each,	1
integers to floating point is	1
integers to floating point numbers	1
integers to signed integers before	1
integers to alias upon the	1
integers and other hardware-related details	1
integers and floating point numbers	1
integers and floating point variables,	1
integers and floating point numbers.	1
integers and 64-bit integers, as	1
integers in 32-bit systems, especially	1
integers in case of overflow	1
integers in 16-bit systems or	1
integers in comparisons, such as	1
integers are equally near then	1
integers or floating point numbers.	1
integers or four float's when	1
integers if the application can	1
integers with the value 0	1
integers with a very large	1
integers with hardly any loss	1
integers as Boolean vectors, and	1
integers - they are guaranteed	1
integers int a, b; double	1
integers use truncation towards zero,	1
integers from 0 to 12.	1
integers which range from -128	1
integers In most cases, there	1
integers before conversion to floating	1
integers (see page 142). 30	1
integers simply makes the compiler	1
integers Conversion from floating point	1
integers ................................... 141 14.9 Using	1
option is also available from	1
option is less useful in	1
option in the compiler. You	1
option in the compiler. Loop	1
option for the linker. Both	1
option for all modules that	1
option for assembly language output.	1
option for source annotation in	1
option for whole program optimization	1
option for assuming no pointer	1
option for "assume no pointer	1
option for RTTI then turn	1
option for "standard stack frame"	1
option for "function level linking"	1
option that allows less precise	1
option that gives the simplest	1
option that limits the CPU	1
option if you want to	1
option then use an object	1
option only in the Professional	1
option makes the code section	1
option makes the assembly output	1
option available. Some compilers offer	1
option -fpic according to the	1
option -fno-pic and link with	1
option -fno-pic when compiling for	1
option -fno-pic apparently has no	1
option -fno-builtin to get library	1
option -fpie because the linker	1
option -fpie instead of -fpic.	1
option "assume no pointer aliasing"	1
option /MT). In Linux and	1
option -mveclibabi=acml. Agner's vector class	1
option -ftrapv, but this is	1
option /QaxAVX or -axAVX. This	1
option (Windows: /Gy, Linux: -ffunction-sections)	1
option -fwrapv or -fno-strict-overflow. You	1
option -read_only_relocs suppress. GOT and	1
option -mveclibabi=svml. This library has	1
option -Wstrict-overflow=2, or (5) make	1
good to have two or	1
good to do a thorough	1
good for the logical structure	1
good for the application. You	1
good for making clear and	1
good for optimizing execution speed	1
good if you can take	1
good code performance is to	1
good as the compiler itself	1
good as the Microsoft, Intel,	1
good as possible. The first	1
good as expected. I believe	1
good compiler can often optimize	1
good compiler can optimize away	1
good compiler will optimize this	1
good compiler will convert example	1
good at optimizing away p	1
good compilers and optimized function	1
good compilers will reduce int	1
good performance and precision. The	1
good performance for many applications	1
good way of making sure	1
good way to prevent such	1
good optimization options. Supports parallel	1
good optimizing compiler should produce	1
good implementation of the memcpy	1
good implementation uses XMM registers	1
good development tools, rather than	1
good choice for code that	1
good choice for all platforms.	1
good choice for all Unix-like	1
good choice for Linux platforms	1
good idea to make a	1
good idea to put time-	1
good idea to collect the	1
good deal of programming experience	1
good deal of research on	1
good investment. A redesign can	1
good performance). Aligned operands means	1
good knowledge of the C++	1
power of the processors on	1
power of the graphics processing	1
power of 2 is faster	1
power of 2 and the	1
power of 2 in example	1
power of 2 in order	1
power of 2 can be	1
power of 2 // Still	2
power of 2 or not.	1
power of 2 if the	4
power of 2 if possible	1
power of 2 by using	1
power of 2 then the	2
power of 2 then N&(N-1)	1
power of 2 return powN<(N	1
power of 2 template <int	1
power of 2 does not	1
power of 2 Integer division	1
power of 2 (See page	1
power of 10 double xpow10(double	2
power of 2. The following	1
power of 2. Example: //	2
power of 2. Objects bigger	1
power of 2. Contentions in	1
power of 2, so the	1
power of N template <int	1
power of 2: template <bool	1
power of two. In the	1
power function when the exponent	1
power than PCs. Therefore, it	1
power using loop double ipow	1
power using template metaprogramming //	1
power consumption are actually quite	1
matrix is the same as	1
matrix is a multiple of	1
matrix is a power of	1
matrix is a high power	1
matrix is so big that	1
matrix is bigger than the	1
matrix a in a column-wise	1
matrix a power of 2	1
matrix and stores the result	1
matrix in my experiments. Contentions	1
matrix in STL as a	1
matrix for use as pivot	1
matrix // function to transpose	2
matrix // call transpose function	1
matrix // define a macro	1
matrix or multidimensional array is	1
matrix or multidimensional array should	1
matrix on a Pentium 4	1
matrix when the size of	1
matrix when contentions occur in	1
matrix using example 9.5a on	1
matrix size causes misses in	2
matrix into smaller squares and	1
matrix void TransposeCopy(double a[SIZE][SIZE], double	2
matrix line size. I tried	1
matrix line (in bytes) is	1
matrix longer than needed in	1
matrix 512 520 and leave	1
matrix sizes were measured on	1
matrix happen to be equal	1
matrix element. The multiplication by	1
matrix line. The delay is	1
matrix 96 void transpose(double a[SIZE][SIZE])	1
matrix sizes. The results of	1
matrix cell for different matrix	1
matrix a: // Example 9.6b.	1
Linux is that the loader	1
Linux is more efficient than	1
Linux and 32-bit Windows in	1
Linux and Windows platforms. The	1
Linux and Windows platforms. This	1
Linux and supported by the	1
Linux and Mac platforms. 2.	1
Linux and Mac platforms By	1
Linux and Mac systems, this	1
Linux and BSD comes at	1
Linux and BSD, the slow	1
Linux and perhaps Mac OS.	1
Linux and Mac. Supports parallel	1
Linux and BSD. The Windows	1
Linux and BSD. If a	1
Linux in almost all respects	1
Linux The procedure to calculate	1
Linux with Microsoft, Intel and	1
Linux as well as Intel-based	1
Linux than in 64-bit Windows	1
Linux than in 64-bit Windows.	2
Linux have an attribute which	1
Linux Intel compiler Intel compiler	1
Linux Intel compiler Windows Intel	2
Linux also applies to BSD	1
Linux operating systems give almost	1
Linux systems. The user interface	1
Linux platform n.a. __unix__ __linux__	1
Linux syntax 90 Gives a	1
Linux platforms if the bias	1
Linux compiler, or vice versa.	1
Linux Shared objects are normally	1
Linux platforms, and in some	1
Linux __INTEL_COMPILER __INTEL_COMPILER n.a. n.a.	1
Linux kernel version 2.6.30 and	1
Linux Align by 16 __declspec(	1
Linux Optimize for speed /O2	1
been a power of 2	1
been stored in the container,	1
been called before. This is	1
been accessed recently than to	1
been allocated is also deallocated.	1
been replaced by my comments,	1
been tested in Mac systems.	1
been tested only on PC	1
been given a name. #define	1
been reduced from 20 to	1
been initialized to valid values	1
been copied to the disk	1
been defined in other ways	1
been added and then use	1
been increased from 64-bit MMX	1
been updated since 2004. Can	1
been updated lately. Vector class	1
been doubled. Thin clients that	1
been loaded. This makes a	1
been translated to the instruction	1
been deallocated. The program logic	1
been deallocated. Failure to do	1
been added? If search facilities	2
been incremented to 5 by	1
been lost at the time	1
been incremented, while in the	1
been reordered, inlined, or optimized	1
been alleviated in the 64-bit	1
been identified, then it may	1
been found, then it is	1
been unsatisfied with the performance	1
been calculated. Therefore, it is	1
been introduced in Linux and	1
been criticized for code bloat	1
been brutally interrupted. Now it	1
been identified. My test tool	1
been wasted. The consequence is	1
been allocated. If the final	1
cause the memory to be	1
cause the cache to load	1
cause the software to be	1
cause the heap to be	1
cause the creation of temporary	1
cause the resource-hungry applications to	1
cause a cache miss. But	1
cause a lot of jumping	1
cause a waste of cache	1
cause a loss of precision,	1
cause of errors in C++	1
cause of reduced performance. 25	1
cause of unacceptably long response	1
cause other variables to be	1
cause all kinds of strange	1
cause cache contentions if the	1
cause cache contentions. See page	1
cause branch mispredictions if the	1
cause large delays. The easiest	1
cause overflow in the particular	1
cause overflow or loss of	1
cause problems if the network	1
cause problems when the hardware	1
cause caching problems because static	1
cause contentions in the code	1
cause contentions in the data	2
cause errors if the size	1
cause overflow. For example, in	1
cause overflow. Example: // Example	1
cause seven memory allocations of	1
cause overflow, this code can	1
cause unpredictable errors elsewhere in	1
cause delays in the program	1
cause complications with member pointers	1
cause slight imprecision in some	1
cause severe delays if the	1
cause fatal errors if they	1
cause holes of unused bytes	1
AVX is supported in Windows	1
AVX is supported by both	1
AVX and later instruction sets.	1
AVX or later with code	1
AVX or later instruction set	1
AVX code to non-AVX code	1
AVX code to non-AVX code.	1
AVX int 32 16 512	1
AVX only when AVX2 is	1
AVX instruction set is that	1
AVX instruction set is available	1
AVX instruction set is supported	2
AVX instruction set and YMM	2
AVX instruction set can run	1
AVX instruction set. The main	1
AVX instruction set, another version	1
AVX using CPU dispatching then	1
AVX double 64 4 256	1
AVX version int CriticalFunction_AVX(int parm1,	1
AVX version 127 int CriticalFunction_AVX(int	1
AVX 32 instruction set is	1
AVX instructions have very few	1
AVX support and another part	1
AVX support then call _mm256_zeroupper()	1
AVX support calls a function	1
AVX supported return &CriticalFunction_AVX; }	1
AVX supported CriticalFunction = &CriticalFunction_AVX;	1
AVX 256 bit float and	1
AVX instructions. The automatic vectorization	1
AVX instructions. A further extension	1
AVX support. There is a	1
AVX part. If a function	1
AVX part. If a piece	1
AVX instr. set Automatic CPU	1
AVX support, then call _mm256_zeroupper()	1
AVX _mm256_permutevar_ps 4 4 bytes	1
AVX immintrin.h AMD SSE4A ammintrin.h	1
classes is just a matter	1
classes and using overloaded operators	1
classes and member functions is	1
classes and overloaded operators. Vectorized	1
classes and templates for several	1
classes in the same generation	1
classes in the STL (Standard	1
classes in the form of	1
classes that use these methods	1
classes are given in www.agner.org/optimize/cppexamples.zip.	1
classes are generally not thread	1
classes are currently available, one	1
classes can also be convenient	1
classes // Function to load	1
classes or modify the ones	1
classes or structures. Accessing a	1
classes with destructors to take	1
classes on page 93. 7.10	1
classes than by using assembly	1
classes use dynamic memory allocation	1
classes use dynamic memory allocation.	1
classes void SelectAddMul(short int aa[],	1
classes like string, wstring or	1
classes #include "vectorclass.h" // Define	1
classes defined in Intel header	1
classes defined in two libraries	1
classes allocate a new memory	1
classes implement the functions that	1
classes contain the different versions	1
classes Agner's vector class library	1
classes Fortunately, it is rarely	1
classes ............................................................................................. 113 12.6 Transforming	1
classes Whenever dynamic memory allocation	1
classes ..................................................................................................... 93 9.8 Strings	1
classes looks like this: //	1
classes Programming in the way	1
classes (Intel) #include <pmmintrin.h> //	1
classes 114 #include <dvec.h> //	1
classes Nowadays, programming textbooks recommend	1
done the job before you.	1
done a good deal of	1
done to choose the optimal	1
done in a loop of	1
done in a single instruction.	1
done in big blocks rather	1
done in connection with reading	1
done by the operating system	1
done by the constructor itself.	1
done by the linker and	1
done by copying the entire	1
done by multiplying with the	1
done by declaring the table	1
done by me manually, but	1
done by controlling the order	1
done by fetching, decoding and	1
done with the functions lrintf	1
done with the operators new	1
done with the resolution of	1
done with a special trick	1
done with a shift operation,	1
done with an extended number	1
done with long double precision.	1
done with single or double	1
done with just two additions	1
done on the type of	1
done as a shift operation.	1
done at the second step.	1
done at compile time. (Examples	1
done at every access. The	1
done at runtime here if	1
done only once. One may	1
done only once, while the	1
done every time the critical	1
done simply by ignoring the	1
done outside the loop. In	1
done under the best-case conditions.	1
done manually by the programmer.	1
done implicitly when calculating the	1
therefore the system code is	1
therefore a good idea to	1
therefore be a disadvantage if	1
therefore be used only for	1
therefore be advantageous to make	1
therefore be advantageous when a	1
therefore be aware of situations	1
therefore it is accessed much	1
therefore as efficient as any	1
therefore as fast as integer	1
therefore not be too worried	1
therefore not possible to distribute	1
therefore not advantageous by itself.	1
therefore not recommended if portability	1
therefore more error prone. The	1
therefore more safe than the	1
therefore possible for the compiler	1
therefore cannot do the optimization	1
therefore need modification if implemented	1
therefore important to understand how	1
therefore necessary to do the	1
therefore necessary to do this	1
therefore necessary to convert b	1
therefore likely to be cached	1
therefore certain to be mispredicted	1
therefore count as true, if	1
therefore recommended to put a	1
therefore recommended that big arrays	1
therefore preferably be stored at	1
therefore preferably be put away	1
therefore preferably have a balanced	1
therefore difficult to maintain. If	1
therefore fail to see the	1
therefore fail to start the	1
therefore equal to the time	1
therefore becoming more and more	1
therefore safer to do this	1
therefore suffer from mispredictions. 44	1
therefore conclude that most variables	1
precision is not supported. The	1
precision is good if you	1
precision is used. A newer	1
precision of approximately seven significant	1
precision to double precision before	1
precision in all operands in	1
precision in 32-bit systems gives	1
precision in programs compiled for	1
precision for reasons explained on	1
precision or by making a	1
precision or double precision, but	1
precision or four single precision	1
precision or eight single precision	1
precision if you have big	1
precision by default, so 1.2	1
precision on most processors (when	1
precision as the operands. The	1
precision than for double precision.	1
precision when the XMM registers	2
precision takes only slightly more	1
precision variables in the XMM	1
precision variables in the YMM	1
precision before multiplying with the	1
precision without worrying too much	1
precision constant and then convert	1
precision (see page 73). It	1
precision calculations are just as	1
precision calculations take no more	1
precision conversion instructions which can	1
precision conversion Conversions between float,	1
precision requires only SSE). The	1
precision require precision conversion instructions	1
precision math allow addition of	1
precision constant. It is therefore	1
precision math. Memory copying. There	1
precision math. Libraries for high	1
precision division, square root and	1
precision (80 bits). The advantages	1
line is implicitly converting a	1
line to be read and	1
line in both the level-1	1
line that we expect to	1
line that was used by	1
line that covered the address	1
line can hold 8 double's	1
line or a make utility.	1
line or an input file.	1
line if you don't want	1
line by any other form	1
line by line when it	1
line with all the relevant	1
line when it is run.	1
line will be loaded anyway.	1
line then the line that	1
line at a time and	1
line at a time. A	1
line has to be reloaded	1
line size is typically 64	1
line size of 64 bytes.	1
line size of 64. Each	1
line size in order to	1
line size // define matrix	1
line size may possibly be	1
line size (typically 64) can	1
line number information. It is	1
line doesn't work int i	1
line would be evicted. Don't	1
line options relevant to optimization	1
line size. I tried to	1
line containing the address range	1
line size, which is typically	1
line separately through multiple function	1
line (in bytes) is a	1
line covers 64 consecutive bytes	1
line provokes an error. //	1
line 29. Each cache line	1
line written. This worked sufficiently	1
works is of course a	1
works and suggests methods for	1
works in the following way.	1
works in the main executable	1
works for any compile-time constant	1
works by compiling in two	1
works with all compilers. Use	1
works on all the compilers	1
works on Intel processors. The	1
works more efficiently with coarse-grained	1
works then you may put	1
works only for compilers that	1
works only for Intel CPUs,	1
works only for positive n.	1
works only for powers of	1
works only if the loop	1
works only if it is	1
works only with Intel processors.	1
works only on registers, not	1
works most efficiently if functions	1
works most efficiently if pieces	1
works most efficiently when the	1
works less efficiently if the	1
works even if a and	1
works best if the following	1
works best on the newest	1
works best on a typical	1
works best on processors with	1
works best on processor X?"	1
works well on all brands	1
works well on non-Intel processors,	1
works particularly bad on a	1
works automatically. However, there are	1
works best. Some common function	1
works differently. The link to	1
works correctly. A code branch	1
works somewhat less efficiently when	1
works (gcc v. 4.5.2, July	1
optimized is to do it	1
optimized and fine-tuned for a	1
optimized for the Intel Core	1
optimized for is likely to	1
optimized for a particular CPU	1
optimized for SSE2 and later	1
optimized for large data sets.	1
optimized for execution speed and	1
optimized for accessing arrays forwards,	1
optimized for 16-bit mode and	1
optimized function libraries available use	1
optimized function libraries. C++ is	1
optimized if a and b	1
optimized by using indexes, working	1
optimized code with CPU dispatching,	1
optimized code will load the	1
optimized code because it doesn't	1
optimized code looks like this:	1
optimized code (release version) in	1
optimized as good as the	1
optimized program is often reorganized	1
optimized Intel function libraries, but	1
optimized version of the executable.	1
optimized version because the debugging	1
optimized software design, it is	1
optimized part of the code	1
optimized versions of memory and	1
optimized mathematical functions. It also	1
optimized function, but unfortunately the	1
optimized math function libraries available.	1
optimized to: // Example 7.10b	1
optimized away and the result	1
optimized well, others are not.	1
optimized programs. The profiler identifies	1
optimized away. It is common	1
optimized away. Note that volatile	1
optimized further. The first thing	1
optimized yet. Supports both AMD	1
inside the function in which	1
inside the function that needs	1
inside the function they are	1
inside the CPU which can	1
inside the CPU used for	1
inside the loop is in	1
inside the loop are finished.	1
inside the loop can be	1
inside the loop can change	1
inside the loop does not	1
inside the loop is. The	1
inside the class definition. This	1
inside the critical innermost loop.	1
inside the function. This is	1
inside the innermost loop. Another	1
inside the loop. The following	1
inside the loop. Example 12.4b	1
inside the loop. If each	1
inside the class. Which solution	1
inside the derived class: //	1
inside the pow function when	1
inside the loop, for example	1
inside the template. The powN	1
inside a function are stored	2
inside a function but outside	1
inside a loop with few	1
inside a class are stored	1
inside a class Variables declared	1
inside a class definition. Inlining	1
inside can be predicted perfectly.	1
inside one function, if possible.	1
inside another loop that also	1
inside your program before and	1
inside containers should be identified	1
inside {} brackets. However, most	1
inside sqaure: for (r2 =	1
inside square: // Example 8.1b	1
manual is for advanced programmers	1
manual is number one in	1
manual is also relevant to	1
manual is based on the	1
manual is based mainly on	1
manual for your compiler for	1
manual for my test tool	1
manual for reasons explained on	1
manual for details. // Example	1
manual for details. Use function	1
manual or in the programming	1
manual on usability, but I	1
manual will soon be obsolete.	1
manual at www.agner.org/optimize/cppexamples.zip contains examples	1
manual at www.agner.org/optimize/cppexamples.zip containing container	1
manual at www.agner.org/optimize/cppexamples.zip. 9.9 Access	1
manual does not cover graphics	1
manual 3: "The microarchitecture of	7
manual 2: "Optimizing subroutines in	3
manual 5: calling conventions. The	1
manual 5: "Calling conventions for	5
manual currently doesn't works (gcc	1
manual discusses how to make	1
manual 4: "Instruction tables". There	1
manual 4: "Instruction tables". Tips	1
/ b as a *	1
/ 2 (be aware of	1
/ 4 = 2048 bytes	1
/ 8 = 64 kb.	1
/ unsigned conversion // Example	1
/ c; a = b	1
/ means integer division with	1
/ b) is calculated in	1
/ b) etc. at compile	1
/ b) >> n with	1
/ 3; } This can	1
/ 10; a = b	1
/ 10; a = (unsigned	1
/ 10; // Convert to	1
/ CodeGear / Embarcadero Comes	1
/ 16; a = (unsigned	1
/ 16; // This is	1
/ b2; This can be	1
/ (number of ways). If	1
/ 64) % 32 =	1
/ sar ebx,1 adds this	1
/ jl $B1$2 is the	1
/ c) 139 can sometimes	1
/ (line size) % (number	1
/ x64 (Visual Studio 2005).	1
/ shr ebx,31 copies the	1
/ 4; The compiler may	1
/ 4; Register variables The	1
/ (b1*b2); The trick of	1
/ nfac; xn *= x;	1
/ 1.2345; Change this to:	1
/ b1; y2 = a2	1
/ 1.2345); The compiler will	1
/ (b1 * b2); y1	1
/ 0x40) % 0x20 =	1
/ 3.0; The compiler will	1
/ Embarcadero Comes with the	1
explained in the other volumes	1
explained in the next paragraph.	1
explained in the next section.	1
explained in the previous chapter	1
explained in the chapter "Register	1
explained in example 7.35 page	1
explained in manual 5: "Calling	1
explained in chapter 9.10, then	1
explained in detail on page	1
explained on page 8 below.	1
explained on page 16. If	1
explained on page 146 below.	1
explained on page 105. Floating	1
explained on page 93. Avoid	1
explained on page 26. Avoid	1
explained on page 122. The	1
explained on page 72. It	1
explained on page 72. You	1
explained on page 22. Avoid	1
explained on page 107. A	1
explained on page 62. If	1
explained on page 96. 14.5	1
explained on page 44. The	1
explained on page 132. Unfortunately,	1
explained on page 87. This	1
explained on page 130. It	1
explained on page 27. An	1
explained at page 150. Using	1
explained below. The disadvantage of	1
explained below. There are other	1
explained below. Shared objects in	2
explained below on page 134.	1
explained above, the maximum loop	1
explained above, so that it	1
explained above. A shared object	1
explained above. Examples are provided	1
calculated the first time Func	1
calculated the fastest first. However,	1
calculated in advance and the	1
calculated in advance and stored	1
calculated in advance. This reduces	1
calculated by the series: ex	1
calculated by a single &	1
calculated by an induction variable	1
calculated by an induction variable.	1
calculated by n additions and	1
calculated by adding a constant	1
calculated with the same precision	1
calculated with two decimals, for	1
calculated as follows: floatvalue (	1
calculated as (critical stride) =	1
calculated as (b*2.0)/3.0 rather than	1
calculated as ((a+b)+c)+d. This is	1
calculated more efficiently from the	1
calculated from the value that	1
calculated from the previous value	2
calculated from a value that	1
calculated at compile time here.	1
calculated at compile time. For	1
calculated using multiplications only. The	1
calculated faster than double precision	1
calculated much faster than the	1
calculated fast if it is	1
calculated value. The keyword static,	1
calculated result. Example: // Example	1
calculated twice because the macro	1
calculated first, then d+e, then	1
calculated once, rather than each	1
calculated internally as (int)&matrix[0][0] +	1
calculated independently. The CPU will	1
calculated asa << 4, anda	1
calculated as(a << 4) +	1
calculation is more complicated in	1
calculation of the array address	1
calculation of the address of	1
calculation of the power function	1
calculation of the residual error	1
calculation of the factorials, but	1
calculation of this polynomial can	1
calculation of A is finished.	1
calculation of A is slow,	1
calculation of A and then	1
calculation of one iteration should	1
calculation of one iteration before	1
calculation of expressions where operands	1
calculation of graphics objects in	1
calculation of B before the	1
calculation of self-relative references in	1
calculation of c+b will generate	1
calculation of B. In order	1
calculation of (a+b). This can	1
calculation and table lookup mechanisms	1
calculation in a way that	2
calculation in 64 bit mode	1
calculation may be moved out	1
calculation time is actually more	1
calculation time is doubled. The	1
calculation time of 250 ms.	1
calculation more efficient: // Example	1
calculation time. A loop counter	1
calculation implemented with template metaprogramming.	1
calculation becomes easier if we	1
calculation requires n-1 multiplications, which	1
calculation here gives a+b=0, and	1
calculation depends on the result	1
calculation depends on the previous	1
calculation faster. The advantage of	1
calculation capabilities. Here is a	1
}; The values of nonzero	1
}; The offset of b	1
}; // The child classes	1
}; // constant data //	1
}; // Function template for	1
}; // Make all instances	1
}; // Any function that	1
}; // Index out of	1
}; // Full template specialization	2
}; // Called directly //	1
}; // Partial template specialization	1
}; if ((unsigned int)n <	1
}; if (y) { F1(a);	1
}; int order(int x); const	1
}; int Sum2(S3 * p)	1
}; class C1 : public	1
}; class CChild2 : public	1
}; class C2 : public	1
}; void test () {	2
}; void F1() { C1	1
}; void g() { C1	1
}; void Func() { S1	1
}; char abc; }; Bitfield	1
}; S1 ArrayOfStructures[100]; Here, there	1
}; struct Sdouble { unsigned	1
}; struct Slongdouble { unsigned	1
}; Bitfield x; int A,	2
}; Weekdays Day; if (Day	2
}; Replace with: // Example	1
}; 7.23 Constructors and destructors	1
}; 52 or class is	1
}; vector() {} vector(float a,	1
128 function cannot rely on	1
128 because the offset can	1
128 double 128 float 256	1
128 float 256 double 256	1
128 bit vector of two	1
128 bit vector of four	1
128 bit vector containing integers.	1
128 bit integer and double	1
128 bit float vectors SSE2	1
128 SSE2 int 32 4	1
128 SSE2 float 32 4	1
128 SSE2 long long 64	1
128 SSE2 short int 16	1
128 SSE2 char 8 32	1
128 bits (XMM), 256 bits	1
128 bits (XMM) if the	1
128 bytes or more then	1
128 bytes then put the	1
128 bytes Intel Core 2	1
128 bytes AMD Opteron K8	1
128 128 128 17.4 129	1
128 128 17.4 129 129	1
128 below. Dispatch at installation	1
128 == 0) { //	1
128 bytes. 7.19 Class member	1
128 SSE double 64 2	1
128 Is16vec8 Vec8s 16 8	1
128 13.7 CPU dispatching in	1
128 Is8vec16 Vec16c 8 16	1
128 Iu32vec4 Vec4ui 64 2	1
128 17.4 129 129 130	1
128 Is32vec4 Vec4i 32 4	1
128 I64vec2 Vec2q 64 2	1
128 Vec2uq 8 32 char	1
128 Iu8vec16 Vec16uc 16 8	1
128 Iu16vec8 Vec8us 32 4	1
uses the cache in between	1
uses the new features. Take	1
uses the dispatch on every	1
uses a different implementation when	1
uses a lot of runtime	1
uses a lot of CPU-time	1
uses a lookup table instead	1
uses a newer version of	1
uses a procedure linkage table	1
uses a GOT. Another possibility	1
uses of a and b	1
uses of dynamic memory allocation	1
uses by looking at a	1
uses an unfortunate method that	1
uses an ordinary procedure linkage	1
uses more than 2 gigabytes	1
uses more cache space. Excessive	1
uses more clock cycles than	1
uses more bits than a	1
uses CPU dispatching: 1. How	1
uses most of its time	1
uses many small dynamically allocated	1
uses 32-bit absolute addresses. This	1
uses 64 bits. The vector	1
uses pointers because it cannot	1
uses new and delete to	1
uses 32 bits while a	1
uses much more resources than	1
uses few resources. On the	1
uses XMM registers to test	1
uses position-independent code and lazy	1
uses ebx as a temporary	1
uses logarithms in the general	1
uses 90% of the CPU	1
uses SSE3. // (This is	1
uses (live ranges) do not	1
four function parameters to be	1
four cache lines in set	1
four cache lines in each	1
four cache lines from set	1
four double precision or eight	1
four float additions in the	1
four elements of b into	1
four single precision variables in	1
four integers of 32 bits	1
four parameters to be transferred	1
four parameters are transferred in	1
four numbers of type int.	1
four numbers at a time	1
four results in a. This	1
four consecutive terms in one	1
four kinds of costs to	1
four cores can run eight	1
four (or eight) points with	1
four additions in one operation.	1
four parameters. There is no	1
four B value in the	1
four places back. Thus, we	1
four physical processors but eight	1
four objects. STL vector stores	1
four floats F32vec4 xxn(x4, x2*x,	1
four bits, and the result	1
four numbers, then you have	1
four multiplications. How was it	1
four float. The type __m128d	1
four x^n } return add_elements(s);	1
four G values in the	1
four R value in one	1
four float's when the SSE2	1
four float's fits into a	1
four sums } This loop	1
four floats. The same applies	1
functions. The code is compact	1
functions. The compiler makes a	1
functions. The floating point stack	1
functions. The template parameter should	1
functions. The following example shows	1
functions. The difference is simply	1
functions. The second generation class	2
functions. The 'this' pointer takes	1
functions. The CPU- specific functions	1
functions. This is useful in	1
functions. This so-called virtual table	1
functions. This applies to default	1
functions. A static member function	2
functions. A lot of advanced	1
functions. A frame function is	1
functions. A metaprogramming implementation analogous	1
functions. A thread-safe function should	1
functions. It is recommended to	1
functions. It is just easier	1
functions. It also works on	1
functions. There is no performance	1
functions. You can force a	1
functions. See page 49 for	1
functions. I disagree with this	1
functions. Many function libraries are	1
functions. Avoid virtual functions if	1
functions. Alternatively, you can use	1
functions. 80 Unfortunately, this method	1
functions. While an empty throw()	1
functions. 7.4 Enums An enum	1
functions. 7.27 Overloaded operators An	1
functions. 9.4 Variables that are	1
functions. Sum1 has an implicit	1
functions. Time- consuming library functions	1
another function and these two	1
another function with the same	1
another function which in turn	1
another function library that works	1
another function F2 that can	1
another by assignment. shared_ptr allows	1
another memory access. Assume that	1
another vector register containing (2,2,2,2),	1
another loop that also repeats	1
another C++ program (or part	1
another version for CPUs with	1
another way than last time.	1
another dynamic library requiring the	1
another part of the program	1
another error has occurred anywhere	1
another thread is waiting for	1
another thread can take care	1
another thread will always run	1
another thread void DelayFiveSeconds() {	1
another source file. If the	1
another addition to sum2 from	1
another function, etc., and if	1
another compiler. 2.6 Choice of	1
another class. It makes a	1
another thread. This prevents the	1
another thread. If seconds was	1
another problem. The compiler sometimes	1
another array. The disadvantage of	1
another dispatched function then the	1
another security problem. The official	1
another computer. The Pentium 4	1
another exception. 64 If you	1
another module. The compiler has	1
another module. The size of	1
another module. This non-inlined copy	1
another platform. 14.8 Conversions between	1
parameters a and r are	1
parameters of the new function.	1
parameters to a class member	1
parameters to be transferred in	4
parameters and the 49 first	1
parameters that are declared as	1
parameters are not affected by	1
parameters are stored on the	1
parameters are always resolved at	1
parameters are transferred in registers	5
parameters are transferred in registers,	2
parameters are transferred by value	1
parameters are transferred on the	1
parameters are replaced by their	1
parameters are exactly the same.	1
parameters are evaluated every time	1
parameters on the stack and	1
parameters on CodeGear compiler). Fastcall	1
parameters then the code can	1
parameters then make it a	1
parameters because of alignment problems.	1
parameters Function parameters are transferred	1
parameters would be transferred in	1
parameters replaced by their actual	1
parameters ............................................................................................... 50 7.16 Function	1
parameters typedef int CriticalFunctionType(int parm1,	1
parameters Vec4f polynomial (Vec4f const	1
parameters differ then you will	1
get the same result if	1
get the value 10 *	1
get the value -100+100+100 =	1
get the generic branch, which	1
get the exact time consumption	1
get a compiler warning for	1
get a good performance for	1
get a good deal of	1
get a lot of branches	1
get a better result by	1
get a misprediction penalty of	1
get a realistic number of	1
get a reply about investigation	1
get as much data as	1
get an integral number of	1
get x to the power	1
get time slices of typically	1
get more reproducible time measurements:	1
get used to read and	1
get one instance for each	1
get no warning from the	1
get library versions instead. The	1
get any answer. Beginners are	1
get very expensive cache contentions,	1
get access to the same	1
get 0 rather than 1.23456.	1
get its own address through	1
get four float additions in	1
get next each bit in	1
get reliable results for branch	1
get reproducible results. This is	1
get ReadTSC as a library	1
get rid of the branch.	1
get rid of the GOT	1
get rid of all the	1
get answers to your programming	1
b; a = b +	1
b; a = b *	3
b; a = b /	1
b; a = b ?	1
b; a = parabola (2.0f);	1
b; a = (b ==	1
b; a = (int)d; //	1
b; a = Multiply(10,8); b	1
b; a += b; In	1
b; for (i = 0;	1
b; // 4 bytes. first	1
b; // 8 bytes. first	1
b; // everything is float	1
b; // Critical innermost loop:	1
b; if (b) { y	2
b; This is typically implemented	1
b; int c; int UnusedFiller;	1
b; int d; // 2	1
b; int c;}; abc *	1
b; int Sum1() {return a	1
b; A branch can also	1
b; will make 32 AND-operations	1
b; } A problem with	1
b; } else { a	1
b; double c; b =	1
b; b = a ^	1
b; b = !a; can	1
b; static const float OneOrTwo5[2]	1
b; In this example, the	1
b; c = b +	1
b; Here, I have used	1
b; d = a |	1
b; d = a ||	1
check the code that the	1
check the order of functions	1
check the final result to	1
check is bypassed by any	1
check for the error code.	1
check for the supported instruction	1
check for CPU brand simply	1
check for all the necessary	1
check for integer overflow. Signed	1
check for array bounds violations,	1
check for overflow of the	2
check for overflow and works	1
check for overflow by checking	1
check for overflow before it	1
check for overflow outside the	1
check for buffer overflow on	1
check for overflow. This function	1
check for overflow. Example: //	1
check for exceptions thrown by	1
check that the conversion is	1
check that thrown exceptions are	1
check if the compiler does	1
check if the inputs have	1
check if a floating point	1
check if it has been	1
check if an array index	1
check if your modifications actually	1
check if XMM registers are	1
check if nonzero u.i +=	1
check on b can be	1
check on n here because	1
check makes dynamic_cast more time-consuming	1
check before the loop if	1
check whether an integer is	1
check after the loop if	1
advantageous the smaller the data	1
advantageous to use the smallest	2
advantageous to use the newest	1
advantageous to use a lookup	1
advantageous to use vector operations	1
advantageous to use vector operations.	1
advantageous to use float rather	1
advantageous to use hyperthreading or	1
advantageous to make the number	1
advantageous to do simple integer	1
advantageous to do things in	1
advantageous to replace the branch	1
advantageous to put the operand	1
advantageous to put file access	1
advantageous to mix integer and	1
advantageous to mix floating point	1
advantageous to keep the two	1
advantageous to roll out a	1
advantageous to split the tasks	1
advantageous in most cases where	1
advantageous in cases where we	1
advantageous for applications that can	1
advantageous or not. The Intel	1
advantageous if the function is	1
advantageous if the loop body	1
advantageous if the operands are	1
advantageous if the typical repeat	1
advantageous if a lot of	1
advantageous by itself. But a	1
advantageous as replacements for switch	1
advantageous when a program has	1
advantageous then it is necessary	1
advantageous because registers is a	1
advantageous vectorization is. Factors that	1
advantageous if, and only if,	1
implemented a separate version for	1
implemented a collection of example	1
implemented in the same way	1
implemented in the high level	1
implemented in a more efficient	1
implemented in a separate dynamic	2
implemented in different places making	1
implemented in compiled C++ or	1
implemented in compiled C++. This	1
implemented in hardware in the	1
implemented in various ways depending	1
implemented in PC processors. The	1
implemented by the compiler in	1
implemented by (partial) template specialization.	1
implemented with an intermediate code	1
implemented with template metaprogramming. Don't	1
implemented with intrinsic functions for	1
implemented with interpretation. The program	1
implemented on a platform with	1
implemented on other platforms with	1
implemented as a function library	1
implemented as a function call	1
implemented as a table of	1
implemented as a linked list.	1
implemented as a circular buffer	2
implemented as vector operations. 105	1
implemented as three branches. They	1
implemented as follows in 64-bit	1
implemented as recursive templates. The	1
implemented simply by storing the	1
implemented like this in a	1
implemented either as static link	2
implemented internally as a member	1
problem is to use a	1
problem is to use string	1
problem is to make the	1
problem is to combine the	1
problem is that it is	1
problem is likely to go	1
problem is too important to	1
problem of the x86 instruction	1
problem and make the next	1
problem and assume that the	1
problem in interactive programs because	1
problem that the clock frequency	1
problem that were not present	1
problem are the following: 130	1
problem can be overcome by	1
problem can be solved by	1
problem if the user has	1
problem if the repeat count	1
problem by increasing the thread	1
problem by defining _mm_malloc and	1
problem by bypassing the so-called	1
problem with the C++ language	1
problem with this code is	1
problem with vector operations when	1
problem with accessing 32 bits	1
problem with macros is that	1
problem when the repeat count	1
problem when mixing code compiled	1
problem then it may be	1
problem has been alleviated in	1
problem only occurs because the	1
problem cannot easily be obtained.	1
problem void AddTwo(int * __restrict	1
problem here is that access	1
problem since we are assuming	1
known to the compiler at	1
known to be an annoying	1
known to be 0 or	1
known to be true anyway.	1
known to be false regardless	1
known in 36 C++ as	1
known with certainty that the	1
known as memory leak. An	1
known as memory leaks. It	1
known then it is more	1
known from a previous branch.	1
known at this place. This	1
known at compile time to	1
known at compile time or	2
known at compile time then	1
known at compile time because	1
known at compile time which	1
known at compile time. The	1
known at compile time. //	1
known at compile time. A	1
known at compile time. Integer	1
known at compile time. Are	1
known at compile time. Text	1
known at compile time. Four	1
known at compile time, but	1
known at compile time? If	1
known at compile-time whether the	1
known CPU model is over.	1
known which version of the	1
known before the first element	2
known hardware CPU. These virtual	1
known processors. Other brands or	1
known type, but you cannot	1
(i = 0; i <	26
(i = 2; i <=	1
(i = StringLength; i >	1
(i = (int)n - 2,	1
(i < 0 || i	1
(i < ARRAYSIZE && list[i]	1
(i < arraysize) { //	1
(i >= min && i	1
(i >= N) { //	1
(i % 2 == 0)	1
solution is the combination of	1
solution is a fixed size	1
solution is to have a	1
solution is to use inline	1
solution is to make the	1
solution is to make a	1
solution is to compile with	1
solution is to rely on	1
solution is more complicated. If	1
solution is using one register	1
solution is best for all	1
solution is optimal on the	1
solution is too high. It	1
solution is clearly better. The	1
solution a = 1.0f +	1
solution of making the arrays	1
solution of making the entire	1
solution to this problem is	2
solution to make the functions	1
solution to these problems is	1
solution in this case is	1
solution in such cases. The	1
solution in some cases. An	1
solution for the memory model	1
solution that doesn't compromise safety	1
solution can still give a	1
solution can incur a large	1
solution on future CPUs. Half	1
solution may be a binary	1
solution you prefer is a	1
solution because the high level	1
solution because of its simplicity.	1
solution where a soft processor	1
solution would be to include	1
container is to hold only	1
container is too big for	1
container for a specific purpose:	1
container for each row or	1
container for exclusive access by	1
container that contains only a	1
container that allows you to	1
container be recycled? There is	1
container are allowed to have	1
container or memory pool. Alignment?	1
container than to delete it	1
container may move the object	1
container class that takes care	1
container class that behaves like	1
container class libraries use dynamic	1
container class must have a	1
container class templates are available	1
container class templates, as explained	1
container elements are cumbersome to	1
container rather than by pointers	1
container without dynamic memory allocation.	1
container classes and templates for	1
container classes in the STL	1
container classes in the form	1
container classes that use these	1
container classes are given in	1
container classes or modify the	1
container classes on page 93.	1
container classes use dynamic memory	1
container class. The container class	1
container classes. The standard template	1
container classes. An appendix to	1
container classes. Unfortunately, many standard	1
container classes. Text strings are	1
container expandable, but it is	1
advantage of the AVX instruction	2
advantage of the fact that	1
advantage of a new register	1
advantage of this by preferably	1
advantage of this method is	1
advantage of this fact by	1
advantage of this capability: //	1
advantage of vector operations, as	1
advantage of using a software	1
advantage of using a template	1
advantage of using static here	1
advantage of using powers of	1
advantage of using ready made	1
advantage of static data is	1
advantage of 64-bit integer calculations.	1
advantage of 64-bit integers. The	1
advantage of these guidelines by	1
advantage of bigger vector registers.	1
advantage of out-of-order execution. The	1
advantage of out-of-order execution, you	1
advantage of sharing the same	1
advantage to using hyperthreading. On	1
advantage to using hyperthreading, but	1
advantage to unroll a loop.	1
advantage to obtain, such as	1
advantage in the select function,	1
advantage in using the larger	1
advantage in applications that can	1
advantage in interpreted languages where	1
advantage that the response time	1
advantage that it does not	1
advantage if the threads are	1
advantage because integer operations are	1
advantage comes automatically. There is	1
Function to store aligned integer	1
Function to store unaligned integer	3
Function to load aligned integer	1
Function to load unaligned integer	3
Function with vector parameters Vec4f	1
Function pointer initially points to	1
Function pointer serves as entry	1
Function return types The return	1
Function return types .............................................................................................. 50	1
Function libraries can be implemented	2
Function template for x to	1
Function pointers ...................................................................................................... 37 7.8	1
Function pointers Calling a function	1
Function calls may slow down	1
Function parameters that are declared	1
Function parameters are stored on	1
Function parameters are transferred in	2
Function parameters are transferred by	1
Function parameters Function parameters are	1
Function parameters ............................................................................................... 50 7.16	1
Function addresses are obscured in	1
Function inlining The compiler can	1
Function inlining can open the	1
Function inlining has the complication	1
Function inlining x-xxxx--x Constantfolding xxxxxxxxx	1
Function names are undocumented. 2.7	1
Function level linking (remove unreferen-	1
Function prototype CriticalFunctionType CriticalFunction_Dispatch; //	1
Function Assembly name Intrinsic function	1
support the necessary instruction set.	1
support the SSE and later	1
support the ADX instructions for	1
support a new vector size	1
support of the different instructions	1
support and is available in	1
support and another part of	1
support in the optimized version	1
support for the exception handling	1
support for the stack. The	1
support for 64-bit integers. Many	1
support for exception handling unless	1
support for inline assembly on	1
support for intrinsic functions (i.e.	1
support for intrinsic functions, but	1
support for runtime type identification	1
support for XMM registers; see	1
support for relative addressing of	1
support for whole program optimization.	1
support for calculating the address	1
support for hard disk copying.	1
support for multiplying the index	1
support this instruction set or	1
support then call _mm256_zeroupper() before	1
support from both compiler, linker	1
support different CPUs. This method	1
support which is used during	1
support static linking. A dynamic	1
support 32-bit and 64-bit Linux	1
support calls a function in	1
support processor X" is simply	1
support intrinsic functions. Alternatively, you	1
support it. There are situations	1
support anyway. The exception is	1
support SSE. Several function libraries	1
supported in the latest compilers	1
supported in such applications. Alternatively,	1
supported in Windows 7 and	1
supported by the CPU and	2
supported by the operating system.	1
supported by the Gnu utilities	1
supported by the processor and	1
supported by the microprocessor and	1
supported by the compiler. We	1
supported by the Gnu, Clang,	1
supported by all modern CPUs.	1
supported by most CPUs and	1
supported by some very good	1
supported by both the CPU	1
supported by Microsoft, Intel, PathScale	1
supported on all 64-bit CPUs	1
supported on all major platforms.	1
supported on AMD CPUs. The	1
supported at all. Can only	1
supported instruction set for the	1
supported instruction set int iset	1
supported instruction sets and cache	1
supported instruction set. Aligning data	1
supported instruction set, using asmlib	2
supported instruction sets, cache size,	1
supported return &CriticalFunction_SSE2; } //	1
supported return &CriticalFunction_AVX; } if	1
supported 128-bit vector registers had	1
supported CriticalFunction = &CriticalFunction_SSE2; }	1
supported CriticalFunction = &CriticalFunction_AVX; }	1
supported 256-bit instructions were splitting	1
supported fprintf(stderr, "\nError: Instruction set	1
eight to fit the eight-element	4
eight in 32-bit systems and	1
eight or sixteen vector registers	1
eight different cache lines in	1
eight floating point registers available	1
eight floating point registers organized	1
eight floating point parameters are	1
eight elements in row 28	1
eight elements will go into	1
eight elements at a time	2
eight times because it is	1
eight threads simultaneously. This processor	1
eight single precision variables in	1
eight integers of 16 bits	1
eight numbers of type short	1
eight consecutive elements in aa:	4
eight consecutive elements from cc	3
eight consecutive elements from bb	3
eight consecutive elements c.load(cc+i); //	1
eight consecutive elements b.load(bb+i); //	1
eight 16-bit integers or four	1
eight 16-bit integers. The branch	1
eight logical processors. Hyperthreading is	1
operators is more advantageous if	1
operators and functions consume a	1
operators The pre-increment operator ++i	1
operators for things like adding	1
operators for checking multiple values	2
operators that have Boolean variables	1
operators that have Booleans as	1
operators that produce Boolean output.	1
operators are single instructions that	1
operators are calculated much faster	1
operators are inlined so that	1
operators on integer variables. 31	1
operators will cause the creation	1
operators because they do not	1
operators using integers as Boolean	1
operators also applies to decrement	1
operators new and delete or	1
operators An overloaded operator is	1
operators Integer operations are generally	1
operators Integer sizes Integers can	1
operators && and || are	1
operators produce a single result,	1
operators produce 32 results when	1
operators (e.g. '>') are not	1
operators Modern microprocessors in the	1
operators ............................................................................................. 56 7.28 Templates...............................................................................................................57	1
operators &, |, ^, ~	1
operators &, |, ^, ~,	1
operators &, |, ~. The	1
operators ...................................................................... 32 7.4 Enums	1
operators &&, ||, ! and	1
operators (& and |) instead	1
operators (&& and ||). The	1
few of the functions are	1
few or no other branches.	1
few more integer vector instructions	1
few functions that are particularly	1
few compilers are able to	1
few clock cycles to read	1
few clock cycles that we	1
few clock cycles more than	2
few clock cycles before the	1
few clock cycles after the	1
few clock cycles, but it	1
few cases where it makes	1
few cases where it matters:	1
few instructions that may be	1
few times may be enough	1
few extra instructions for address	1
few arrays of variable size.	1
few programs do. Hence, it	1
few cases, however, where there	1
few branches as possible, and	1
few unused points in the	1
few lines should be split	1
few resources. On the smallest	1
few parameters. Or it might	1
few machine instructions. Intrinsic functions	1
few files, preferably in the	1
few pitfalls here. You cannot	1
few lines. A few decades	1
few restrictions on alignment and	1
few kilobytes at a time.	1
few comments about how the	1
few decades ago, the recommendation	1
few places. Constant folding and	1
contains the address of the	4
contains a function which cannot	1
contains a lot of extra	1
contains a negative list of	1
contains a positive list of	1
contains only a single element.	1
contains only simple standard operations.	1
contains only six instructions rather	1
contains integer division: Integer division	1
contains no calls to frame	1
contains no absolute addresses that	1
contains floating point calculations and	1
contains many functions for common	1
contains many functions for audio	1
contains many variables and objects	1
contains many useful mathematical functions.	1
contains any member functions that	1
contains any non-polymorphic member functions.	1
contains calls to frame functions	1
contains several branches is not	1
contains optimized mathematical functions. It	1
contains various functions for these	1
contains automatic CPU dispatching or	1
contains examples of arrays with	1
contains similar functions, but less	1
contains debug information in order	1
contains well-tested libraries for many	1
contains natural parallelism. The gain	1
contains complete code examples for	1
contains i/2+r. The next instruction	1
contains writeable data. Therefore, the	1
whether the code is running	1
whether the compiler will vectorize	1
whether the different compilers succeeded	1
whether the object belongs to	1
whether the call p->f() goes	1
whether the arrays are aligned	1
whether the arrays are properly	1
whether the processor is an	1
whether the second operand is	1
whether the positive or the	1
whether the largest vector register	1
whether the original pointer actually	1
whether a particular integer size	1
whether to use dynamic memory	1
whether to store help files	1
whether to repeat or to	1
whether to base a software	1
whether it is possible to	1
whether it is advantageous to	3
whether it is optimal to	1
whether it is profitable to	1
whether an integer is within	1
whether you are using single	1
whether you use pre-increment or	1
whether there is other code	1
whether they are integers or	1
whether they were able to	1
whether r is a reference	1
whether p is a simple	1
whether vectorization will be advantageous	1
whether CriticalFunction is called once	1
whether others have done the	1
i++) is the same as	1
i++) for (j = 0;	1
i++) { // Loop to	1
i++) { // Loop through	1
i++) { // Get upper	1
i++) { // Overflow may	1
i++) { if (i %	1
i++) { ... a =	1
i++) { a[i] = b	1
i++) { a[i] = i	1
i++) { a[i] = r	1
i++) { a[i] = temp;	2
i++) { a[i] = *p	1
i++) { a[i] = b[i]	1
i++) { temp = a[i]	1
i++) { j = order(i);	2
i++) { b[i] = Func(a[i]);	1
i++) { aa[i] = (bb[i]	1
i++) { aa[i] = bb[i]	1
i++) { list[i].a = 1.0;	1
i++) { time1 = ReadTSC();	1
i++) { ab[i].b = Func(ab[i].a);	1
i++) { 92 DynamicArray[i] =	1
i++) a[i] = i+1; The	1
i++) a[i] = 0.0; //	1
i++) sum += a[i]; The	1
i++) sum += a[i]; Converting	1
i++) sum += list[i]; This	1
i++) f *= i; return	1
i++) b[i] = a[i]; It	1
i++) List[i]++; Here, the compiler	1
i++) matrix[FuncRow(i)][FuncCol(i)] += x; Here,	1
list is the most efficient	1
list is a convenient way	1
list is less efficient than	1
list is large because the	1
list is almost certain to	1
list of which code branch	1
list of which processor models	2
list of some long vector	1
list of short vector math	1
list of processors on which	1
list of processor models on	2
list of data. A hash	1
list of numbers: // Example	1
list of titles. Literature on	1
list and make this extra	1
list in example 11.2b was	1
list can be very inefficient	1
list or a binary tree.	1
list or with an index	1
list with a simple index.	1
list from static memory to	1
list has its own memory	1
list should preferably be static,	1
list float a[100]; float sum	1
list takes more time than	1
list does not need to	1
list (see page 93). All	1
list every time the function	1
list needs to be updated	1
list points out some typical	1
list causes all subsequent elements	1
list plus i*sizeof(S1). This is	1
would of course be the	1
would be to include a	1
would be an infinite loop.	1
would be 8 and no	1
would be even faster to	1
would be while (0 <	1
would be able do function	1
would be needed because the	1
would be transferred in registers	1
would be predicted well. Even	1
would be invalid in a	1
would be invalid if a	1
would be obvious to do	1
would be straightforward. The MASM	1
would be evicted. Don't mix	1
would be re-calculated every time	1
would not only be a	1
would have to add the	1
would have spent fighting with	1
would make the access non-sequential	1
would make the induction variable	1
would only read the value	1
would all be below the	1
would double the number of	1
would take longer time. It	1
would cause overflow or loss	1
would like to put a	1
would give annoyingly long and	1
would assume that seconds remains	1
would know that a template	1
would require two floating point	1
would still be in the	1
would otherwise go undetected. Converting	1
likely is a model that	1
likely to be the optimal	1
likely to be a bottleneck	1
likely to be in the	1
likely to be faster than	1
likely to be less than	1
likely to be predicted by	1
likely to be limited by	1
likely to be scattered around	1
likely to be slower than	1
likely to be obsolete. Programmers	1
likely to be irrelevant within	1
likely to be cached more	1
likely to be mispredicted, which	1
likely to use the memcpy	1
likely to work best on	1
likely to cause contentions in	1
likely to run most of	1
likely to inline a function	1
likely to generate a store	1
likely to require modifications in	1
likely to go away in	1
likely to execute slower than	1
likely to fail if the	1
likely to consume time at	1
likely to lead to a	1
likely to experience. Occasionally, the	1
likely in a more distant	1
likely that the producer will	1
likely that code cache and	1
likely that memory access is	1
likely be called, even if	1
likely case that the next	1
structure is a good way	1
structure is simply a matter	1
structure is created. There is	1
structure of the problem. This	1
structure of a program dictates	1
structure of four float's fits	1
structure to make sure its	1
structure and then merge the	1
structure and class members may	1
structure and clarity of the	1
structure in example 9.1b. On	1
structure in some cases. Does	1
structure that can easily be	1
structure are stored consecutively in	1
structure or class is less	1
structure or class for containing	1
structure or class with members	1
structure or class should be	1
structure or class declaration and	1
structure or class elements. The	1
structure or class objects. The	1
structure or each of its	1
structure or union can use	1
structure or class. The transfer	1
structure or class. This makes	1
structure then you may consider	1
structure has one big problem.	1
structure object takes no more	1
structure where data members share	1
structure 8 bytes smaller and	1
structure }; 52 or class	1
structure y into a vector	1
structure needed? A matrix or	1
doing the same thing and	2
doing the same thing. Example:	1
doing the optimizations that we	1
doing the heavy background calculations	1
doing the division. Some compilers	1
doing the spell checking. Any	1
doing a sequence of calculations	1
doing an addition to sum1	1
doing different kinds of jobs.	1
doing floating point operations involves	2
doing multiple calculations in parallel	1
doing multiple calculations in parallel.	1
doing multiple calculations simultaneously or	1
doing multiple logically distinct tasks.	1
doing two or more jobs	1
doing two iterations in one.	1
doing some calculations at compile	1
doing type conversions: // Example	1
doing calculations on large data	1
doing mathematical calculations. In other	1
doing optimizations on that variable.	1
doing things only after they	1
doing whole program 81 optimization	1
doing out-of-order execution, as explained	1
doing parallel calculations on vectors	1
doing something on these data.	1
doing arithmetic operations. The most	1
doing exactly the same thing	1
doing equivalent reductions at their	1
doing calculations, and then use	1
doing divisions. It is recommended	1
run the program in a	1
run the most advanced code	1
run the optimized code (release	1
run the advanced version on	1
run a little faster than	1
run a speed-critical program on	1
run in the background are	1
run in a low priority	1
run in an array. The	1
run in both 16-bit, 32-bit	1
run in parallel. Small lightweight	1
run with a profiler which	1
run with reduced speed or	1
run on a CPU with	1
run on its own CPU	1
run on Mac platform. Intel	1
run an inferior version on	1
run at more than half	1
run at less than half	1
run only if AVX is	1
run most of its time	1
run two threads in the	1
run two threads in each	1
run many processes simultaneously. Actually,	1
run any code branch for	1
run faster than when compiled	1
run faster at the cost	1
run faster because we can	1
run time. Therefore, both the	1
run eight threads simultaneously. This	1
run slightly faster in 64-bit	1
run slower than a thread	1
run optimally on any brand	1
calculate the function is less	1
calculate the time delay that	1
calculate the same function on	1
calculate the most common math	1
calculate the value of a	1
calculate the value and write	1
calculate the table is not	1
calculate the table in the	1
calculate the table at runtime,	1
calculate the table values by	1
calculate the address of each	1
calculate the address of element	1
calculate the addresses of array	1
calculate the absolute value of	1
calculate a vector just as	1
calculate that the number of	1
calculate it at compile time.	1
calculate it only once. Example:	1
calculate than the other then	1
calculate when long double precision	1
calculate which set of cache	1
calculate each value from the	1
calculate each address by adding	1
calculate how much memory a	1
calculate its address. The address	1
calculate element addresses for one	1
calculate xn as x4xn-4. There	1
calculate self-relative addresses is much	1
calculate *p+2 a hundred times	1
calculate *p+2 and store it	1
calculate (c+d) before it has	1
calculate (1./1.2345) at compile time	1
calculate pow(x,10) with only four	1
inline the function and to	1
inline the function or otherwise	1
inline the function, and it	1
inline a function if it	1
inline and optimize both functions	1
inline or static or by	1
inline function is expanded like	1
inline function instead of a	1
inline function #define MAX(a,b) (a	1
inline int lrint (double const	2
inline int lrintf (float const	1
inline this function and calculate	1
inline functions An inline function	1
inline double IntegerPower (double x)	1
inline float add_elements(__m128 const &	1
inline void SelectAddMul(short int aa[],	1
inline void StoreVector(void * d,	3
inline void StoreNTD(double * dest,	1
inline void StoreVectorA(void * d,	1
inline assembly or easy linking	1
inline assembly on all platforms	1
inline assembly code to give	1
inline assembly instruction for interrupt	1
inline assembly syntax in both	1
inline __m128i LoadVector(void const *	3
inline __m128i LoadVectorA(void const *	1
inline keyword is used or	1
inline T max(T const &	1
every function that is longer	1
every function or every code	1
every code line. Time-based sampling:	1
every time the function is	2
every time the function pointer	1
every time the program is	1
every time the critical function	1
every time the computer starts	1
every time a new and	1
every time a new processor	1
every time a string is	2
every time a thousand cache	1
every time it is filled	1
every time an object is	1
every time they are used.	1
every time Func is executed.	1
every clock cycle. The highest	1
every clock cycle. This means	1
every call of the critical	1
every call method. When the	1
every element in the arrays:	1
every four objects. STL vector	1
every intermediate version. For one-man	1
every three clock cycles. But	1
every second by another thread	1
every iteration of the loop.	1
every access. The code section	1
every version. For team projects,	1
every call. A branch tree	1
every millisecond. The profiler counts	1
standard is used in almost	1
standard for specifying parallel processing	1
standard function library that takes	1
standard function libraries. Several special	1
standard library functions like sqrt,	1
standard libraries for many of	1
standard libraries are not always	1
standard template library (STL) is	1
standard template library (STL) if	1
standard user interface elements that	1
standard stack frame is used	1
standard stack frame makes function	1
standard solution to this problem	1
standard container classes use dynamic	1
standard calling conventions. Optimizes reasonably	1
standard operations. All you have	1
standard tasks are available from	1
standard tasks such as sorting	1
standard header file stdint.h or	1
standard PC processors is not	1
standard PC processors are preferred	1
standard PC processors with CISC	1
standard PC platform with an	1
standard specifies that all floating	1
standard specifies truncation so the	1
standard C, specifying that two	1
standard C, specifying that pointers	1
standard API calls rather than	1
standard PC's in a network	1
standard PCs. The clock frequency	1
standard says that the behavior	1
standard 754 (1985). This standard	1
hardware is updated. Most copy	1
hardware in the x86 CPUs.	1
hardware for raising an exception	1
hardware can be wired for	1
hardware often requires that all	1
hardware functions. The floating point	1
hardware support for the stack.	1
hardware support for calculating the	1
hardware support for multiplying the	1
hardware implementation of these functions	1
hardware implementation in most cases	1
hardware implementation in most cases,	1
hardware platform and operating system.	1
hardware platform The choice of	1
hardware platform for a given	1
hardware platform has become less	1
hardware platform ....................................................................................... 5 2.2	1
hardware access. Available protocols and	1
hardware CPU. These virtual processors	1
hardware definition code in addition	1
hardware definition language is that	1
hardware definition language is inherently	1
hardware definition language in the	1
hardware definition language defines hardware	1
hardware definition language. Such a	1
hardware definition language, such as	1
hardware conditions. A dispatcher function	1
hardware interfaces and system calls.	1
hardware exceptions. The mechanism relies	1
hardware circuits consisting of digital	1
hardware design. The ultimate solution	1
hardware identification. Such schemes cause	1
1 is certain to have	1
1 is changed to c	1
1 to 127 will generate	1
1 and that the value	1
1 for the sake of	1
1 for negative numbers. The	1
1 for true. Boolean variables	1
1 if nonzero and normal	1
1 by XOR'ing it with	1
1 - 5. www.amd.com. 163	1
1 from -128 generates 127.	1
1 b = lrint(d); //	1
1 64 MMX char 8	1
1 short int, signed or	1
1 (see page 135). This	1
1 1 short int, signed	1
1 1 char, signed or	1
1 : 0] in this	1
1 cache. This has hardly	1
1 byte = char 16	2
1 byte at 8, last	1
1 fraction 2 23 ,	1
1 fraction 2 52 ,	1
1 ebx, DWORD PTR [edx]	1
1 eax, 8 edx, eax	1
1 eax, 100 $B1$2 ebx	1
1 int64_t 64 I64vec1 8	1
1 char, signed or unsigned	1
1 Introduction This manual is	1
1 Introduction ....................................................................................................................... 3 1.1	1
1 0.5ns. 2GHz A clock	1
: b * c; a	1
: b * c; Is16vec8	1
: c (a&&b) || (a&&b&&c)	1
: c x-xx----- 75 (a&&b)	1
: b; } A problem	1
: 1; // always 1	1
: 1; // sign bit	1
: public CHello { public:	2
: public C0 { public:	1
: public CParent<CChild1> { has	1
: public CParent<CChild1> { public:	1
: public CGrandParent { public:	1
: public B1 { public:	1
: public CParent<CChild2> { public:	1
: public B1, public B2	1
: b) y = MAX(f(x),	1
: 8; // exponent +	1
: (bb[i] * cc[i]); }	1
: 23; // fractional part	1
: 0] in this case	1
: "memory" ); #else //	1
: "=m"(n) : "m"(x) :	1
: x(0) {}; void xplus2()	1
: EXCEPTION_CONTINUE_SEARCH) { // Floating	1
: 52; // fractional part	1
: 63; // fractional part	1
: "m"(x) : "memory" );	1
: 2.6f; The ?: operator	1
: 15; // exponent +	1
: 2.5f; If we assume	1
: 11; // exponent +	1
add the static keyword to	1
add the constant vector (1,2,3,4),	1
add the four sums }	1
add the keyword static to	1
add the last element outside	1
add a to this number	1
add a few unused points	1
add to the total computation	1
add or remove any objects	1
add an extra dummy element	1
add b and c first.	1
add i to p is	1
add 2 to x 43	1
add elements }; vector() {}	1
add new features to each	1
add extra code to check	1
add add cmp ja $B2$3:	1
add counter variables that count	1
add what r points to	1
add n to exponent }	1
add unused columns to a	1
add mov add cmp jl	1
add statements like throw(A,B,C) to	1
add ebx, DWORD PTR [edx]	1
add ebx, eax / sar	1
add functionality to an existing	1
add cmp jl $B1$3: pop	1
add cmp ja $B2$3: ret	1
add Divide by constant =	1
add sar add mov add	1
add dummy elements at the	1
add eax,1 is the loop	1
mode is used in the	1
mode and some operating systems	1
mode and back again. Obviously,	1
mode and back again. Accessing	1
mode and mostly relative references	1
mode or when the SSE2	3
mode or enable the SSE2	1
mode if the image base	1
mode if SSE2 is available:	1
mode than in 32-bit mode,	1
mode than in 32 bit	1
mode program is useful for	1
mode program is fast, compact,	1
mode program are typically specified	1
mode has to be changed	1
mode because the function calling	1
mode because the 64-bit instruction	1
mode because the x86-64 instruction	1
mode where the parameters are	1
mode so that the first	1
mode 4 4 pointer or	1
mode 8 8 float 4	1
mode rather than generating denormal	1
mode program. The inputs for	1
mode unless the SSE2 instruction	1
mode unless you have special	1
mode SSE 128 bit float	1
mode (SSE2): #include <xmmintrin.h> _mm_setcsr(_mm_getcsr()	1
mode (SSE): #include <xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);	1
mode Parameter transfer is more	1
store the floating point and	1
store the table in static	1
store the result in x.	1
store the four results in	1
store the values in a	1
store the information in the	1
store the shared variable inside	1
store the intermediate result of	1
store the reciprocal factorials so	1
store is known before the	1
store it in a temporary	1
store x in memory rather	1
store data because the same	1
store all strings in a	1
store all strings in one	1
store each object in its	1
store many objects together in	1
store objects of different types	1
store result in array ;	1
store An uncached write is	1
store intermediate data and local	1
store intermediate results in RAM	1
store aligned integer vector into	1
store operation doesn't delay the	1
store strings in a memory	1
store unaligned integer vector into	3
store help files and other	1
store application-specific information in a	1
store forwarding delay in the	2
values is closest to the	1
values of a and b	2
values of all variables. Obviously,	1
values of its arguments. This	1
values of nonzero floating point	1
values of A, B and	1
values in the code then	1
values in the next vector,	1
values in a pre-calculated table.	1
values are then output after	1
values are simply put there	1
values are confined to a	1
values or if they come	1
values if they are uninitialized	1
values by hand and insert	1
values than 0 and 1.	2
values than 0 or 1.	2
values have to be put	1
values then the line containing	1
values at once The bitwise	1
values at once................................... 135 14.4	1
values because a typo in	1
values before the program starts.	1
values before it is compiled.	1
values before compilation. The following	1
values per point. This does	1
values far from each other	1
values first, then all the	1
All the code is included	1
All the reductions that the	1
All of these compilers can	1
All of these methods are	1
All in all, it will	1
All code that is not	1
All you have to do	1
All functions have to save	1
All C++ compilers have various	1
All software should be tested	1
All pointers and addresses in	1
All these libraries have very	1
All these instructions require that	1
All these problems are usability	1
All these examples are optimized	1
All dynamic memory allocation using	1
All calculations are done with	1
All common implementations of string	1
All optimizing compilers will automatically	1
All addresses in the code	1
All intermediate results should be	1
All source files are first	1
All public functions and public	1
All x86 platforms (Windows, Linux,	1
All global variables (i.e. variables	1
All modern x86 CPUs can	1
All identical constants in the	1
All newer microprocessors in the	1
All non-static variables and objects	1
All accesses to functions and	1
All disturbing influences are removed,	1
sign is stored as a	1
sign of a floating point	1
sign of a double: //	1
sign and rounding 137 errors	1
sign bit of x The	1
sign bit of x by	1
sign bit of i in	1
sign bit of i into	1
sign bit of i ;	1
sign bit of f is	1
sign bit of f cout	1
sign bit of u.f We	1
sign bit to zero We	1
sign bit to compare absolute	1
sign bit to zero: //	1
sign bit in the above	1
sign bit are zero. Zero	1
sign bit // u.d is	1
sign bit so that the	1
sign bit }; The values	1
sign bit set). We can	1
sign must be reversed if	1
sign : 1; // sign	1
sign bit: // Example 14.23	1
sign bit: // Example 14.25	1
sign bit: absvalue = a[i].u[1]	1
sign bit. The fact that	1
sign bit. We can tell	1
sign :1;//signbit }; struct Sdouble	1
sign :1;//signbit }; struct Slongdouble	1
sign bit, the exponent, and	1
copy the table from static	1
copy the entire object. Any	1
copy the contents of the	1
copy is dead code if	1
copy a to b for	1
copy a to b memcpy(b,	1
copy of the table that	1
copy of the function, but	1
copy of the inlined function	1
copy of an inlined function.	1
copy of every intermediate version.	1
copy that the only reasonable	1
copy matrix void TransposeCopy(double a[SIZE][SIZE],	2
copy Function inlining has the	1
copy constructor is not needed	1
copy constructor and the destructor	1
copy constructor and no destructor	1
copy constructor can be a	1
copy constructor may be called	1
copy constructor must be called	1
copy constructor specifying otherwise. In	1
copy protection schemes are based	2
copy protection schemes are annoying	1
copy protection scheme should be	1
copy constructors and overloaded operators.	1
copy constructors and destructors of	1
copy constructors and destructors to	1
copy constructor, if any, is	1
copy constructors, and any other	1
optimizing the software for speed	1
optimizing the first algorithm that	1
optimizing a particular piece of	1
optimizing for size and optimizing	1
optimizing for speed. Optimizing for	1
optimizing // Time // Serialize	1
optimizing compiler can use the	1
optimizing compiler can replace an	1
optimizing compiler can see that	1
optimizing compiler can bypass the	1
optimizing compiler may try to	1
optimizing compiler will see that	1
optimizing compiler will change the	1
optimizing compiler should produce the	1
optimizing compiler would assume that	1
optimizing compiler might store the	1
optimizing CPU use in programs	1
optimizing compilers can compute a	1
optimizing compilers will automatically choose	1
optimizing compilers available, though less	1
optimizing library functions than in	1
optimizing execution speed or program	1
optimizing code, as explained on	1
optimizing database access. 3.10 Graphics	1
optimizing away p and inlining	1
optimizing away cpuid // Read	1
optimizing features, and you may	1
optimizing application-specific code. The best	1
optimizing ............................................................................................... 4 2 Choosing	1
optimizing multithreaded applications: The cost	1
optimizing University courses in programming	1
memory. The functions are usually	1
memory. The static memory is	1
memory. The renaming mechanism works	1
memory. This is useful on	1
memory. This can be done	1
memory. This may be faster	1
memory. This makes data caching	1
memory. This prevents the CPU	1
memory. A register is a	1
memory. It is therefore important	1
memory. It is difficult for	1
memory. It will not use	1
memory. If the word static	1
memory. If you don't care	1
memory. If several functions that	1
memory. See the discussion of	1
memory. See page 89 for	1
memory. Example: // Example 7.2	1
memory. Example: // Example 9.4	1
memory. These methods are discussed	1
memory. Function parameters are stored	1
memory. Function parameters are transferred	1
memory. Most compilers will recognize	1
memory. No information about the	1
memory. Variables and objects should	1
memory. They may be scattered	1
memory. One kilobyte is 1024	1
memory. Big arrays should be	1
memory. Copying constant data from	1
memory. 9.6 Dynamic memory allocation	1
memory. Efficient caching is therefore	1
well the compiler optimizes a	1
well the microprocessor can predict	1
well in tests on Intel	1
well it optimizes the code.	1
well if the repeat count	1
well if it is inside	1
well with non-Intel CPUs. Includes	1
well on all brands of	1
well on AMD and VIA	1
well on non-Intel processors, as	1
well on non-Intel machines? Possible	1
well as the size of	1
well as in Linux kernel	1
well as efficient functions for	1
well as pointers and references.	1
well as important usability problems	1
well as writing data. Multidimensional	1
well as directly compiled code.	1
well as Intel-based Mac OS	1
well use a #define, const	1
well only on some processors	1
well only on some processors.	1
well before the pointer is	1
well optimized Intel function libraries,	1
well optimized software design, it	1
well spend more CPU time	1
well specify the alignment explicitly	1
well developed as C++ compilers.	1
well tested, and very useful	1
well documented. The examples in	1
well thought-through approach to error	1
information is contained in p1	1
information is utilized appropriately. Users	1
information to all class objects	1
information to optimize the code	1
information in the database anyway	1
information in a separate file	1
information in order to identify	1
information for the exception handler,	1
information for function F1. However,	1
information that we can surely	1
information can be left out	1
information stored by the heap	1
information about the function type	1
information about the class that	1
information about the class c1	1
information about the performance of	1
information about the destructor to	1
information about the chain of	1
information about the third generation	1
information about the dimensions of	1
information about a variable, pointer	1
information about function names and	1
information about functions in other	1
information about which implementation is	1
information about pointer alignment and	1
information about its child class	1
information about supported instruction sets,	1
information about mathematical functions. 7.4	1
information about Func1 when compiling	1
information about bugs, compatibility problems,	1
information elsewhere and get a	1
simply the address of the	1
simply a matter of programming	2
simply a matter of interpreting	2
simply a matter of habit,	1
simply to increment an integer	1
simply by using a different	1
simply by copying all data	1
simply by setting these variables	1
simply by storing the elements	1
simply by comparing them as	1
simply by performing an illegal	1
simply by removing the call	1
simply by ignoring the higher	1
simply by inverting the sign	1
simply not appropriate here. It	1
simply an integer in disguise.	1
simply no difference in speed	1
simply makes the compiler interpret	1
simply optimized away and the	1
simply don't have the time	1
simply put there when the	1
simply put 80 into a	1
simply predicted to go the	1
simply stores the offset of	1
simply stores the lower 16	1
simply zero. Execution time too	1
simply treated as different functions.	1
simply identical. For example, for	1
simply prints an appropriate error	1
able to do the reduction	1
able to do the devirtualization	1
able to do this optimization.	1
able to do more complicated	1
able to do different kinds	1
able to do so. 58	1
able to do so). A	1
able to avoid the calls	1
able to run two threads	1
able to calculate the most	1
able to inline and optimize	1
able to inline this function	1
able to optimize this with	1
able to automatically prefetch data	1
able to see this. It	1
able to generate an assembly	1
able to reduce (a*b*c)+(c*b*a) to	1
able to find the optimal	1
able to mix the two	1
able to predict the target	1
able to predict a switch	1
able to predict correctly whether	1
able to define application-specific instructions	1
able to evaluate the loop	1
able to completely rule out	1
able to recover from errors.	1
able to recover from exceptions.	1
able to overlap the call	1
able to reorder instructions without	1
able to do, at least	1
able do function inlining and	1
certain to be divisible by	1
certain to be mispredicted whenever	1
certain to be inlined. But	1
certain to have no other	1
certain to become obsolete within	1
certain to truly represent a	1
certain that the 64-bit systems	1
certain that a will never	1
certain that a call to	1
certain that this part of	1
certain that u < 231	1
certain Intel CPUs, but not	1
certain operating system functions (e.g.	1
certain programming principles in order	1
certain instructions that allow you	1
certain calculations are done at	1
certain parts of the program	1
certain options are set to	1
certain conditions are satisfied. The	1
certain tasks on current Intel	1
certain kinds of code execute	1
certain optimizations. Do not use	1
certain rules about register use,	1
certain limit to the length	1
certain restrictions on using the	1
certain restrictions on mixing code	1
certain modification is profitable. On	1
certain events, for example every	1
certain events, such as the	1
certain tolerance. The time it	1
certain interval: // Example 14.5a	1
cycles to do a floating	1
cycles to read from a	1
cycles to fetch the variable	1
cycles in the case that	1
cycles for 32-bit integers, depending	1
cycles that we may save	1
cycles if it is not	1
cycles if it is cached,	1
cycles on most other microprocessors.	1
cycles on Pentium 4 processors,	1
cycles than other CPUs for	1
cycles more than it takes	1
cycles more than calling the	1
cycles then it will still	1
cycles at the actual clock	1
cycles before the time the	1
cycles rather than seconds or	1
cycles even if the CPU	1
cycles counter is counting clock	1
cycles after the pointer p	1
cycles after the value of	1
cycles later and the work	1
cycles per array element. Matrix	1
cycles per element for a	1
cycles per byte of data	1
cycles per element. The table	1
cycles per element. 100 As	1
cycles whenever it feeds a	1
cycles spent on executing instructions	1
cycles (depending on the processor)	1
... a = FactorialTable[b]; ...	1
... for (i = 0;	4
... for (int i =	2
... can be changed to:	1
... // Use ReadTSC() from	1
... // Call critical function	2
... if (i < 0	1
... if (i >= min	1
... int i, a, b;	1
... } } The function	1
... } } The FactorialTable	1
... } } } Obviously,	1
... } If Func1 and	1
... } void F0() {	1
... } Here, log(2.0) is	1
... then you may improve	1
... There is an even	1
... return 0; } The	2
... Here, you cannot swap	1
... Here you cannot swap	1
... Conversions between signed and	1
... x.a = y.a +	1
... ~C1(); }; void F1()	1
... list[i & 15] +=	1
addresses is much simpler in	1
addresses is reused again and	1
addresses of library functions linked	1
addresses of array elements of	1
addresses of array elements. Example:	1
addresses of dynamically linked library	1
addresses to be mispredicted (See	1
addresses to function names. But	1
addresses in the code are	2
addresses in the code section,	1
addresses in order to optimize	1
addresses in 32-bit Mac code	1
addresses for one array rather	1
addresses for everything, which is	1
addresses that need relocation. All	1
addresses that need relocation, but	1
addresses are often used by	1
addresses are accessed in sequential	1
addresses are spaced a multiple	1
addresses are obscured in optimized	1
addresses with different set values	1
addresses at each access. The	1
addresses all belong to set	1
addresses divisible by the memory	1
addresses divisible by the cache	1
addresses divisible by 16. Library	1
addresses divisible by 16. Alignment	1
addresses (i.e. where the function	1
addresses 0x2F00, 0x3700, 0x3F00 and	1
counter is a counter inside	1
counter is an integer, then	1
counter is used as an	1
counter is very useful when	1
counter is counting clock cycles	1
counter and using the integer	1
counter and go back into	1
counter in the CPU, which	1
counter in Intel processors is	1
counter that measures the number	1
counter can be calculated by	2
counter can be calculated more	1
counter can be obtained with	1
counter // For unused returns	1
counter // Calculate polynomial The	1
counter by a constant can	1
counter with its limit, etc.	1
counter when the final value	1
counter then make an additional	1
counter should preferably be an	1
counter i is stored as	1
counter variables that count how	1
counter before and after executing	1
counter (see below) 16.1 Using	1
counter inside the CPU which	1
counter becomes invalid if a	1
counter outside both loops //	1
counter ahead of time so	1
counter //=2*A //=A*x*x+B*x+C //=DeltaY //	1
shared object is called, it	1
shared object is accessed, it	1
shared object can be speeded	1
shared object has a table	1
shared object which is typically	1
shared object where most of	1
shared object without the -fpic	1
shared object without -fpic in	1
shared object compiled without -fpic	1
shared object made with option	1
shared objects in Mac OS	1
shared objects in Unix-like systems.	1
shared objects are not used.	1
shared objects without position-independent code	1
shared objects (*.dll, *.so). The	1
shared objects (*.dll, *.so). There	1
shared variable inside the class.	1
shared between multiple threads must	1
shared between multiple processes because	1
shared between multiple threads, but	1
shared between multiple threads, while	1
shared between multiple processes. The	1
shared resources are limiting factors	1
shared object. This so-called symbol	1
shared object. It is possible	1
shared object. Obviously, all these	1
shared object. Likewise, when a	1
shared object, then the version	1
shared object, then the instance	1
shared objects), resource files, configuration	1
count is not certain to	1
count is large or constant.	1
count is small and always	1
count is small and changing	1
count is too big. 7.14	1
count is divisible by the	2
count is usually higher than	1
count is near the maximum	1
count is mispredicted only when	1
count is odd and you	1
count to 5 } }	1
count and the calculation of	1
count and the subsequent counts	1
count and no branches inside	1
count and always use this	1
count that can be predicted	2
count on it. Instead of	1
count as true, if any	1
count may be completely unrolled	1
count has been reduced from	1
count should preferably be a	1
count before and after executing	1
count how many times the	1
count how many times each	1
count up to some positive	1
count certain events, such as	1
count down to zero than	1
count (ArraySize) is constant and	1
program. The time measurements may	1
program. The use of structures	1
program. The CPU dispatcher does	1
program. The number of context	1
program. The advantage of static	1
program. The map file includes	1
program. The inputs for a	1
program. The profilers are not	1
program. This is the case	1
program. This has influence on	1
program. This makes data caching	1
program. This requires no modification	1
program. This requires, of course,	1
program. In some programs, more	1
program. See page 150 for	1
program. An optimizing compiler may	1
program. All in all, it	1
program. Many programmers have discovered	1
program. Avoid unnecessary functions Some	1
program. 3 Finding the biggest	1
program. 6 Development process There	1
program. Add to 122 this	1
program. Reading or writing to	1
program. 16.2 The pitfalls of	1
program. Small functions are often	1
program. Whole program optimization cannot	1
program. Weighing the above advantages	1
program. During the history of	1
program. Frequent context switches can	1
program. Application programmers rarely program	1
quite a long time compared	1
quite a long time. It	1
quite a good investment. A	1
quite as versatile. Fortran is	1
quite efficient thanks to the	1
quite often as a result	1
quite often because the block	1
quite simple in most cases:	1
quite likely is a model	1
quite well if it is	1
quite certain that the 64-bit	1
quite fast on such small	1
quite difficult to implement the	1
quite inefficient in large applications.	1
quite inefficient if a program	1
quite inefficient. The modern microprocessors	1
quite time-consuming (see page 140).	1
quite fast. The lesson we	1
quite expensive - in terms	1
quite costly because all caches	1
quite efficient, but the syntax	1
quite powerful and may be	1
quite inefficient, and it will	1
quite dramatic consequences. I once	1
quite tedious and the code	1
quite tedious indeed. It is	1
quite substantial. This gain in	1
quite convenient. It is easier	1
quite often. This is necessary	1
quite ingenious things to make	1
used. a and b should	1
used. The operating system may	1
used. The method currently used	1
used. The advantages of dynamic	1
used. The advantages of alloca	1
used. A computer with many	1
used. A smart pointer may	1
used. A newer method of	1
used. It is more common	1
used. It is possible to	1
used. It is important that	1
used. It is recommended to	1
used. It takes between 2	1
used. If the number of	1
used. You may avoid this	1
used. See page 32 for	1
used. See page 140. Avoid	1
used. For example, x =	1
used. Example: // Example 7.34a.	1
used. An optimizing compiler can	1
used. However, this does not	1
used. We can calculate which	1
used. Such variables and objects	1
used. Dynamic linking makes it	1
used. No program should leave	1
used. Do not mix single	1
used. Conversion of an unsigned	1
used. Conversions of float or	1
used. Whenever a function in	1
used. Web systems should be	1
files to be installed. The	1
files and other resources locally	1
files and system modules. 3.12	1
files and network connections. Temporary	1
files and databases with lots	1
files and executables. Make sure	1
files and databases. The operating	1
files for the sake of	1
files for intrinsic functions You	1
files that need to be	1
files are as follows: Instruction	1
files are then linked together	1
files are also included. Combining	1
files are first compiled to	1
files or accessing databases, network	1
files on access. Sequential forward	1
files on access. Run multiple	1
files when the program is	1
files from different compilers is	1
files from disk. Memory-hungry applications	1
files into a single object	2
files into one by means	1
files For example, a 128-bit	1
files need to be converted	1
files while less than 1%	1
files etc. scattered around on	1
files generated by the Intel	1
files smaller. It is faster	1
files (*.ini files). 20 3.9	1
recommended to use the static	1
recommended to use the const	1
recommended to use the vectors	1
recommended to use the default	1
recommended to use a different	1
recommended to use a version	1
recommended to use a constant	1
recommended to use a systematic	1
recommended to use that for	1
recommended to make member functions	1
recommended to make 16-bit programs,	1
recommended to set the flush-to-zero	1
recommended to return from functions	1
recommended to calculate the value	1
recommended to put a test	1
recommended to put a parenthesis	1
recommended to turn on this	1
recommended to turn off support	2
recommended to enable the SSE2	1
recommended to enable fast floating	1
recommended to modify a double	1
recommended to try different libraries	1
recommended to declare the table	1
recommended to specify static linking	1
recommended to wrap the allocated	1
recommended to place the user	1
recommended for critical applications because	1
recommended that big arrays and	1
recommended if portability is important.	1
intermediate code is that the	1
intermediate code is that it	2
intermediate code is needed for	1
intermediate code and just-in-time compilation	1
intermediate code and just-in-time compilation.	1
intermediate code for the common	1
intermediate code by emulating the	1
intermediate code cannot be executed	1
intermediate code like the one	1
intermediate code (byte code). The	1
intermediate data and local variables	1
intermediate object for (b +	1
intermediate code. The reason for	1
intermediate code. This framework typically	1
intermediate file format is not	1
intermediate file format instead of	1
intermediate calculations can cause overflow.	1
intermediate result of each step	1
intermediate result (b+c) can be	1
intermediate files are then linked	1
intermediate expression b * 5).	1
intermediate results in RAM memory.	1
intermediate results are always calculated	1
intermediate results as floating point.	1
intermediate results should be saved	1
intermediate code, which is the	1
intermediate code, interpreters, just-in-time compilers,	1
intermediate version. For one-man projects,	1
intermediate results, which may be	1
fast and easy development of	1
fast and efficient, but not	1
fast in a simple test	1
fast in most cases, regardless	1
fast that the clock cycles	1
fast that what is brand	1
fast if the table is	1
fast if it is an	1
fast on a hard disk	1
fast on such small devices	1
fast on newer processors. Many	1
fast as a scalar (Scalar	1
fast as integer arithmetic operations.	1
fast as single precision. And	1
fast as calling a simple	1
fast as accessing it directly.	1
fast as additions. When used	1
fast floating point calculations or	1
fast 32-bit software development", Addison-	1
fast access to array elements.	1
fast whether p is a	1
fast division c = a	1
fast ways of multiplying by	1
fast math and the SSE	1
fast anyway and you want	1
fast approximate reciprocal square root,	1
fast approximate reciprocal, fast approximate	1
fast enough. A hash table	1
fast enough. For example, some	1
allocation is done with the	1
allocation is particularly risky because	1
allocation is used, it is	1
allocation is negligible when the	1
allocation is unnecessarily wasteful in	1
allocation of memory for a	1
allocation of memory or other	1
allocation and function inlining is	1
allocation and parameter transfer across	1
allocation and deallocation of memory	1
allocation and deallocation of big	1
allocation and de-allocation of memory	1
allocation in an inefficient way.	1
allocation for all objects. This	1
allocation can be mentioned here:	1
allocation can therefore be advantageous	1
allocation with new and delete,	1
allocation may be needed, however,	1
allocation when the size of	1
allocation using new/delete or malloc/free	1
allocation also tends to make	1
allocation process because the microprocessor	1
allocation are: The process of	1
allocation are: int BigArray[1024] __attribute__((aligned(64)));	1
allocation Dynamic memory allocation is	1
allocation Any array or object	1
allocation Objects and arrays can	1
allocation ...................................................................................... 90 9.7 Container	1
allocation (new and delete). 88	1
(int i = 0; i	13
(int * p) { *p	2
(int & r) { r	1
(int a, int x[]) {	1
(int a, bool b) {	4
(int x) { static float	1
(int x) { return x	1
(int n = 1; n	1
(int x, int m) {	1
(int n) { // n!	2
(int n) { if (n	1
(int a[], int * p)	1
write the same in a	1
write the variable at the	1
write the file to a	1
write the members individually. Example:	1
write is more expensive than	1
write a + b than	1
write a 64-bit double 32	1
write to the same memory	1
write that something takes 10	2
write it in one operation	1
write it with many decimals.	1
write instruction prevents the level-2	1
write less than a few	1
write instructions are not suitable	1
write instructions are not optimal.	1
write instructions becomes noticeable. The	1
write instructions (MOVNT) are designed	1
write expressions that can be	1
write expressions like -(-a) very	1
write your own container classes	1
write #pragma vector nontemporal #pragma	1
write causes an entire cache	1
write directly to memory without	1
write configuration files (*.ini files).	1
write FatalAppExitA(0,"Array index out of	1
write 2.0/3.0 than to calculate	1
write _mm_add_epi16(a,b). Two libraries of	1
write if(!a && !b) rather	1
optimize the code and put	1
optimize the code further by	1
optimize the parts of the	1
optimize a piece of CPU-intensive	1
optimize for several different CPUs.	1
optimize code that uses pointers	1
optimize as good as the	1
optimize this with induction variables.	1
optimize this loop by using	1
optimize this loop? Certainly not!	1
optimize example 8.26a by rolling	1
optimize performance for background services	1
optimize register allocation and parameter	1
optimize both functions and simply	1
optimize well. Open Watcom Another	1
optimize away the variable in	1
optimize away the extra overhead	1
optimize away a const reference	1
optimize away an overflow check.	1
optimize Modern compilers can do	1
optimize across the function call.	1
optimize across function calls. There	1
optimize across modules The compiler	1
optimize anything else than finding	1
optimize access, as given in	1
optimize caching. Smaller microcontrollers have	1
optimize ............................................................................................ 66 8.2 Comparison	1
optimize anything, you have to	1
optimize specifically for the CPU	1
above the diagonal are accessed	1
above the diagonal have been	1
above the diagonal. The first	1
above the diagonal. The c	1
above for the 32-bit case.	1
above can still be used	1
above code is serial because	1
above code in details. The	1
above code can be optimized	1
above code will fail if	1
above code will catch an	1
above example with floating point	1
above example with u.i[1] ^=	1
above example may fail in	1
above example sets the sign	1
above example, the compiler is	1
above example, the size of	1
above example, the template function	1
above example, then all five	1
above template class is declared	1
above doesn't work // Re-do	1
above line doesn't work int	1
above methods if the most	1
above examples will therefore be	1
above examples all use single	1
above advantages of each method,	1
above sections are dominating and	1
above table. If the standard	1
above security advices in critical	1
However, the code that you	1
However, the Intel libraries do	1
However, the const int declaration	1
However, the short vector method	1
However, the STL is designed	1
However, the out-of-order mechanism allows	1
However, the CISC instruction set	1
However, the pipeline structure has	1
However, a software implementation is	1
However, in most cases you	1
However, it is inefficient to	1
However, if F1 calls another	1
However, with a well optimized	1
However, you must be careful	1
However, this is not a	1
However, this does not work	1
However, this involves the problems	1
However, this did not improve	1
However, most compilers do not	1
However, there are a couple	1
However, there are many cases	1
However, there are cases where	1
However, there are disadvantages of	1
However, there may be so	1
However, C++ is also a	1
However, such applications are highly	1
However, we must consider that	1
However, we still want to	1
However, these languages have the	1
was the opposite: Don't put	1
was it possible to come	1
was not declared volatile then	1
was an odd number then	1
was more than doubled for	1
was used by element 0	1
was called from), function parameters,	1
was less popular at the	1
was done by me manually,	1
was certain to truly represent	1
was never designed for this	1
was zero or infinity or	1
was too slow. Today, the	1
was called. There is no	1
was unknown at the time	1
was executed. It is therefore	1
was executed. If the value	1
was down to 36. There	1
was hardly any speed advantage	1
was saved in the beginning.	1
was split into two 64-bit	1
was programmed. But if the	1
was programmed. Therefore, it is	1
was manipulated to fake an	1
was started. The length of	1
was assigned previously in the	1
was coded. If the software	1
was developed. A CPU dispatch	1
was originally designed by Intel	1
both the CPU and the	2
both the pointers and the	1
both the level-1 and the	1
both the executable file and	1
both are negative or if	1
both can be accessed with	1
both have addresses divisible by	1
both functions and simply put	1
both static and dynamic versions.	1
both static and dynamic linking.	1
both 32-bit and 64-bit operating	1
both Windows and Linux, 32-bit	1
both Windows and Linux. The	1
both AMD and Intel vector	1
both get the value 10	1
both Intel, AMD and VIA	1
both positive and negative impacts	1
both positive } Example 14.27	1
both cases. This is because	1
both during installation of the	1
both loops // The purpose	1
both compiler, operating system and	1
both compiler, linker and loader	1
both parent and child class.	1
both operands. Nevertheless, the bitwise	1
both cheaper and more efficient	1
both positive. It will fail	1
both 16-bit, 32-bit and 64-bit	1
programs to run a little	1
programs and also a possible	1
programs that are based on	1
programs that have many file	1
programs that have big data	1
programs can be less efficient	1
programs if there are many	1
programs with many Boolean expressions.	1
programs use time searching for	1
programs use more time loading	1
programs use internet or intranet	1
programs use inappropriate CPU dispatch	1
programs when the clock frequency	1
programs because the response time	1
programs but rarely in Linux.	1
programs should be standardized and	1
programs where security matters. Problems	1
programs they are running. Such	1
programs must use thread-safe functions.	1
programs compiled for the instruction	1
programs compiled for 64-bit operating	1
programs implemented in compiled C++.	1
programs automatically download updates through	1
programs search for updates every	1
programs spend most of their	1
programs do. Hence, it is	1
programs written in Java, C#,	1
programs installed can take several	1
problems is quite simple in	1
problems of the original, poorly	1
problems of overflow and loss	1
problems and they waste a	1
problems and system crash. Furthermore,	1
problems and system breakdown. Many	1
problems and necessary support. Hardware	1
problems and desired new features.	1
problems and compatibility problems and	1
problems and planned solutions. Patches	1
problems for integer constants. Register	1
problems that the clock frequency	1
problems that software developers should	1
problems that cause the resource-hungry	1
problems that relate to CPU-intensive	1
problems are usability issues, and	1
problems or performance problems. Avoid	1
problems if the necessary library	1
problems if the network is	1
problems with profilers are: Coarse	1
problems you must make your	1
problems when the hardware is	1
problems because static data are	1
problems should be taken into	1
problems into account when deciding	1
problems mentioned above. Now the	1
problems associated with profiling, but	1
problems separating the flags register	1
unless the function is doing	1
unless the function can be	1
unless the code relies on	1
unless the loop is rolled	1
unless the size of the	1
unless the value is calculated	1
unless the address of it	1
unless the SSE2 or later	1
unless the SSE2 instruction set	2
unless the SSE2 (or later)	1
unless the SSE4.1 instruction set	1
unless the length of each	1
unless the strictness is required.	1
unless the Pentium-II or later	1
unless you are making a	1
unless you are overriding Intel's	2
unless you have special reasons	1
unless you have ample resources.	1
unless you put a parenthesis	1
unless you expect the &&	1
unless you specify an option	1
unless there is a specific	1
unless there is a copy	1
unless there is a compelling	1
unless they are wrapped into	1
unless your program relies on	1
optimal to use a loop	1
optimal to use exception handling	1
optimal to do so (i.e.	1
optimal to inline the function,	1
optimal to mirror the remote	1
optimal in most cases. Don't	1
optimal in special cases where	1
optimal for each calculation. In	1
optimal on the actual processor.	1
optimal code for this instruction	1
optimal code because they fail	1
optimal from a technological point	1
optimal because it takes too	1
optimal because it prevents the	1
optimal only on CPUs with	1
optimal number of accumulators for	1
optimal version of the critical	1
optimal branch can be chosen	1
optimal solution is a fixed	1
optimal solution because the high	1
optimal platform ........................................................................................... 5 2.1	1
optimal platform 2.1 Choice of	1
optimal choice for future models	1
optimal algorithm The first thing	1
optimal algorithm before you start	1
optimal algorithm ....................................................................................... 24 6	1
optimal order. Some compilers have	1
optimal decomposition of the data.	1
space is used for the	1
space is automatically deallocated when	1
space is freed when the	1
space is occupied throughout the	1
space of the 64-bit systems.	1
space to store data because	1
space to become fragmented. An	1
space and are difficult to	1
space in the code cache	2
space in the code cache.	1
space in the branch target	1
space for the parameters of	1
space can be given in	1
space or make files smaller.	1
space by joining a and	1
space by allowing two data	1
space on the stack for	1
space than needed. This makes	1
space has become too fragmented.	1
space used for constants. Integer	1
space where a #define directive	1
space never becomes fragmented thanks	1
space becomes more fragmented when	1
space becomes fragmented when objects	1
space were scarce resources. However,	1
space explicitly when alloca is	1
space 91 step by step.	1
cases, the compiler may be	1
cases, the compiler will convert	1
cases, the Intel mechanism executes	1
cases, the optimal branch can	1
cases, the fastest way to	1
cases, the log on process	1
cases, a data member pointer	1
cases, for example to produce	1
cases, it is possible to	1
cases, it is optimal to	1
cases, an optimizing compiler can	1
cases, you can assume that	1
cases, you can obtain much	1
cases, but it may be	1
cases, but not all. Fortunately,	1
cases, but its data members	1
cases, double precision calculations take	1
cases, there is an extra	1
cases, there is no reason	1
cases, there is no difference	1
cases, there are two versions	1
cases, even for double precision.	1
cases, while many reductions involving	1
cases, however, there is a	1
cases, however, where there are	1
cases, however, where template metaprogramming	1
cases, composite objects are returned	1
cases, regardless of the size.	1
else if else if else	1
else if else { (iset	1
else if (level >= 4)	1
else on a computer. Security	1
else than finding the most	1
else { a = a	4
else { a = c;	1
else { // No cache	1
else { // f is	1
else { // Generic version	1
else { float b[1000]; F2(b);	1
else { return a -	1
else { return 0; //	1
else { y = cos(x);	2
else { list[i] += 1.0f;	2
else { (iset >= 8)	1
else { F2(b); } }	1
else { goto CFALSE; }	1
else { goto DTRUE; }	1
else { FuncB(i); } FuncC(i);	1
else { CFALSE: c =	1
else { DTRUE: d =	1
else being initialized. The dispatcher	1
lot of code is serial	1
lot of time both during	1
lot of time cleaning up	1
lot of data manipulation is	1
lot of data shuffling, such	1
lot of CPU time, RAM	1
lot of cache space by	1
lot of cache space. Putting	1
lot of optimization by executing	1
lot of time. You can	1
lot of extra instructions for	1
lot of extra resources. Each	1
lot of branches that take	1
lot of runtime DLL's (dynamically	1
lot of advanced mathematical functions	1
lot of added information about	1
lot of background processes running,	1
lot of computing resources. Typically,	1
lot of resources, and the	1
lot of modifications to the	1
lot of bookkeeping in order	1
lot of jumping around and	1
lot of irrelevant software installed,	1
lot of CPU-time in library	1
lot to gain in speed	1
lot to gain if such	1
lot to gain by optimizing	1
lot in performance. I have	1
Integer to float conversion Conversion	1
Integer to float conversions can	1
Integer size conversion // Example	1
Integer variables can be 8,	1
Integer operations are fast in	1
Integer operations are generally very	1
Integer constant const int ArraySize	1
Integer overflow is another security	1
Integer power using template metaprogramming	1
Integer operators Integer operations are	1
Integer multiplication takes longer time	1
Integer multiplication takes 11 clock	1
Integer multiplication Integer multiplication takes	1
Integer multiplication ............................................................................................. 136 14.5	1
Integer division is faster the	1
Integer division by a constant	3
Integer division by a power	1
Integer division takes much longer	1
Integer division takes 40 -	1
Integer division Integer division takes	1
Integer expressions are less susceptible	1
Integer XMM (vector) reductions: Common	1
Integer constants are usually included	1
Integer sizes Integers can be	1
Integer algebra reductions: a+b =	1
Integer division...................................................................................................... 137 14.6 Floating	1
dispatching to make multiple code	1
dispatching to C1::Disp() or C2::Disp()	1
dispatching and is used in	1
dispatching and run any code	1
dispatching and discovered that many	1
dispatching in the code to	1
dispatching in Intel compiler Intel	1
dispatching in Intel compiler .........................................................................	1
dispatching in Gnu compiler //	1
dispatching in Gnu compiler A	1
dispatching in Gnu compiler .........................................................................	1
dispatching can be made for	1
dispatching or memory-intensive functions such	1
dispatching with vector classes Agner's	1
dispatching on first call //	1
dispatching on every call of	1
dispatching then call _mm256_zeroupper() before	1
dispatching only to the most	1
dispatching only for speed-critical functions	1
dispatching should be based on	1
dispatching There may be cases	1
dispatching works only with Intel	1
dispatching #include "vectorclass.h" // vector	1
dispatching mechanism can be bypassed	1
dispatching are: Optimizing for present	1
dispatching explicitly as in example	1
dispatching .................................................................................... 124 13.3 Difficult	1
dispatching 125 for this function,	1
particular code implementation works particularly	1
particular code version. 2. Check	1
particular compiler to do and	1
particular memory address by the	1
particular memory address cannot be	1
particular CPU or other hardware	1
particular CPU model is likely	1
particular instruction set then it	1
particular instruction set, then you	1
particular integer size is big	1
particular set of CPUs. These	1
particular branch of code is	1
particular programming language and development	1
particular part of the program,	1
particular processor model. You may	1
particular advantageous as replacements for	1
particular application uses a lot	1
particular piece of code. Each	1
particular brand is likely to	1
particular application. The integer size	1
particular application. If hyperthreading is	1
particular reduction would be invalid	1
particular part. It is discussed	1
particular purpose. The clumsy AND-OR	1
particular weakness or bottleneck, it	1
particular meaning, then you can	1
particular subtask before coordination with	1
particular situation, but the programmer	1
microprocessor is doing an addition	1
microprocessor is able to overlap	1
microprocessor and the operating system,	1
microprocessor and therefore not advantageous	1
microprocessor in an FPGA as	1
microprocessor The benchmark performance of	1
microprocessor that supports this). Use	1
microprocessor can predict the loop	1
microprocessor can execute the loop	1
microprocessor can begin the calculation	1
microprocessor it is running on.	1
microprocessor with out-of-order capabilities can	1
microprocessor with out-of-order capabilities (see	1
microprocessor has the SSE or	1
microprocessor has hardware support for	1
microprocessor has made the right	1
microprocessor has hyperthreading, then try	1
microprocessor because the hardware can	1
microprocessor doesn't know in advance	1
microprocessor hardware for raising an	1
microprocessor hardware design. The ultimate	1
microprocessor core and an FPGA	1
microprocessor jump to a different	1
microprocessor ........................................................................................... 6 2.3 Choice	1
microprocessor handles this code. For	1
microprocessor microarchitecture. A higher level	1
microprocessor wastes several clock cycles	1
replace the code in example	1
replace the CPU detection function	2
replace the branch by a	1
replace the call to square	1
replace the Gnu compiler on	1
replace a function call by	1
replace a branch by a	1
replace a && b with	1
replace a || b with	1
replace a database by a	1
replace a poorly predictable branch	1
replace it by a table	1
replace it with the calculated	1
replace an integer constant with	1
replace this by // Example	5
replace this line by any	1
replace all occurrences of ArraySize	1
replace integer multiplication by a	1
replace such loops by calls	1
replace arrays by well-tested container	1
replace j * 32 with	1
replace u[1] by u[0]. 14.10	1
next time the function is	1
next time a function is	1
next instruction mov DWORD PTR	1
next each bit in nn	1
next example shows this calculation	1
next two instructions add ebx,	1
next new model comes on	1
next function. However, the short	1
next processor model will work	1
next line provokes an error.	1
next four x^n } return	1
next model work better. Remember	1
next higher instruction set is	1
next section (page 131) shows	1
next instance of S1 in	1
next generation of processors is	1
next generation of computers and	1
next chapter describes how this	1
next block. A linked list	1
next element. I have confirmed	1
next vector, and the four	1
next step in the sequence	1
next step. With a short	1
next calculation. However, the out-of-order	1
next paragraph. The target of	1
next year. Ignoring virtualization. The	1
next section. 12.5 Using vector	1
branches is not predicted well.	1
branches to feed into the	1
branches and the number of	1
branches and function calls in	1
branches and function calls are	1
branches and switch statements should	1
branches in a function should	1
branches The code can be	1
branches for correctness. It is	1
branches that are fine-tuned for	1
branches that can skip large	1
branches that take up cache	1
branches that select between two	1
branches are scattered everywhere in	1
branches are poorly predictable. It	1
branches can be mispredicted even	1
branches or function calls. The	1
branches as possible, and the	1
branches may take a long	1
branches at the vector element	1
branches such as error handling	1
branches works correctly. A code	1
branches inside can be predicted	1
branches every time the function	1
branches separately and test their	1
branches Eliminate jumps Eliminate branches	1
branches Remove branch that is	1
typically in a message loop	1
typically have more powerful computers	1
typically have variable lengths that	1
typically have much less memory	1
typically use integer operations for	1
typically use pointers may be	1
typically used on bigger systems.	1
typically takes a few clock	1
typically takes one clock cycle	1
typically takes 40 clock cycles.	1
typically between 5 and 20	1
typically stored in different modules.	1
typically 64 bytes on contemporary	1
typically 64 bytes. This makes	1
typically take much more resources	1
typically 0 - 2 clock	1
typically small pieces of code	1
typically uses much more resources	1
typically get the generic branch,	1
typically implemented by the compiler	1
typically aligned by 8 rather	1
typically look like this: //	1
typically loaded at a higher	1
typically happens if the program	1
typically specified on a command	1
typically 30 ms for foreground	1
typically thinks "what works best	1
operator is as efficient as	1
operator is used for pointer	1
operator is used for converting	1
operator is used for relieving	1
operator is also useful for	1
operator is exactly as efficient	1
operator is equivalent to a	1
operator that specifies how to	1
operator that transfers ownership of	1
operator // add elements };	1
operator will detect an error	1
operator } }; // Index	1
operator which otherwise can only	1
operator + (vector const &	1
operator does the same as	1
operator These different methods have	1
operator here is a branch.	1
operator here is to remove	1
operator i++ are as fast	1
operator forces the compiler to	1
operator (bitwise and) will cut	1
operator less. Fortunately, all compilers	1
operator (|) works even if	1
operator ++i and the post-increment	1
operator %. Conversion to floating	1
operator (&) and the EXCLUSIVE	1
operator (^) may give inconsistent	1
preferably in the same directory	1
preferably be a simple type,	1
preferably be a constant that	1
preferably be a power of	3
preferably be an integer. If	1
preferably be stored at an	1
preferably be done in big	1
preferably be done on the	1
preferably be put away in	1
preferably be declared in the	1
preferably be declared inside the	1
preferably be avoided on processors	1
preferably be static, as explained	1
preferably be kept small in	1
preferably be kept entirely inside	1
preferably be responded to at	1
preferably with contiguous memory. See	1
preferably have a balanced mix	1
preferably have no more threads	1
preferably using powers of 2	1
preferably 32 for AVX. 5.	1
preferably avoid global variables or	1
preferably implemented on a platform	1
preferably aligned by 32 and	1
preferably isolated into a separate	1
1; for (i = 0;	1
1; for (i = 2;	1
1; // always 1 if	1
1; // sign bit };	1
1; } The compiler may	1
1; } This is of	1
1; } This code has	1
1; } } The compiler	1
1; } } A branch	1
1; } } Loop unrolling	1
1; } return y; }	1
1; } }; class CChild2	1
1; } }; class C2	1
1; } else { a	2
1; } else { goto	1
1; } module2.cpp int Func2()	1
1; return c; } In	1
1; You cannot replace a	1
1; n <= 16; n++)	1
1; r < SIZE; r++)	2
1; list[i+2] = 2; }	2
1; x[1] = b; c	1
1; a[1] = 2; Unfortunately,	1
1; 69 } else {	1
Therefore, the code section can	1
Therefore, the data and resources	1
Therefore, the data section may	1
Therefore, the number of jumps,	1
Therefore, the dispatcher 128 function	1
Therefore, the __fastcall keyword is	1
Therefore, it is even more	1
Therefore, it is important to	1
Therefore, it is necessary to	1
Therefore, it is advantageous to	1
Therefore, it is recommended to	1
Therefore, it is slightly more	1
Therefore, it is worthwhile to	1
Therefore, it can often happen	1
Therefore, it will run faster	1
Therefore, it has to assume	1
Therefore, it cannot inline the	1
Therefore, you only need a	1
Therefore, you should avoid any	1
Therefore, you should avoid making	1
Therefore, you should avoid macros	1
Therefore, you should apply the	1
Therefore, you don't have to	1
Therefore, make sure that the	1
Therefore, 64-bit Linux is more	1
Therefore, both the executable file	1
Therefore, micro- processors have to	1
Mac The libraries included with	1
Mac code uses an unfortunate	1
Mac Intel CodeGear Microsoft Table	1
Mac operating system running in	1
Mac systems often use position-independent	1
Mac systems normally use the	1
Mac programs but rarely in	1
Mac systems. 14 Specific optimization	1
Mac platforms. 2. Optimizing subroutines	1
Mac Windows, Linux, Mac, BSD	1
Mac platforms By Agner Fog.	1
Mac OS and Itanium systems.	1
Mac OS X The code	1
Mac OS X make position-independent	1
Mac OS X operating system	1
Mac OS X operating systems,	1
Mac OS X Compilers for	1
Mac OS X (Darwin) are	1
Mac OS X, 32-bit and	1
Mac OS X, unless you	1
Mac OS X. 14.13 System	1
Mac allow up to fourteen	1
Mac systems, this may work	1
Mac platform. Intel The Intel	1
Mac OS, etc.) have little-endian	1
Mac OS. See page 128	1
Mac platform, but also supports	1
multiplication is done with an	1
multiplication is exact. Multiple divisions	1
multiplication of xxn rather than	1
multiplication and an addition. If	1
multiplication are permissible in all	1
multiplication can be replaced by	1
multiplication or division. The compiler	1
multiplication by a constant with	1
multiplication by 2 in example	1
multiplication by columns in this	1
multiplication by changing this to:	1
multiplication may be three or	1
multiplication will be faster when	1
multiplication } // ipow faster	1
multiplication at the same time.	1
multiplication but only an addition.	1
multiplication takes longer time than	1
multiplication takes 11 clock cycles	1
multiplication would take longer time.	1
multiplication Integer multiplication takes longer	1
multiplication units. This means that	1
multiplication here: a[i] = log	1
multiplication ............................................................................................. 136 14.5 Integer	1
multiplication b[i]*c[i], though this only	1
multiplication (27 - 80 clock	1
multiplication (20 - 45 clock	1
multiplication prior to SSE4.1 and	1
application is preferably implemented on	1
application is generally faster and	1
application to a different platform	1
application to calculate the time	1
application that uses a newer	1
application can make use of	1
application if dynamic linking is	1
application with many function calls	1
application then you should disable	1
application program will be able	1
application program without invoking the	1
application program loads the library	1
application has a graphical user	1
application software is implemented as	1
application code. An interrupt service	1
application uses a lot of	1
application uses most of its	1
application program. The number of	1
application program. All in all,	1
application program. Add to 122	1
application programs use internet or	1
application programmer gets the new	1
application depends on the way	1
application software. Such an extra	1
application itself and take more	1
application integration, mixed language 11	1
application programmer. There is a	1
x) { // (N &	1
x) { // Remove right-most	1
x) { // polynomial(x) =	1
x) { // Round to	1
x) { double x2 =	1
x) { float xn =	1
x) { static float list[]	1
x) { return x *	3
x) { return x; }	1
x) { return 1.0; }	1
x) { return Func1(x) *	1
x) { return pow(x,10); }	1
x) { return IntegerPower<10>(x); }	1
x) { return x*x +	1
x) { return ipow(x,10); //	1
x) { return powN<true,N/2>::p(x) *	1
x) { return square(x) +	1
x) { return _mm_cvtss_si32(_mm_load_ss(&x));} static	1
x) { return _mm_cvtsd_si32(_mm_load_sd(&x));} The	1
x) { __declspec(align(16)) static const	1
x) { _mm_storeu_si128((__m128i *)d, x);	2
x) { _mm_storeu_si128((__m128i *)d, x);}	1
x) { __m128 s; s	1
x) { _mm_store_si128((__m128i *)d, x);	1
automatically and vectorize the code	1
automatically in cases where the	1
automatically in simple cases where	1
automatically in simple cases. 7.28	1
automatically in vectorized code when	1
automatically or does so in	1
automatically if this appears to	1
automatically by the compiler. On	1
automatically when the function returns.	1
automatically when the computer is	1
automatically then it is certainly	1
automatically but you may as	1
automatically but only if certain	1
automatically check for array bounds	1
automatically replace a branch by	1
automatically replace such loops by	1
automatically generate multiple versions of	1
automatically choose the most often	1
automatically come into force when	1
automatically detect which instruction set	1
automatically detect opportunities for parallelization	1
automatically prefetch data for regular	1
automatically deallocated when returning from	1
automatically thanks to out-of-order execution	1
automatically reduces example 15.1a to	1
automatically download updates through the	1
see the result of full	1
see the excessive memory swapping	1
see the compiler-generated code in	1
see the delay. But if	1
see in the debugger is	1
see that the addresses are	1
see that the rows are	1
see that p always points	1
see if the code is	1
see if a certain modification	1
see if it is a	1
see if our estimate is	1
see which one works best.	1
see which part of the	1
see which solution is optimal	1
see page 105. 8.7 Checking	1
see page 122. The Intel	1
see how well it optimizes	1
see whether the call p->f()	1
see whether they were able	1
see below. Installing a second	1
see my free E-book Usability	1
see this. It also prevents	1
see shortly. The following examples	1
see http://www.agner.org/optimize/ - vectorclass www.agner.org/optimize/#vectorclass.	1
see emulated processors and FPGA	1
caching is a problem then	1
caching is therefore becoming more	1
caching is advantageous if, and	1
caching is critical. The worst	1
caching is critical. Optimizing for	1
caching is poor if data	1
caching and data caching less	1
caching for the following reasons:	1
caching more efficient than when	1
caching more efficient today where	1
caching more efficient. Variables that	1
caching will be better because	1
caching very efficient. The following	1
caching less efficient. The size	1
caching less efficient. There are	1
caching less efficient. Dynamic libraries	1
caching less efficient. Do not	1
caching less efficient. Access to	1
caching less efficient. Extra memory	1
caching problems for integer constants.	1
caching problems because static data	1
caching becomes a problem. If	1
caching becomes inefficient. There is	1
caching conditions are optimal. Best-case	1
caching inefficient. An allocated array	1
caching inefficient. Dynamic memory allocation	1
allows the function argument to	1
allows the compiler to optimize	1
allows the compiler to assume	1
allows the compiler to ignore	1
allows the CPU to increment	1
allows the linker to remove	1
allows a maximum of four	1
allows it to begin calculating	1
allows you to use the	1
allows you to override the	1
allows you to reserve the	1
allows only four function parameters	1
allows multiple pointers to the	1
allows less precise floating point	1
allows common subexpression elimination and	1
allows bigger segments (32-bit or	1
allows parallel calculations. Examples are	1
allows 256-bit integer vectors. Code	1
allows compile-time if statements (called	1
allows larger floating point vectors.	1
allows overriding of public functions	1
allows it, it may be	1
allows us to compare two	1
allows us to manipulate the	1
allows direct access to hardware	1
allows "__attribute__((visibility("hidden")))". Use whole program	1
sets the CPU supports, rather	1
sets the variable __intel_cpu_feature_indicator where	1
sets the variable __intel_cpu_feature_indicator_x. You	1
sets the sign bit of	1
sets is as follows: Instruction	1
sets is provided in manual	1
sets a function pointer to	2
sets and other features it	1
sets and cache sizes. Fortunately,	1
sets are mutually incompatible. A	1
sets are mutually incompatible. You	1
sets can be used, but	1
sets can be determined with	1
sets have certain instructions that	1
sets have got RISC cores,	1
sets A more detailed explanation	1
sets from the same source	1
sets all other bits to	1
sets all elements to zero.	1
sets where the same operation	1
sets 4 ways. This means	1
sets rather than loops, etc.	1
sets enable the compiler to	1
sets include a few instructions	1
sets Microprocessor producers keep adding	1
expression is optimized away. Note	1
expression is calculated as ((a+b)+c)+d.	1
expression is used, then there	1
expression a = (b*c)/d, it	1
expression a = b++; will	1
expression a && b needs	1
expression to generate many branch	1
expression that is a linear	1
expression that is an n'th	1
expression that is AND'ed with	2
expression that it can move	1
expression that should not be	2
expression or an anonymous object.	1
expression or subexpression containing only	1
expression with multiple overloaded operators	1
expression b * 5). As	1
expression b && a needs	1
expression contains a function which	1
expression y = a &	1
expression better explains the logic	1
expression list[i] is invalid when	1
expression -(-a) to a. I	1
expression (Tuesday | Wednesday |	1
expression -a > -b to	1
implementation is faster than the	2
implementation is optimal only on	1
implementation is needed. These complicated	1
implementation is best. These cases	1
implementation of the member pointer.	1
implementation of the factorial function	1
implementation of the memcpy function.	1
implementation of the lrint function	1
implementation of member pointers if	1
implementation of these functions is	1
implementation in most cases when	1
implementation in most cases, even	1
implementation for a given instruction	1
implementation can be a viable	1
implementation if the SSE2 instruction	1
implementation if possible, and make	1
implementation may look like this:	1
implementation when b is floating	1
implementation rather than a hardware	1
implementation works particularly bad on	1
implementation uses a lookup table	1
implementation uses XMM registers to	1
implementation would only read the	1
implementation dependent. The stack unwinding	1
implementation analogous to example 15.1b	1
Most of the code in	1
Most of the advice in	1
Most of the comments generated	1
Most compiler packages include a	1
Most compilers can make thread-local	1
Most compilers can do simple	1
Most compilers can reduce simple	1
Most compilers have an option	1
Most compilers will use the	1
Most compilers will make temp	1
Most compilers will automatically replace	1
Most compilers will align data	1
Most compilers will recognize that	1
Most compilers include standard libraries	1
Most compilers offer the choice	1
Most C++ compilers are able	1
Most C++ compilers have various	1
Most performance tests are done	1
Most copy protection schemes are	1
Most reductions involving integer addition,	1
Most modern CPUs have two	1
Most implementations of C++, Pascal	1
Most programmers have little or	1
Most caches are organized into	1
Most IDE's (Integrated Development Environments)	1
Most importantly, it requires an	1
complicated to make CPU- specific	1
complicated and time consuming. A	1
complicated and clumsy, as you	1
complicated and error-prone. The program	1
complicated in a large memory	1
complicated that I consider it	1
complicated if the number of	1
complicated code that is difficult	1
complicated because various corrections for	1
complicated functions like sin. Pointer	1
complicated address calculation and table	1
complicated template method. 7.29 Threads	1
complicated cases should definitely be	1
complicated cases cannot be vectorized	1
complicated solution is to use	1
complicated implementation is needed. These	1
complicated implementation of the member	1
complicated implementation of member pointers	1
complicated mathematical tasks. Before you	1
complicated process which is difficult	1
complicated algorithm if a simple	1
complicated algebraic expressions. For example,	1
complicated algorithms is that it	1
complicated techniques like square blocking	1
complicated reductions. Algebraic reduction is	1
complicated criteria or lists of	1
handling is not necessary for	1
handling is not necessary when	1
handling is intended for detecting	1
handling is negligible because there	1
handling a full size vector.	1
handling and you want the	1
handling in the end of	1
handling in this example. We	1
handling for the whole program	1
handling for a single function	1
handling can be expensive in	1
handling then you cannot be	1
handling takes no extra time	1
handling even in the most	1
handling system makes sure that	1
handling system instead of using	1
handling option in the compiler.	1
handling support anyway. The exception	1
handling unless the code relies	1
handling errors without using exceptions.	1
handling cleanup jobs is to	1
handling information. Each function call	1
handling Exception handling is not	1
handling Exception handling is intended	1
handling ................................................................................ 61 7.31 Other	1
handling /EHs- No stack frame	1
like the one that is	1
like a pointer. It has	1
like a macro so that	1
like a key press or	1
like a mouse move or	1
like a parameter, so there	1
like to put a tag	1
like and how you can	1
like an array with bounds	1
like this in a pivot	1
like example 12.4a where current	1
like adding vectors. The operators	1
like square blocking for the	1
like this: // Example 16.2	1
like this: // Example 14.1a	1
like this: // Example 12.4e.	1
like this: // Example 7.9b	1
like this: // Example 12.9a.	1
like this: // Example 14.4a	1
like -(-a) very often, but	1
like pressing a button or	1
like throw(A,B,C) to tell explicitly	1
like string, wstring or CString	1
like sin. Pointer elimination A	1
like sqrt, pow and log	1
like these, it is important	1
dependency chains is stronger when	1
dependency chains in the code	1
dependency chains can be very	1
dependency chains can be broken	1
dependency chains with long latencies.	1
dependency chains then each thread	1
dependency chains (see p. 22).	1
dependency chain is a series	1
dependency chain in two: //	1
dependency chain may fill up	1
dependency chain has a latency	1
dependency chain which prevents out-of-order	1
dependency chain where each addition	1
dependency chain would make the	1
dependency chain. A microprocessor with	1
dependency chain. If a floating	1
dependency chain. We want the	1
dependency chain. Such dependency chains	1
dependency chain. 3.16 Execution unit	1
dependency chain. Nothing in the	1
dependency chains. A dependency chain	1
dependency chains. In this case,	1
dependency chains. Another thing that	1
dependency chains, especially loop-carried dependency	1
dependency chains, namely the two	1
dependency chain, especially on the	1
members is added to the	1
members of the same class	2
members of the same structure	1
members of a class or	1
members of a class need	1
members of a class (also	1
members of a parent class	1
members of both parent and	1
members of mixed sizes. For	1
members to round addresses in	1
members in the first 128	1
members that are never used	1
members are then you may	1
members can be copied into	1
members or member functions. A	1
members or non-static member functions.	1
members with a total offset	1
members may cause a waste	1
members come first. If it	1
members within the first 128	1
members share the same memory	1
members (properties) The data members	1
members (properties) ............................................................................ 51 7.19	1
members last: // Example 7.35b	1
members individually. Example: // Example	1
their time waiting for user	1
their CPU dispatchers up to	1
their clock frequency dynamically depending	1
their software faster. It is	1
their 32-bit counterparts. In general,	1
their address and attempts to	1
their execution time on executing	1
their uses (live ranges) do	1
their values before compilation. The	1
their own graphical user interfaces	1
their own initiative whenever it	1
their CPUs. Intel's profiler is	1
their index or key in	1
their stack. This can cause	1
their smart pointer then you	1
their implementations reveal a zigzag	1
their live ranges do not	3
their live ranges now overlap.	1
their actual values before it	1
their 23 software. This is	1
their functionality. This will be	1
their live-ranges do not overlap	1
their workplace and the system	1
their superior performance/price ratio. The	1
__m128i a = _mm_or_si128(c2, bc);	1
__m128i a = _mm_blendv_epi8(bc, c2,	1
__m128i b = LoadVector(bb +	2
__m128i two = _mm_set1_epi16(2); //	2
__m128i const & x) {	4
__m128i c = LoadVector(cc +	2
__m128i zero = _mm_set1_epi16(0); //	2
__m128i c2 = _mm_add_epi16(c, two);	2
__m128i defines a 128 bit	1
__m128i bc = _mm_mullo_epi16 (b,	2
__m128i mask = _mm_cmpgt_epi16(b, zero);	2
__m128i LoadVector(void const * p)	3
__m128i LoadVectorA(void const * p)	1
Using the vector operations of	1
Using the SSE2 instruction set	1
Using the methods in the	1
Using the out-of-order capabilities of	1
Using the nontemporal write instruction	1
Using a union is not	1
Using an overloaded operator is	1
Using vector operations Today's microprocessors	1
Using vector classes ............................................................................................. 113	1
Using vector classes Programming in	1
Using vector operations............................................................................................... 105 12.1	1
Using integer operations for manipulating	2
Using double precision in 32-bit	1
Using multiple CPUs or multi-core	1
Using performance monitor counters Many	1
Using performance monitor counters ....................................................................	1
Using pointers makes it more	1
Using complicated techniques like square	1
Using intrinsic functions can be	1
Using intrinsic functions It is	1
Using intrinsic functions ........................................................................................ 109	1
Using templates for polymorphism A	1
Using unaligned reads and writes	1
Using hexadecimal numbers, we have	1
Boolean vector operations An integer	1
Boolean vector operations. 7.6 Pointers	1
Boolean variables are stored as	1
Boolean variables are overdetermined in	1
Boolean variables are overdetermined Boolean	1
Boolean variables as input less	1
Boolean variables as input check	1
Boolean operations can be made	1
Boolean operators because they do	1
Boolean operators && and ||	1
Boolean operators produce a single	1
Boolean operators &&, ||, !	1
Boolean operators (&& and ||).	1
Boolean XMM (vector) reductions: ~(~a)	1
Boolean operands The operands of	1
Boolean operands because you should	1
Boolean vector. For example, if	1
Boolean expressions. There are lots	1
Boolean expressions. Whether the constants	1
Boolean algebra reductions: !(!a)=a x-xxxxxxx	1
Boolean operands. You cannot swap	1
Boolean output. The optimized code	1
Boolean vectors, and these operations	1
Boolean algebra, it is possible	1
Boolean NOT on a variable	1
cache. The different kinds of	1
cache. The same can happen	1
cache. The cache works most	1
cache. The operating system may	1
cache. The register stack also	1
cache. The problem only occurs	1
cache. The advantage of sharing	1
cache. The level-2 cache is	1
cache. The subsequent sections describe	1
cache. The Core2 processor performs	1
cache. This has a very	1
cache. This has hardly any	1
cache. If the number of	1
cache. If the combined size	1
cache. These instructions are accessible	1
cache. Most compilers will make	1
cache. Using the nontemporal write	1
cache. We can take advantage	1
cache. When we reach element	1
cache. Compilers will usually unroll	1
cache. 2.2 Choice of microprocessor	1
cache. Single precision is good	1
cache. Files on remote or	1
cache. Bit-fields of sizes other	1
cache. Multithreaded programs must use	1
don't have the time to	1
don't have to do the	1
don't have to care about	1
don't have to wait for	1
don't have to prefetch data	1
don't have to distribute all	1
don't have to reinvent the	1
don't need the "override" feature.	1
don't need a smart pointer.	1
don't need an error message	1
don't need any non-static access.	1
don't need conversions between integers	1
don't even have an operating	1
don't want this initialization, or	1
don't get rid of the	1
don't support processor X" is	1
don't count on it. Instead	1
don't know if this is	1
don't modify the carry flag	1
don't vectorize the code automatically.	1
don't care to calculate the	1
don't depend on x so	1
don't understand it. I am	1
don't think that programmers write	1
don't send your programming questions	1
256 int int64_t 256 uint64_t	1
256 double 256 F32vec4 F64vec2	1
256 float 128 double 128	1
256 clock cycles. Calculations in	1
256 bit integer vectors FMA3	1
256 bit float and double	1
256 unsigned 256 int int64_t	1
256 16 16 256 Vec32uc	1
256 bits (YMM), and soon	1
256 bits (YMM) if the	1
256 short int int 256	1
256 times and the speed	1
256 AVX int 32 16	1
256 AVX double 64 4	1
256 && SIZE % 128	1
256 AVX2 int 32 8	1
256 AVX2 float 32 8	1
256 AVX2 long long 64	1
256 AVX2 short int 16	1
256 F32vec4 F64vec2 F32vec8 F64vec4	1
256 bytes) on future processors.	1
256 uint64_t 256 float 128	1
256 Kbytes to 2 Mbytes.	1
256 Vec32c unsigned char short	1
256 Vec32uc Vec16s Vec16us Vec8i	1
intrinsic function call is translated	1
intrinsic function _mm256_zeroupper() before any	1
intrinsic vector functions have names	1
intrinsic functions and it can	1
intrinsic functions for the SSE2	1
intrinsic functions can be quite	1
intrinsic functions // This function	1
intrinsic functions // Function to	1
intrinsic functions or vector classes	2
intrinsic functions It is difficult	1
intrinsic functions You have to	1
intrinsic functions Use predefined vector	1
intrinsic functions (i.e. Microsoft, Intel	1
intrinsic functions ........................................................................................ 109 12.5	1
intrinsic instructions for mathematical functions	1
intrinsic function. Provoke branch mispredictions	1
intrinsic functions. This is useful	1
intrinsic functions. It is just	1
intrinsic functions. Alternatively, you can	1
intrinsic hardware functions. The floating	1
intrinsic vectors requires alignment to	1
intrinsic functions, but the function	1
intrinsic functions, but in a	1
intrinsic functions, inline assembly or	1
methods of rounding, but neither	1
methods to improve efficiency. These	1
methods and algebraic reductions in	1
methods in the above examples	1
methods for communication and synchronization	1
methods for avoiding the costs	1
methods for dealing with this	1
methods for exploiting fine-grained parallelism.	1
methods are time consuming. Therefore,	1
methods are based on my	1
methods are further described in	1
methods are discussed in manual	1
methods are incremental or iterative	1
methods or require runtime type	1
methods if the most time-consuming	1
methods with little or no	1
methods may be used for	1
methods have exactly the same	1
methods then the critical part	1
methods only if you are	1
methods also work when Intel	1
methods described on page 153.	1
methods could possibly be relevant	1
methods mentioned above. An object	1
methods depend on the system,	1
signed and unsigned integers is	1
signed and unsigned integers in	1
signed and unsigned integers simply	1
signed and unsigned variables. A	1
signed and unsigned integers. But	1
signed or unsigned 2 2	1
signed or unsigned 4 4	1
signed or unsigned 8 8	1
signed or unsigned 1 1	1
signed or unsigned. The following	1
signed with unsigned integers is	1
signed than with unsigned integers	1
signed when you divide an	1
signed when converting to double	1
signed integer to a float	1
signed integer if there is	1
signed integer doesn't cause overflow.	1
signed integer overflow doesn't occur	1
signed variable produces a negative	1
signed before converting to floating	1
signed integers in case of	1
signed integers before conversion to	1
signed integers. It is more	1
signed number. If the offset	1
signed number, or no offset	1
model the best possible branch	1
model is likely to be	1
model is hardly ever used,	1
model is going to be	1
model is over. Virtualization is	1
model and then think that	1
model that was unknown at	1
model with a higher number	1
model will work better. If	1
model has its own set	1
model used here. The compiler	1
model number to reflect this	1
model where the combined size	1
model work better. Remember again,	1
model numbers are not always	1
model numbers form a logical	1
model comes on the market.	1
model N supports a particular	1
model number. The only CPUID	1
model number. I have seen	1
model number. Failure to handle	1
model numbers, but on what	1
model N+1 supports at least	1
model N-1 is inferior. A	1
model fast=2 Simple member pointers	1
development of a program. The	1
development of user interfaces and	1
development and the low priority	1
development are more important than	1
development time and maintainability of	1
development time for WTL applications	1
development more expensive and more	1
development time. Interpreted languages are	1
development work as a learning	1
development methods are incremental or	1
development process and software engineering	1
development process can influence the	1
development time, usability, program compactness,	1
development models have a strict	1
development tool is faster to	1
development tool is Microsoft Visual	1
development tools. The simplest possible	1
development tools. A popular user	1
development tools. One popular development	1
development process. These requirements are	1
development tools for supporting multi-threaded	1
development tools have powerful facilities	1
development environment (IDE) supports multiple	1
development kit (SDK or PSDK).	1
development tools, rather than by	1
mathematical functions that 150 you	1
mathematical functions are calculated faster	1
mathematical functions are supplied in	1
mathematical functions such as logarithms	1
mathematical functions such as logarithms,	2
mathematical functions such as pow,	1
mathematical functions take more time	1
mathematical code. There are two	1
mathematical operations on vectors and	1
mathematical calculations with memory access.	1
mathematical calculations including linear algebra	1
mathematical functions. A lot of	1
mathematical functions. It also works	1
mathematical functions. 7.4 Enums An	1
mathematical applications with large data	1
mathematical calculations. It is important	1
mathematical calculations. In other programs,	1
mathematical calculations. In such cases,	1
mathematical iterations such as Taylor	1
mathematical tasks. Before you start	1
mathematical calculations, should be scheduled	1
mathematical purity. In many cases	1
mathematical purity. For example, compilers	1
mathematical notion of a "function".	1
never be sure that the	1
never be negative so that	1
never be negative. The last	1
never use static variables. See	1
never used at the same	2
never takes memory space. A	1
never return any pointer or	1
never stored in a register,	1
never uses the new features.	1
never used. A computer with	1
never used. Whenever a function	1
never becomes fragmented thanks to	1
never called. The disadvantage of	1
never called. This method is	1
never called. Unfortunately, the syntax	1
never designed for this purpose.	1
never interrupt the user but	1
never spend time doing the	1
never modified by the program,	1
never occurs, even for arrays	1
never throw any exception so	1
never changed. This will allow	1
never exceeds an acceptable limit,	1
never respond to a command	1
separate for each thread. It	1
separate function library and you	1
separate function library. The radical	1
separate from seldom used functions,	1
separate version for specific CPU	1
separate file than in the	1
separate dynamic link library (*.dll	2
separate function. Sometimes, functions are	1
separate threads with low priority.	1
separate threads so that one	1
separate thread in systems with	1
separate thread if the application	1
separate thread if it is	1
separate thread if there is	1
separate thread with lower priority	1
separate modules if necessary, each	1
separate C or C++ file	1
separate containers for each thread	1
separate module then it is	1
separate storage. No function or	1
separate layers of abstraction is	1
separate subroutine if it is	1
separate executables for 32-bit and	1
separate module, and to put	1
block the execution of everything	2
block is allocated and the	1
block is re-allocated every time	1
block of memory for all	1
block of 16 bytes. Some	1
block of data. This is	1
block to copy that the	1
block and a pointer to	1
block and copy the contents	1
block for each object. A	1
block for every four objects.	1
block that the object owns.	1
block that has already been	1
block or function call (other	1
block than to store each	1
block then become invalid. The	1
block from one object to	1
block should have its pointer	1
block size grows by only	1
block into the beginning of	1
block every time a string	2
block containing many objects can	1
block turns out to be	1
name is not allowed in	1
name of this function is	1
name of Func with a	1
name and the template parameter.	1
name and model number. The	1
name in the object file.	1
name for the child class	1
name for each instruction set.	1
name for local references. Shared	1
name that the compiler has	1
name as a function in	1
name as a global variable	1
name as template parameter. In	1
name at the time MemberPointer	1
name cannot be overloaded or	1
name ; start of Func	1
name depending on instruction set	1
name Instruction set Prefetch PREFETCH	1
name Intrinsic function name Instruction	1
name ?Func@@YAXQAHAAH@Z is the name	1
name mangling are explained in	1
name mangling. The characters '?',	1
name "position-independent code" actually implies	1
name _alloca) for (int i	1
name ;startofFunc ; a ;	1
systems. The Intel compiler supports	1
systems. The 64 bit instruction	1
systems. The user interface library	1
systems. The appropriate version of	1
systems. The smaller the system,	1
systems. The latter is more	1
systems. The Intel-based Mac OS	1
systems. A software developer may	1
systems. A look in my	1
systems. It is intended for	1
systems. If the compiler doesn't	1
systems. If you are in	1
systems. There is no heavy	1
systems. Some compilers have difficulties	2
systems. All of these methods	1
systems. Mac systems often use	1
systems. Floating point variables use	1
systems. 10 Gnu This is	1
systems. 3 The latest versions	1
systems. Virtual member functions are	1
systems. 14 Specific optimization topics	1
systems. Applications that use large	1
systems. Today (2013) both 32-bit	1
systems. 67 The maximum number	1
put the different functions in	1
put the most often used	1
put the most predictable operand	1
put the desired measurement instruments	1
put the whole software project	1
put the operand that is	2
put the task-specific part of	1
put a test feature into	1
put a task into a	1
put a parenthesis around the	1
put a parenthesis around such	1
put a tag on a	1
put an equal amount of	1
put into the list every	1
put there when the program	1
put file access and network	1
put file access in a	1
put something in a separate	1
put away in reusable and	1
put time-consuming tasks into separate	1
put 80 into a and	1
put seldom used branches such	1
put measurement instruments directly into	1
put time- consuming calculations into	1
needs the result of the	1
needs a floating point counter	1
needs a little explanation. The	1
needs of position- independent code,	1
needs to be called. It	1
needs to be distributed to	1
needs to be updated every	1
needs to be stored. All	1
needs to be saved. Any	1
needs to code the offset	1
needs to make a new	1
needs to call a polymorphic	1
needs to look up in	1
needs to load the dynamic	1
needs to switch to protected	1
needs to evaluate a only	1
needs to evaluate b when	1
needs to follow the track	1
needs an extra jump through	1
needs only calculate element addresses	1
needs all information about the	1
needs one instance for each	2
needs them. Pure functions A	1
needs careful optimization. A mixed	1
y = a + b	3
y = a & b;	1
y = c + b	1
y = d + e	1
y = (a + b)	1
y = 1.0; while (n	1
y = b;} vector operator	1
y = cos(x); } z	1
y = cos(x); z =	1
y = sin(x); } 68	1
y = sin(x); z =	1
y = a1/b1 + a2/b2;	1
y = pow(x,n) As we	1
y = (a1*b2 + a2*b1)	1
y = MAX(f(x), g(x)); In	1
y will get the value	1
y into a vector register,	1
y + 1.; } The	1
y + 1.; } else	1
y + 1.; Eliminate jumps	1
y + a.y);} vector a,	1
y && z != 0;	1
y *= x; x *=	1
conversion is costly if XMM	1
conversion is valid. For example,	1
conversion of i to float	1
conversion to floating point if	1
conversion to signed integer doesn't	1
conversion and shuffling can sometimes	1
conversion // Example 7.21 int	1
conversion // Example 7.20 int	1
conversion // C-style type casting	1
conversion time is typically between	1
conversion A pointer can be	1
conversion from floating point to	1
conversion from example 15.1b to	1
conversion from float or double	1
conversion takes more time than	1
conversion takes no extra time.	1
conversion takes zero or one	1
conversion takes 50 - 100	1
conversion between signed and unsigned	1
conversion often takes no extra	1
conversion instructions which can be	1
conversion Conversion of a floating	1
conversion Conversion of a signed	1
conversion Conversions between float, double	1
conversion generates no extra code	1
c; a = b /	2
c; a = b %	2
c; a = select(b >	1
c; The calculation here gives	1
c; for (r = 0;	2
c; // Define biggest possible	1
c; // Roll out loop	1
c; int UnusedFiller; }; int	1
c; } In this example,	1
c; } Can be reduced	1
c; double temp; for (r	2
c; b = (unsigned int)a	1
c; b = (a+1) *	1
c; }; Replace with: //	1
c; }; 7.23 Constructors and	1
c; ... // Call critical	2
c; y = d +	1
c; Here, y will get	1
c; Is16vec8 a = select_gt(b,	1
c; x[0] = a; b	1
#include directives and declare all	1
#include directives. This is sure	1
#include <stdio.h> // define fprintf	1
#include <stdio.h> #include <asmlib.h> void	1
#include <dvec.h> // Define vector	2
#include "vectorclass.h" // vector class	1
#include "vectorclass.h" // Define vector	1
#include <emmintrin.h> // Define SSE2	1
#include <emmintrin.h> static inline int	1
#include "asmlib.h" // Define function	1
#include "asmlib.h" // Lowest version	1
#include <xmmintrin.h> _mm_setcsr(_mm_getcsr() | 0x8040);	1
#include <xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It is	1
#include <ia32intrin.h> etc. // Returns	1
#include <excpt.h> #include <float.h> #include	1
#include "xmmintrin.h" // header for	1
#include <float.h> #include <math.h> #define	1
#include <pmmintrin.h> // SSE3 required	1
#include <malloc.h> void SomeFunction (int	1
#include <intrin.h> long long ReadTSC()	1
#include "instrset_detect.cpp" // instrset_detect function	1
#include <asmlib.h> void CriticalFunction(); ...	1
#include <math.h> #define EXCEPTION_FLT_OVERFLOW 0xC0000091L	1
various function libraries for computing	1
various functions for these calculations.	1
various other optimizations possible because	1
various instruction sets can be	1
various efficient container classes. Text	1
various optimization methods and algebraic	1
various optimization options that you	1
various programming languages. www.yeppp.info And	1
various methods for communication and	1
various options to control the	1
various ways of reducing the	1
various ways to do this:	1
various ways to avoid the	1
various ways to avoid this	1
various ways to avoid these	1
various ways to get more	1
various ways around this problem.	1
various ways depending on the	1
various things you can do	1
various discussion forums on the	1
various algebraic expressions on seven	1
various profilers available which are	1
various alternatives to using a	1
various corrections for sign and	1
disadvantage is that the compiler	1
disadvantage is that the memory	1
disadvantage is that the cache	1
disadvantage is that the value	1
disadvantage is that CParent::Hello() has	1
disadvantage of the Intel compiler	1
disadvantage of a very large	1
disadvantage of function inlining is	1
disadvantage of using the newest	1
disadvantage of using a long	1
disadvantage of using an intermediate	1
disadvantage of 64-bit Windows may	1
disadvantage of C++ relates to	1
disadvantage of intermediate code is	1
disadvantage of complicated algorithms is	1
disadvantage of binary data storage	1
disadvantage of compiling without -fpic	1
disadvantage for the end user	1
disadvantage that the function is	1
disadvantage that the function must	1
disadvantage that the branching takes	1
disadvantage if the sequence of	1
disadvantage if other nearby parts	1
disadvantage when the arrays are	1
high and decreased when the	1
high for programs that are	1
high that it is more	1
high that it is unrealistic	1
high that it rarely justifies	1
high then the most efficient	1
high speed of modern microprocessors	1
high power of 2. The	1
high power of 2. Contentions	1
high precision math allow addition	1
high precision math. Memory copying.	1
high overhead cost of heap	1
high repeat count is mispredicted	1
high processing power of the	1
high priority of structured software	1
high level framework based on	1
high level framework still consumes	1
high level framework. The optimized	1
high priority. The gain in	1
high priority. Other tasks such	1
high resolution if time intervals	1
high degree of optimization is	1
high complexity of modern software,	1
high price, and in most	1
zero is sometimes more efficient	1
zero and to make overflow	2
zero and then call __intel_cpu_features_init_x().	1
zero in the while loop	1
zero for (i = 0;	1
zero that is more efficient	1
zero // Return the size	1
zero = _mm_set1_epi16(0); // Make	2
zero or one clock cycle.	1
zero or infinity or NAN	1
zero if all bits except	1
zero by using memset: //	1
zero by testing all bits	1
zero than making it count	1
zero } We can multiply	1
zero at the same time	1
zero We can check if	1
zero whenever the objects they	1
zero within a block of	1
zero flag and don't modify	1
zero flags on certain Intel	1
zero memset(a, 0, sizeof(a)); //	1
Microsoft and Intel compilers for	1
Microsoft and PathScale compilers. (The	1
Microsoft or Gnu compilers without	1
Microsoft compiler for Windows applications.	1
Microsoft compiler does not allow	1
Microsoft compiler #define Alignd(X) __declspec(align(16))	1
Microsoft compiler supports this option	1
Microsoft C++ compilers www.agner.org/ optimize/#vectorclass	1
Microsoft C++ Compiler v. 14.00	1
Microsoft Table 2.1. Comparing performance	1
Microsoft compilers. // It will	1
Microsoft directives work on the	1
Microsoft Intel, Microsoft, Gnu, Clang	1
Microsoft platform software development kit	1
Microsoft compiler. Some functions are	1
Microsoft compiler. Supports only 32-bit	1
Microsoft Visual Studio This is	1
Microsoft Visual Studio when compiling	1
Microsoft Visual Studio IDE. Has	1
Microsoft Visual Studio. This tool	1
Microsoft Visual studio 2008, v.	1
Microsoft Constant propagation Pointer elimination	1
Microsoft Comes with Microsoft compiler.	1
Microsoft Foundation Classes (MFC). A	1
what the compiler can do	1
what the compiler does It	1
what the compiler does .............................................................................	1
what the assembly output of	1
what the preprocessor can do	1
what is most appropriate for	1
what is brand new today	1
what is happening. It is	1
what a function pointer points	1
what a pointer points to	1
what it can not do.	1
what it points to. A	1
what if an exception occurs	1
what you are doing. See	1
what you want it to.	1
what you want when the	1
what instruction sets and other	1
what class of object p	1
what they are. However, there	1
what r points to ;	1
what kind of exceptions a	1
what fits best into the	2
what happens inside the loop,	1
parameter is that the overhead	1
parameter is always resolved at	1
parameter is part of a	1
parameter is bigger than the	1
parameter is copied to a	1
parameter is wrong, but it	1
parameter of composite type is	1
parameter to the library function,	1
parameter to the function. The	1
parameter and a template parameter:	1
parameter can also be a	1
parameter has a composite type	1
parameter should be a class	1
parameter rather than a function	1
parameter comes first when you	1
parameter transfer is avoided for	1
parameter transfer is avoided. The	1
parameter transfer for 'this' is	1
parameter transfer are eliminated. Code	1
parameter transfer across all .cpp	1
parameter 2: 12 $B1$1: push	1
parameter 1: 4 + esp	1
parameter 1: 8 + esp	1
parameter $B1$1: mov mov mov	1
division is faster the smaller	1
division is inexact if b	1
division to be slower. Many	1
division and relational operators (e.g.	1
division in vectors, but the	1
division by a variable because	1
division by a constant is	3
division by a constant should	1
division by a power of	1
division by a variable. Make	1
division by making a common	1
division with truncation, and %	1
division takes much longer time	2
division takes 40 - 80	1
division take longer time. Integer	1
division c = a *	1
division Integer division takes much	1
division Floating point division takes	1
division prevents the compiler from	1
division faster. Of course, this	1
division ........................................................................................... 139 14.7 Don't	1
reference is the same as	1
reference is valid only until	1
reference to the class or	1
reference to the object. The	1
reference to the object. If	1
reference to a static object	1
reference to a variable that	1
reference to a public variable	1
reference to a structure. For	1
reference to such an object	1
reference to a[i] More examples	1
reference to it. Therefore, you	1
reference to anything it has	1
reference to provoke error //	1
reference can be eliminated if	1
reference or a simple variable.	1
reference or pointer to the	1
reference if the function is	1
reference may be just as	1
reference makes sure that the	1
reference cannot change what it	1
reference allows the function argument	1
reference instead: // Example 12.6.	1
reference parameters). The this pointer	1
source is an arithmetic expression.	1
source of such container classes.	1
source of error known as	1
source of information about bugs,	1
source of errors in C++	1
source and destination both have	1
source code is compiled into	1
source code more complex, but	1
source compiler for 32-bit Windows.	1
source so that it can	1
source code. The library has	1
source code. It is therefore	1
source code. #if is more	1
source file and the derived	1
source files for the sake	1
source files are first compiled	1
source files into one by	1
source code, as the example	1
source library. Supports x86 and	1
source file. If the member	1
source file. Keep often used	1
source files. 13.2 Model-specific dispatching	1
source annotation in the assembly	1
source annotation option if you	1
cost is seen in 64	1
cost is minimized if the	1
cost of this solution is	1
cost of dynamic memory allocation	1
cost of exception handling Exception	1
cost of longer response times	1
cost of task switching. This	1
cost of heap management and	1
cost of keeping a CPU	1
cost of starting and stopping	1
cost of fine-tuning, testing, verifying	1
cost of verifying, debugging and	1
cost of synchronizing and communicating	1
cost to memory management and	1
cost to using templates (see	1
cost to using templates. Ready	1
cost to accessing an object	1
cost to creating and deleting	1
cost in performance. Integer size	1
cost in terms of execution	2
cost because it goes automatically	1
cost whenever a smart pointer	1
cost anything here because we	1
running the advanced version on,	1
running the services only when	1
running a program you want	1
running and before any constructors	1
running in the same core	1
running in the same core.	1
running in the majority of	1
running in other threads with	1
running in 64-bit mode because	1
running in 32-bit or 64-bit	1
running in parallel. Fine-grained parallelism	1
running on the same computer,	1
running on the newest processors.	1
running on an Intel CPU.	1
running on an Intel processor.	1
running on non-Intel processors (see	1
running this code with a	1
running when it is not	1
running multiple threads in the	1
running two threads with widely	1
running on, while it is	1
running simultaneously can share the	1
running on. Replace or bypass	1
running at, rather than the	1
automatic CPU dispatching or memory-intensive	1
automatic CPU dispatching #include "vectorclass.h"	1
automatic CPU dispatching. The code	1
automatic CPU dispatching. Many Intel	1
automatic CPU dispatching. Unfortunately, the	1
automatic check for integer overflow.	1
automatic dispatching can be made	1
automatic vectorization (see page 107).	1
automatic vectorization (see page 107),	1
automatic vectorization works best if	1
automatic vectorization leads to suboptimal	1
automatic updates to the operating	1
automatic vectorization. The compiler will	1
automatic vectorization. The Gnu compiler	1
automatic vectorization. It is possible	1
automatic vectorization. Optimizes reasonably well.	1
automatic vectorization. Optimizes moderately well.	1
automatic prefetching so this feature	1
automatic parallelization. The Gnu, Intel	1
automatic parallelization. Supports vector intrinsics	1
automatic parallelization of code into	1
automatic vectorization, such as Gnu,	1
automatic CPU-dispatching (see page 122)	1
automatic updates, remote help files,	1
resources of the core with	1
resources and servers should be	1
resources for other virtual processors	1
resources that need to be	1
resources are not recommended for	1
resources are most critical. However,	1
resources are cleaned up in	1
resources are sufficient, and the	1
resources are limiting factors for	1
resources than the code itself.	1
resources than the program itself	1
resources than the programs they	1
resources than a static library,	1
resources than doing arithmetic operations.	1
resources than standard PCs. The	1
resources than C if you	1
resources than non-virtual functions. Avoid	1
resources from a higher-priority thread	1
resources should be organized so	1
resources cannot be controlled. Small	1
resources .......................................................................................... 21 3.12 Network	1
resources Writes to a printer	1
resources cleaned up. If an	1
resources locally or remotely. If	1
induction variable for accessing list[i].a	1
induction variable can be calculated	1
induction variable as loop counter	1
induction variable because it is	1
induction variable method unfavorable, unless	1
induction variable would be needed	1
induction variable unless the loop	1
induction variable Y // Update	1
induction variable Z } The	1
induction variable (eax) which contains	1
induction variables to calculate the	1
induction variables for the same	1
induction variables for floating point	1
induction variables for calculating a	1
induction variables can also be	1
induction variables const double A	1
induction variables (see below). A	1
induction variables Compilers cannot make	1
induction variables Y and Z.	1
induction variables. It is important	1
induction variable. The compiler can	1
induction variable. (This eliminates the	1
induction variables: // Example 8.23b.	1
reason is that the CPU	1
reason is that the C/C++	1
reason is that a positive	1
reason is that modern processors	1
reason to use it for	1
reason to use dynamic memory	1
reason to use try, catch,	1
reason to add statements like	1
reason to unroll the loop	1
reason for this is that	1
reason for this efficiency lies	1
reason for using an intermediate	1
reason for updating. The update	1
reason that they cannot make	1
reason why the compiler doesn't	1
reason why it is safe	1
reason why this effect is	1
reason why all modern computers	1
reason why compilers do not	1
reason why there is virtually	1
reason why such runtime frameworks	1
reason why exception handling can	1
reason is, I guess, that	1
dispatcher to know whether the	1
dispatcher in the MKL relies	1
dispatcher in only the lowest	1
dispatcher that doesn't handle current	1
dispatcher function is usually called	1
dispatcher function and replaces the	1
dispatcher function will most likely	1
dispatcher function decides which function	1
dispatcher then sets a function	1
dispatcher should not look at	1
dispatcher should have as few	1
dispatcher should give a CPU	1
dispatcher function. This will make	1
dispatcher function. When the program	1
dispatcher function. typeof(CriticalFunction) * CriticalFunctionDispatch(void)	1
dispatcher does not check if	1
dispatcher 128 function cannot rely	1
dispatcher based on complicated criteria	1
dispatcher checks whether the processor	1
dispatcher changes the function pointer	1
dispatcher signal an error simply	1
dispatcher treats non-Intel CPUs in	1
dispatcher updated. It is tempting	1
n is the number of	1
n is a loop count.	1
n is an array index	1
n is known at compile	1
n to the exponent: //	1
n to exponent } Example	1
n and reorganize the code	1
n = 1; n <=	1
n = 4, we have:	1
n with a suitable choice	1
n from the exponent if	1
n < 223 to a	1
n bits of the number	1
n 0 n! 117 A	1
n << 23; // add	1
n here because the consequence	1
n factorial } return sum;	1
n additions and no multiplications.	1
n <= 16; n++) {	1
n places back, where n	1
n being out of range	1
n >>= 1; } return	1
n floats: float * DynamicArray	1
string is created or modified.	2
string is already known then	1
string is checked before storing.	1
string of bytes to find	1
string to lower case: //	1
string and then interpret that	1
string or CString. This is	1
string as code. Metaprogramming can	1
string functions and some other	1
string functions as well as	1
string functions have no check	1
string classes use dynamic memory	1
string classes allocate a new	1
string functions. A metaprogramming implementation	1
string instructions. The built-in code	1
string length function scans a	1
string search instructions AVX 256	1
string searching and parsing are	1
string constants, and initialized arrays.	1
string constants, array initializer lists,	1
string manipulation Mathematical functions Encryption,	1
string classes, such as string	1
programmer to be aware of	1
programmer to make and therefore	1
programmer to make sure the	3
programmer to make sure that	2
programmer to make explicit checks	1
programmer to know what the	1
programmer to know about. Function	1
programmer in a bad dilemma.	1
programmer that pointers to different	1
programmer can use standard user	1
programmer can do to take	1
programmer may prefer to write	1
programmer has defined a constructor,	1
programmer does not have to	1
programmer typically thinks "what works	1
programmer gets the new version	1
programmer choosing the most efficient	1
programmer forgets that the system	1
programmer can. It is therefore	1
programmer hasn't thought about the	1
three to seven times faster	1
three or four, depending on	1
three different object file formats.	1
three functions Sum1, Sum2 and	1
three clock cycles. But if	1
three times the other way,	1
three times faster. The logic	1
three versions should be linked	1
three functions. Sum1 has an	1
three values per point. This	1
three aligned arrays Alignd (	1
three ways to make a	1
three ways to do things	1
three things that can be	1
three conditions which are implemented	1
three times. Then again two	1
three branches. They can be	1
three times, one for the	1
three clauses are separated by	1
three clauses: initialization, condition, and	1
three parts: one for constants	1
three advantages: The i<20 loop	1
three levels of cache for	1
better to do the CPU	1
better to join them into	1
better and better at vectorization.	1
better on very small loops	1
better than the 32-bit version.	1
better than its reputation. The	1
better than RISC in situations	1
better use of the data	1
better at vectorization. 3. Use	1
better at reducing integer expressions	1
better because the code becomes	1
better version of the code.	1
better result by using intrinsic	1
better processor appears on the	1
better solution to make the	1
better support for hard disk	1
better metaprogramming tools to be	1
better solution. It might be	1
better backup features, and current	1
better explains the logic behind	1
better understanding of the whole	1
better performing software product is	1
better standardization of programming languages,	1
keyword is not recognized in	1
keyword is only a hint	1
keyword is used or if	1
keyword to all local non-member	1
keyword can be added to	1
keyword has a different meaning	1
keyword has several meanings depending	1
keyword static to the function	2
keyword also makes various other	1
keyword makes sure that a	1
keyword __restrict or __restrict__, if	1
keyword volatile is that it	1
keyword far (arrays can also	1
keyword static, when applied to	4
keyword __fastcall changes the function	1
keyword specifies that a variable	1
keyword tells that a variable	1
keyword __thread or __declspec(thread). Such	1
keyword wherever appropriate to give	1
efficient. The size of the	1
efficient. The size of all	1
efficient. The performance can be	1
efficient. The SSE2 instruction set	1
efficient. The following example shows	1
efficient. This instruction set is	1
efficient. If the compiler has	1
efficient. If you look at	1
efficient. 64-bit Windows allows a	1
efficient. In 64-bit systems, you	1
efficient. In many cases, the	1
efficient. There are various ways	1
efficient. You can disable exception	1
efficient. You may use the	1
efficient. 64 bit systems have	1
efficient. Most C++ compilers have	1
efficient. Dynamic libraries are less	1
efficient. Do not make variables	1
efficient. Variables that are members	1
efficient. Access to static or	1
efficient. Extra memory space is	1
efficient. Simple function parameters are	1
efficient. Splitting up a function	1
lookup is to use static	1
lookup is often an obstacle	1
lookup in a procedure linkage	1
lookup for a virtual function	1
lookup can be used in	1
lookup or require a lot	1
lookup if the function has	1
lookup } else { return	1
lookup at the vector element	1
lookup table is advantageous in	1
lookup table if you expect	1
lookup table instead of calculating	1
lookup cannot be vectorized with	1
lookup operations slow down the	1
lookup Using intrinsic functions can	1
lookup process is used for	1
lookup tables if this prevents	1
lookup tables Reading a value	1
lookup tables ................................................................................................. 132 14.2	1
lookup Lookup tables can be	1
lookup table: // Example 14.3b	1
lookup table: // Example 14.1b	1
lookup mechanisms explained above. A	1
end of the array to	1
end of the array, which	1
end of a function or	1
end of a ; top	1
end of an array can	1
end of this section for	1
end of array ; jump	1
end of procedure 4 Most	1
end in order to get	1
end with a non-recursing template	1
end when all threads have	1
end user is likely to	1
end user will have an	1
end user who has to	1
end user gets the latest	1
end up with the correct	1
end user. The advantages of	1
end user. There may be	1
end user. Dynamic linking works	1
end user. Installation problems. The	1
end user. Menus, buttons, dialog	1
end users have. The developers	1
end user's computers. At this	1
applications to perform poorly for	1
applications and the Gnu, Clang,	1
applications that can be divided	1
applications that can take advantage	1
applications are highly system dependent	1
applications can be expected to	1
applications it is much more	1
applications with many function calls.	1
applications with large data sets.	1
applications have less computing resources	1
applications use the same DLL	1
applications use a database for	1
applications because the response times	1
applications such as a make	1
applications need better backup features,	1
applications without an operating system	1
applications even on such small	1
applications run faster at the	1
applications running simultaneously can share	1
applications require that data are	1
applications (e.g. in linear algebra)	1
applications spend most of their	1
applications force the operating system	1
below. The function rounds a	1
below. The time unit is	1
below. The program will not	1
below. The stack is a	1
below. The disadvantage of function	1
below. This manual is based	1
below. There are other possible	1
below. You may choose either	1
below. Microsoft Visual Studio This	1
below. Make calls directly to	1
below. Many libraries for special	1
below. Shared objects in 64	1
below. Shared objects in 32	1
below. Intrinsic function Size of	1
below. Position-independent code is used	1
below. Dispatch at installation time.	1
below. 126 Make pointer at	1
below. Signed / unsigned conversion	1
below. Devirtualization An optimizing compiler	1
below. 3.7 File access Reading	1
below. Installing a second application	1
below. Cannot optimize across modules	1
below. Those who are satisfied	1
&& is false, then the	1
&& a = a x	1
&& a needs to evaluate	1
&& to & unless you	1
&& and || are evaluated	1
&& b with a &	1
&& b needs to evaluate	1
&& i <= max) {	1
&& b; d = a	1
&& expression to generate many	1
&& true = a, a	1
&& list[i] > 1.0) {	1
&& false = false, a	1
&& SIZE % 128 ==	1
&& z != 0; 35	1
&& !a = false, a	1
&& expression, or first in	1
&& a<c) = (a<b &&	1
&& !b) rather than the	1
&& !b = !(a ||	1
&& b<c && a<c) =	1
&& WriteFile(handle, ...)) { ...	1
&& b<c) Multiply by constant	1
| a = a -	1
| b if b is	1
| operations than to write	1
| 0 = a a	1
| 0 = a -	1
| b; Here, I have	1
| operator which otherwise can	1
| -1 = -1 -	1
| -1 = -1 x	1
| Wednesday | Friday) in	1
| Wednesday | Friday)) {	1
| operator; you can clear	1
| (~a&c) | (b&c) =	1
| (~a&c) a&b&c&d = (a&b)&(c&d)	1
| Friday) in example 14.7b	1
| (b&c) = (a&b) |	1
| ((C & 3) <<6	1
| ((B & 3) <<	1
| Friday)) { DoThisThreeTimesAWeek(); }	1
| 0x3F800000; // Now 1.0	1
| (C << 6); Or,	1
| (B << 4) |	1
| 0x8040); See page 145	1
Make the function a constructor	1
Make the function return a	1
Make the function modify an	1
Make the function construct an	1
Make the dispatcher function. typeof(CriticalFunction)	1
Make a vector of (0,0,0,0,0,0,0,0)	3
Make a vector of (2,2,2,2,2,2,2,2)	3
Make a C++ program that	1
Make a member function or	1
Make functions local A function	1
Make all instances of S1	1
Make pointer at initialization. The	1
Make two or more versions	1
Make array of 100 floats	1
Make sure the value of	1
Make sure to distinguish these	1
Make dynamic array of n	1
Make calls directly to the	1
Make three aligned arrays Alignd	1
We can make an approximate	1
We can make sure that	1
We can only hope that	2
We can take the absolute	1
We can take advantage of	1
We can therefore conclude that	1
We can check if a	1
We can calculate which set	1
We can never be sure	1
We can change the sign	1
We can shift out the	1
We can tell it this	1
We can convert an integer	1
We can multiply a nonzero	1
We may decide to do	1
We cannot change its possible	1
We take the elements from	1
We want the CPU to	1
We want to vectorize the	1
We must bear in mind,	1
We might check for overflow	1
We took advantage of the	1
examples of how to make	1
examples of how to avoid	1
examples of how to break	1
examples of arrays with bounds	1
examples of container classes are	1
examples of suitable containers class	1
examples of poor CPU dispatching.	1
examples of bad CPU dispatching.	1
examples in the appendix at	1
examples in this table may	1
examples in these manuals can	1
examples for these methods. If	1
examples are optimized for execution	1
examples are intended to work	1
examples on page 134 and	1
examples have been tested only	1
examples will therefore be a	1
examples all use single precision.	1
examples where the reduction would	1
examples we are using unions	1
examples I have tested. The	1
examples explain how metaprogramming can	1
examples exist. Therefore the compiler	1
char a = 0, b	1
char a = 0, b;	1
char a = -100, b	1
char const * const Greek[4]	1
char 8 8 64 MMX	1
char 8 16 128 SSE2	1
char 8 32 256 AVX2	1
char 8 0 255 uint8_t	1
char 8 -128 127 int8_t	1
char 64 Iu8vec8 16 4	1
char 64 Is8vec8 8 8	1
char 16 SSSE3 _mm_perm_epi8 32	1
char 16 XOP, AMD only	1
char short int 832 256	1
char 128 Is8vec16 Vec16c 8	1
char 128 Iu8vec16 Vec16uc 16	1
char 256 Vec32c unsigned char	1
char (or int) instead of	1
char pointers. 144 The above	1
char string[100], *p = string;	2
char pointers). An optimizing compiler	1
char abc; }; Bitfield x;	1
difference is simply a matter	2
difference in performance between the	1
difference in performance between 32-bit	1
difference in speed between using	1
difference in speed between single	1
difference in speed between rounding	1
difference in performance. A good	1
difference in efficiency. For example,	1
difference for the performance. 14.4	1
difference for each test //	1
difference between the two clock	1
difference between the Boolean operators	1
difference between the efficiency of	1
difference between a function parameter	1
difference between a software programming	1
difference between two pointers requires	1
difference between 32-bit Linux and	1
difference between rounding and truncation.	1
difference between commas and semicolons	1
difference less than 2-20, but	1
difference whether you use pre-increment	1
difference lies in the way	1
addition is finished. The optimal	1
addition of integers with a	1
addition to the code cache	1
addition to the instruction set	1
addition to sum1 from time	1
addition to sum2 from time	1
addition and multiplication may be	1
addition and subtraction (3 -	1
addition with floating point multiplication,	1
addition with another vector register	1
addition on a modern CPU.	1
addition then you will have	1
addition has to wait for	1
addition takes 5 clock cycles,	1
addition takes 3 - 6	1
addition before the preceding addition	1
addition every clock cycle. The	1
addition every clock cycle. This	1
addition every three clock cycles.	1
addition depends on the result	1
addition units, and 22 one	1
addition unit, but this unit	1
addition to) the time stamp	1
data. The code goes through	1
data. The data have to	1
data. The need for special	1
data. The test data should	1
data. The speed of CPUs	1
data. The disadvantage is that	1
data. The effect is much	1
data. The similarity between the	1
data. This is the reason	1
data. This is data decomposition.	1
data. This makes position- independent	1
data. A database can consume	1
data. A hash table can	1
data. A missing check for	1
data. A complete redesign of	1
data. It is very important	1
data. Use an old computer	1
data. Use OpenMP directives. OpenMP	1
data. Therefore, the data section	1
data. Extra data conversion, shuffling,	1
data. 148 It is possible	1
data. That being said, I	1
data. Multidimensional arrays should be	1
too many branches. If you	1
too long time to execute	1
too important to ignore, then	1
too large for the stack	1
too big for the stack.	1
too big before multiplying them.	1
too much data for one	1
too much about the costs	1
too much space in the	1
too small to cause overflow,	1
too small or too long.	1
too little data for analysis.	1
too long. If the program	1
too slow. Today, the 8	1
too fragmented. This garbage collection	1
too big. 7.14 Functions Function	1
too small. Are objects numbered	1
too fine then it is	1
too high. It may be	1
too late. You should therefore	1
too worried about this condition.	1
too much. Excessive loop unrolling	1
too small, then it is	1
mechanism is also used in	1
mechanism is also used when	1
mechanism is rarely enough to	1
mechanism of static linking is	1
mechanism to advertise new versions	1
mechanism in the Intel compiler	2
mechanism in Intel compilers has	1
mechanism that treats different brands	1
mechanism can be implemented in	1
mechanism can be bypassed when	1
mechanism can prefetch the data.	1
mechanism may be used when	1
mechanism because it makes dispatching	1
mechanism should never interrupt the	1
mechanism called stack unwinding that	1
mechanism even when it would	1
mechanism works only on registers,	1
mechanism works automatically. However, there	1
mechanism allows the CPU to	1
mechanism stores a pointer to	1
mechanism relies on non- standardized	1
mechanism executes a series of	1
Table of factorials: static const	1
Table of factorials: const int	1
Table // Loop counter //	1
Table // Loop counter //=2*A	1
Table lookup } else {	1
Table lookup cannot be vectorized	1
Table 8.1 (page 77) shows	1
Table 12.5. Vector classes defined	1
Table 8.1. Comparison of optimizations	1
Table 9.2. Cache control instructions.	1
Table 18.2. Compiler directives and	1
Table 12.4. Vector class libraries	1
Table 7.2. Alignment of data	1
Table 9.1. Time for transposition	1
Table 9.3. Time for transposing	1
Table 13.1. Instruction sets A	1
Table 12.1. Vector classes defined	1
Table 12.3. Intrinsic functions for	1
Table 7.1. Sizes of different	1
Table 18.1. Command line options	1
Table 2.1. Comparing performance of	1
Table 18.3. Predefined macros Compiler	1
Table 12.2. Header files for	1
runtime of the .NET framework.	1
runtime if all the inputs	1
runtime from the caller to	1
runtime address calculations have to	1
runtime libraries and frameworks, rather	1
runtime type identification (RTTI) If	1
runtime type identification (RTTI) /GR	1
runtime type identification (RTTI). See	1
runtime type identification (RTTI), which	1
runtime check that the conversion	1
runtime framework for interpreting or	1
runtime framework that must be	1
runtime framework may use more	1
runtime dispatch to virtual member	1
runtime here if the compiler	1
runtime DLL or a static	1
runtime DLL takes more memory	1
runtime polymorphism that is obtained	1
runtime frameworks are used at	1
runtime frameworks, intermediate code, interpreters,	1
runtime frameworks. The .NET framework	1
runtime polymorphism: // Example 7.43a.	1
runtime DLL's (dynamically linked libraries	1
needed a few clock cycles	1
needed in this case. A	1
needed in 64-bit mode because	1
needed in 64-bit mode where	1
needed in order to avoid	1
needed in advance rather than	1
needed for the calculation of	1
needed for other reasons, but	1
needed for calculating row addresses	1
needed for setting up a	1
needed for communication between different	1
needed if the object can	1
needed if the object doesn't	1
needed by the application, while	1
needed from the library file	1
needed because the CPU has	1
needed only if it cannot	1
needed before all objects have	1
needed before adding the first	1
needed even when the function	1
needed after all objects have	1
needed anyway. You may preferably	1
needed _mm_shuffle_epi8 16 1 byte	1
means of making software more	1
means of #include directives and	1
means of #include directives. This	1
means to make code that	1
means that the function is	1
means that the value of	1
means that a must be	1
means that a particular memory	1
means that it is not	1
means that it is possible	1
means that it is initialized	1
means that it can be	1
means that it cannot access	1
means that if a piece	1
means that if each addition	1
means that different threads are	1
means that all the cache	1
means that source and destination	1
means are among the most	1
means not a vector). The	1
means integer division with truncation,	1
means avoid powers of 2	1
means modulo. For example, if	1
last the second result is	1
last in a structure or	1
last in an && expression,	1
last time the statement was	1
last time it was executed.	1
last all the B values.	1
last cache level, and in	1
last 8 columns unused. This	1
last time. Newer processors are	1
last element outside the loop	1
last line is implicitly converting	1
last byte at 1 byte	1
last byte at 19 };	1
last byte at 15 byte	1
last byte at 7 int	1
last byte at 13 //	1
last byte at 11 short	1
last byte at 403 int	1
last byte at 399 int	1
last index changes fastest: //	1
last index changing in the	1
last vector. Organize the data	1
last member. This pointer is	1
byte of data (low numbers	1
byte of zero within a	1
byte of zero. A good	1
byte = char 16 SSSE3	1
byte = char 16 XOP,	1
byte at 1 byte at	1
byte at 0, last byte	3
byte at 8, last byte	2
byte at 19 }; S1	1
byte at 15 byte at	1
byte at 7 int d;	1
byte at 16, last byte	1
byte at 13 // 2	1
byte at 11 short int	1
byte at 12, last byte	1
byte at 403 int ReadB()	1
byte at 400, last byte	1
byte at 399 int b;	1
byte longer in 64 bit	1
parts of the code in	2
parts of the code that	2
parts of the code can	1
parts of the code have	1
parts of the code where	1
parts of the code 16	1
parts of the code could	1
parts of the program of	1
parts of the program to	1
parts of the program code	1
parts of the program have	1
parts of the program appear	1
parts of the floating point	1
parts of the software package	1
parts of the code. See	1
parts of the code. C#,	1
parts of the program. In	1
parts of the memory, depending	1
parts of a big program.	1
parts only. Critical pieces of	1
|| is true, then the	1
|| are evaluated in the	1
|| b with a |	1
|| i >= size) {	1
|| b; This is typically	1
|| b) a && !a	1
|| true = true a	1
|| false = a a	1
|| !a = true a	1
|| expression. Assume, for example,	1
|| Day == Wednesday ||	1
|| Day == Friday) {	1
|| (a&&c) = a&&(b||c) !a	1
|| (a&&c) || (a&&b&&c) =	1
|| (a&&b&&c) = a&&(b||c) (a&&!b)	1
|| (a&&b&&c) = a&&b (a&&b)	1
|| (!a&&c) = a ?	1
|| (!a&&c) || (b&&c) =	1
|| b)) even though the	1
|| defined(__GNUC__) // 32-bit Linux,	1
|| (b&&c) = a ?	1
|| (!a&&b) = a XOR	1
> and >= operators). The	1
> b / c) 139	1
> b ? a :	2
> 0; i--) *(p++) |=	1
> 0 is true, and	1
> 0 ? c +	2
> 256 && SIZE %	1
> y && z !=	1
> 0, c + 2,	2
> b) But beware of	1
> 0) { // Make	1
> 0) ? (cc[i] +	1
> v.f if both positive	1
> largest_abs) { largest_abs =	1
> abs(v.f) } The multiplication	1
> -b to a <	1
> 1.0) { ... Here,	1
> v.i * 2) {	1
> v.i) { // u.f	1
types of a specific size.	1
types of floating point registers	1
types of floating point operations	1
types of floating point instructions.	1
types of elements is known	1
types of expressions and other	1
types of graphics cards, etc.	1
types of variables. Move the	1
types of expressions, but no	1
types to integers of the	1
types The return type of	1
types or strings of different	1
types or sizes? It is	1
types with the same template.	1
types because the CPU has	1
types such as int, float,	1
types cannot point to the	2
types Unfortunately, the way of	1
types (See Sutter: A Pragmatic	1
types available. declaration size, bits	1
types .............................................................................................. 50 7.17 Structures	1
expressions and other compilers can	1
expressions and operators. Make a	1
expressions for every element in	1
expressions that can be reduced.	1
expressions are less susceptible to	1
expressions or more complex integer	1
expressions on seven different compilers.	1
expressions as arguments while pointers	1
expressions than on floating point	1
expressions than floating point expressions,	1
expressions may have undesired effects.	1
expressions may occur as a	1
expressions when not selected. Compiler	1
expressions using the fundamental laws	1
expressions also occur quite often	1
expressions where operands have mixed	1
expressions rather than Boolean expressions.	1
expressions (see page 72). The	1
expressions like -(-a) very often,	1
expressions Automatic vectorization Devirtualization ---x-----	1
expressions Induction variables for float	1
expressions (except for the <,	1
difficult to get reproducible results.	1
difficult to find the right	1
difficult to find elsewhere. Faster	1
difficult to predict which compiler	1
difficult to predict whether the	1
difficult to implement the many	1
difficult to implement in a	1
difficult to measure exactly what	1
difficult to debug and maintain.	1
difficult to maintain. If the	1
difficult to maintain. Any specific	1
difficult to maintain. And it	1
difficult to understand and therefore	1
difficult to use, incompatible or	1
difficult to read. It is	1
difficult to read. If a	1
difficult to diagnose. It is	1
difficult for the compiler to	2
difficult for the CPU dispatcher	1
difficult for the programmer to	1
difficult cases like these, it	1
set. The most compatible way	1
set. The following example shows	1
set. The examples on page	1
set. The main advantage of	1
set. The newer instruction sets	1
set. The preprocessing macro INSTRSET	1
set. This instruction set was	1
set. A CPU dispatcher then	1
set. It is rarely worth	1
set. If the CPU brand	1
set. If the cache always	1
set. If you are including	1
set. These new instructions can	1
set. Therefore, you only need	1
set. Make two or more	1
set. Do not use lookup	1
set. 120 However, there are	1
set. Aligning data Loading data	1
set. 13.6 CPU dispatching in	1
set. More complicated cases cannot	1
set. Neither can you assume	1
set. High precision math. Libraries	1
instead of the most common	1
instead of the Boolean operators	1
instead of the usual object	1
instead of a template parameter.	1
instead of a macro. If	1
instead of functions A macro	1
instead of using exception handling	1
instead of user input in	1
instead of virtual functions. The	1
instead of main memory. A	1
instead of bool in order	1
instead of copying it Use	1
instead of calculating the value	1
instead of (or in addition	1
instead of j as index	1
instead of truncation and make	1
instead of pointers, by initializing	1
instead of int. A short	1
instead of truncation. This is	1
instead of double, then sizeof(S1)	1
instead of if. This is	1
instead of -fpic. This will	1
compilers. The code is inlined	1
compilers. The advantage of using	1
compilers. The results are listed	1
compilers. // It will look	1
compilers. // Example 14.19 static	1
compilers. This function is OS	1
compilers. This includes the libraries	1
compilers. If exception handling is	1
compilers. Intel C++ compiler (parallel	1
compilers. See www.openmp.org and the	1
compilers. Some compilers have a	1
compilers. Use automatic parallelization. The	1
compilers. #include <excpt.h> #include <float.h>	1
compilers. We want to vectorize	1
compilers. Several other programming languages	1
compilers. Dispatch at load time.	1
compilers. Fastcall is not needed	1
compilers. 2.5 Choice of compiler	1
compilers. 8.3 Obstacles to optimization	1
compilers. Wikipedia article on compiler	1
compilers. (The PGI compiler supports	1
compilers. Mixing object files from	1
transferred to the function. In	1
transferred in registers by default	1
transferred in registers rather than	4
transferred in registers anyway. Pure	1
transferred in registers (6 integer	1
transferred in registers (8 float	1
transferred in registers. 64-bit Unix	1
transferred in registers, regardless of	1
transferred in registers, whereas 64-bit	1
transferred in registers, totaling up	1
transferred by value in most	1
transferred on the stack in	1
transferred on the stack at	1
transferred as an implicit parameter	1
transferred as pointers unless they	1
transferred as machine code to	1
transferred from one function to	1
transferred from one auto_ptr to	1
transferred at runtime from the	1
longer in 64 bit mode	1
longer than a few lines	1
longer than a few lines.	1
longer than needed in order	1
longer time to call a	1
longer time in the unit-test	1
longer time than addition and	1
longer time than addition, subtraction	2
longer time than rounding unless	1
longer time than normally. There	1
longer time slices. This will	1
longer used and searching for	1
longer size by extending the	1
longer time. It is possible	1
longer time. It is faster	1
longer time. It can therefore	1
longer time. Integer multiplication takes	1
longer used. A smart pointer	1
longer used. It is important	1
longer response times for user	1
longer loop- carried dependency chain	1
after the program is terminated	1
after the loop if the	1
after the pointer p has	1
after the 64-bit vector operations	1
after the value of the	1
after the test loop. The	1
after the last member. This	1
after the piece of code	1
after it has been deallocated.	2
after this statement so that	1
after all objects have been	2
after all elements have been	1
after each of the most	1
after each time slice are	1
after they have put the	1
after debugging if required for	1
after executing the critical code.	1
after executing a critical piece	1
after jumping out of a	1
after exceptions: while (i <	1
read the time before and	1
read the value of the	1
read the value of seconds	1
read the performance monitor counters	1
read and write configuration files	1
read and understand compiler-generated assembly	1
read and written back. The	1
read or write it in	1
read or write less than	1
read this first manual. The	1
read from the same or	1
read from a table in	1
read from memory address a	1
read from different addresses with	1
read from 0x4700. Reading again	1
read because the write causes	1
read one or more performance	1
read into one of the	1
read before p is incremented.	1
read operations into two 128-bit	1
read about in my blog.	1
read four elements of b	1
give the compiler additional information	1
give the variable two names,	1
give the execution time when	1
give the result 100 rather	1
give the result -56 rather	1
give the full information about	1
give the 124 necessary information	1
give a CPU of unknown	1
give a considerable improvement in	1
give it a pointer or	1
give you access to all	1
give each thread its own	1
give some indication of which	1
give overflow and negative inputs	1
give higher priority to one	1
give almost identical performance for	1
give inconsistent results if the	1
give annoyingly long and irregular	1
give misleading results or fail	1
give -2.0 55 In this	1
give infinity. A typical implementation	1
Each of the following methods	1
Each function call statement occupies	1
Each code version is implemented	2
Each compiler does some things	1
Each time a new object	1
Each cache line can hold	1
Each cache line has to	1
Each object is allocated separately.	1
Each type has advantages and	1
Each element in a linked	1
Each element matrix[r][c] below the	1
Each thread can then run	1
Each thread will get time	1
Each thread has its own	1
Each thread should then handle	1
Each line covers 64 consecutive	1
Each dependency chain has a	1
Each graphics operation in the	1
Each instance of a polymorphic	1
Each 128-bit operation was split	1
becomes the same as if	1
becomes a little more complicated	1
becomes a problem. If the	1
becomes more efficient when there	1
becomes more fragmented when the	1
becomes more readable when you	1
becomes faster and that threads	1
becomes bigger if there is	1
becomes smaller if there is	1
becomes easier if we use	1
becomes invalid if a thread	1
becomes invalid as soon as	1
becomes inefficient. There is a	1
becomes fragmented when objects of	1
becomes fragmented thanks to the	1
becomes simpler because it needs	1
becomes inconsistent and sometimes unacceptably	1
becomes full. This may require	1
becomes noticeable. The following example	1
becomes contiguous. The code becomes	1
becomes bulky and difficult to	1
aligned to an address divisible	1
aligned // Structure of 4	1
aligned or the __assume_aligned directive	1
aligned or not. The loop	1
aligned or not. See page	1
aligned by the vector size	1
aligned by at least the	1
aligned by 8 rather than	1
aligned by 32 and the	1
aligned by 16, i.e. stored	2
aligned at round addresses. Especially	1
aligned integer vector from array	1
aligned integer vector into array	1
aligned arrays with vector access.	1
aligned arrays Alignd ( short	1
aligned operands Intel Core 2	1
aligned operands AMD Opteron K8	1
aligned #pragma vector aligned #pragma	1
aligned #pragma vector aligned Assume	1
aligned Assume pointer not aliased	1
directives and declare all functions	1
directives and keywords relevant to	1
directives for parallel processing. Scott	1
directives for multi-core processing. Visual	1
directives that select the best	1
directives are useful for supporting	1
directives are supported by Microsoft,	1
directives are equivalent to const	1
directives are compiler-specific. You cannot	1
directives when used as macros	1
directives which are used for	1
directives do not always work.	1
directives 32 bit code 64	1
directives Some compilers have many	1
directives work on the Intel	1
directives work on the PathScale	1
directives around it so that	1
directives .............................................................................................. 82 8.7 Checking	1
directives ......................................................................................... 65 7.33 Namespaces...........................................................................................................	1
directives Preprocessing directives (everything that	1
directives (everything that begins with	1
requires the loading of modules	1
requires a compiler with C++0x	1
requires a big floating point	1
requires a CPU- specific profiler.	1
requires a division, which is	1
requires that the background job	1
requires that you can predict	1
requires that you analyze all	1
requires that all software be	1
requires an extra register to	1
requires only an integer comparison,	1
requires only SSE). The YMM	1
requires no modification of the	1
requires static linking (e.g. option	1
requires several layers of abstraction	1
requires support from both compiler,	1
requires alignment to addresses divisible	1
requires OS support and is	1
requires log on with a	1
requires compilation or interpretation on	1
requires n-1 multiplications, which can	1
optimizations is that it may	1
optimizations of the whole program.	1
optimizations of a variable for	1
optimizations in different C++ compilers	1
optimizations in some cases, there	1
optimizations in precompiled code. The	1
optimizations that it is relevant	1
optimizations that we want it	1
optimizations that rely on the	1
optimizations with option -Wstrict-overflow=2, or	1
optimizations on the variable. This	1
optimizations on that variable. The	1
optimizations you can expect a	1
optimizations you have to do	1
optimizations when interprocedural optimization is	1
optimizations such as function inlining.	1
optimizations such as common subexpression	1
optimizations possible because the compiler	1
optimizations across function calls. Example:	1
optimizations across modules (See page	1
optimizations automatically, but as long	1
graphics function is time consuming	1
graphics function that draws a	1
graphics function libraries and drivers	1
graphics on the screen. However,	1
graphics library or API function	1
graphics objects in computer games	1
graphics application is preferably implemented	1
graphics framework is used. The	1
graphics framework between the operating	1
graphics processors. 5 Programmable logic	1
graphics operation in the application	1
graphics calculations. In some cases	1
graphics processing unit for other	1
graphics processing unit. Various graphics	1
graphics processing unit, either on	1
graphics frameworks, interpreters, just-in-time compilers,	1
graphics card or integrated in	1
graphics accelerator card for other	1
graphics accelerator card. Some systems	1
graphics coprocessor or graphics accelerator	1
graphics cards, etc. Use an	1
public and static data. 148	1
public data can be overridden	1
public data object: (1) get	1
public functions and data in	1
public functions and public data	1
public variable in a shared	1
public variable where it expects	1
public variables in a 64-bit	1
public variables go through the	1
public variables. All global variables	1
public CHello { public: virtual	2
public C0 { public: virtual	1
public CParent<CChild1> { has the	1
public CParent<CChild1> { public: void	1
public CGrandParent { public: void	1
public B2 { public: int	1
public B1 { public: B2	1
public CParent<CChild2> { public: void	1
public B1, public B2 {	1
public symbols, but this feature	1
public: int c; }; Replace	1
public: int a; int b;	1
public: int a[100]; // 400	1
public: float x, y; //	1
public: static double p(double x)	4
public: void Disp() { cout	2
public: void Hello() { cout	1
public: void NotPolymorphic(); virtual void	1
public: void NotPolymorphic(); }; //	1
public: virtual void Disp() {	2
public: virtual void f(); };	2
public: ... ~C1(); }; void	1
public: B2 b2; int c;	1
public: c1() : x(0) {};	1
public: SafeArray() { memset(a, 0,	1
framework is used. The operating	1
framework and the Java virtual	1
framework and compile the program	1
framework in its API. In	1
framework for interpreting or compiling	1
framework that must be loaded	1
framework that uses few resources.	1
framework are based on just-in-time	1
framework can consume a lot	1
framework as well as directly	1
framework may use more resources	1
framework should definitely be avoided	1
framework between the operating system	1
framework must be a compromise	1
framework typically uses much more	1
framework Most of the code	1
framework based on intermediate code	1
framework sometimes have unacceptably long	1
framework still consumes a lot	1
framework itself, during installation of	1
framework requiring many files to	1
look in my crystal ball	1
look at the function bodies	1
look at the code generated	2
look at the example of	1
look at the possible alternatives	1
look at the assembly output	1
look at the "worst case"	1
look at to see if	1
look at CPU brand names	1
look at what happens inside	1
look different in other compilers.	1
look up the function address	1
look up the address of	2
look up in a virtual	1
look like and how you	1
look like this: // Example	3
look clumsy and tedious. The	1
linking is that the linker	1
linking is used. The advantages	1
linking is used. Dynamic linking	1
linking is used, but not	1
linking is preferable for speed-critical	1
linking to assembly language modules	1
linking and by not using	1
linking and position-independent code Function	1
linking and position-independent code .......................................................	1
linking for any library functions	1
linking makes the entire library	1
linking makes it necessary to	1
linking cannot be avoided, there	1
linking rather than dynamic linking	1
linking works differently. The link	1
linking are: Static linking includes	1
linking are: 146 Multiple applications	1
linking (e.g. option /MT). In	1
linking includes only the part	1
linking (remove unreferen- ced functions)	1
linking (multithreaded) /arch:AVX /openmp /MT	1
Many of the advices may	1
Many of these directives are	1
Many function libraries are available	1
Many CPU dispatchers are designed	1
Many compilers have an option	1
Many Intel library functions have	1
Many software programs automatically download	1
Many software applications use a	1
Many software applications need better	1
Many 32-bit systems allow you	1
Many optimization options are incompatible	1
Many libraries for special purposes	1
Many processors can calculate a	1
Many CPUs have a built-in	1
Many copy protection schemes are	1
Many programs spend most of	1
Many containers use linked lists.	1
Many algebraic reductions are not	1
Many programmers have discovered that	1
Many advices on optimization of	1
Many services that run in	1
processors. The cache line size	1
processors. The performance is inferior	1
processors. The following example shows	1
processors. The application program will	1
processors. A non-Intel processor makes	1
processors. It is possible to	1
processors. In a C++ program,	1
processors. There is no way	1
processors. There are various methods	1
processors. See page 130 for	1
processors. AMD processors and earlier	1
processors. Many processors can calculate	1
processors. 5 Programmable logic devices	1
processors. Supports all x86 and	1
processors. On many processors, a	1
processors. Other brands or models	1
processors. Explicit CPU dispatching works	1
processors. Consider the time it	1
processors. Hyperthreading is Intel's term	1
processors. Henry S. Warren, Jr.:	1
processors. Details about instruction latencies	1
actually be better than RISC	1
actually more than 250 ms.	1
actually has to wait for	1
actually called in a single	1
actually making a pointer. The	1
actually doing something on these	1
actually add extra code to	1
actually able to reorder instructions	1
actually quite powerful and may	1
actually quite convenient. It is	1
actually used. No program should	1
actually needed by the application,	1
actually reduce speed if the	1
actually points to an object	1
actually is. This above code	1
actually increase the speed or	1
actually reducing example 15.1d to	1
actually adds 16 to the	1
actually hidden behind the C++	1
actually implies more than it	1
actually throws an exception. Therefore,	1
Intel, even if the processor	1
Intel, Gnu and PathScale compilers.	2
Intel, Gnu and Clang compilers.	1
Intel, AMD and VIA CPUs.	1
Intel, AMD and VIA including	1
Intel, AMD and VIA processors,	1
Intel, AMD and VIA CPUs").	3
Intel, AMD and VIA CPUs"	3
Intel, AMD and VIA CPUs:	1
Intel, AMD and VIA CPUs".	2
Intel, AMD or VIA processor	1
Intel, Microsoft and PathScale compilers.	1
Intel, Microsoft Intel, Microsoft, Gnu,	1
Intel, PathScale and Gnu compilers.	1
Intel, Microsoft, Gnu, Clang Supported	1
linked function is not resolved	1
linked from static libraries (.lib	1
linked into the same executable.	1
linked into projects made with	1
linked library functions. 9.4 Variables	1
linked libraries or shared objects),	1
linked list is a convenient	1
linked list is less efficient	1
linked list or with an	1
linked list has its own	1
linked list takes more time	1
linked list (see page 93).	1
linked together in the second	1
linked together with C or	1
linked either as a runtime	1
linked lists in most cases.	1
linked list. Each element in	1
linked list. Do not use	1
linked list. 94 Are objects	1
linked together. The link order	1
linked lists. A linked list	1
x; for (i = 0;	2
x; for (x = 0;	1
x; // x^2 float x4	1
x; This can be improved	1
x; This makes sure that	1
x; int A, B, C;	2
x; x *= x; n	1
x; } }; // Full	1
x; float sum = 1.f;	1
x; const double A2 =	1
x; ... } void F0()	1
x; n >>= 1; }	1
x; public: c1() : x(0)	1
x; Here, the code must	1
x; Note the difference between	1
x; __asm fistp dword ptr	1
x; nfac *= n+1; //	1
x; *(int*)&x |= 0x80000000; //	1
x; x.f = 2.0f; x.i	1
microprocessors is obtained by using	1
microprocessors is split between several	1
microprocessors is lost. This dilemma	1
microprocessors and operating systems (but	1
microprocessors in the x86 family	2
microprocessors that do not have	1
microprocessors are not optimized for	1
microprocessors are using advanced algorithms	1
microprocessors are very similar thanks	1
microprocessors are able to run	1
microprocessors are able to automatically	1
microprocessors are constructed. All non-static	1
microprocessors can do out-of-order execution.	1
microprocessors have vector instructions that	1
microprocessors have no native floating	1
microprocessors when an operand is	1
microprocessors from Intel, AMD and	1
microprocessors without any of these	1
microprocessors work. The recommendations are	1
microprocessors have. In some cases	1
load the dynamic linker. The	1
load the structure y into	1
load the framework and compile	1
load the entire 64 or	1
load is high and decreased	1
load is low in order	1
load a program than to	1
load a new cache line	1
load time can be annoyingly	1
load more than one instance	1
load all the modules of	1
load into memory even when	1
load time. The program uses	1
load time. Shared objects in	1
load several files when the	1
load aligned integer vector from	1
load unaligned integer vector from	3
load address. If this address	1
load address. Relocation is done	1
control the way member pointers	1
control the addresses of dynamically	1
control it compares the array	1
control no yes License license	1
control branch is mispredicted only	1
control branch is executed 10	1
control branch depends on the	1
control branch depends on calculations	1
control branch ahead of time	1
control instructions than the ones	1
control statement several iterations ahead.	1
control condition is a simple	1
control condition The most efficient	1
control instructions. There are other	1
control branch. There is nothing	1
control branch. See the preceding	1
control .............................................................................................. 99 10 Multithreading..............................................................................................................	1
control Microprocessors with the SSE	1
control condition: // Example 7.32b	1
control tool. 7 The efficiency	1
assume the worst possible case	1
assume is optimized. We cannot	1
assume that the compiler takes	1
assume that the value of	1
assume that the type conversion	1
assume that the next processor	1
assume that the overall computation	1
assume that it doesn't occur.	1
assume that an optimizing compiler	1
assume that floating point comparisons	1
assume that b is always	1
assume that there is hardly	1
assume that there are no	1
assume that these integer operations	1
assume that model N+1 supports	1
assume that model N-1 is	1
assume that seconds remains zero	1
assume that F1 will never	1
assume that *p+2 is a	1
assume no pointer aliasing (see	1
100; // Array of 100	1
100; int i; float a[size],	1
100; int matrix[NUMROWS][NUMCOLUMNS]; int row,	1
100; i += 2) {	1
100; i += 4) {	1
100; float list[size], sum =	1
100; float list[size], sum1 =	1
100; float list[ARRAYSIZE]; if (i	1
100; i++) { a[i] =	6
100; i++) { list[i].a =	1
100; i++) sum += a[i];	1
100; i++) matrix[FuncRow(i)][FuncCol(i)] += x;	1
100; S1 list[size]; int i,	1
100; x++) { Table[x] =	2
numbers is less efficient than	1
numbers is inefficient. Division, square	1
numbers of type short int	1
numbers of type int. Therefore,	1
numbers to integers use truncation	1
numbers and integers Conversion from	1
numbers and integers ................................... 141	1
numbers in case of underflow:	1
numbers in b[i] and c[i]	1
numbers in question without generating	1
numbers are not always sequential,	1
numbers are stored in a	1
numbers are powers of 2.	1
numbers can be calculated as	1
numbers as a parameter to	1
numbers at a time packed	1
numbers because all the numbers	1
numbers simply by comparing them	1
numbers form a logical sequence.	1
numbers mean good performance). Aligned	1
platform is likely to require	1
platform is obviously influenced by	1
platform and operating system. See	1
platform The choice of hardware	1
platform for a given task	1
platform with a graphics coprocessor	1
platform with an Intel, AMD	1
platform not _WIN64 not _WIN64	1
platform has become less important	1
platform n.a. __unix__ __linux__ __unix__	1
platform software development kit (SDK	1
platform _WIN64 _LP64 _WIN64 _LP64	1
platform ....................................................................................... 5 2.2 Choice	1
platform _M_IX86 and _WIN64 _M_X64	1
platform _M_IX86 _M_IX86 x86-64 platform	1
platform _WIN32 _WIN32 Linux platform	1
platform ........................................................................................... 5 2.1 Choice	1
platform 2.1 Choice of hardware	1
platform __GNUC__ and not not	1
platform independence, and easy development.	1
later and the work it	1
later in the program flow.	1
later // Header file for	1
later with code compiled without	1
later instruction set is enabled.	2
later instruction set is enabled	1
later instruction set is specified.	1
later instruction set if possible.	1
later instruction set. 120 However,	1
later instruction sets. Supports only	1
later instruction sets. Vector operations	1
later instruction sets. Does not	1
later Intel processors. AMD processors	1
later reads from addresses 0x2F00,	1
later deleted by another function	1
later ported to another platform.	1
later maintenance. However, this is	1
later discovers that it has	1
later __svml_expf4 __svml_exp2 Intel SVML	1
together and tested it. The	1
together in the second step	1
together in an object of	2
together in one big memory	1
together in order to minimize	1
together The code cache works	1
together are also stored together	1
together are stored near each	1
together if they are members	1
together with C or C++	1
together on the stack. String	1
together should be stored together	3
together should be stored together......................................	1
together into a single container,	1
together near each other in	1
together Cache misses are very	1
together ...................................... 88 9.5 Alignment	1
dispatch is made to the	1
dispatch to virtual member functions	1
dispatch by CPU brand. The	1
dispatch on first call method	1
dispatch on every call method.	1
dispatch branch of the latter	1
dispatch branches are scattered everywhere	1
dispatch mechanism is rarely enough	1
dispatch mechanism in the Intel	2
dispatch mechanism that treats different	1
dispatch mechanism can be implemented	1
dispatch mechanism even when it	1
dispatch Automatic vectorization Automatic paralleli-	1
dispatch process. This can be	1
dispatch methods. The most common	1
dispatch strategies........................................................................................ 122 13.2 Model-specific	1
dispatch strategies It is quite	1
dispatch decision at different times:	1
dispatch mechanisms, and some of	1
calling the function for the	1
calling the function directly if	1
calling the library function. 12.2	1
calling the intrinsic function _mm256_zeroupper()	1
calling a simple function with	1
calling function can use for	1
calling function must then check	1
calling more efficient in 64-bit	1
calling from other applications such	1
calling program is more manageable	1
calling any necessary destructors after	1
calling method in 32-bit mode	1
calling conventions for functions that	1
calling conventions are different. 64-bit	1
calling itself in order to	1
calling conventions. The dot in	1
calling conventions. Optimizes reasonably well.	1
calling conventions. FreeBSD and Open	1
calling vector::reserve with a prediction	1
calling WritePrivateProfileString, which opens and	1
your code is likely to	1
your code is running in	1
your compiler for restrictions on	1
your program to turn off	1
your program before and after	1
your program exception safe. In	1
your program relies on exception	1
your optimization effort is concentrated	2
your programming questions to me.	1
your programming questions if you	1
your application then you should	1
your own error handling system	1
your own error message function.	1
your own container classes or	1
your own profiling instruments in	1
your own error-handling function that	1
your program, you will be	1
your software. A negative list,	1
your modifications actually increase the	1
own function library made for	1
own memory block and a	1
own data structure and then	1
own CPU core. There are	1
own set of performance monitoring	1
own address through a function	1
own error handling system instead	1
own error message function. The	1
own allocated memory block. A	1
own container classes or modify	1
own block of data. This	1
own stack. Alternatively, you may	1
own graphical user interfaces from	1
own profiling instruments in the	1
own IDE. It is intended	1
own research, not on publicly	1
own research, I have developed	1
own initiative whenever it is	1
own error-handling function that simply	1
own caller, and so on.	1
declared in the function in	1
declared in the thread have	1
declared in a class are	1
declared in a C++ program.	1
declared or created it will	1
declared by specifying the type	1
declared with the static keyword,	1
declared with #define is certain	1
declared as constant references accept	1
declared const in order to	1
declared inside the function in	1
declared inside the function they	1
declared inside a function are	2
declared inside a class are	1
declared inside a class Variables	1
declared outside of any function	1
declared whenever an instance of	1
declared volatile then an optimizing	1
declared volatile. This prevents the	1
XMM and 256-bit YMM registers.	1
XMM vector registers are available	1
XMM register can be organized	1
XMM registers to test 16	1
XMM registers for floating point	1
XMM registers are supported by	1
XMM registers are used. a	1
XMM registers are used. See	2
XMM registers are used, while	1
XMM registers are extended to	1
XMM registers can benefit from	1
XMM registers (see page 105).	1
XMM vectors must be aligned	1
XMM registers. Example: // Example	1
XMM register. In example 12.2,	1
XMM (vector) reductions: Common subexpression	1
XMM (vector) reductions: a+b=b+a, a*b=b*a	1
XMM (vector) reductions: ~(~a) =	1
XMM registers; see page 122.	1
second by another thread void	1
second way is to set	1
second result is stored in	1
second application that uses a	1
second induction variable (eax) which	1
second operand is not evaluated	1
second operand is not evaluated,	1
second operand is evaluated only	1
second operand is valid. For	1
second thing we notice is	1
second generation of processors that	1
second generation class gets information	1
second generation class (CParent<>) contains	1
second step of interpretation or	1
second step where the compilation	1
second step. The intermediate file	1
second sum, then the first	1
second source, and the availability	1
second operand. Likewise, if the	1
second sub-vector before it has	1
shows the same code as	1
shows the principle for a	1
shows a code that current	1
shows a way to work	1
shows that a particular application	1
shows that it takes 40%	1
shows an example of how	1
shows this calculation implemented with	1
shows which reductions the compilers	1
shows first the runtime polymorphism:	1
shows how to use the	1
shows how to make the	1
shows how to make a	1
shows how to take advantage	1
shows how to align arrays.	1
shows how to implement the	1
shows how you can make	1
shows how this can be	1
shows whether the different compilers	1
shows what the assembly output	1
interface is not in the	1
interface is obtained by dropping	1
interface to the calling program	1
interface to the rest of	1
interface and use a console	1
interface and other system- specific	1
interface can use a lot	1
interface than on the essential	1
interface library for Windows and	1
interface library can be linked	1
interface library may be bigger	1
interface elements that come with	1
interface framework must be a	1
interface framework Most of the	1
interface calls. The usability may	1
interface frameworks are available for	1
interface etc., can be implemented	1
interface frameworks. This is often	1
interface framework........................................................................... 14 2.8 Overcoming	1
interface (OnIdle in Windows MFC).	1
improve the performance if the	1
improve the performance by organizing	1
improve the performance by 5-10%	1
improve the performance significantly simply	1
improve the performance dramatically by	1
improve the performance somewhat. The	1
improve the code. The third	1
improve the execution speed in	1
improve the speed of functions	1
improve the performance, it is	1
improve the possibilities for optimization.	1
improve this by writing: 103	1
improve cache efficiency, then you	1
improve performance in some cases.	1
improve speed without jeopardizing safety,	1
improve optimizations in some cases,	1
improve efficiency by using rounding	1
improve performance. It is useful	1
improve search times 24 dramatically	1
improve efficiency. These are available	1
higher for single precision than	1
higher for shared_ptr than for	1
higher than the subsequent counts.	1
higher than normal. This happens	1
higher instruction set is supported.	1
higher instruction set than the	1
higher instruction set. Therefore, you	1
higher instruction set. More complicated	1
higher instruction set, but possibly	1
higher number is not necessarily	1
higher clock frequency than other	1
higher address which can't be	1
higher priority to one thread	1
higher priority than code generality.	1
higher level of optimization can	1
higher risk that the programmer	1
higher bits. There is no	1
higher speed. In the same	1
higher due to poor documentation	1
higher resolution can be obtained	1
bigger and more complex, that	1
bigger if there is more	1
bigger than the cache then	1
bigger than the cache size.	1
bigger than the application itself	1
bigger than the level-2 cache	1
bigger than the level-1 data	1
bigger than the destination array.	1
bigger than it actually is.	1
bigger than 2 GB. When	1
bigger than 16 bytes should	1
bigger than 127 bytes is	1
bigger memory block is allocated	1
bigger memory block and copy	1
bigger memory block. This is	1
bigger vector registers. The vector	1
bigger software packages and who	1
bigger systems. The smaller the	1
bigger vectors do not have	1
bigger segments (32-bit or 64-bit	1
vectors of two double precision	1
vectors of 64 bits total	1
vectors of four floats F32vec4	1
vectors of eight 16-bit integers.	1
vectors of inte- ger or	1
vectors and matrixes. Algorithms that	1
vectors are preferably aligned by	1
vectors if the code contains	1
vectors then you have to	1
vectors do not have this	1
vectors into C++ classes and	1
vectors There are various function	1
vectors SSE2 128 bit integer	1
vectors must be aligned by	1
vectors requires alignment to addresses	1
vectors AVX2 256 bit integer	1
vectors SSE3 horizontal add, etc.	1
vectors RGB image data have	1
vectors ....................................................... 120 12.10 Conclusion	1
vectors FMA3 floating point multiply-and-add	1
Floating point variables and operators	2
Floating point variables use a	1
Floating point variables do not	1
Floating point operations are done	1
Floating point calculations usually take	1
Floating point overflow has occurred.	1
Floating point precision conversion Conversions	1
Floating point parameters are not	1
Floating point division by a	1
Floating point division takes much	1
Floating point division Floating point	1
Floating point division ........................................................................................... 139	1
Floating point induction variables Compilers	1
Floating point addition takes 3	1
Floating point numbers are stored	1
Floating point XMM (vector) reductions:	1
Floating point algebra reductions: a+b=b+a	1
Floating point comparisons are slow	1
Floating point comparisons are inefficient	1
AVX2 is supported in such	1
AVX2 and all three versions	1
AVX2 // specific version of	1
AVX2 int 32 8 256	1
AVX2 instruction set also allows	1
AVX2 instruction set gives the	1
AVX2 float 32 8 256	1
AVX2 long long 64 4	1
AVX2 short int 16 16	1
AVX2 256 bit integer vectors	1
AVX2 Table 12.3. Intrinsic functions	1
AVX2 Mathematical vector function libraries.	1
AVX2 _mm256_i64gather_pd unlimited 8 bytes	1
AVX2 _mm_i64gather_pd unlimited 8 bytes	1
AVX2 _mm256_i32gather_epi32 unlimited 4 bytes	1
AVX2 _mm_i32gather_ps unlimited 4 bytes	1
AVX2 _mm256_i64gather_epi32 unlimited 8 bytes	1
AVX2 _mm_i32gather_epi32 unlimited 4 bytes	1
AVX2 _mm_i64gather_epi32 unlimited 8 bytes	1
AVX2 _mm256_i32gather_ps unlimited 4 bytes	1
piece of code is fastest	1
piece of code to test	1
piece of code in multiple	1
piece of code in general.	1
piece of code that works	1
piece of code that produces	1
piece of code you want	1
piece of code then you	1
piece of code compiled with	1
piece of code once the	1
piece of memory inside the	1
piece of program code is	1
piece of software specifies the	1
piece of code. Each compiler	1
piece of code. Furthermore, most	1
piece of memory. See page	1
piece of CPU-intensive software is	1
piece in a function that	1
piece by piece in a	1
piece at a time because	1
divisible by the memory page	1
divisible by the vector size	2
divisible by the cache line	1
divisible by the size of	1
divisible by the number of	1
divisible by the unroll factor.	3
divisible by the 107 number	1
divisible by vector size. Unpredictable	1
divisible by 8 in order	1
divisible by 16 (see below).	1
divisible by 16. In example	1
divisible by 16. You can	1
divisible by 16. Library versions	1
divisible by 16. Alignment of	1
divisible by 8. The size	1
divisible by 8. There are	1
divisible by TILESIZE // Loop	1
<< and | operations than	1
<< 1; } }; class	2
<< 2; } }; void	2
<< list[i] << endl; //	1
<< 4, anda * 17is	1
<< 4) + a. You	1
<< 4) | ((C &	1
<< 4) | (C <<	1
<< "Hello "; // call	1
<< "Hello "; Disp(); class	1
<< 5. If columns had	1
<< "Error: Index out of	2
<< 23; // add n	1
<< 6); Or, if protection	1
<< x.f; // will give	1
<< endl; // Output array	1
Here, the code must compute	1
Here, the compiler can replace	1
Here, the compiler has no	1
Here, the value that is	1
Here, the address of matrix[j][0]	1
Here, the constant 3.5 will	1
Here, the Gnu compiler will	1
Here, it is necessary to	1
Here, you can also find	1
Here, you should be prepared	1
Here, you cannot swap the	1
Here, each value xn is	1
Here, there are 6 unused	1
Here, we have inserted UnusedFiller	1
Here, I have used char	1
Here, I have AND'ed b	1
Here, / means integer division	1
Here, y will get the	1
Here, log(2.0) is only calculated	1
x86 and x86-64 platforms. AMD	1
x86 and x86-64 platforms. Comparison	1
x86 and ARM platforms and	1
x86 instruction set is the	1
x86 instruction set has no	1
x86 instruction set where the	1
x86 processors are used in	1
x86 CPUs can execute instructions	1
x86 platform _M_IX86 _M_IX86 x86-64	1
x86 CPUs. However, a software	1
x86 platforms. This library has	1
x86 platforms. Microsoft, Intel, Gnu	1
x86 platforms. 3. The microarchitecture	1
x86 platforms. Works well with	1
x86 platforms (Windows, Linux, BSD,	1
x86 family of microprocessors from	1
x86 family can run in	1
x86 family have two different	1
x86 systems). 42 If you	1
process is used for all	1
process is used when it	1
process is known to be	1
process of dynamic allocation and	1
process to take more than	1
process and software engineering principles	1
process can proceed unattended. Uninstallation	1
process can influence the performance	1
process or by an executable	1
process or thread does not	1
process may take more than	1
process when compiled without -fpic	1
process because the microprocessor has	1
process which is difficult to	1
process should always use standardized	1
process should run in a	1
process There is a considerable	1
process where the main feedback	1
process running when it is	1
binary code and can be	1
binary data storage is that	1
binary value of i to	1
binary executable code. Most implementations	1
binary search for finding elements.	1
binary integer, and the fraction	1
binary representation is particularly tricky.	1
binary representation of N: #define	1
binary representation according to the	1
binary form than if the	1
binary tree or a hash	2
binary tree may be used	1
binary code). Supports 32-bit and	1
binary search, or even a	1
binary tree. Is searching needed	1
binary decimals of the fraction.	1
binary digits. The exponent is	1
binary trees, hash maps etc.	1
know the value of m	1
know in advance which of	1
know for sure whether the	1
know that a function is	1
know that a template class	1
know that double precision calculations	1
know that processor model N	1
know that standard library functions	1
know that u.f and v.f	1
know if this is possible	1
know how a cache is	1
know how to avoid them.	1
know how to recover in	1
know how this works, here's	1
know whether the largest vector	1
know what the compiler can	1
know what you are doing.	1
know what class of object	1
know about. Function inlining The	1
512 bits when the AVX512	1
512 bits (ZMM). Vector operations	1
512 matrix in my experiments.	1
512 matrix size causes misses	1
512 512 matrix in my	1
512 512 matrix size causes	1
512 512 2048 230.7 513	1
512 512 matrix. My experimental	1
512 512 378.7 168.5 513	1
512 AVX512 double 64 8	1
512 AVX512 float 32 16	1
512 AVX512 long long 64	1
512 AVX512 Table 12.1. Vector	1
512 kb / 8 =	1
512 2048 230.7 513 513	1
512 matrix. My experimental results	1
512 378.7 168.5 513 513	1
512 520 and leave the	1
512 kb, 8 ways. The	1
generate the value infinity, and	1
generate a new instance of	1
generate a store forwarding delay	1
generate a piece of code	1
generate a bit-mask: __m128i mask	2
generate an error message in	1
generate an assembly language output,	1
generate an overflow and give	1
generate an underflow and give	1
generate an interrupt, e.g. every	1
generate floating point underflow in	1
generate multiple versions of the	1
generate many branch mispredictions. Boolean	1
generate any extra code and	1
generate relative addresses in the	1
generate relocations in the code	1
generate interrupts at certain events,	1
generate -128, and subtracting 1	1
advantages of function inlining are:	1
advantages of each method, it	1
advantages of using the vector	1
advantages of using the register	1
advantages of using static linking	1
advantages of using pointers rather	1
advantages of using references rather	1
advantages of object oriented programming	1
advantages of C++ but is	1
advantages of dynamic memory allocation	1
advantages of dynamic linking are:	1
advantages of alloca over new	1
advantages and drawbacks of using	1
advantages and disadvantages. The original	1
advantages that can be obtained.	1
advantages that may improve the	1
advantages when it comes to	1
advantages over the disadvantages when	1
advantages over 32 bit systems:	1
r is the number of	1
r is a reference or	1
r is re-loaded from memory	1
r in Sum2 and Sum3.	1
r are transferred on the	1
r = r + 2;	1
r = 28. We take	1
r + 2; } These	1
r + i/2; } }	1
r < SIZE; r++) {	4
r ; unused label ;	1
r points to ; store	1
r points to. A reference	1
r points to. Now ebx	1
r ebx, eax ebx, 31	1
r places back in the	1
usually the order in which	1
usually not able to see	1
usually faster to transfer a	1
usually stored in the order	1
usually called in the copying	1
usually called before the program	1
usually take the same time	1
usually much faster to access	1
usually done in a loop	1
usually requires log on with	1
usually higher than the subsequent	1
usually predicted well if the	1
usually inlined if the inline	1
usually unroll a loop automatically	1
usually share the same cache,	1
usually included as part of	1
usually divided into three parts:	1
usually 32. In 64-bit systems	1
usually dealt with in assembly	1
results of the two AND	1
results of my experiment are	1
results in table 9.1 show	1
results in another array. The	1
results in RAM memory. This	1
results in a. This operation	1
results in meaningless event counts	1
results for branch mispredictions. The	1
results are always calculated with	1
results are listed in table	1
results are combined by some	1
results are summarized in table	1
results or fail completely because	1
results if the operands have	1
results as floating point. Use	1
results when applied to 32-bit	1
results should be saved in	1
results were as follows: Matrix	1
results printf("\n%2i %10I64i", i, timediff[i]);	1
b, and the elements are	1
b, c and d would	1
b, c; a = b	2
b, c; // Define biggest	1
b, c; // Roll out	1
b, c; b = (a+1)	1
b, c; ... // Call	2
b, c; x[0] = a;	1
b, temp; temp = b	1
b, c, d; a =	1
b, c, d; if (a	1
b, c, d; c =	1
b, c, d; }; void	1
b, c, temp; temp =	1
b, c, d, y; y	2
b, c, d, e, f,	1
storage is that it is	1
storage is inefficient because it	1
storage is determined where the	1
storage of static and global	1
storage of text strings in	1
storage and page 87 about	1
storage are explained on page	1
storage on the stack (see	1
storage A limited number of	1
storage should be avoided, if	1
storage order is opposite). 9.10	1
storage Most compilers can make	1
storage methods mentioned above. An	1
storage Variables and objects are	1
storage Variables that are declared	1
storage (e.g. PowerPC). We can	1
storage space. It should therefore	1
storage p. 28) The threads	1
storage principles are the same	1
old memory block into the	1
old data file in simple	1
old version of Intel's Math	1
old operating systems that do	1
old operating systems DOS and	1
old processors without the SSE2	1
old CPUs is not needed.	1
old block then become invalid.	1
old microprocessors that do not	1
old microprocessors without any of	1
old CPUs. The Pentium Pro	1
old computer with a slow	1
old Pentium 4, while all	1
old Pentium 4. The reason	1
old version. Updating mechanisms often	1
old C-style method of storing	1
old DOS compilers). The representation	1
old fashioned C style with	1
old fashioned C style as	1
reduce the integer expression -a	1
reduce the number of context	1
reduce the performance because the	1
reduce the problem by increasing	1
reduce a to the constant	1
reduce int x = 2	1
reduce this problem. The most	1
reduce this to: // Example	2
reduce other types of expressions,	1
reduce example 12.1b to 12.1a.	1
reduce any expression, but none	1
reduce some types of expressions	1
reduce simple algebraic expressions using	1
reduce speed if the bottleneck	1
reduce complicated algebraic expressions. For	1
reduce various algebraic expressions on	1
reduce them all. In the	1
reduce (a*b*c)+(c*b*a) to a*b*c*2. It	1
goes the same way is	1
goes the other way. A	1
goes to the user interface.	1
goes to the console or	1
goes to cache misses, branch	1
goes to actually doing something	1
goes to C0::f or C1::f.	1
goes in the // parent	1
goes from the leftmost column	1
goes one way most of	1
goes into sleep mode. See	1
goes many times one way,	1
goes faster if the data	1
goes up and down. Remember	1
goes through the following steps	1
goes through an import table	1
goes another way than last	1
goes automatically when the function	1
goes randomly one way or	1
union is a structure where	1
union is not a safe	1
union is not optimal because	1
union can be used for	1
union can use any of	1
union can also be used	1
union { double d; int	1
union { float f; int	7
union { float f; unsigned	1
union { 89 int a[1000];	1
union Bitfield { struct {	1
union {double d; unsigned int	1
union forces the variable to	1
0, b = 0, c,	1
0, c + 2, b	2
0, b; b = a	1
0, last byte at 1	1
0, last byte at 7	1
0, last byte at 399	1
0, c, d; c =	1
0, _EM_OVERFLOW); // _controlfp(0, _EM_OVERFLOW);	2
0, sum2 = 0; int	1
0, s3 = 0, sum;	1
0, s2 = 0, s3	1
0, sum; for (int i	1
0, (a&b) | (~a&c) |	1
0, s1 = 0, s2	1
0, sizeof(a)); // copy a	1
0, sizeof(a)); } int Size()	1
0, sizeof(list)); A multidimensional array	1
called. The compiler will store	1
called. The program is exception	1
called. The values are simply	1
called. The disadvantage of compiling	1
called. The safe way to	1
called. This is done by	1
called. This has the disadvantage	1
called. This method is illustrated	1
called. A considerable delay comes	1
called. It is recommended to	1
called. If virtual functions are	1
called. There is no need	1
called. You may declare the	1
called. I have added a	1
called. Example: // Example 8.25	1
called. Therefore, the dispatcher 128	1
called. Unfortunately, the syntax described	1
called. Lazy binding can be	1
called. 118 12.7 Mathematical functions	1
10 is an integer, so	1
10 - 20 clock cycles	1
10 - 20 clock cycles.	1
10 page 101 for further	1
10 double xpow10(double x) {	2
10 * 8 = 80.	1
10 clock cycles then it	1
10 clock cycles even if	1
10 clock cycles, depending on	1
10 elements were inserted, one	1
10 times rather than 20.	1
10 Gnu This is one	1
10 means that it can	1
10 s today, then it	1
10 ms for background jobs.	1
10 2.6 Choice of function	1
10 Multithreading The clock frequency	1
10 Multithreading.............................................................................................................. 101 10.1 Hyperthreading	1
based on the standard PC	1
based on the x86 family	1
based on the CPUID information	1
based on the past history	1
based on an interpreter which	1
based on which instruction sets	1
based on its family and	1
based on big runtime frameworks,	1
based on hardware identification. Such	1
based on intermediate code is	1
based on intermediate code and	1
based on complicated criteria or	1
based on what is most	1
based on compilers. Several other	1
based on my own research,	1
based on just-in-time compilation of	1
based on BSD, but the	1
based on hacks that violate	1
based mainly on my study	1
choose the compilers that are	1
choose the most often used	1
choose the variables that are	1
choose the method that gives	1
choose the type that is	1
choose the optimal algorithm before	1
choose the appropriate version of	1
choose a software framework that	1
choose a newer instruction set	1
choose to use intrinsic functions	1
choose to make memory-hungry software	1
choose to align large objects	1
choose an up-to-date function library	1
choose this method for all	1
choose other programming languages. This	1
choose one of the following	1
choose between c2 and bc	1
choose either C or C++	1
choose between. It is difficult	1
options to control the way	1
options to enable the desired	1
options and the options -S	1
options in the BIOS setup.	1
options for the compiler you	1
options for fast math and	1
options that you can turn	1
options are set to relax	1
options are incompatible with debugging.	1
options at the start so	1
options All C++ compilers have	1
options Table 18.1. Command line	1
options relevant to optimization MS	1
options prevent optimization. The debugger	1
options turned on, the compilers	1
options turned on, including relaxed	1
options turned on. Most IDE's	1
options -S or /Fa for	1
options ................................................................................... 81 8.6 Optimization	1
feature is used in the	1
feature is intended for CPU	1
feature is rarely needed anyway.	1
feature is rarely needed. 11	1
feature is seldom used. It	1
feature for making multiple versions	1
feature for reserving memory in	1
feature that the object it	1
feature that there is always	1
feature that allows overriding of	1
feature on Intel CPUs. Another	1
feature will become available in	1
feature into the code that	1
feature called performance monitor counters.	1
feature called whole program optimization,	1
feature called "Gnu indirect function"	1
feature uses an ordinary procedure	1
feature was never designed for	1
feature information, such as supported	1
ways of doing the same	1
ways of doing type conversions:	1
ways of doing things only	1
ways of handling errors without	1
ways of copying blocks of	1
ways of multiplying by 3,	1
ways of reducing the number	1
ways of organizing the data.	1
ways to make a function	1
ways to do things in	1
ways to do this: Use	1
ways to avoid the time-	1
ways to avoid this wasteful	1
ways to avoid these problems.	1
ways to get more reproducible	1
ways to divide the workload	1
ways than by a macro,	1
ways around this problem. If	1
ways depending on the available	1
were in the same module	1
were as follows: Matrix size	1
were not divided into threads	1
were not present in the	1
were float instead of double,	1
were able to do different	1
were able to reduce (a*b*c)+(c*b*a)	1
were unknown at the time	5
were measured on a Pentium	1
were scarce resources. However, the	1
were splitting 256-bit read operations	1
were carried out with all	1
were tested: Microsoft C++ Compiler	1
were observed between the optimization	1
were inserted, one by one,	1
link to the appropriate version	1
link to a function in	1
link with the option -read_only_relocs	1
link with external libraries. www.agner.org/optimize/#vectorclass	1
link pointer can be loaded	1
link pointer has been loaded.	1
link library because it needs	1
link library (*.dll or *.so).	2
link library (DLL) which is	1
link order is usually the	1
link libraries slower than static	1
link libraries (*.lib, *.a) or	2
link pointers and for information	1
link libraries. These factors are	1
link map or an assembly	1
link libraries, also called shared	2
made the structure 8 bytes	1
made the right prediction. The	1
made a Windows program that	1
made a series of experiments	1
made to the desired version	1
made to recover from errors.	1
made for all suitable functions	1
made for demonstration purposes. Available	1
made with option -fpie because	1
made with Microsoft or Gnu	1
made more compact by joining	1
made very big in order	1
made available to the function	1
made about whether the positive	1
made much more efficient if	1
made container class templates are	1
made smaller by reordering the	1
made containers is that you	1
made local. This makes it	1
appropriate to give the compiler	1
appropriate for the desired program	1
appropriate function version CriticalFunctionType *	1
appropriate compiler options to enable	1
appropriate instruction set specified. Insert	1
appropriate version of the program	1
appropriate version of the critical	1
appropriate version of the library.	2
appropriate version of the subroutine	1
appropriate version (May use a	2
appropriate type of vector, such	1
appropriate error message and then	1
appropriate error messages to the	1
appropriate header file for the	1
appropriate header file will give	1
appropriate here. It reveals a	1
i, a, b; // Critical	1
i, sum = 0; for	1
i, f = 1; for	1
i, a[100]; for (i =	1
i, i_div_3; for(i=i_div_3=0; i<300; i+=3,i_div_3++){	1
i, a); } } The	2
i, a); } 111 }	1
i, j; int order(int x);	1
i, j; float x; for	1
i, j; ... for (i	1
i, a[100], b; for (i	1
i, a[100], b, temp; temp	1
i, a[100], temp; temp =	1
i, StringLength; for (i =	1
i, a[2]; for (i =	1
i, largest_index = 0; for	1
i, timediff[i]); } The code	1
constructor is not needed if	2
constructor is implemented internally as	1
constructor and the destructor by	1
constructor and no destructor the	1
constructor for the object. Make	1
constructor that does the necessary	1
constructor can be a time	1
constructor // constructor // sum	1
constructor // sum operator //	1
constructor or overloaded operator is	1
constructor may be called whenever	1
constructor may be inlined for	1
constructor must be called when	1
constructor sets all elements to	1
constructor specifying otherwise. In difficult	1
constructor itself. Constructors are therefore	1
constructor initializes x to 0	1
CPUs. The performance on non-Intel	1
CPUs. The SSE2 instruction set	1
CPUs. The Gnu compiler can	1
CPUs. The Pentium Pro instruction	1
CPUs. The sequence of backwards	1
CPUs. This is called CPU	1
CPUs. This method is explained	1
CPUs. It uses the dispatch	1
CPUs. These costs can be	1
CPUs. However, a software implementation	1
CPUs. On the other hand,	1
CPUs. (See page 130 for	1
CPUs. Intel's profiler is called	1
CPUs. 5. Calling conventions for	1
CPUs. New versions are produced	2
CPUs. Includes many functions for	1
CPUs. Half size execution units.	1
2; // Find numerically largest	1
2; } The loop unrolling	1
2; } A good compiler	1
2; } } The most	1
2; } } void Func2()	1
2; } void FuncB (int	1
2; } These two functions	1
2; } }; void test	2
2; } else { a	2
2; } list[300] = 0;	1
2; i <= n; i++)	1
2; return a + 1;	2
2; i++) a[i] = i+1;	1
2; Unfortunately, some compilers unroll	1
2; Common subexpression elimination If	1
just a single function from	1
just a few clock cycles,	1
just a matter of convenience	1
just by turning off the	1
just as a normal array.	1
just as fast as a	1
just as fast as single	1
just as fast as accessing	1
just an arbitrary name that	1
just because it is long	1
just one or a few	1
just one clock cycle. The	1
just two additions by the	1
just two branches: one for	1
just long enough to be	1
just want the program to	1
just easier to write a	1
just happened to be possible.	1
a[i] is ecx+eax*4. The result	1
a[i] and shift out sign	1
a[i] = b * b	1
a[i] = i * 9	1
a[i] = r + i/2;	1
a[i] = temp; } 70	1
a[i] = temp; temp +=	1
a[i] = *p + 2;	1
a[i] = log (b[i] *	1
a[i] = b[i] + 2;	1
a[i] = Induction; ; a[i+1]	1
a[i] = Induction; a[i+1] =	1
a[i] = log(b[i]) + log(c[i]);	1
a[i] = log(b[i]) + log(c[i]);.	1
a[i] = i+1; The compiler	1
a[i] = 0.0; // copy	1
a[i] + b[i]; c[i] =	1
a[i] More examples of container	1
function, the compiler doesn't know	1
function, and the function stores	1
function, and the AVX2 instruction	1
function, and it prevents the	1
function, if possible. Use inline	1
function, then the exception handler	1
function, but it may be	1
function, but it has the	1
function, but unfortunately the unit-test	1
function, one that discriminates between	1
function, each optimized for a	1
function, while a function that	1
function, means that the function	1
function, though not all libraries	1
function, provided that the function	1
function, m is transferred at	1
function, m is replaced by	1
function, etc., and if an	1
operands of the Boolean operators	1
operands and add b and	1
operands in case the code	1
operands The operands of the	1
operands are integer expressions rather	1
operands are variables than if	1
operands are comparisons, etc. For	1
operands if the evaluation of	1
operands have other values than	1
operands have no other values	1
operands have mixed precision require	1
operands has side effects or	1
operands because the expression list[i]	1
operands because you should not	1
operands Intel Core 2 0.12	1
operands cannot be changed without	1
operands AMD Opteron K8 0.24	1
operands means that source and	1
innermost loop is predicted well.	1
innermost loop of a program	2
innermost loop and without the	1
innermost loop that includes the	1
innermost loop by storing intermediate	1
innermost loop A function that	1
innermost loop should preferably be	1
innermost loop doing mathematical calculations.	1
innermost loop bigger than the	1
innermost function, then the exception	1
innermost loop. The loop will	1
innermost loop. This is done	1
innermost loop. This reflects the	1
innermost loop. Another possibility is	1
innermost loop. log is a	1
innermost loop: for (i =	1
innermost loops. 13.1 CPU dispatch	1
require a very high resolution	1
require a few extra instructions	1
require a lot of data	1
require a multiplication but only	1
require a variable. Efficiency Accessing	1
require that the code you	1
require that the operating system	1
require that the arrays are	1
require that the microprocessor has	1
require that a new bigger	1
require that data are aligned	1
require more resources, even if	1
require other access patterns. This	1
require two floating point comparisons,	1
require precision conversion instructions which	1
require runtime type identification (RTTI),	1
require cleanup before terminating a	1
require modifications in the code.	1
compiler. The compilers are becoming	1
compiler. This library contains many	1
compiler. This method is described	1
compiler. It is therefore not	1
compiler. You can disable exception	1
compiler. Some functions are optimized	1
compiler. Some compilers can reduce	1
compiler. Some compilers have efficient	1
compiler. Use CPUs with execution	1
compiler. We can never be	1
compiler. Many algebraic reductions are	1
compiler. Supports only 32-bit Windows.	1
compiler. Loop invariant code motion	1
compiler. On the other hand,	1
compiler. Object files generated by	1
compiler. Not optimized as good	1
compiler. 2.6 Choice of function	1
compiler. Remember, therefore, always to	1
advanced and complicated algorithm if	1
advanced code version on, then	1
advanced data structures with First-In-First-Out	1
advanced C++ programming, how to	1
advanced version on all newer	1
advanced version on, then it	1
advanced system performance options. I	1
advanced programming constructs are costly	1
advanced optimizing features, and you	1
advanced development tools. The simplest	1
advanced mathematical functions are supplied	1
advanced programmers and software developers	1
advanced features rarely found in	1
advanced prediction mechanisms. Modern microprocessors	1
advanced algorithms to predict which	1
advanced principles of software develop-	1
advanced facilities of the operating	1
advanced high-level language with a	1
#define is certain to be	1
#define makes no difference for	1
#define directives are equivalent to	1
#define directives when used as	1
#define directive never takes memory	1
#define N1 (N & (N-1))	1
#define pure_function #endif double Func1(double)	1
#define pure_function __attribute__((const)) #else #define	1
#define FUNCNAME SelectAddMul_SSE41 #elif INSTRSET	1
#define FUNCNAME SelectAddMul_SSE2 #elif INSTRSET	1
#define FUNCNAME SelectAddMul_AVX2 #endif //	1
#define swapd(x,y) {temp=x; x=y; y=temp;}	2
#define EXCEPTION_FLT_OVERFLOW 0xC0000091L void MathLoop()	1
#define ABC 123 and static	1
#define Alignd(X) X __attribute__((aligned(16))) #endif	1
#define Alignd(X) __declspec(align(16)) X #else	1
#define MAX(a,b) (a > b	1
points is not divisible by	1
points to the dispatcher function.	1
points to the dispatcher. //	1
points to the selected version	1
points to is deleted when	1
points to a dispatcher. The	1
points to and you can	1
points to an object of	2
points to ; store result	1
points to (see page 73).	1
points in the end in	1
points with the four R	1
points out some typical sources	1
points to. A const member	1
points to. A reference is	1
points to. Therefore, it cannot	1
points to. Now ebx contains	1
switch is a switch between	1
switch to protected mode and	1
switch in your program to	1
switch between different tasks in	1
switch statement if it follows	1
switch statement with many labels	1
switch statement with sequential labels	1
switch statement jump tables, and	1
switch statement leads to the	1
switch statements is a kind	1
switch statements The high speed	1
switch statements because switch statements	1
switch statements should preferably be	1
switch statements often suffer from	1
switch occurs during execution of	1
switch statements, as explained on	1
switch (n) { case 0:	1
switch statements............................................................................. 43 7.13 Loops......................................................................................................................	1
range is possibly more serious	1
range of a variable is	1
range of code in which	1
range of an integer if	1
range of memory addresses is	1
range of floating point variables	1
range and we don't need	1
range } } This implementation	1
range then the value is	1
range then a simple array	2
range from -128 to +127.	1
range from 0x2700 to 0x273F	2
range (see page 134 on	1
range analysis The live range	1
range analysis Join identical branches	1
range printf(Greek[n]); } The declaration	1
start the calculation of one	1
start the next calculation. However,	1
start a new floating point	1
start a new addition before	1
start of the function. Copying	1
start of the program, and	1
start of Func ;a ;r	1
start to calculate (c+d) before	1
start to program. Many programmers	1
start to optimize anything, you	1
start to code, you may	1
start and stop the thread.	1
start at an address divisible	1
start at unpredictable times and	1
start so that the rest	1
start calculations on the second	1
start garbage collection when the	1
start up, which is a	1
modules of a big program	1
modules and header files. 121	1
modules The compiler doesn't have	1
modules that use the same	1
modules that make up a	1
modules are linked together. The	1
modules or resource files from	1
modules if necessary, each compiled	1
modules with a different compiler.	1
modules with a well-defined interface	1
modules than the one it	1
modules may be loaded only	1
modules when the highest level	1
modules into one by means	1
modules call the function. This	1
modules (See page 81). 77	1
modules contiguous in program memory.	1
modules appear in the project	1
smaller the data elements are.	1
smaller the integer size on	1
smaller the system, the more	1
smaller and the array 800	1
smaller and more efficient. You	1
smaller and closer to the	1
smaller in a computer with	1
smaller if there is only	1
smaller by declaring it inside	1
smaller by reordering the data	1
smaller as well. The conversion	1
smaller than the vector register	1
smaller memory footprint. If, for	1
smaller because relative addresses are	1
smaller functions only makes the	1
smaller size is done simply	1
smaller sizes (char, short int)	1
smaller squares and handle one	1
here is the only one	1
here is a list of	1
here is a branch. If	1
here is to remove the	1
here is that the list	1
here is that access times	1
here is likely to be	1
here to draw the attention	1
here in a rather unconventional	1
here // Virtual function //	1
here if the compiler doesn't	1
here may apply to other	1
here because the consequence of	1
here because we are relying	1
here about Linux also applies	1
here about increment operators also	1
here means that different threads	1
here gives a+b=0, and then	1
core is running at, rather	1
core of modern microprocessors is	1
core and an FPGA in	1
core and high-priority threads are	1
core by setting a thread	1
core with another thread will	1
core on multi-core CPUs, but	1
core will always compete for	1
core then it is not	1
core library contains optimized mathematical	1
core library contains similar functions,	1
core clock cycles counter is	1
core clock cycles per byte	1
core clock cycles. The core	1
core clock cycle counter is	1
core clock cycle counter (see	1
core during time measurements to	1
relevant to software optimization. Everything	1
relevant to optimization MS compiler	2
relevant to test the performance	1
relevant to small devices, but	1
relevant to optimization. Prefetching data	1
relevant for the programmer to	1
relevant when the code is	1
relevant when CPU access and	1
relevant when testing worst-case performance:	1
relevant optimization options and the	1
relevant optimization options turned on,	2
relevant optimization options turned on.	1
relevant options. Many optimization options	1
relevant information. 1.1 The costs	1
relevant books and manuals. I	1
are: The process of dynamic	1
are: The overhead of call	1
are: The syntax is simpler	1
are: int BigArray[1024] __attribute__((aligned(64))); //	1
are: It is easy to	1
are: There is very little	1
are: All calculations are done	1
are: No loop-carried dependency chain.	1
are: When you look at	1
are: Avoid the conversions by	1
are: Variables that are used	1
are: Optimizing for present processors	1
are: Static linking includes only	1
are: 146 Multiple applications running	1
are: Long double precision is	1
are: Non-static member functions have	1
are: Coarse time measurement. If	1
around the constant subexpression. A	1
around the hot spot. Sometimes,	1
around and less efficient code	1
around in the memory. It	1
around in memory or accessed	1
around in memory then there	1
around in program memory. If	1
around in memory. Function parameters	1
around it so that it	1
around on the hard disk.	1
around on overflow and underflow.	1
around this problem. If a	1
around this limitation and other	1
around at different memory addresses.	1
around at different places when	1
around such a subexpression to	1
around 1980 where RAM memory	1
5 and 20 clock cycles.	1
5 and 9. Multiplications are	1
5 by another thread. If	1
5 } } In this	1
5 * 0.5 ns =	1
5 clock cycles to do	1
5 clock cycles, then this	1
5 clock cycles, then we	1
5 times faster either by	1
5 / 2 (be aware	1
5 #define FUNCNAME SelectAddMul_SSE41 #elif	1
5 Choosing the optimal algorithm	2
5 s on the next	1
5 2.2 Choice of microprocessor	1
5 2.1 Choice of hardware	1
5 Programmable logic devices A	1
replaced by the function body.	1
replaced by the calculated result.	1
replaced by a table with	1
replaced by a single comparison:	1
replaced by a shift operation	1
replaced by a blend instruction	1
replaced by // Example 14.15b	1
replaced by more efficient container	1
replaced by its value at	1
replaced by their values before	1
replaced by their actual values	1
replaced by storage on the	1
replaced by my comments, in	1
replaced by x<<3, which is	1
replaced i by a second	1
replaced with: // Example 14.12b	1
replaced with: // Example 14.13b	1
a; // 2 bytes. first	1
a; int b; a =	1
a; int b; int c;	1
a; int b; int c;};	1
a; int b; int Sum1()	1
a; int b; static const	1
a; int b;}; Sab ab[size];	1
a; double b; a +=	1
a; double b; int d;	1
a; double b;}; S1 list[100];	1
a; double b;}; S1 list[100],	1
a; b = a +	1
a; float x, y, z;	1
a; y = b;} vector	1
a; bool b; a =	1
a; Plus2 (&a); The compiler	1
a; 72 This may be	1
things to make the code	1
things to test when software	1
things in parallel. Coarse-grained parallelism	1
things in parallel: Using multiple	1
things that the programmer can	1
things that can be optimized	1
things that can be improved	1
things with the sign bit	1
things with pointers that are	1
things you can do to	1
things you can do with	1
things at the same time.	1
things only after they have	1
things very smart and other	1
things very stupid. Some common	1
things like a mouse move	1
things like adding vectors. The	1
negative or if one is	1
negative or -0 } It	1
negative by AND'ing it with	1
negative integer will be interpreted	1
negative value of i will	1
negative so that we don't	1
negative list of which processor	1
negative list of processors on	1
negative list of processor models	1
negative effect on performance. 7.18	1
negative inputs give infinity. A	1
negative result. An overflow of	1
negative numbers. The exponent is	1
negative effects of object oriented	2
negative list, on the other	1
negative impacts on program performance.	1
section is not shared between	1
section is always position-independent because	1
section and read-only data sections	1
section for some caveats. We	1
section can be loaded at	1
section if you are satisfied	1
section by summing up the	1
section may contain pointers or	1
section will be different for	1
section so that it cannot	1
section contains no absolute addresses	1
section needs one instance for	2
section (page 131) shows a	1
section discusses how to overcome	1
section position-independent, makes a PLT	1
section 17.9: "Moving blocks of	1
reductions the compilers are able	1
reductions in my test examples.	1
reductions that the compilers cannot	1
reductions are not permissible for	1
reductions on integer code. It	1
reductions on integer expressions than	1
reductions on floating point code	1
reductions on floating point expressions.	1
reductions as 0/a = 0	1
reductions at their own initiative	1
reductions such as -(-a) =	1
reductions they cannot do. All	1
reductions Most compilers can reduce	1
reductions explicitly in many cases.	1
reductions manually. I have tested	1
reductions involving integer addition, subtraction	1
reductions involving division and relational	1
go the same way as	1
go to the desired version.	1
go to dispatched version return	1
go more than two ways.	1
go one way two times	1
go into eight different cache	1
go through the PLT and	1
go through a second step	1
go through multiple layers and	1
go based on the past	1
go here // Virtual function	1
go outside the bounds of	1
go back into the for-loop:	1
go away in the future	1
go undetected. The principle of	1
go undetected. Converting class objects	1
go deeper into the technical	1
depends on the size and	1
depends on the number of	1
depends on the value that	1
depends on the way the	1
depends on the calculations inside	1
depends on the result of	2
depends on the preceding value	1
depends on the previous one.	1
depends on the processor. Nested	1
depends on how well the	1
depends on calculations inside the	1
depends on whether CriticalFunction is	1
depends on what fits best	1
depends only on the values	1
depends only on n, including	1
depends very much on the	1
example: // Example 7.8 if	1
example: // Example 8.4 double	1
example: // Example 7.7 unsigned	1
example: // Example 7.11 bool	1
example: // Example 7.14 class	1
example: // Example 7.13 struct	1
example: // Example 7.29a float	1
example: // Example 8.17 char	1
example: // Example 7.35a struct	1
example: // Example 7.9a bool	1
example: // Example 8.24. Integer	1
example: // Example 14.16a double	1
example: // Example 7.37 class	1
example: // Example 14.15a if	1
example: // Example 14.2a float	1
example: Use a reference or	1
example: 38 // Example 7.15a.	1
tested the strlen function in	1
tested the capability to reduce	1
tested and investigated by the	1
tested in different browsers, different	1
tested in Mac systems. 14	1
tested can convert example 15.1a	1
tested with a realistic set	1
tested on a network with	1
tested on different platforms, different	1
tested only on PC platforms.	1
tested library modules and header	1
tested were able to reduce	1
tested it. The insight you	1
tested under worst-case conditions in	1
tested implement OneOrTwo5[b!=0] as OneOrTwo5[(b!=0)	1
tested seem to do so.	1
tested (not up to date):	1
contentions is that the level-2	1
contentions is that branches can	1
contentions and the time consumption	1
contentions in the code cache.	1
contentions in the data cache.	2
contentions in large data structures	2
contentions can be prevented in	1
contentions if the threads write	1
contentions if the threads share	1
contentions than for level-1 cache	1
contentions will occur: if (SIZE	1
contentions do not occur. The	1
contentions occur in the level-2	2
contentions expected. Use square blocking:	1
predicted to go the same	1
predicted or if the prediction	1
predicted if the value of	1
predicted by the branch prediction	1
predicted most of the time,	1
predicted well if the repeat	1
predicted well only on some	2
predicted quite well if it	1
predicted depends on the processor.	1
predicted well. A loop with	1
predicted well. A switch statements	1
predicted well. Even function calls	1
predicted well, of course. A	1
predicted perfectly on a Pentium	1
predicted perfectly varies between 9	1
predicted perfectly. As explained above,	1
main will be used, even	1
main will take precedence, not	1
main memory and therefore it	1
main memory in a computer.	1
main has the same name	1
main through an imported pointer,	1
main advantage of the AVX	1
main memory. A register is	1
main program. See page 150	1
main reason why such runtime	1
main executable to a function	1
main executable has the same	1
main executable because it is	1
main reasons why object oriented	1
main principles here: functional decomposition	1
main feedback comes from testing.	1
main focus is on mathematical	1
references to data within the	1
references to relocate, but these	1
references in the code carefully	1
references in 32-bit mode. The	1
references in 64 bit mode.	1
references in 32 bit mode	1
references are equally efficient because	1
references then tell the compiler	1
references do not need relocation	1
references rather than pointers are:	1
references instead of pointers, by	1
references require a variable. Efficiency	1
references are: When you look	1
references Pointers and references are	1
references Pointers versus references Pointers	1
references ............................................................................................ 36 7.7 Function	1
references accept expressions as arguments	1
loaded or at run time.	1
loaded from memory each time	1
loaded at a higher address	1
loaded at an address below	1
loaded at an arbitrary memory	1
loaded at round memory addresses	1
loaded only when they are	1
loaded into an arbitrary cache	1
loaded into memory when the	1
loaded into memory. If the	1
loaded into ecx and edx,	1
loaded cannot be determined in	1
loaded rather than each time	1
loaded type casting operator that	1
loaded every time the program	1
loaded until the previous link	1
loaded anyway. If we modify	1
positive and 1 for negative	1
positive and negative impacts on	1
positive or the negative effects	1
positive } Example 14.27 assumes	1
positive integer constant. // General	1
positive floating point numbers simply	1
positive number when i is	1
positive number when converted to	1
positive overflow of a signed	1
positive list of which processor	1
positive list of processor models	1
positive list needs to be	1
positive result. The conversion between	1
positive effects are: Variables that	1
positive n. You can divide	1
positive integer: // Example 15.1b.	1
positive value, n. But not	1
loop. The time that is	1
loop. The loop will use	1
loop. The following example converts	1
loop. The effect of the	1
loop. The loop-branch is usually	1
loop. This is done by	1
loop. This reflects the order	1
loop. It is not permissible	1
loop. Example 12.4b executes three	1
loop. Example 8.21 is indeed	1
loop. If each floating point	1
loop. In general, you have	1
loop. Example: // Example 7.30a	1
loop. Some implementations use just-in-time	1
loop. Most compilers have an	1
loop. Another possibility is to	1
loop. log is a library	1
computer is not always comparable	1
computer is restarted anyway. Software	1
computer is reset or goes	1
computer is rebooted. To prevent	1
computer for security reasons before	1
computer with a slow CPU,	1
computer with multiple CPUs or	1
computer with many such programs	1
computer has only one CPU	1
computer where the level-1 data	1
computer while he or she	1
computer during the update process.	1
computer users and much time	1
computer starts up, even if	1
computer game or animation. It	1
computer games and animations is	1
computer games. Such a coprocessor	1
overhead of the operating system	1
overhead of the iterator in	1
overhead of call and return	1
overhead of parameter transfer is	2
overhead of parameter transfer for	1
overhead of transferring the variable	1
overhead of semaphores, mutexes, etc.	1
overhead of switching to protected	1
overhead of managing a memory	1
overhead to the allocation process	1
overhead to prevent such errors.	1
overhead in the program code	1
overhead which consumes CPU time.	1
overhead while other compilers have	1
overhead cost of heap management	1
overhead cost to memory management	1
VIA processors because this brand	1
VIA processor and a Windows,	1
VIA processors. It is possible	1
VIA processors. See page 130	1
VIA processors. Explicit CPU dispatching	1
VIA CPUs. 5. Calling conventions	1
VIA including the 64-bit versions.	1
VIA processors, and it is	1
VIA CPUs"). This is one	1
VIA CPUs"). This can be	1
VIA CPUs"). Const cast The	1
VIA CPUs" for an explanation	2
VIA CPUs" gives more details	1
VIA CPUs: An optimization guide	1
VIA CPUs". A branch instruction	1
VIA CPUs". 9.3 Functions that	1
pointer. The pointer is simply	1
pointer. The copy constructor, if	1
pointer. This is the variable	1
pointer. This can be avoided	1
pointer. A variable in a	1
pointer. It is important that	1
pointer. It is recommended to	1
pointer. It may be obvious	1
pointer. It has the special	1
pointer. It has some syntax	1
pointer. If a program uses	1
pointer. You may make member	1
pointer. But there is an	1
pointer. These conversions do not	1
pointer. Likewise, all non-static variables	1
pointer. Accessing an object by	1
pointer. 7.9 Smart pointers A	1
supports the corresponding instruction set.	1
supports a particular instruction set,	1
supports this option only in	1
supports this kind of instructions	1
supports then you are risking	1
supports at least the same	1
supports vector intrinsics, automatic vectorization	1
supports CPU dispatching to make	1
supports multiple programming languages, profiling	1
supports 32-bit and 64-bit Windows	1
supports Linux and Windows platforms.	1
supports both Intel, AMD and	1
supports intrinsic functions, but in	1
supports automatic vectorization, such as	1
supports self-relative addressing of data.	1
supports self-relative addressing. In 32-bit	1
supports this). Use rounding instead	1
C and C++ faster than	1
C are too small to	1
C = 3.3; // Polynomial	1
C = 3.3; double Table[100];	1
C or C++ code. Compilers	1
C or C++ file and	1
C or C++ based on	1
C or C++. Critical device	1
C function library for a	1
C if you follow the	1
C functions such as strcpy,	1
C language as a subset,	1
C standard says that the	1
C library. It requires support	1
C style with character arrays.	1
C style as character arrays.	1
C style string functions have	1
compatible with the other compilers).	1
compatible with a better version	1
compatible with that branch. The	1
compatible with different versions of	1
compatible with other compilers at	1
compatible with all CPUs that	1
compatible with CPUs that are	1
compatible with old microprocessors that	1
compatible with old microprocessors without	1
compatible with 16-bit programs. It	1
compatible with structured exception handling.	1
compatible with Gnu. It is	1
compatible with these. The CodeGear,	1
compatible on the object file	1
compatible instruction sets is as	1
compatible way is to make	1
compatible across compilers. Fastcall is	1
change the code in example	1
change the value of ebx.	1
change the order of the	1
change the sign of a	1
change the expression -(-a) to	1
change the value. The loop	1
change the behavior of the	1
change of a hard disk	1
change in the YMM register	1
change this to: // Example	1
change its possible exception handling	1
change their clock frequency dynamically	1
change what a pointer points	1
change what it points to.	1
change && to & unless	1
change during the loop. It	1
change pre-increment to post-increment. There	1
global and one local, and	1
global and static variables if	1
global if it is accessed	1
global if you can avoid	1
global variable in the shared	1
global variable in main has	1
global variable means that it	1
global variables or hide them	1
global variables by using the	1
global variables (i.e. variables defined	1
global const variable or replace	1
global arrays require a few	1
global variables. (See thread-local storage	1
global variables. They can be	1
global offset table (GOT). These	1
global offset table (GOT) in	1
global object. The calling function	1
my vector class library). The	1
my optimization manuals are used	1
my optimization manuals. I am	1
my test tool for details	1
my test examples. The table	1
my manual will soon be	1
my own research, not on	1
my own research, I have	1
my free E-book Usability for	1
my study of how compilers	1
my experiment are given below.	1
my blog. Here, you can	1
my experiments. Contentions in the	1
my crystal ball reveals that	1
my blog for details. The	1
my comments, in green. It	1
my tests, the Intel compiler	1
conversions is discussed below. Signed	1
conversions and make the code	1
conversions in the critical part	1
conversions The C++ syntax has	1
conversions are not safe, of	1
conversions can be used freely	1
conversions can sometimes be avoided	1
conversions by using different types	1
conversions from integer to floating	1
conversions from floating point numbers	1
conversions from float or double	1
conversions do not produce any	1
conversions between integers and floating	2
conversions take a lot of	1
conversions out of the innermost	1
statement and all the integer	1
statement in the condition clause.	1
statement in this example has	1
statement that calls the function	1
statement can be made about	1
statement can improve optimizations in	1
statement if it follows a	1
statement with many labels that	1
statement with sequential labels is	1
statement so that it can	1
statement always calls the same	1
statement several iterations ahead. It	1
statement was executed. If the	1
statement jump tables, and virtual	1
statement leads to the appropriate	1
statement occupies a space in	1
errors is to replace arrays	1
errors in C++ programs and	1
errors in C++ programs. Writing	1
errors in case the array	1
errors in cases where they	1
errors in programs where security	1
errors that would otherwise go	1
errors that seldom occur and	1
errors can happen if the	1
errors can happen with the	1
errors if the size parameter	1
errors if they are uninitialized,	1
errors without using exceptions. The	1
errors must be added. This	1
errors elsewhere in the program	1
errors associated with dynamic memory	1
off the loop unroll option	1
off the exception handling option	1
off the binary value of	1
off the computer for security	1
off the computer during the	1
off the position-independent code flag	1
off the reading of the	1
off and use alternative implementations.	1
off or until the computer	1
off or log off the	1
off by default unless there	1
off all optimizations of a	1
off support for exception handling	1
off support for runtime type	1
off debugging and profiling support	1
off requirements for strict floating	1
unused bytes in the end.	1
unused bytes in a structure	1
unused bytes can be reduced	1
unused bytes // 8 bytes.	1
unused bytes between a and	1
unused bytes byte at 0,	1
unused bytes S1 ArrayOfStructures[100]; This	1
unused copy of an inlined	1
unused points in the end	1
unused columns to a matrix.	1
unused label ; return from	1
unused label ; save ebx	1
unused label ; restore ebx	1
unused label ;eax=addressofa ;edx=addressinr ;	1
unused returns // Volatile to	1
unused fourth value to make	1
relative to the stack pointer.	1
relative to the beginning of	4
relative to the current position.	1
relative addresses in the code	1
relative addresses in 32-bit Mac	1
relative addresses are often used	1
relative reference to a public	1
relative difference less than 2-20,	1
relative references in 64 bit	1
relative references do not need	1
relative efficiency of different C++	1
relative addresses. Therefore, the code	1
relative addressing of data. The	1
columns is a power of	1
columns a power of 2	1
columns to a matrix. For	1
columns in a matrix is	2
columns in a matrix a	1
columns in this case is	1
columns in matrix // function	2
columns = 8; float matrix[rows][columns];	1
columns = 32; float matrix[rows][columns];	1
columns = 50; float matrix[rows][columns];	1
columns below diagonal // swap	1
columns below diagonal swapd(a[r][c], a[c][r]);	1
columns had not been a	1
columns unused. This removed the	1
p is a simple pointer	1
p is a pointer, but	1
p is not i but	1
p is therefore equal to	1
p is identical to one	1
p is incremented. See page	1
p and r in Sum2	1
p and inlining the call	1
p = & obj1; p->f();	1
p = p + i;	1
p = &Object1; p->NotPolymorphic(); p->Hello();	1
p = &Object2; p->Hello(); }	1
p has been incremented, while	1
p + i; Here, the	1
p always points to an	1
p points to (see page	1
platforms. The Microsoft and Intel	1
platforms. The Clang compiler is	1
platforms. This library has reduced	2
platforms. See the compiler documentation	1
platforms. AMD AMD Math core	1
platforms. However, C++ is also	1
platforms. 2. Optimizing subroutines in	1
platforms. PathScale C++ compiler for	1
platforms. Microsoft, Intel, Gnu and	1
platforms. Clang The Clang compiler	1
platforms. Graphics accelerators The choice	1
platforms. 3. The microarchitecture of	1
platforms. Comparison of function libraries	1
platforms. Works well with non-Intel	1
platforms. Pascal has many of	1
languages and their implementations reveal	1
languages in Microsoft's .NET framework	1
languages that do not support	1
languages that do have such	1
languages are out of the	1
languages are good for making	1
languages are good for optimizing	1
languages are implemented with interpretation.	1
languages can be quite substantial.	1
languages as well. This is	1
languages have the disadvantage of	1
languages use an intermediate code	1
languages such as C++ for	1
languages such as C#, Visual	1
languages where everything happens at	1
languages include C, C++, D,	1
installation of the program that	1
installation of the framework itself,	1
installation of downloaded program updates	1
installation and uninstallation of programs	1
installation The time it takes	1
installation time and compatibility problems	1
installation program makes a symbolic	1
installation time. Each code version	1
installation process to take more	1
installation process can proceed unattended.	1
installation process or by an	1
installation process should always use	1
installation options at the start	1
installation tools. It should be	1
installation tools. Automatic updates. Automatic	1
installation .................................................................................................. 18 3.4 Automatic	1
depending on the available instruction	1
depending on the work load.	1
depending on the processor and	1
depending on the CPU. Unrolling	1
depending on the processor. This	1
depending on the processor. Nested	1
depending on the specified instruction	1
depending on the microprocessor. Integer	1
depending on the microprocessor. Multiplication	1
depending on the context. The	1
depending on the processor). Integer	1
depending on the processor). Optimizing	1
depending on instruction set #if	1
depending on how they are	1
depending on how predictable the	1
depending on what fits best	1
syntax is so kludgy that	1
syntax is very old-fashioned. Development	1
syntax is fully standardized and	1
syntax is simpler when using	1
syntax in example 8.15b. The	1
syntax in example 7.43b is	1
syntax in both Windows and	1
syntax or See page 95	1
syntax may seem a little	1
syntax has several different ways	1
syntax described in the Gnu	1
syntax checking and is therefore	1
syntax 90 Gives a more	1
syntax check. It does not	1
syntax checks. These conversions are	1
syntax restriction, but it doesn't	1
cases. The most critical part	1
cases. The so-called iterators that	1
cases. The equivalent expression b	1
cases. The explicit use of	1
cases. This is because algebraic	1
cases. This means that the	1
cases. It is best when	1
cases. See manual 5: "Calling	1
cases. For example: // Example	1
cases. An even more powerful	1
cases. Integer expressions are less	1
cases. Don't change && to	1
cases. Multiple threads? Container classes	1
cases. Does not allocate more	1
cases. 7.28 Templates A template	1
cases. Database queries can often	1
Supports the OpenMP directives for	1
Supports vector intrinsics and automatic	1
Supports only 32-bit Windows. Gnu	1
Supports only 32-bit Windows. Does	1
Supports all x86 and x86-64	2
Supports all x86 platforms. Microsoft,	1
Supports 32-bit and 64-bit Windows.	2
Supports both AMD and Intel	1
Supports three different object file	1
Supports x86 and ARM platforms	1
Supports parallel processing, OpenMP and	2
Supports OpenMP and automatic parallelization.	1
Supports 32- and 64-bit Windows	1
choice of compiler may in	1
choice of which method to	1
choice of user interface framework	1
choice of programming language is	1
choice of programming language and	1
choice of hardware platform for	1
choice of hardware platform has	1
choice of platform is obviously	1
choice of algorithm is very	1
choice of n. The constant	1
choice for code that can	1
choice for all platforms. PathScale	1
choice for all Unix-like platforms.	1
choice for Linux platforms if	1
choice for future models of	1
choice between optimizing for size	1
1. The reason why the	1
1. The AND operator (&)	1
1. This makes operations with	1
1. This ends the recursion	1
1. This '1' is not	1
1. See page 34. In	1
1. Use a compiler that	1
1. / (b1 * b2);	1
1. Note that there are	1
1. Optimizing software in C++	1
1. Optimizing software in C++:	1
1. Add the keyword static	1
1. Number 18 will evict	1
1. How much you gain	1
1. Writing a = OneOrTwo5[b!=0];	1
1. Relocation. All pointers and	1
STL is not satisfactory. The	1
STL is designed for generality	1
STL for accessing container elements	1
STL are universal, flexible, well	1
STL as a vector of	1
STL has been criticized for	1
STL vector stores all the	1
STL vector turned up to	1
STL also costs in terms	1
STL container are allowed to	1
STL containers is 95 not	1
STL containers do not have	1
STL templates, such as list,	1
STL containers. See page 90.	1
STL (Standard Template Library) and	1
STL deque (doubly ended queue)	1
intended to be platform-independent and	1
intended to work in both	1
intended to mimic the behavior	1
intended for CPU dispatching and	1
intended for array sizes and	1
intended for variables that are	1
intended for 32-bit Windows and	1
intended for system code. System	1
intended for calculating the movements	1
intended for finding hot spots,	1
intended for detecting errors that	1
intended as a plug-in to	1
intended because of a store	1
intended (see page 84). The	1
intended for. In other words,	1
intended for. Some systems also	1
dynamically and that measurements are	1
dynamically with new and delete,	1
dynamically when the size of	1
dynamically when the total number	1
dynamically allocated memory Memory allocated	1
dynamically allocated objects are not	1
dynamically allocated objects with each	1
dynamically allocated memory. It is	1
dynamically allocated memory. 9.6 Dynamic	1
dynamically allocated memory, using new.	1
dynamically allocated memory, windows, mutexes,	1
dynamically allocated memory................................................................. 120 12.9	1
dynamically linked library functions. 9.4	1
dynamically depending on the work	1
dynamically created by one function	1
dynamically (with new or malloc)	1
consecutive elements in aa: StoreVector(aa	3
consecutive elements in aa: a.store(aa+i);	1
consecutive elements from cc into	3
consecutive elements from bb into	3
consecutive elements c.load(cc+i); // result	1
consecutive elements b.load(bb+i); // Load	1
consecutive bytes of memory. One	1
consecutive variables. Example: // Example	1
consecutive terms in one vector.	1
consecutive indices or by keys	1
profiler is most useful for	1
profiler is called CodeAnalyst. These	1
profiler is called VTune; AMD's	1
profiler to find hot spots	2
profiler that can tell how	1
profiler may sample more data	1
profiler which determines the program	1
profiler works then you may	1
profiler counts how many times	1
profiler tells the CPU to	1
profiler tells the operating system	1
profiler itself. Function addresses are	1
profiler inserts temporary debug breakpoints	1
profiler measures not only the	1
profiler identifies any hot spots	1
become a serious legal issue.	1
become a serious legal issue,	1
become more powerful. The high	1
become very big. In the	1
become less important than it	1
become available in the future.	1
become too fragmented. This garbage	1
become bigger and more complex,	1
become fragmented and caching becomes	1
become fragmented when objects of	1
become fragmented. This makes data	1
become fragmented. An alternative is	1
become invalid. The heap manager	1
become invalid, and by avoiding	1
become imprecise or simply zero.	1
become obsolete within the lifetime	1
Windows, the first four parameters	1
Windows, you can use the	1
Windows, you may write FatalAppExitA(0,"Array	1
Windows, while most of the	1
Windows, Linux and Mac platforms.	1
Windows, Linux and Mac platforms	1
Windows, Linux and Mac. Supports	1
Windows, including an IDE. Does	1
Windows, Linux, Mac Windows, Linux,	1
Windows, Linux, BSD and Mac	1
Windows, Linux, BSD or Mac	1
Windows, Linux, Mac, BSD Instruction	1
Windows, allow variables to be	1
Windows, SetThreadAffinityMask, in Linux, sched_setaffinity).	1
Windows, -msse2, -mavx, etc. for	1
Windows, Intel/MASM syntax: __asm fld	1
index is not out of	1
index is out of range	2
index is out of range.	1
index of memory blocks. A	1
index or key in the	1
index by 8. 71 The	1
index than when n is	1
index then the compiler can	1
index then it is important	1
index out of range"); or	1
index must be multiplied by	1
index operator } }; //	1
index changes fastest: // Example	1
index changing in the innermost	1
index multiplied by a factor	1
modern C++ compilers. The advantage	1
modern programming languages use an	1
modern processors prefetch data automatically	1
modern CPUs can change their	1
modern CPUs have two or	1
modern microprocessors is obtained by	1
modern microprocessors is split between	1
modern microprocessors and operating systems	1
modern microprocessors are not optimized	1
modern x86 CPUs can execute	1
modern CPUs. The SSE2 instruction	1
modern CPU. But it is	1
modern CPUs, as described in	2
modern computers have memory caches.	1
modern software, it is not	1
gives the value of N	1
gives the advantage of bigger	1
gives the simplest possible implementation	1
gives the simplest code. If	1
gives the chosen expression. Example	1
gives the worst possible performance.	1
gives a measure that is	1
gives an advantage in the	1
gives an 9 extra overhead	1
gives more details on branch	1
gives more reliable and reproducible	1
gives more reliable results. If	1
gives access to the sign	1
gives zero. An OR combination	1
gives a+b=0, and then 0+1.23456	1
gives rise to some extra	1
Loop to make table of	1
Loop to print out results	1
Loop with branch // Loop	1
Loop with branch void SelectAddMul(short	1
Loop through array cout <<	1
Loop counter // Calculate polynomial	1
Loop counter //=2*A //=A*x*x+B*x+C //=DeltaY	1
Loop unrolling should only be	1
Loop unrolling should preferably be	1
Loop unrolling also has disadvantages:	1
Loop unrolling In some cases	1
Loop unrolling Some compilers will	1
Loop r1 and c1 for	1
Loop r2 and c2 for	1
Loop invariant code motion A	1
Loop invariant code motion Induction	1
avoided in 64-bit systems by	1
avoided for these variables. The	1
avoided by using references instead	1
avoided by making the full	1
avoided by making an additional	1
avoided by calling the intrinsic	1
avoided by inlining the latter	1
avoided by copying the code	1
avoided by joining the operations:	1
avoided by rolling out the	1
avoided by replacing an integer	1
avoided on processors with a	1
avoided when speed is critical.	1
avoided because of the large	1
avoided because they cannot be	1
avoided unless you have ample	1
turn it off and use	1
turn on and off. It	1
turn on this option. This	1
turn on this option. 8.4	1
turn on all relevant options.	1
turn on correction for the	1
turn calls another function, etc.,	1
turn off the loop unroll	1
turn off the computer during	1
turn off the reading of	1
turn off or log off	1
turn off support for exception	1
turn off support for runtime	1
turn off debugging and profiling	1
turn off requirements for strict	1
turn them off or until	1
inlining the call to Object1.Hello(),	1
inlining the frame function or	1
inlining the latter function, but	1
inlining is that the code	1
inlining is done at the	1
inlining a function if the	1
inlining and constant propagation and	1
inlining The compiler can replace	1
inlining can open the possibility	1
inlining more efficient and enables	1
inlining has the complication that	1
inlining all the functions that	2
inlining are: The overhead of	1
inlining causes technical problems or	1
inlining x-xxxx--x Constantfolding xxxxxxxxx Codeplay	1
size. The alternative solution of	1
size. This is because the	1
size. If this is the	1
size. In other words, it	1
size. In fact, the STL	1
size. There is a disadvantage	1
size. I tried to make	1
size. However, it is inefficient	1
size. Integer operations are fast	1
size. When the critical function	1
size. Alternatively, you may actively	1
size. Vectorized code is more	1
size. Integers of smaller sizes	1
size. Today, it is not	1
size. Unpredictable branches that select	1
size. Later models had the	1
network is overloaded or the	1
network is unstable or if	1
network and other resources than	1
network or database is heavily	1
network with heavy traffic and	1
network may be both cheaper	1
network access to virus attacks	1
network access in separate threads	1
network access may be fast	1
network resources and servers should	1
network resources are not recommended	1
network resources cannot be controlled.	1
network resources. This time is	1
network resources, databases, etc. The	1
network connections. Temporary files that	1
slow and fragmented hard disk.	1
slow // Division by a	1
slow // Modulo by a	1
slow or completely absent in	1
slow instruction that you are	1
slow bit scan instruction and	1
slow bit scan instructions. My	1
slow unless the size of	1
slow unless the Pentium-II or	1
slow implementations of this bit	1
slow GOT lookup process is	1
slow down the execution to	1
slow down the execution considerably.	1
slow down a program for	1
slow CPU, an insufficient amount	1
b) is calculated in advance	1
b) a && !a =	1
b) = (a >= b)	1
b) - n.a. Floating point	1
b) { if (b) {	4
b) { return a >	1
b) + (c + d);	1
b) But beware of the	1
b) etc. at compile time.	1
b) y = MAX(f(x), g(x));	1
b) >> n with a	1
b) {x = a; y	1
>= size can be replaced	1
>= 0; i--, x++) factorial	1
>= b) - n.a. Floating	1
>= (unsigned int)size) { cout	1
>= 2) SelectAddMul_pointer = &SelectAddMul_SSE2;	1
>= 4) { // SSE2	2
>= 8) SelectAddMul_pointer = &SelectAddMul_AVX2;	1
>= size) { cout <<	1
>= 5) SelectAddMul_pointer = &SelectAddMul_SSE41;	1
>= 11) { // AVX	2
>= min && i <=	1
>= operators). The same argument	1
>= N) { // Array	1
desired function version // Get	1
desired program structure. It is	1
desired instruction set (/arch:SSE2, /arch:AVX	1
desired instruction set. If the	1
desired version of the function.	1
desired version in a procedure	1
desired new features. User feedback	1
desired function. The PLT entry	1
desired parameters typedef int CriticalFunctionType(int	1
desired values before the program	1
desired version. Note that the	1
desired polymorphism effect with templates	1
desired functionality without polymorphism or	1
desired measurement instruments into the	1
desired interval is a power	1
Such a branch will be	1
Such a processor will have	1
Such a list is almost	1
Such a soft processor is	1
Such a coprocessor might also	1
Such an extra framework can	1
Such variables and objects will	1
Such variables have one instance	1
Such dependency chains can be	1
Such units can be used	1
Such schemes are frequent sources	1
Such schemes cause problems when	1
Such frameworks are frequent sources	1
Such events as task switches	1
Such hybrid solutions are now	1
#pragma vector always to tell	1
#pragma vector always #pragma vector	1
#pragma vector always Optimize function	1
#pragma vector aligned or the	1
#pragma vector aligned #pragma vector	1
#pragma vector aligned Assume pointer	1
#pragma vector nontemporal is used.	1
#pragma vector nontemporal Table 18.3.	1
#pragma vector nontemporal #pragma vector	1
#pragma ivdep Assume function is	1
#pragma ivdep __restrict #pragma ivdep	1
#pragma optimize("a",on). Specifies that pointer	1
#pragma optimize(...) Fastcall function __fastcall	1
#pragma optimize("a", on) __restrict __restrict	1
#pragma novector to tell the	1
Dynamic memory allocation is done	1
Dynamic memory allocation is particularly	1
Dynamic memory allocation can therefore	1
Dynamic memory allocation may be	1
Dynamic memory allocation also tends	1
Dynamic memory allocation Dynamic memory	1
Dynamic memory allocation Any array	1
Dynamic memory allocation Objects and	1
Dynamic memory allocation ...................................................................................... 90	1
Dynamic libraries are less efficient	1
Dynamic linking and position-independent code	2
Dynamic linking makes it necessary	1
Dynamic linking works differently. The	1
Dynamic cast The dynamic_cast operator	1
functions, and other complications that	1
functions, and put seldom used	1
functions, or if this is	1
functions, but the function names	1
functions, but in a very	1
functions, but less optimized. Note	1
functions, but unfortunately there is	1
functions, where static has a	1
functions, called procedure linkage table	1
functions, etc. in vectors. These	1
functions, etc. are implemented in	1
functions, inline assembly or easy	1
functions, trigonometric functions, etc. in	1
functions, trigonometric functions, etc. are	1
functions, classes, templates or modules	1
whole program by turning off	1
whole program optimization or for	1
whole program optimization Some compilers	1
whole program optimization. This works	1
whole program optimization. 2.4 Choice	1
whole program execution, even if	1
whole program optimization, which will	1
whole program 81 optimization is	1
whole loop will take only	1
whole software project together and	1
whole software package, including all	1
whole structure of the problem.	1
whole program. During the history	1
whole polygon or bitmap than	1
whole workday or more. Many	1
inefficient to use an integer	1
inefficient to use 32-bit integers	1
inefficient in large applications. The	1
inefficient if the list is	1
inefficient if a program creates	1
inefficient when the floating point	1
inefficient because the compiler must	1
inefficient because the body of	1
inefficient because of the costs	1
inefficient because it is accessed	1
inefficient virtual function dispatch process.	1
inefficient way. The Codeplay compiler	1
inefficient way. See page and	1
inefficient solution. Many containers use	1
inefficient code-based methods or require	1
level-2 cache is 512 kb	1
level-2 cache is 512 kb,	1
level-2 cache of 256 Kbytes	1
level-2 cache and the data	1
level-2 cache are so expensive	1
level-2 cache as when contentions	1
level-2 cache from loading any	1
level-2 cache because the out-of-order	1
level-2 cache cannot prefetch more	1
level-2 cache contentions than for	1
level-2 cache contentions will occur:	1
level-2 cache miss can be	1
level-2 cache. The level-2 cache	1
level-2 cache. This has a	1
level-2 cache. Using the nontemporal	1
response is delayed for several	1
response to pressing a key	1
response time is so long	1
response time is consistent for	1
response time to user input	1
response time to e.g. a	1
response time under worst-case conditions.	1
response from a hard disk	1
response times to simple things	1
response times to keyboard and	1
response times for user input.	1
response times for simple tasks	1
response times for network resources	1
response times. It is often	1
response times, even for simple	1
described a mechanism called stack	1
described in the Gnu manual	1
described in the subsequent manuals.	1
described in the sections below.	1
described in the book "Performance	1
described in this chapter. Using	1
described in more detail in	1
described in chapter 12. Most	1
described in chapter 11. Using	1
described in detail in manual	1
described on page 153. A	1
described some of the considerations	1
described above can still be	1
described below. The program will	1
described below. Make calls directly	1
2. The compiler has not	1
2. The instruction add ebx,	1
2. The following example illustrates	1
2. The result is the	1
2. Example: // Example 14.8	1
2. Example: // Example 14.6	1
2. Use the latest version	1
2. Using hexadecimal numbers, we	1
2. (See page 71). The	1
2. Optimizing subroutines in assembly	1
2. Position-independent code. All addresses	1
2. Objects bigger than 16	1
2. Contentions in the level-1	1
2. Check that all code	1
2. Put the function or	1
variables. The negative effects of	1
variables. This includes pointers and	1
variables. A positive overflow of	1
variables. It is important to	1
variables. In these examples we	1
variables. See chapter 10 page	1
variables. Example: // Example 12.2	1
variables. All global variables (i.e.	1
variables. (See thread-local storage p.	1
variables. Vector operations are available	1
variables. Obviously, this is not	1
variables. They can be accessed	1
variables. 9.5 Alignment of data	1
variables. 31 7.3 Floating point	1
variables. Move the conversions out	1
lines is 8*1024/64 = 128.	1
lines to use for a	1
lines and sets. Let me	1
lines in the set can	1
lines in a 512 512	1
lines in set number 28.	1
lines in each set. If	1
lines in column 28 because	1
lines for matrix a: //	1
lines are organized as 32	1
lines from set 0x1C. If	1
lines should be split up	1
lines we used above the	1
lines follow the rows, not	1
lines belong to the same	1
hot spots and measuring the	1
hot spots in the program	1
hot spots in the code.	1
hot spots have been identified.	1
hot spots Before you start	1
hot spots .................................................................................. 16 3.3	1
hot spot and make measurements	1
hot spot that uses 90%	1
hot spot has been identified,	1
hot spot but also the	1
hot spot. Use the call	1
hot spot. Sometimes, the best	1
hot spot. Repeating the break	1
hot spots, but for studying	1
hot spots. The test should	1
Unfortunately, the compiler cannot know	1
Unfortunately, the CPU detection mechanism	1
Unfortunately, the way of declaring	1
Unfortunately, the standard libraries are	1
Unfortunately, the syntax is so	1
Unfortunately, the syntax described in	1
Unfortunately, the cross-platform compatibility is	1
Unfortunately, this method doesn't work	1
Unfortunately, many standard container classes	1
Unfortunately, some compilers unroll too	1
Unfortunately, table lookup is often	1
Unfortunately, these functions are missing	1
Unfortunately, few compilers are able	1
Unfortunately, profilers are often unreliable.	1
Unfortunately, contemporary operating systems are	1
v. 8.42n, 2004. Open Watcom	1
v. 11.1 for IA-32/Intel64, 2009.	1
v. 10.1.020. Functions _intel_fast_memcpy and	1
v. 3.1, 2007. PGI C++	1
v. 4.5.2, July 2011). Instead,	1
v. 9.0 CodeGear Borland bcc,	1
v. 1.4, 2005. Codeplay VectorC	1
v. 7.2). This library has	1
v. 5.5 Mac: Darwin8 g++	1
v. 2.00. Intel C++ compiler,	1
v. 2.1.7, 2004. No differences	1
v. 14.00 for 80x86 /	1
v. 4.1.0, 2006 (Red Hat).	1
v. 2.7, 2.8. Asmlib: v.	1
v. 7.1-4, 2008. Digital Mars	1
operation is performed on a	1
operation is performed on multiple	1
operation in the application software	1
operation that crashes the program.	1
operation can often be executed	1
operation on such processors requires	1
operation will be non-zero, and	1
operation will then be repeated	1
operation which is much faster.	1
operation using the | operator;	1
operation takes 5 clock cycles,	1
operation rather than reading or	1
operation doesn't delay the subsequent	1
operation was split into two	1
operation isolates the least significant	1
code, as the example below	1
code, as explained on page	1
code, as described in the	1
code, you may consider whether	1
code, then you may improve	1
code, which is the code	1
code, which supposedly is system-independent,	1
code, but this makes the	1
code, but there are serious	1
code, cache misses and branch	1
code, so you will never	1
code, specific preferences for the	1
code, see below. Installing a	1
code, including user interface etc.,	1
code, interpreters, just-in-time compilers, etc.,	1
instance of the data members.	1
instance of the class or	1
instance of the library into	1
instance of the template function	1
instance of the class. Storing	1
instance of a polymorphic class	1
instance of S1 in the	1
instance in main will be	1
instance for each set of	1
instance for each process when	1
instance for each thread. This	1
instance for each thread. Thread-local	1
instance for each process. A	1
instance then you may as	1
instance has its parameters replaced	1
comes to optimization, it does	1
comes to mind. In some	1
comes with the compiler, and	1
comes with most modern C++	1
comes with most distributions of	1
comes with some of the	1
comes on the market. But	1
comes when a function is	1
comes from a reliable source	1
comes from testing. Here, you	1
comes at a high price,	1
comes only in the second	1
comes before the compiler and	1
comes first when you are	1
comes automatically. There is no	1
fact that the floating point	1
fact that the Intel CPU	1
fact that the repeat count	1
fact that the representation of	1
fact that n is known	1
fact be less than the	1
fact it does not, and	1
fact by replacing a function	1
fact an integer that holds	1
fact only 64-bit execution units.	1
fact using each bit in	1
fact accessed through pointers in	1
fact doing the same thing.	1
fact represented as two 32-bit	1
fact addressed relative to the	1
find the one that works	1
find the address of the	1
find the first byte of	1
find the best algorithm. The	1
find the optimal decomposition of	1
find the right function for	1
find the GOT through a	1
find the answers in the	1
find and resolve compatibility problems.	1
find more examples of bad	1
find out which one is	1
find out whether it is	1
find hot spots Before you	1
find hot spots .................................................................................. 16	1
find elsewhere. Faster than most	1
rely on the compiler to	1
rely on the compiler bypassing	1
rely on the strict aliasing	1
rely on the assumption that	1
rely on is the feature	1
rely on a unit-test without	1
rely on compiler optimization than	1
rely on only the most	1
rely on static or global	1
rely on instructions that use	1
rely on automatic vectorization. The	1
rely on automatic prefetching so	1
rely on anything else being	1
rely on longjmp in time-critical	1
rely heavily on table lookup	1
No function or class that	1
No time is wasted on	1
No memory will be allocated	1
No program should leave a	1
No cache contentions. Use simple	1
No error return a[i]; //	1
No stack frame /Oy -fomit-	1
No exception handling /EHs- No	1
No information about the dimensions	1
No runtime type identification (RTTI)	1
No link pointer can be	1
No general statement can be	1
No loop-carried dependency chain. Nothing	1
No differences were observed between	1
No universal solution is best	1
produce the same code in	1
produce the same result. A	1
produce the optimal code for	1
produce a single result, true	1
produce no other value than	1
produce any extra code for	1
produce any extra code. It	1
produce any extra code. Dynamic	1
produce less optimal code because	1
produce 32 results when applied	1
produce Boolean output. The optimized	1
produce binary code). Supports 32-bit	1
produce tables of mathematical functions	1
produce undesired results. Integer operators	1
produce streaming audio or video	1
position-independent code is smaller because	1
position-independent code and table lookup	1
position-independent code and lazy binding	2
position-independent code by default. This	1
position-independent code when you compile	1
position-independent code Function libraries can	1
position-independent code flag in the	1
position-independent code ....................................................... 20 3.7	1
position-independent code everywhere by default.	1
position-independent code (option -fno-pic). 64	1
position-independent has the following features:	1
position-independent because this is the	1
position-independent code. These workaround methods	1
position-independent code. 147 14.12 Position-independent	1
vectorization will be advantageous or	1
vectorization then follow the advice	1
vectorization const int size =	1
vectorization less favorable: Larger data	1
vectorization (see page 107). The	1
vectorization (see page 107), OpenMP	1
vectorization works best if the	1
vectorization Automatic paralleli- zation by	1
vectorization is. Factors that make	1
vectorization ......................................................................................... 107 12.4 Using	1
vectorization leads to suboptimal code.	1
vectorization Not all code has	1
vectorization Devirtualization ---x----- x -	1
vectorization favorable: Small data types:	1
vectorization Good compilers such as	1
including the library libmmt.lib and	1
including the 64-bit versions. The	1
including the while loop, the	1
including the profiler itself. Function	1
including the terminating zero and	2
including the ability to define	1
including a header file for	1
including an IDE. Does not	1
including all runtime libraries and	1
including 32-bit and 64-bit Linux,	1
including user interface etc., can	1
including local data that don't	1
including linear algebra and statistics,	1
including relaxed floating point precision.	1
checking is explained below on	1
checking is included for the	1
checking and is therefore more	1
checking and various efficient container	1
checking for array bounds violations	1
checking for overflow, and the	1
checking if b[i] and c[i]	1
checking all the array elements	1
checking multiple values at once	1
checking multiple values at once...................................	1
checking In C++, it is	1
checking how well the compiler	1
checking template <typename T, unsigned	1
checking (see page 134) return	1
checking .................................................................................................. 134 14.3 Use	1
out-of-order execution and advanced prediction	1
out-of-order execution mechanism can prefetch	1
out-of-order execution mechanism works automatically.	1
out-of-order mechanism allows the CPU	1
out-of-order capabilities of modern CPUs,	1
out-of-order capabilities are very smart.	1
out-of-order capabilities can overlap the	1
out-of-order capabilities (see page 103)	1
out-of-order execution. The most important	1
out-of-order execution. This means that	1
out-of-order execution. It is often	1
out-of-order execution. There is no	1
out-of-order execution, as explained on	1
out-of-order execution, you have to	1
platforms and the possibility of	1
platforms and other compiled programming	1
platforms and operating systems are	1
platforms and various programming languages.	1
platforms that use big endian	1
platforms or multiple configurations with	1
platforms if the bias of	1
platforms with Windows, Linux, BSD	1
platforms with big-endian storage. All	1
platforms as well, but the	1
platforms as shown in the	1
platforms because it doesn't depend	1
platforms By Agner Fog. Technical	1
platforms (Windows, Linux, BSD, Intel-based	1
particularly time consuming. Sometimes it	1
particularly critical because they can	1
particularly useful performance monitor counter	1
particularly important on small devices	1
particularly fast on newer processors.	1
particularly slow instruction that you	1
particularly slow implementations of this	1
particularly critical. A very time-consuming	1
particularly critical. 129 13.7 CPU	1
particularly bad on a particular	1
particularly problematic because there may	1
particularly interesting because it makes	1
particularly risky because it involves	1
particularly tricky. I have used	1
given a false model number	1
given a name. #define directives	1
given in the following table.	1
given in example 14.19 below.	1
given in manual 5: "Calling	1
given in www.agner.org/optimize/cppexamples.zip. An array	1
given in advance. The disadvantages	1
given on page 136 and	1
given as a template parameter:	1
given instruction set. The following	1
given below. The time unit	1
given here may apply to	1
given task is often determined	1
given above. 7. If the	1
output of the first program.	1
output of a compiler can	1
output are unacceptable. Each of	1
output can often reveal things	1
output can produce no other	1
output more readable but unfortunately	1
output should be measured separately.	1
output option is also available	1
output option then use an	1
output after the test loop.	1
output goes to the console	1
output file. A console mode	1
output listing to see if	1
output (/FAs or -fsource-asm). This	1
level-1 and the level-2 cache.	1
level-1 data cache is 8	1
level-1 data cache of 8	1
level-1 data cache and accessed	1
level-1 data cache, where it	1
level-1 cache is used in	1
level-1 cache are less expensive.	1
level-1 cache may not be	1
level-1 cache from the level-2	1
level-1 cache contentions is that	1
level-1 cache size. This is	1
level-1 cache. The different kinds	1
level-1 cache. The advantage of	1
level-1 cache. We can take	1
resources. The system is likely	1
resources. This time is included	1
resources. In this case we	1
resources. There are various ways	1
resources. For example, a FIFO	1
resources. For these reasons, the	1
resources. But it can be	1
resources. However, the CISC instruction	1
resources. Most of the advice	1
resources. Each graphics operation in	1
resources. On the smallest devices,	1
resources. Modern CPUs are so	1
resources. Typically, a specific graphics	1
resources. Consider running the services	1
outside the loop or add	1
outside the loop if you	1
outside the loop without checking	1
outside the critical innermost loop.	1
outside the innermost loop and	1
outside the innermost loop. This	1
outside the loop. In general,	1
outside the loop. Most compilers	1
outside the bounds of valid	1
outside the loop: // Example	1
outside of any function are	1
outside this interval, for example	1
outside any function) should be	1
outside both loops // The	1
task is often determined by	1
task is divided into many	1
task of the program. Application	1
task in question. For example,	1
task that takes a long	1
task that consumes most of	1
task or thread are smaller.	1
task when the CPUID was	1
task into a separate thread	1
task must have a high	1
task switch occurs during execution	1
task switches and garbage collection	1
task switching. This cost is	1
task switches; so that it	1
limited is to do multiple	1
limited to well-tested functions, classes,	1
limited and there are no	1
limited in scope. A macro	1
limited by the throughput of	1
limited by the latency of	1
limited by physical factors. The	1
limited number of possible inputs.	1
limited number of variables can	1
limited range then a simple	1
limited resources. Most of the	1
limited resource. The CISC instruction	1
limited "express" edition is available	1
limited audience for educational purposes	1
vectorized if the code is	1
vectorized if you take into	1
vectorized with the current instruction	1
vectorized with SSE4.1 // Function	1
vectorized code or not. I	1
vectorized code when the #pragma	1
vectorized code should therefore preferably	1
vectorized as intended (see page	1
vectorized as follows (using Intel	1
vectorized table lookup Using intrinsic	1
vectorized table lookup. These instructions	1
vectorized code. Storing something in	1
vectorized #include <dvec.h> // Define	1
vectorized automatically. For example, let's	1
sometimes be replaced by //	1
sometimes be avoided by replacing	1
sometimes be obtained by the	1
sometimes be eliminated completely. For	1
sometimes it does incredibly stupid	1
sometimes have unacceptably long response	1
sometimes more efficient than functions.	1
sometimes more efficient than comparing	1
sometimes possible to obtain the	1
sometimes take more time than	1
sometimes uses 32-bit absolute addresses.	1
sometimes able to predict a	1
sometimes give misleading results or	1
sometimes unacceptably long. Lazy binding	1
local A function that is	1
local data that don't need	1
local object is overwritten, possibly	1
local object static then it	1
local objects are called. The	1
local variables and therefore likely	1
local variables in registers rather	1
local const variable means that	1
local name for local references.	1
local variable. This is efficient	1
local references. If we compile	1
local references. Shared objects in	1
local variables, and for saving	1
local non-member functions. 80 Unfortunately,	1
costs of this bookkeeping depends	1
costs of software development, and	1
costs of dynamic memory allocation.	1
costs of optimizing ............................................................................................... 4	1
costs of optimizing University courses	1
costs of position-independent code. 147	1
costs to other parts of	1
costs to such a formalism.	1
costs to multithreading that we	1
costs in terms of code	1
costs in terms of usability	1
costs are higher for shared_ptr	1
costs can be justified for	1
costs if it is good	1
S1 in the array must	1
S1 { int a; int	1
S1 { double b; //	1
S1 { float a, b,	1
S1 { short int a;	1
S1 aligned // Structure of	1
S1 x, y; ... x.a	1
S1 list[100]; int i; for	1
S1 {double a; double b;};	2
S1 ArrayOfStructures[100]; This reordering has	1
S1 ArrayOfStructures[100]; Here, there are	1
S1 list[size]; int i, j;	1
S1 list[100], *temp; for (temp	1
math is required for finding	1
math and the SSE or	1
math function library with a	1
math function libraries available. The	1
math functions should work efficiently	1
math functions such as sqrt	1
math library (SVML). This is	1
math library (VML, MKL). Works	1
math core library contains similar	1
math libraries. The Gnu C++	1
math allow addition of integers	1
math libraries: Intel vector math	1
math libraries: Intel short vector	1
math libraries: long vector libraries	1
temp a register variable in	1
temp in one iteration of	1
temp in memory. This prevents	1
temp = b * b	1
temp = a[i] + b[i];	1
temp = 3; for (i	1
temp = a+1; b =	1
temp * temp; c =	1
temp * temp; 104 }	1
temp < &list[100]; temp++) {	1
temp before it is finished	1
temp even though the logical	1
temp += 9; } Induction	1
temp / 4; Register variables	1
inlined for improved performance. A	1
inlined or cannot be calculated	1
inlined function and the function	1
inlined function for the sake	1
inlined if the inline keyword	1
inlined by declaring the function	1
inlined - no need to	1
inlined functions may not be	1
inlined so that the resulting	1
inlined even when it is	1
inlined function. The static keyword	1
inlined function. Function inlining can	1
inlined automatically by the compiler.	1
inlined 15.1b and the Gnu	1
still the same regardless of	1
still the fastest way to	1
still be in the cache.	1
still be used if the	1
still be vectorized, but the	1
still have a niche in	1
still take 10 clock cycles	1
still want to get rid	1
still uses a GOT. Another	1
still run on a CPU	1
still needs careful optimization. A	1
still give a considerable improvement	1
still consumes a lot of	1
still frustrated by unacceptably long	1
class. The static keyword has	1
class. The container class must	1
class. The child class is	1
class. The transfer of a	1
class. This is only safe	1
class. This makes data caching	1
class. This check makes dynamic_cast	1
class. It makes a runtime	1
class. Make the function return	1
class. Data members of a	1
class. Calling a member function	1
class. Storing variables in a	1
class. Which solution you prefer	1
class. Members of parent and	1
database is heavily loaded. 21	1
database in the Windows system.	1
database in Windows. It is	1
database for storing user data.	1
database can consume a lot	1
database by a plain old	1
database It can take several	1
database access. 3.10 Graphics A	1
database ...................................................................................................... 20 3.9 Other	1
database anyway if you are	1
database connections. Open files and	1
database integration, web application integration,	1
database queries is beyond the	1
database connections, etc. The C++	1
constants is very fast if	1
constants and floating point constants	1
constants in the entire program	1
constants that are never modified	1
constants are double precision by	1
constants are stored in static	1
constants are usually included as	1
constants are defined with enum,	1
constants are identical so that	1
constants can be replaced by	1
constants will be replaced by	1
constants because it can be	1
constants we can define in	1
constants Sunday, Monday, etc. are	1
bool is used as an	1
bool in order to make	1
bool a, b; b =	1
bool a, b, c, d;	2
bool b; a = b	1
bool b; if (b) {	2
bool 1 1 char, signed	1
bool a; float x, y,	1
bool b) { if (b)	4
Do not use the source	1
Do not use a stack	1
Do not use a linked	1
Do not use one container	1
Do not use lookup tables	1
Do not use STL containers.	1
Do not make a destructor	1
Do not make variables global	1
Do not read or write	1
Do not turn on correction	1
Do not mix single and	1
Do not swap the order	1
Do objects have a natural	1
Do objects have mixed types	1
frame is used for debugging	1
frame function is a function	1
frame function can be turned	1
frame function or by turning	1
frame function because the stack	1
frame function into a leaf	1
frame functions for reasons explained	1
frame functions then the code	1
frame makes function calls faster	1
frame functions. A frame function	1
frame functions. While an empty	1
frame unless your program relies	1
frame function, while a function	1
frame /Oy -fomit- frame- pointer	1
== 2 // make dispatcher	1
== 2 #define FUNCNAME SelectAddMul_SSE2	1
== 2 12.6 Transforming serial	1
== 8 #define FUNCNAME SelectAddMul_AVX2	1
== 5 #define FUNCNAME SelectAddMul_SSE41	1
== 0) { // Cache	1
== 0) { if (b	1
== 0) { d =	1
== 0) { FuncA(i); }	1
== 0) ? 1.0f :	1
== Wednesday || Day ==	1
== EXCEPTION_FLT_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER :	1
== Friday) { DoThisThreeTimesAWeek(); }	1
== Tuesday || Day ==	1
d; a = b +	1
d; // 2 bytes. first	1
d; // makes intermediate object	1
d; // 4 bytes. first	1
d; if (a != 0)	1
d; This expression is calculated	1
d; int i[2]; } u;	1
d; unsigned int u[2]} a[size];	1
d; c = a &	1
d; c = a &&	1
d; }; void Func() {	1
d; d = u; If	1
d; d = (double)(signed int)u;	2
special vector registers. The maximum	1
special loop predictor. On other	1
special cache called the branch	1
special cases such as multiple	1
special cases where the data	1
special versions of the strlen	1
special feature that the object	1
special position-independent code is smaller	1
special reasons to use denormal	1
special purposes are also available.	1
special purpose libraries are also	1
special trick which is used	1
special precautions for speeding up	1
special mathe- matical applications. But	1
prevent the compiler from making	1
prevent the compiler from doing	1
prevent the CPU from doing	1
prevent it from fully utilizing	1
prevent this kind of problems	1
prevent memory leaks and other	1
prevent cache contention. You may	1
prevent two threads from attempting	1
prevent such errors is to	1
prevent such errors in programs	1
prevent such errors. See page	1
prevent optimizing // Time //	1
prevent optimization. The debugger cannot	1
prevent legitimate backup copying without	1
shift and add Divide by	1
shift in software writing style	1
shift out the sign bit	2
shift out sign bit: absvalue	1
shift operations take only one	1
shift Floating point algebra reductions:	1
shift operation which is much	1
shift right = divide by	1
shift operations. Multiplying by a	1
shift down sign bit of	1
shift operation. For example,a *	1
shift operation. x*8 is replaced	1
shift operation, which is much	1
destructor the object has no	1
destructor is as efficient as	2
destructor is called when the	1
destructor of x. This is	1
destructor to make sure everything	1
destructor to call or any	1
destructor for the object x	1
destructor that makes sure the	1
destructor that needs to be	1
destructor that destroys any memory	1
destructor if it is not	1
destructor by constructing the object	1
destructor causes another exception. 64	1
save a lot of cache	1
save by avoiding the virtual	1
save time for the user.	1
save one unit of received	1
save cache space or make	1
save some information for the	1
save time. The code cache	1
save several clock cycles. You	1
save exception handling information. Each	1
save temp in memory. This	1
save RAM space, if necessary,	1
save ebx on stack ;	1
save power. There are various	1
save recovery information for function	1
prevents the compiler from making	3
prevents the compiler from doing	1
prevents the compiler from aligning	1
prevents the use of register	1
prevents the CPU from doing	1
prevents the CPU from overlapping	1
prevents the level-2 cache from	1
prevents a faster vectorized code.	1
prevents it from making optimizations	1
prevents all optimizations on the	1
prevents certain optimizations. Do not	1
prevents out-of-order execution. It is	1
preceding one is called a	1
preceding one (see page 71).	1
preceding value of sum. The	1
preceding example, this is not	1
preceding branches and the number	1
preceding addition is finished. The	1
preceding addition then you will	1
preceding iteration is finished. Example:	1
preceding label plus one, because	1
preceding one. This prevents the	1
preceding one. You can improve	1
preceding paragraph and manual 3:	1
preceding paragraph described a mechanism	1
preceding row. The same advice	1
safe to use algebraic manipulations	1
safe to make a pointer	1
safe to do the reductions	1
safe and flexible, but quite	1
safe if it has the	1
safe if multiple threads can	1
safe if there are allocated	1
safe if there are wrapper	1
safe than the C-style type-casting	1
safe way to handle an	1
safe way in case of	1
safe programming practice, of course,	1
safe unless the length of	1
safe formula a[i] = log(b[i])	1
d in assembly language is	1
d = a | b;	1
d = a || b;	1
d = 0; } else	1
d = 1; } This	1
d = u; If you	1
d = x- x- x	1
d = ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x =	1
d = (double)(signed int)u; //	1
d = (double)(signed int)u; 14.9	1
d = 1.6; int a,	1
d + 3.5; Here, the	1
d + e + f;	1
d would all be below	1
Choice of function libraries Some	1
Choice of function libraries........................................................................................ 12	1
Choice of compiler There are	1
Choice of compiler .................................................................................................... 10	1
Choice of operating system All	1
Choice of operating system......................................................................................... 6	1
Choice of user interface framework	1
Choice of user interface framework...........................................................................	1
Choice of programming language Before	1
Choice of programming language ...............................................................................	1
Choice of hardware platform The	1
Choice of hardware platform .......................................................................................	1
Choice of microprocessor The benchmark	1
Choice of microprocessor ........................................................................................... 6	1
tell the compiler to assume	1
tell the compiler to vectorize,	1
tell the compiler that the	1
tell the compiler that a	1
tell the compiler that you	1
tell the compiler that this	1
tell the compiler not to	1
tell the compiler e.g. how	1
tell the compiler explicitly that	1
tell a hyperthreading processor to	1
tell it this by making	1
tell how many times each	1
tell these compilers that a	1
tell explicitly what kind of	1
Pentium 4 and AMD processors	1
Pentium 4 with different matrix	1
Pentium 4 computer where the	1
Pentium 4 processors, and 3	1
Pentium 4 processor. Extra time	1
Pentium 4 computer. The measured	1
Pentium 4 (NetBurst) CPU is	1
Pentium CPUs which may cause	1
Pentium 4, while all newer	1
Pentium 4. The if branch	1
Pentium 4. The reason is	1
Pentium 4. Even worse, many	1
Pentium M processor may be	1
Pentium Pro instruction set makes	1
further if the loop is	1
further by using function inlining,	1
further explained in the other	1
further tested and investigated by	1
further described in the book	1
further discussion of the advantages	1
further discussion of the techniques	1
further discussion of this method.	1
further discussion of system code.	1
further optimizations. Loops with a	1
further explanation. The following example	1
further discussion. Integer to float	1
further expansions of the register	1
further extension of vector register	1
Assume that the numbers in	1
Assume that a function opens	1
Assume that a program reads	1
Assume that a loop in	1
Assume that you have two	1
Assume function is pure __attribute((	1
Assume function called only from	1
Assume function does not throw	1
Assume no pointer aliasing /Oa	1
Assume no pointer aliasing. __declspec(noalias)	1
Assume pointer is aligned #pragma	1
Assume pointer not aliased #pragma	1
Assume member function called only	1
Assume now that we are	1
efficiency is obtained when the	1
efficiency is important. A language	1
efficiency is reflected, first and	1
efficiency of the data cache	1
efficiency of the final application	1
efficiency of a loop depends	1
efficiency of different C++ language	1
efficiency of different C++ constructs	1
efficiency of different C++ constructs........................................................................	1
efficiency of 32-bit integers and	1
efficiency and code size have	1
efficiency by using rounding instead	1
efficiency then it is the	1
efficiency lies in the way	1
repeat the above example with	1
repeat or to exit the	1
repeat loop if true ;	1
repeat count is not certain	1
repeat count is large or	1
repeat count is small and	1
repeat count is near the	1
repeat count is mispredicted only	1
repeat count is odd and	1
repeat count and the calculation	1
repeat count and no branches	1
repeat count and always use	1
repeat count may be completely	1
repeat count has been reduced	1
unroll the loop and have	1
unroll the loop further if	1
unroll a loop and use	1
unroll a loop automatically if	1
unroll a loop manually unless	1
unroll a loop. Example: //	1
unroll by two then there	1
unroll option in the compiler.	1
unroll too much. Excessive loop	1
unroll loops if a high	1
unroll factor. A little math	1
unroll factor. If not, then	1
unroll factor. For example, if	1
unroll factor. Loop unrolling should	1
calls. The Gnu compiler and	1
calls. The best performance is	1
calls. The calculation of graphics	1
calls. The usability may be	1
calls. The principle of lazy	1
calls. The consequence of such	1
calls. It is recommended to	1
calls. If the bottleneck is	1
calls. There are three ways	1
calls. Example: // Example 8.20	1
calls. These are of course	1
calls. Unfortunately, the compiler cannot	1
calls. 48 Use macros instead	1
calls. Internal references to data	1
algorithm is used inside the	1
algorithm is very important for	1
algorithm of sequential instructions, where	1
algorithm in question. You may	1
algorithm in question: Put in	1
algorithm The first thing to	1
algorithm that comes to mind.	1
algorithm can do the job	1
algorithm if a simple algorithm	1
algorithm with template metaprogramming, but	1
algorithm than by optimizing the	1
algorithm before you start to	1
algorithm (e.g. QuineMcCluskey or Espresso)	1
algorithm ....................................................................................... 24 6 Development	1
sum of a long list	1
sum of 100 numbers: //	1
sum = 0; for (int	1
sum = 0; for (i=0;	1
sum = 0; int i;	1
sum = 1.f; float nfac	1
sum = (s0+s1)+(s2+s3); Now s0,	1
sum += xn / nfac;	1
sum += a[i]; The above	1
sum += a[i]; Converting an	1
sum += list[i]; This has	1
sum operator // add elements	1
sum depends on the preceding	1
sum for(inti=0;i<16;i+=4){ //Loopby4 s +=	1
strings is the old fashioned	1
strings of different lengths in	1
strings and similar objects of	1
strings in the old fashioned	1
strings in a memory pool.	1
strings in a memory pool,	1
strings in one memory pool.	1
strings in classes like string,	1
strings in character arrays is	1
strings are particularly problematic because	1
strings typically have variable lengths	1
strings including the terminating zero	2
On the other hand, the	1
On the other hand, a	1
On the other hand, it	1
On the other hand, if	1
On the smallest devices, you	1
On the contrary, the code	1
On the contrary, you should	1
On the contrary, each thread	1
On other processors, only the	1
On most compilers you can	1
On many processors, a loop	1
On big endian systems you	1
On older processors, a switch	1
exponent is a positive integer:	1
exponent is an integer known	1
exponent is stored as a	1
exponent is always normalized, if	1
exponent is biased allows us	1
exponent if there is no	1
exponent } Example 14.26 does	1
exponent + 0x3FF unsigned int	1
exponent + 0x3FFF unsigned int	1
exponent + 0x7F unsigned int	1
exponent : 8; // exponent	1
exponent : 15; // exponent	1
exponent : 11; // exponent	1
Linux, the first six integer	1
Linux, 32-bit and 64-bit. They	1
Linux, Mac Windows, Linux, Mac,	1
Linux, BSD and Mac systems	1
Linux, BSD and Mac OS	2
Linux, BSD and Mac allow	1
Linux, BSD or Mac operating	1
Linux, BSD, Windows and Mac.	1
Linux, BSD, Intel-based Mac OS,	1
Linux, sched_setaffinity). The program should	1
Linux, Mac, BSD Instruction set	1
Linux, Gnu/AT&T syntax: __asm ("fldl	1
possibility is to always use	1
possibility is to compile with	1
possibility of using the same	1
possibility of compiling multiple .cpp	1
possibility of algebraic reduction. For	1
possibility of overflow. Table 8.1	1
possibility for other optimizations, as	1
possibility for further optimizations. Loops	1
possibility for significant improvements. Making	1
possibility that the function is	1
possibility that the variable pointed	1
possibility that a particular reduction	1
possibility that such contrived examples	1
discussion of the advantages and	1
discussion of the increment and	1
discussion of the techniques of	1
discussion of this problem. 7.11	1
discussion of this method. Your	1
discussion of different algorithms for	1
discussion of efficient container classes.	1
discussion of system code. In	1
discussion of container classes on	1
discussion of aligning dynamically allocated	1
discussion of profiling. When a	1
discussion that the choice of	1
discussion forums on the Internet	1
conditions is not met then	1
conditions in a single operation.	1
conditions in a graceful way.	1
conditions in order to make	1
conditions that make it possible	1
conditions are listed on page	1
conditions are optimal. Best-case testing	1
conditions are met: the object	1
conditions are satisfied. The conditions	1
conditions are satisfied: 1. Use	1
conditions which are implemented as	1
conditions using & enum Weekdays	1
conditions enum Weekdays { Sunday,	1
non-Intel processors can be improved	1
non-Intel processors (see page 130	1
non-Intel CPUs in a suboptimal	2
non-Intel CPUs was more than	1
non-Intel CPUs unless you are	2
non-Intel processor makes the dispatcher	1
non-Intel CPUs. Includes many functions	1
non-Intel CPU. If not, then	1
non-Intel processors, as explained on	1
non-Intel machines? Possible solutions to	1
non-Intel processors). It has excellent	1
it. The load time can	1
it. The insight you gain	1
it. This is inefficient because	1
it. A dynamic library can	1
it. In C++ template metaprogramming,	1
it. There are situations where	1
it. I am using this	1
it. I am giving this	1
it. Therefore, you should avoid	1
it. Global variables may be	1
it. Possible solutions are: Avoid	1
it. Instead of returning a	1
it. Complicated code is a	1
(See page 130 for how	1
(See page 49 and manual	1
(See page 137 about division).	1
(See page 71). The conclusion	1
(See page 137). The second	1
(See page 81). 77 Pointer	1
(See also page 119). The	1
(See manual 3: "The microarchitecture	4
(See thread-local storage p. 28)	1
(See Sutter: A Pragmatic Look	1
registers. The vector class library	1
registers. The first processors that	1
registers. The maximum size of	1
registers. This problem has been	1
registers. A class member variable	1
registers. It may not be	1
registers. 64-bit Unix systems allow	1
registers. There are eight floating	1
registers. You need to check	1
registers. Example: // Example 7.24	1
registers. Disadvantages are: Long double	1
registers. Except for the simplest	1
registers. Typical candidates for register	1
maximum of four parameters to	1
maximum loop count that can	2
maximum size of each vector	1
maximum number of integer register	1
maximum number of floating point	1
maximum number of constants we	1
maximum possible memory requirement. Useful	1
maximum value in stdint.h char	1
maximum advantage of out-of-order execution.	1
maximum repeat count and the	1
maximum repeat count and always	1
maximum value. There is no	1
mode. The first two integer	1
mode. The next chapter describes	1
mode. The latter is slightly	1
mode. The 32- bit x86	1
mode. A conversion from floating	1
mode. If there are not	1
mode. See the manual for	1
mode. Some 64-bit compilers are	1
mode. Therefore, the __fastcall keyword	1
mode. Make functions local A	1
mode. 16-bit mode is used	1
mode. Storing the parameters on	1
mode. Much of the advice	1
per array element. Matrix size	1
per element for a 512	1
per element Example 9.6a Time	1
per element Example 9.6b 64	1
per element 63 63 31	1
per matrix cell for different	1
per byte of data (low	1
per vector. The simplest and	1
per vector. You may even	1
per row is a constant	1
per element. The table shows	1
per element. 100 As table	1
per point. This does not	1
testing is useful because it	1
testing a condition is relatively	1
testing and maintenance - to	1
testing and maintenance easier. I	1
testing and analyzing program performance	1
testing which version of a	1
testing all bits except the	1
testing multiple conditions in a	1
testing single assembly instructions or	1
testing contains debug information in	1
testing Most performance tests are	1
testing worst-case performance: The first	1
testing ................................................................................................ 157 17 Optimization	1
alignment is not visible in	1
alignment of arrays and structures.	1
alignment of structure and class	1
alignment to addresses divisible by	1
alignment and the resultant code	1
alignment and aliasing. Operations that	1
alignment can cause holes of	1
alignment by 16 is required.	1
alignment problem void AddTwo(int *	1
alignment problems. It is recommended	1
alignment explicitly by writing: __declspec(align(64))	1
alignment automatically. The alignment of	1
alignment requirements are less strict	1
right in order to divide	1
right = divide by 2	1
right function for a particular	1
right from the beginning rather	1
right data into the right	1
right vector elements. 12.1 AVX	1
right version of the function.	2
right version of the virtual	1
right prediction. The time it	1
right format and getting them	1
right formula in each case.	1
right positions in the vectors.	1
offset of the member relative	1
offset of the child class	1
offset of a data member	1
offset of b is 400	1
offset that is coded as	1
offset can be expressed as	1
offset as a 32-bit number.	1
offset at all. This makes	1
offset has to be expressed	1
offset table (GOT). These table	1
offset table (GOT) in order	1
offset bigger than 127 bytes	1
offset relative to the beginning	1
compatibility is not always as	1
compatibility with a lineage of	1
compatibility with some legacy software.	1
compatibility with old CPUs is	1
compatibility with older microprocessors is	1
compatibility with existing systems and	1
compatibility with legacy code, specific	1
compatibility problems and they waste	1
compatibility problems and system crash.	1
compatibility problems and system breakdown.	1
compatibility problems into account when	1
compatibility problems. Software developers should	1
compatibility problems, usability problems and	1
macro is referencing it twice.	1
macro to swap two array	1
macro to swap two elements:	1
macro in the sense that	1
macro for aligning data #ifdef	1
macro by template template <typename	1
macro as inline function #define	1
macro will interfere with any	1
macro so that each statement	1
macro parameters are evaluated every	1
macro declared with #define is	1
macro INSTRSET is used for	1
macro expansions. Programmers do, however,	1
bytes. The time it takes	1
bytes. This makes sure that	1
bytes. first // 4 unused	1
bytes. first // 4 bytes.	1
bytes. first // 6 unused	1
bytes. first byte at 0,	2
bytes. first byte at 8,	1
bytes. first byte at 12,	1
bytes. first byte at 400,	1
bytes. Some CPUs have particularly	1
bytes. Each line covers 64	1
bytes. 7.19 Class member functions	1
object. The compiler can easily	1
object. The allocation of memory	1
object. The calling function must	1
object. This so-called symbol interposition	1
object. A little-known alternative to	1
object. It is possible to	1
object. If the object is	1
object. There is no extra	1
object. Make the function modify	1
object. Any copy constructor must	1
object. Obviously, all these table	1
object. Likewise, when a global	1
object. 7.17 Structures and classes	1
100 and jumps back to	1
100 in the loop control	1
100 floating point operations (addition,	1
100 * 5 * 0.5	1
100 clock cycles. The reason	1
100 so that it can	1
100 rather than -156. Surprisingly,	1
100 / jl $B1$2 is	1
100 As table 9.3 shows,	1
100 floats for (int i	1
100 numbers: // Example 11.2a	1
100 $B1$2 ebx ; top	1
100 doubles: union {double d;	1
Note the difference between the	1
Note the difference between commas	1
Note that the CPU dispatch	1
Note that the Intel function	1
Note that the Intel compiler	1
Note that the system may	1
Note that the dispatcher function	1
Note that the C style	1
Note that there are a	1
Note that these methods are	1
Note that these directives do	1
Note that volatile doesn't mean	1
Note how efficient the calculation	1
them to apply to. It	1
them for the sake of	1
them as integers: // Example	1
them into the right positions	1
them into the executable file.	1
them into a place indicated	1
them into one thread. A	1
them static if they don't	1
them off or until the	1
them again takes extra time.	1
them separately with the appropriate	1
them all. In the case	1
them enabled (there is one	1
writing a variable from address	1
writing a file on a	1
writing a small bit at	1
writing to the same cache	2
writing to a variable in	1
writing to uncached memory and	1
writing from the same address	1
writing data files while less	1
writing big blocks is faster	1
writing small bits in a	1
writing data. Multidimensional arrays should	1
writing style are that software	1
library. The application program loads	1
library. The radical solution of	1
library. This method is useful	1
library. A runtime DLL takes	1
library. It requires support from	1
library. If the application uses	1
library. If you want a	1
library. Supports x86 and ARM	1
library. Open source. Supports all	1
library. Add to this the	1
library. Only available for 64-bit	1
library. 119 The function names	1
library. 78 Therefore, it is	1
struct { int a:4; int	1
struct S1 { int a;	1
struct S1 { double b;	1
struct S1 { float a,	1
struct S1 { short int	1
struct S1 {double a; double	2
struct abc {int a; int	1
struct Bitfield { int a:4;	1
struct Sab {int a; int	1
struct Sdouble { unsigned int	1
struct Slongdouble { unsigned int	1
struct Sfloat { unsigned int	1
calculations. The code in example	1
calculations. The time it takes	1
calculations. The program can check	1
calculations. The loop branch should	1
calculations. This should be taken	1
calculations. It is important that	1
calculations. It is necessary to	1
calculations. In other programs, 99%	1
calculations. In such cases, you	1
calculations. In some cases it	1
calculations. Even with all relevant	1
calculations. Division of a loop	1
calculations. Examples are image processing,	1
operand is not evaluated at	1
operand is not evaluated, because	1
operand is more predictable than	1
operand is faster to calculate	1
operand is evaluated only when	1
operand is infinity or NAN.	1
operand is valid. For example:	1
operand of && is false,	1
operand of || is true,	1
operand that is most often	1
operand that is calculated the	1
operand first. If one operand	1
operand determines whether the second	1
reduced to 2 by putting	1
reduced to always true or	1
reduced from 20 to 10	1
reduced number of cores in	1
reduced performance on CPUs without	1
reduced performance on non-Intel CPUs	2
reduced speed or not at	1
reduced performance. 25 Since most	1
reduced to: // Example 8.10b	1
reduced 15.1b to 15.1c, but	1
reduced 15.1a to an inlined	1
reduced 15.1a to 15.1c). 16	1
cycles. The reason is that	1
cycles. The core clock cycles	1
cycles. The rules for prediction	1
cycles. It may in some	1
cycles. If you cannot avoid	1
cycles. In most cases the	1
cycles. You can improve the	1
cycles. You cannot assume that	1
cycles. But if all the	1
cycles. Floating point comparisons are	1
cycles. Obviously, the initial value	1
cycles. Division takes 14 -	1
cycles. Calculations in a loop	1
final program and whether there	1
final size cannot be predicted	1
final size needed before adding	1
final array size right from	1
final version of the code.	1
final value of the induction	1
final result to see if	1
final result will be infinity	1
final program. This requires, of	1
final application depends on the	1
final program, it is very	1
final product. It is good	1
final destination, but don't count	1
sake of the possibility that	1
sake of compatibility with some	1
sake of compatibility with existing	1
sake of optimization. 14 Portability	1
sake of parallel execution. Example:	1
sake of fastest possible access	1
sake of portability to 64-bit	1
sake of backwards compatibility with	1
sake of efficiency. Using unaligned	1
sake of security. b &	1
sake of cross-platform portability. Unfortunately,	1
sake of modularity. For example,	1
sake of security, but may	1
operations. The most common time-consumers	1
operations. The total size of	1
operations. This can be an	1
operations. A complex digital operation	1
operations. It can be advantageous	1
operations. You may choose one	1
operations. You should use such	1
operations. All you have to	1
operations. When an integer is	1
operations. Algorithms that rely heavily	1
operations. 7.6 Pointers and references	1
operations. 105 The vector operations	1
operations. Multiplying by a power	1
When the function is called,	1
When the program is loaded,	1
When the floating point registers	1
When the most time-consuming parts	1
When the critical function is	1
When a hot spot has	1
When an integer is added	1
When you look at the	1
When used simply to increment	1
When we add a to	1
When we reach element number	1
When accessing a variable through	1
When considering whether a particular	1
tasks in a multitasking environment,	1
tasks that are running in	1
tasks are available from a	1
tasks on current Intel CPUs	1
tasks because this would give	1
tasks into multiple threads. Out-of-order	1
tasks into separate threads with	1
tasks such as copying an	1
tasks such as sorting and	1
tasks such as spell-checking and	1
tasks such as sorting, searching,	1
tasks like pressing a button	1
tasks were not divided into	1
Avoid the function scanf. Violation	1
Avoid the use of longjmp	1
Avoid the conversions by using	1
Avoid an excessive number of	1
Avoid multiple inheritance, virtual functions,	1
Avoid table lookup at the	1
Avoid long dependency chains, especially	1
Avoid virtual functions if possible.	1
Avoid branches at the vector	1
Avoid global and static variables	1
Avoid conversions between integers and	1
Avoid unnecessary functions Some programming	1
Avoid nested function calls in	1
effect is so much stronger	1
effect is much more dramatic	1
effect is simply identical. For	1
effect of the keyword volatile	1
effect of the const_cast operator	1
effect of dependency chains is	1
effect of nontemporal write instructions	1
effect can be illustrated by	1
effect with templates instead of	1
effect on the execution time	1
effect on the total execution	1
effect on performance. 7.18 Class	1
effect on older processors and	1
amount of code and data	1
amount of memory used. You	1
amount of memory space can	1
amount of memory needed in	1
amount of memory required is	1
amount of cache space used	1
amount of time. The objects	1
amount of time. A part	1
amount of work into each	1
amount of necessary communication between	1
amount of space on the	1
amount of RAM memory may	1
amount of RAM, a lot	1
variable. The compiler can use	1
variable. The different threads need	1
variable. The register keyword is	1
variable. The union forces the	1
variable. This is efficient for	1
variable. This can be useful	1
variable. For example, a double	1
variable. Example: // Example 7.26a	1
variable. Most compilers will align	1
variable. Using pointers makes it	1
variable. Make sure the value	1
variable. (This eliminates the need	1
variable. Efficiency Accessing a variable	1
time, of course, but this	1
time, it also makes the	1
time, then the code is	1
time, then the solution is	1
time, but the program is	1
time, but not the more	1
time, but also inconvenient to	1
time, but expensive if they	1
time, such as heavy mathematical	1
time, any processor that you	1
time, RAM and disk space.	1
time, except for some small	1
time, usability, program compactness, and	1
Variables and objects are stored	1
Variables and objects should preferably	1
Variables and objects declared inside	1
Variables that are used together	3
Variables that are stored in	1
Variables that are members of	1
Variables that are declared outside	1
Variables stored on the stack	1
Variables declared inside a class	2
Variables whose distance in memory	1
copying the code that it	1
copying the return statement: //	1
copying the entire list from	1
copying a large object, unless	1
copying of memory blocks, for	1
copying it Use a "move	1
copying an array or setting	1
copying different size matrices, clock	1
copying all data members. A	1
copying without effectively preventing illegitimate	1
copying them into a place	1
copying blocks of memory. These	1
copying process, and the destructor	1
optimization. The debugger cannot set	1
optimization. This works in the	1
optimization. This works by compiling	1
optimization. A mixed implementation can	1
optimization. It is also possible	1
optimization. See www.agner.org/optimize and the	1
optimization. For example, the compiler	1
optimization. 14 Portability C++ is	1
optimization. 2.4 Choice of programming	1
optimization. Everything that is said	1
optimization. 8.2 Comparison of different	1
optimization. Prefetching data The prefetch	1
optimization. en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC TR 18015,	1
accessing the same data in	1
accessing a data member is	1
accessing a variable through a	1
accessing a member of a	1
accessing a simple variable. Most	1
accessing it directly. The reason	1
accessing an object of a	1
accessing an object through a	1
accessing 32 bits of a	1
accessing arrays forwards, not backwards.	1
accessing container elements are cumbersome	1
accessing databases, network and other	1
accessing list[i].a and list[i].b. It	1
until the function returns even	1
until the program is shut	1
until the value has changed	1
until the first time the	1
until the next time the	1
until the computer is reset	1
until the computer is rebooted.	1
until the previous link pointer	1
until the residual error is	1
until a few clock cycles	1
until you turn them off	1
until 10 - 20 clock	1
until seconds has been incremented	1
performance. The Windows and Linux	1
performance. The positive effects are:	1
performance. A good optimizing compiler	1
performance. A copy constructor may	1
performance. It is useful for	1
performance. There are cases, however,	1
performance. I have no specific	1
performance. Integer size conversion //	1
performance. We must bear in	1
performance. 14.4 Integer multiplication Integer	1
performance. 25 Since most development	1
performance. 7.18 Class data members	1
performance. Stefan Goedecker and Adolfy	1
adding the first object to	1
adding the length of a	1
adding a constant to the	2
adding an integer counter and	1
adding one more integer to	1
adding any extra code. Example:	1
adding new instructions to the	1
adding n to the exponent:	1
adding throw() to the function	1
adding vectors. The operators are	1
adding bounds-checking to an array	1
adding -100 to -56 which	1
Define function type with desired	1
Define function name depending on	1
Define vector objects Vec8s a,	1
Define vector classes // Function	1
Define vector classes void SelectAddMul(short	1
Define vector classes (Intel) #include	1
Define size of squares: const	1
Define multiple threads and put	1
Define SSE2 intrinsic functions //	1
Define vectors of four floats	1
Define macro to swap two	1
Define macro for aligning data	1
Define biggest possible vector objects	1
causes the memory to become	1
causes the heap space to	1
causes a long delay. See	1
causes of compatibility problems and	1
causes an entire cache line	1
causes all writes to load	1
causes all subsequent elements in	1
causes floating point division to	1
causes another exception. 64 If	1
causes problem that were not	1
causes misses in the level-2	1
causes misses in the level-	1
causes technical problems or performance	1
processing the data in the	1
processing and image processing. Yeppp.	1
processing in C++ and Fortran.	1
processing speed exceeding that of	1
processing power of the processors	1
processing unit for other purposes	1
processing unit intended for calculating	1
processing Memory and string manipulation	1
processing capabilities still have a	1
processing instructions, multiple cores, and	1
processing power. Connecting several standard	1
processing unit. Various graphics function	1
processing unit, either on a	1
divide the data set into	1
divide the work into multiple	2
divide the work evenly between	1
divide the matrix into smaller	1
divide the job into multiple	1
divide the workload between multiple	1
divide it into multiple threads,	1
divide by 2 ; add	1
divide by 2n by subtracting	1
divide an integer with a	1
divide i by 2. The	2
so-called time stamp counter. This	1
so-called objects are instances of	1
so-called virtual table is used	1
so-called intrinsic functions. This is	1
so-called nontemporal write instructions (MOVNT)	1
so-called Java virtual machine. The	1
so-called soft processor. Such a	1
so-called position- independent code. The	1
so-called symbol interposition is intended	1
so-called partial flags stall because	1
so-called commpage. These functions are	1
so-called iterators that are used	1
so-called CPU-dispatcher that checks whether	1
clear to the reader what	1
clear and more difficult to	1
clear and well-structured code and	1
clear and intelligible way by	1
clear and modular. The so-called	1
clear that static linking is	1
clear that p is a	1
clear or mask out multiple	1
clear from this discussion that	1
clear program structure in some	1
clear whether r is a	1
clear unless the function is	1
clear correspondence between function names	1
total size of each vector	1
total number of objects is	1
total number of elements is	1
total number of elements to	1
total time. Optimizing less critical	1
total execution time because the	1
total execution time. Loop unrolling	1
total calculation time. A loop	1
total offset bigger than 127	1
total amount of code and	1
total waste of the user's	1
total size, because these are	1
total computation time. 4 Performance	1
mix the two types of	1
mix of additions and multiplications.	1
mix different kinds of operations	1
mix integer and floating point	1
mix floating point addition with	1
mix float and double Floating	1
mix float and double..................................................................................... 140	1
mix simple integer with vector	1
mix single and double precision	1
mix signed and unsigned integers	1
mix mathematical calculations with memory	1
mix nontemporal writes with normal	1
16-bit systems or 64-bit integers	1
16-bit integers or four float's	1
16-bit mode is used in	1
16-bit mode and some operating	1
16-bit Windows, allow variables to	1
16-bit integers. The branch inside	1
16-bit systems: int 16 -32768	1
16-bit systems: long int 32	1
16-bit systems: unsigned int 16	1
16-bit systems: unsigned long 32	1
16-bit programs. It is not	1
16-bit programs, except for small	1
child are typically stored in	1
child class is given as	1
child class are accessed equally	1
child class by type-casting its	1
child class through a template	1
child class name and the	1
child class name as template	1
child class members. The code	1
child classes implement the functions	1
child class. This is only	1
child class. Members of parent	1
child function: (static_cast<MyChild*>(this))->Disp(); } };	1
containers is the Standard Template	1
containers is that you don't	1
containers is 95 not needed.	1
containers in the STL are	1
containers in cases where the	1
containers for each thread than	1
containers use linked lists. A	1
containers should be identified by	1
containers should definitely be avoided	1
containers class templates in www.agner.org/optimize/cppexamples.zip.	1
containers do not have such	1
containers 93 themselves. But implementing	1
fit the size of the	1
fit the biggest vectors: for	1
fit the actual load address.	1
fit the eight-element vectors: for	4
fit into the vector. This	1
fit into a vector of	1
fit specific needs. 9.8 Strings	1
fit their CPUs. Intel's profiler	1
fit nicely into the vector	1
predict the loop control branch.	1
predict the target if the	1
predict a switch statement if	1
predict that the loop exits,	1
predict with certainty which version	1
predict which compiler will do	1
predict which variables will be	1
predict which way a branch	1
predict which resources are most	1
predict where the obstacles to	1
predict whether the compiler will	1
predict correctly whether vectorization will	1
priority is no more than	1
priority of program efficiency is	1
priority of structured software development	1
priority to one thread than	1
priority in the same processor	1
priority than the number of	1
priority than the user interface.	1
priority than code generality. The	1
priority before the test and	1
priority back to normal afterwards.	1
priority level, typically in a	1
priority thread, and only if	1
disk or other hardware often	1
disk or network. Various development	1
disk if the RAM size	1
disk because of disk caching,	1
disk often takes much more	1
disk operations to finish. 3.8	1
disk space were scarce resources.	1
disk cache. Files on remote	1
disk space. It may be	1
disk files. See page 16	1
disk copying. Security. The vulnerability	1
disk caching, but it took	1
frequency is 2 GHz then	1
frequency is limited is to	1
frequency is increased when the	1
frequency is doubled. The length	1
frequency of the CPU is	1
frequency that the CPU core	1
frequency than other CPUs, but	1
frequency may be a hundred	1
frequency may vary dynamically and	1
frequency goes up and down.	1
frequency dynamically depending on the	1
frequency (in Windows: __rdtsc()). The	1
unknown at the time the	1
unknown at the time of	3
unknown at the time it	2
unknown CPU based on its	1
unknown processors that support the	1
unknown processors properly. Many CPU	1
unknown brand or model the	1
unknown factors in the early	1
unknown sources. The above code	1
obtained in a computationally intensive	1
obtained if the critical innermost	1
obtained by the use of	1
obtained by using a pipeline	1
obtained by choosing a programming	1
obtained by dropping the graphical	1
obtained with the function ReadTSC	1
obtained with the time stamp	1
obtained with the Gnu, Clang	1
obtained with a fully compiled	1
obtained with virtual member functions.	1
obtained when the code is	1
libraries. The memory address at	1
libraries. The dynamic libraries are	1
libraries. The Gnu C++ compiler	1
libraries. A shared object has	1
libraries. C++ is an advanced	1
libraries. Use Gnu or Intel	1
libraries. These factors are explained	1
libraries. Supports 32- and 64-bit	1
libraries. Several special purpose libraries	1
libraries. To explain the difference,	1
libraries. Numbers in the table	1
libraries. www.agner.org/optimize/#vectorclass All these libraries	1
iteration is a significant contribution	1
iteration is finished. Example: //	1
iteration is repeated until the	1
iteration of the loop in	1
iteration of the loop. Some	1
iteration to the next. The	1
iteration that has to be	1
iteration it decides whether to	1
iteration should depend on the	1
iteration before the preceding iteration	1
iteration needs the result of	1
iteration (except for the loop	1
counters in all the CPU	1
counters in each CPU core).	1
counters are CPU-specific and each	1
counters can be very useful	1
counters when you are not	1
counters when they are disabled	1
counters will stay on until	1
counters before running a program	1
counters inside your program before	1
counters instead of (or in	1
counters Many CPUs have a	1
counters .................................................................... 155 16.2 The	1
Optimizing for size is relevant	1
Optimizing for speed is relevant	1
Optimizing for present processors rather	1
Optimizing memory access ............................................................................................. 87	1
Optimizing memory access 9.1 Caching	1
Optimizing compilers will often replace	1
Optimizing software in C++ An	1
Optimizing software in C++: An	1
Optimizing less critical parts of	1
Optimizing file access is more	1
Optimizing database queries is beyond	1
Optimizing subroutines in assembly language:	1
128-bit vector so that we	1
128-bit vector registers had in	1
128-bit vector register, do an	1
128-bit execution units and hence	1
128-bit XMM and 256-bit YMM	1
128-bit XMM register can be	1
128-bit XMM registers are extended	1
128-bit XMM vectors must be	1
128-bit XMM register. In example	1
128-bit operation was split into	1
128-bit vectors. The following example	1
128-bit reads. The same can	1
possibly in a different thread.	1
possibly be more (128 or	1
possibly be compiled as a	1
possibly be relevant when testing	1
possibly be obtained in a	1
possibly not with earlier CPUs.	1
possibly more serious when n	1
possibly also a lookup in	1
possibly block the execution of	1
possibly improve the code. The	1
possibly save exception handling information.	1
possibly throw an exception then	1
x, and last the second	1
x, int m) { return	1
x, unsigned int n) {	1
x, while other functions can	1
x, y; // x,y coordinates	1
x, y; x = a	1
x, y; ... x.a =	1
x, y; bool b; if	1
x, n, factorial = 1.0;	2
x, y, z; a =	1
x, y, z; bool b;	1
stack. The memory space never	1
stack. This can cause cache	1
stack. This can improve the	1
stack. This makes function calls	1
stack. This behaviour is implementation	1
stack. A static member function	1
stack. These registers have long	1
stack. Each thread has its	1
stack. Alternatively, you may define	1
stack. Is the size known	1
stack. Deallocation has no cost	1
stack. String constants and floating	1
2, x = 2.0; i	1
2, b * c); //	1
2, b * c); a.store(aa+i);	1
2, so the compiler can	1
2, 4 or 8, but	1
2, etc. This means that	1
2, 4, 8, 16, 32,	1
2, 4, etc.). Older operating	1
2, 6, 24, 120, 720,	2
2, 3, 4, 6, 9	1
2, Tuesday = 4, Wednesday	1
full use rather than a	1
full size vector. The use	1
full 64-bit addresses for everything,	1
full advantage of a new	1
full information about the performance	1
full optimization. It is also	1
full 128-bit execution units and	1
full declaration of c1 before	1
full metaprogramming features, including the	1
full debugging support which is	1
full speed. A simple solution	1
full generality and flexibility of	1
Another function __intel_cpu_features_init_x() does the	1
Another problem with accessing 32	1
Another disadvantage is that the	1
Another disadvantage of intermediate code	1
Another disadvantage of complicated algorithms	1
Another example: // Example 7.8	1
Another possibility is to always	1
Another possibility is to compile	1
Another thing that you can	1
Another alternative worth considering is	1
Another serious burden is the	1
Another open source compiler for	1
overloaded or the user is	1
overloaded or limited in scope.	1
overloaded function are simply treated	1
overloaded functions. 7.27 Overloaded operators	1
overloaded operators for things like	1
overloaded operators will cause the	1
overloaded operator is as efficient	1
overloaded operator is exactly as	1
overloaded operator is equivalent to	1
overloaded operators. Function parameters that	1
overloaded operators. Vectorized code often	1
overloaded assignment operator, or an	1
possible. The first count and	1
possible. The AVX instructions have	1
possible. This also makes testing	1
possible. A compiler that automatically	1
possible. See page 141. Applications	1
possible. SSE2 is always enabled	1
possible. Use inline functions An	1
possible. However, there are cases	1
possible. Don't rely on longjmp	1
possible. Template meta- programming is	1
possible. Smaller microprocessors have no	1
possible. Typically it should save	1
efficiently if the code is	1
efficiently if it is stored	1
efficiently if functions that are	1
efficiently if pieces of data	1
efficiently by better standardization of	1
efficiently with coarse-grained parallelism than	1
efficiently on all sizes of	1
efficiently than static memory. If	1
efficiently when the data are	1
efficiently when data are accessed	2
efficiently from the previous value	1
models of the same brand.	1
models to avoid running the	1
models to run the most	1
models that were unknown at	2
models if the problem is	1
models on which a code	1
models on which this code	1
models have a strict formalism	1
models then you will soon	1
models rather than processor features.	1
models had the full 128-bit	1
OS and Itanium systems. The	1
OS support and is available	1
OS independent and checks both	1
OS X The code section	1
OS X make position-independent code	1
OS X operating system is	1
OS X operating systems, though	1
OS X Compilers for 32-bit	1
OS X (Darwin) are part	1
OS X, 32-bit and 64-bit.	1
OS X, unless you are	1
OS X. 14.13 System programming	1
needed. The C++ language is	1
needed. The bitwise operators produce	1
needed. This makes data caching	1
needed. You may write your	1
needed. Example: // Example 8.19.	1
needed. These complicated cases should	1
needed. All the code is	1
needed. Obviously, the best way	1
needed. Even better, you may	1
needed. Objects inside containers should	1
needed. 11 Out of order	1
needed. Predictable branches that can	1
classes. The object oriented programming	1
classes. The standard template library	1
classes. The splitting of N	1
classes. You may avoid multiple	1
classes. An appendix to this	1
classes. Each instance of a	1
classes. Unfortunately, many standard container	1
classes. Text strings are particularly	1
classes. 7.2 Integers variables and	1
classes. Size of each element,	1
classes. Security The most serious	1
classes. Including the appropriate header	1
changed to the old Pentium	1
changed to a = b	1
changed to c = a	1
changed to truncation and back	1
changed by another thread. This	1
changed then the target address	1
changed so that it has	1
changed without the risk of	1
changed to: // Example 14.5b	1
changed to: // Example 14.17b	1
changed five times. Thread-local storage	1
changed freely. The loop counter	1
true a && a =	1
true a && true =	1
true that some development tools	1
true = a, a ||	1
true = true a &&	1
true or always false: //	1
true ; unused label ;	1
true last in an &&	1
true anyway. It may be	1
true 50% of the time	1
true (1) or false (0);	1
true 10% of the time.	1
thread. The cost of task	1
thread. This method works with	1
thread. This structure or class	1
thread. This prevents the compiler	1
thread. A variable that is	1
thread. It is not good	1
thread. If you forget to	1
thread. If seconds was not	1
thread. You cannot be certain	1
thread. However, in most cases	1
thread. Pointers to contained objects?	1
thread. Thread-local storage is inefficient	1
names of the header files	1
names of inlined functions may	1
names and code addresses. The	1
names and variable names from	1
names and variable names. Remember	1
names and model numbers, but	1
names in the SVML and	1
names that begin with _mm.	1
names are not compatible with	1
names are undocumented. 2.7 Choice	1
names with suffixes such as	1
names from string functions. A	1
though the logical register that	1
though the latter has one	1
though the rules of algebra	1
though the 61 function calls	1
though the CPU-type is already	1
though it is doing two	1
though it could free the	1
though not all libraries have	1
though this only happens rarely.	1
though less user friendly. It	1
though these operating systems can	1
though future compilers may be	1
execute the loop control branch	1
execute the program, and the	1
execute a code one line	1
execute then the profiler may	1
execute then measurements can become	1
execute faster than other languages	1
execute instructions out of order	1
execute it. The load time	1
execute CriticalFunction when code and	1
execute faster. The most important	1
execute slower than intended because	1
execute _mm_empty() after the 64-bit	1
% 2 == 0) {	1
% 32 = 28. This	1
% 128 == 0) {	1
% c; a = b	1
% means modulo. For example,	1
% 3; } This can	1
% 10; a = b	1
% 10; a = (unsigned	1
% 16; a = (unsigned	1
% 16; // This is	1
% (number of sets). Here,	1
% 0x20 = 0x1C. Reading	1
mov add cmp jl $B1$3:	1
mov mov mov lea $B2$2:	1
mov mov 2:8+esp eax, edx,	1
mov mov lea $B2$2: mov	1
mov DWORD PTR [ecx+eax*4],ebx stores	1
mov xor mov $B1$2: mov	1
mov shr add sar add	1
mov eax,0. The loop body	1
mov ebx,eax / shr ebx,31	1
mov $B1$2: mov shr add	1
mov 2:8+esp eax, edx, ecx,	1
mov lea $B2$2: mov mov	1
N is a power of	2
N is a positive integer	1
N is not a power	1
N a power of 2	1
N = 0 // This	1
N = 1. This ends	1
N with the rightmost 1-bit	1
N into the individual bits	1
N elements of type T	1
N template <int N> static	1
N supports a particular instruction	1
kinds of code gives an	1
kinds of code execute faster.	1
kinds of vector math libraries:	1
kinds of variable storage are	1
kinds of variable storage Variables	1
kinds of variable storage............................................................................. 26	1
kinds of operations in order	1
kinds of costs to multithreading	1
kinds of storage. See page	1
kinds of optimizations. The results	1
kinds of jobs. For example,	1
kinds of strange and unexpected	1
details of instruction timing, assembly	1
details of cache organization for	1
details in both compiler, operating	1
details that make function calling	1
details are given in manual	1
details on when objects can	1
details on branch predictions in	1
details about how caches work	1
details about name mangling are	1
details about rounding. Pointer type	1
details depend on the hardware	1
details (www.agner.org/optimize/testp.zip). A particularly useful	1
RAM and disk space. It	1
RAM than there is, in	1
RAM than end users have.	1
RAM memory and disk space	1
RAM memory can take quite	1
RAM memory if it is	1
RAM memory may even be	1
RAM size is insufficient. The	1
RAM memory. This may be	1
RAM memory. Big arrays should	1
RAM memory. Efficient caching is	1
RAM space, if necessary, by	1
rows and columns in matrix	2
rows in the matrix longer	1
rows in a big matrix	1
rows for (c = 0;	1
rows are accessed in a	1
rows are accessed consecutively and	1
rows are indexed in a	1
rows // loop columns below	1
rows = 20, columns =	2
rows = 10, columns =	1
square by the code inside	1
square x // get next	1
square at a time. This	1
square (float a) { return	1
square blocking for the level-1	1
square blocking or tiling. This	1
square brackets mean use the	1
square brackets index, just as	1
square root and mathematical functions	2
square blocking: int r1, r2,	1
square root, RGB color difference.	1
fail to see the excessive	1
fail to start the next	1
fail to keep their CPU	1
fail to eliminate common sub-expressions.	1
fail to distinguish elements with	1
fail to recognize VIA processors	1
fail in the event that	1
fail if the object is	1
fail if the destructor causes	1
fail if an int uses	1
fail if both are negative	1
fail completely because of technical	1
purposes. The use of coprocessors	1
purposes. The most commonly used	1
purposes. The const keyword tells	1
purposes. This is advantageous because	1
purposes. This memory space is	1
purposes. If the code is	1
purposes. All these examples are	1
purposes. All dynamic memory allocation	1
purposes. However, the STL is	1
purposes. Floating point operations are	1
purposes. Unfortunately, the standard libraries	1
purposes. Available from www.agner.org/optimize/asmlib.zip. Currently	1
(e.g. in linear algebra) require	1
(e.g. with _finite()) and redo	1
(e.g. an if-else structure), the	1
(e.g. option /MT). In Linux	1
(e.g. GetLogicalProcessorInformation in Windows) to	1
(e.g. PowerPC). We can make	1
(e.g. DEC, JNZ). This solution	1
(e.g. GetProcessAffinityMask in Windows). There	1
(e.g. IsProcessorFeaturePresent in Windows). Alternatively,	1
(e.g. '>') are not permissible	1
(e.g. QuineMcCluskey or Espresso) that	1
(e.g. Sandy Bridge) because it	1
compiling the intermediate code. This	1
compiling the module with, e.g.	1
compiling in two steps. All	1
compiling for the AVX and	1
compiling for a lower instruction	1
compiling for 32-bit Mac OS	1
compiling for Windows and to	1
compiling for Linux. It can	1
compiling for AVX2, or two	1
compiling multiple .cpp files into	1
compiling without -fpic in 32-bit	1
compiling module2.cpp. The simplest way	1
convert the unsigned integer to	1
convert the result back to	1
convert it to a branch	1
convert it to signed before	1
convert an integer in the	1
convert example 15.1b to 15.1c.	1
convert example 15.1a to 151	1
convert example 12.8a to 12.8b	1
convert b from single precision	1
convert float to int. Reinterpret	1
convert unsigned integers to signed	1
convert these types to integers	1
thing is to avoid long	1
thing to do when you	1
thing to do. The reason	1
thing and the CPUID instruction	1
thing and if you look	1
thing and they are equally	1
thing that can be improved	1
thing that you can do	1
thing as p and r	1
thing at the same time,	1
thing we notice is that	2
least the same instruction set.	1
least the cache line size	1
least a large part of	1
least in some situations, and	1
least in simple cases. The	1
least at the last cache	1
least one other function. A	1
least one virtual member functions	1
least significant bit of ebx.	1
least significant n bits of	1
least recently 4 ?Func2@@YAXQAHAAH@Z ENDP	1
least temporarily. Using the methods	1
containing the functions that have	1
containing the address range from	1
containing the members of both	1
containing only constants will be	1
containing multiple streams with different	1
containing many objects can be	1
containing container classes and templates	1
containing integers. It can contain	1
containing pure function calls. Unfortunately,	1
containing thread-specific data and make	1
containing (2,2,2,2), and store the	1
containing numerical data is more	1
0) { // test sign	1
0) { // Make dynamic	1
0) { // Cache contentions	1
0) { if (n &	1
0) { if (b ==	1
0) { if (b !=	1
0) { c = 1;	1
0) { d = 0;	1
0) { FuncA(i); } else	1
0) ? 1.0f : 2.5f;	1
0) ? (cc[i] + 2)	1
0) *(p++) |= 0x20; If	1
precision. The compilers will not	1
precision. The following compiler versions	1
precision. The speed is many	1
precision. You may use the	1
precision. But the software implementation	1
precision. These conversions take a	1
precision. Using double precision in	1
precision. When the floating point	1
precision. Conversions between different precisions	1
precision. And who would know	1
precision. Let's repeat the above	1
precision. Long double precision takes	1
algebraic expressions on seven different	1
algebraic expressions using the fundamental	1
algebraic reductions in my test	1
algebraic reductions are not permissible	1
algebraic reductions on floating point	2
algebraic reductions such as -(-a)	1
algebraic reductions explicitly in many	1
algebraic expressions. For example, only	1
algebraic manipulations of floating point	1
algebraic manipulations on integer expressions	1
algebraic reduction. For example, a	1
structures to addresses divisible by	1
structures and classes. The object	1
structures in the end when	1
structures for standard tasks such	1
structures that typically use pointers	1
structures are accessed through pointers	1
structures by 16 for SSE2,	1
structures with non-sequential access and	1
structures with First-In-First-Out or First-In-Last-Out	1
structures It is not always	1
structures ............................................................. 96 9.11 Explicit	1
structures (without member functions) has	1
little or no overhead while	1
little or no idea how	1
little more complicated if the	1
little more syntax check. It	1
little data for analysis. If	1
little faster than 32-bit programs	1
little work as possible. Typically	1
little space in the code	1
little overhead to the allocation	1
little math is required for	1
little explanation. The value of	1
little odd here. The address	1
Any function that needs to	1
Any code that accesses b	1
Any other allocated resource. The	1
Any floating point operation on	1
Any array or object that	1
Any pointers to data in	1
Any language that requires compilation	1
Any specific bottleneck or any	1
Any copy constructor must be	1
Any expression that is an	1
Any task that takes a	1
Any writable data section needs	1
logical register that appears in	1
logical processors available in the	1
logical processors available can be	1
logical processors usually share the	1
logical processors (0, 2, 4,	1
logical processor is not an	1
logical structure and clarity of	1
logical processors. There is no	1
logical processors. Hyperthreading is Intel's	1
logical register. This advantage comes	1
logical architecture of the software.	1
logical sequence. If you know	1
level of optimization is needed.	1
level of optimization can sometimes	1
level of abstraction which makes	1
level = InstructionSet(); // Set	2
level framework based on intermediate	1
level framework still consumes a	1
level linking (remove unreferen- ced	1
level framework. The optimized part	1
level 9. Avoid table lookup	1
level 108 You may look	1
level linking" if available. See	1
access. The code section needs	1
access. The compiler may not	1
access. The execution core of	1
access. Assume that a program	1
access. 12 Using vector operations	1
access. Reading or writing big	1
access. Available protocols and standardized	1
access. 7.20 Virtual member functions	1
access. 3.10 Graphics A graphical	1
access. 12.9 Aligning RGB video	1
access. Sequential forward access to	1
access. Run multiple processes or	1
bitwise operators is more advantageous	1
bitwise operators for checking multiple	2
bitwise operators are single instructions	1
bitwise operators are calculated much	1
bitwise operators using integers as	1
bitwise operators produce 32 results	1
bitwise operators &, |, ^,	1
bitwise operators &, |, ~.	1
bitwise operators (& and |)	1
bitwise AND operation isolates the	1
bitwise OR operator, which can	1
handle the strings including the	2
handle is invalid. Boolean variables	1
handle an unrecoverable error without	1
handle only known processors. Other	1
handle one square at a	1
handle its own block of	1
handle eight elements at a	1
handle strings is the old	1
handle unknown processors properly. Many	1
handle current CPUs optimally. The	1
handle text strings in the	1
heap is reserved for dynamic	1
heap to be filled up.	1
heap can easily become fragmented	1
heap has become fragmented. This	1
heap space to become fragmented.	1
heap space has become too	1
heap space becomes fragmented when	1
heap manager for each allocated	1
heap manager can spend a	1
heap manager will start garbage	1
heap manager has a garbage	1
heap management and garbage collection.	1
DWORD PTR [edx] DWORD PTR	1
DWORD PTR [edx] DWORD PTR[ecx+eax*4],ebx	1
DWORD PTR [edx] adds, not	1
DWORD PTR [esp+8] DWORD PTR	1
DWORD PTR [esp+8] eax, eax	1
DWORD PTR [eax+400] DWORD PTR	1
DWORD PTR [eax+4], ecx 86	1
DWORD PTR [esp+4] DWORD PTR	1
DWORD PTR [ecx+eax*4],ebx stores this	1
DWORD PTR [esp+12] ; edx	1
DWORD PTR [eax], ecx DWORD	1
DWORD PTR[ecx+eax*4],ebx eax, 1 eax,	1
Other compilers need assembly code	1
Other compilers offer the possibility	1
Other system resources .......................................................................................... 21	1
Other system resources Writes to	1
Other cases of stack unwinding	2
Other programs use time searching	1
Other tasks such as spell-checking	1
Other brands or models that	1
Other manuals by Agner Fog	1
Other databases Many software applications	1
Other databases ....................................................................................................... 21 3.10	1
during the development of a	1
during the loop. It is	1
during the installation process or	1
during the update process. 3.5	1
during this time has been	1
during time measurements to avoid	1
during program execution then it	1
during program development, and a	1
during execution of CriticalFunction. You	1
during start of the program,	1
during installation of the program	1
during installation of the framework	1
initialized to zero by using	1
initialized to desired values before	1
initialized to valid values or	1
initialized or comes from a	1
initialized by a list should	1
initialized when the function is	1
initialized when the program is	2
initialized only the first time	1
initialized variables that may be	1
initialized arrays. I have no	1
occur and recovering from error	1
occur in the multiplication b[i]*c[i],	1
occur in the level-2 cache	1
occur in the level-2 cache.	1
occur in this hot spot.	1
occur in multiplication here: a[i]	1
occur if a program has	1
occur as a result of	1
occur at random times and	1
occur has the unfortunate consequence	1
occur quite often as a	1
target of branches and function	1
target if the changes of	1
target address is likely to	1
target address is predicted if	1
target address can be predicted.	1
target buffer is also a	1
target buffer can occur if	1
target buffer (BTB). Contentions in	1
target pointed to is known.	1
target buffer. Contentions in the	1
target buffer, branch pattern history,	1
especially in floating point expressions	1
especially in 32-bit mode. The	1
especially in 32-bit mode. If	1
especially in 32-bit mode, for	1
especially if the code involves	1
especially if the user has	1
especially if the branches are	1
especially if there is no	1
especially on the Pentium 4	1
especially when the code mixes	1
especially loop-carried dependency chains with	1
smart and other things very	1
smart pointer is an object	1
smart pointer is created, deleted,	1
smart pointer may be considered	1
smart pointer then you may	1
smart pointer (see page 38).	1
smart pointers is to make	1
smart pointers are auto_ptr and	1
smart pointer. If a program	1
smart pointer. But there is	1
smart pointer. Accessing an object	1
includes the time it takes	1
includes the critical functions and	1
includes the libraries named MKL,	1
includes the addresses of library	1
includes the low-level C language	1
includes only the part of	1
includes static variables, floating point	1
includes pointers and references, which	1
includes optimized versions of memory	1
includes standard function libraries. Several	1
includes languages such as C#,	1
entire program in multiple versions	1
entire program will be joined	1
entire cache line to be	1
entire floating point library. If	1
entire library (or at least	1
entire 64 or 0x40 bytes	1
entire file in a memory	1
entire list from static memory	1
entire level-1 cache is used	1
entire object. Any copy constructor	1
entire contents copied to the	1
executable to a function in	1
executable to be as small	1
executable has the same name	1
executable because it is sure	1
executable code. Most implementations of	1
executable file and all the	1
executable file and one or	1
executable file when static linking	1
executable file needs to be	1
executable file stub. If different	1
executable file. Only the executable	1
subexpression to make sure the	1
subexpression containing only constants will	1
subexpression occurs more than once	1
subexpression elimination and loop-invariant code	1
subexpression elimination x n.a. Constant	1
subexpression elimination If the same	1
subexpression c+b can be reused	1
subexpression elimin., integer Common subexpression	1
subexpression elimin., float Register variables,	1
subexpression elimination, constant propagation, and	1
subexpression elimination, constant propagation, etc.	1
insert the values in the	1
insert the piece of code	1
insert the reciprocal in the	1
insert a code that copies	1
insert a switch in your	1
insert a fixed breakpoint in	1
insert an instruction that the	1
insert only the SSE2 version	1
insert any other error reporting	1
insert optimization hints as pragmas	1
insert nontemporal writes automatically in	1
nontemporal is used. However, this	1
nontemporal write instruction prevents the	1
nontemporal write instructions are not	2
nontemporal write instructions becomes noticeable.	1
nontemporal write instructions (MOVNT) are	1
nontemporal Table 18.3. Predefined macros	1
nontemporal #pragma vector nontemporal Table	1
nontemporal writes with normal writes	1
nontemporal writes automatically in vectorized	1
nontemporal writes. If the cache	1
bounds is probably the most	1
bounds of valid addresses, or	1
bounds check on n here	1
bounds checking is explained below	1
bounds checking and various efficient	1
bounds checking template <typename T,	1
bounds violations, invalid pointers, etc.	1
bounds checking, as illustrated in	1
bounds checking). An error message	1
bounds violations and invalid pointers.	1
bounds violation, integer overflow, and	1
improved is that r+i/2 could	1
improved in the following way:	1
improved by a factor 4	1
improved by using a lookup	1
improved by using one or	1
improved by using static linking	1
improved by inlining the frame	1
improved by adding an integer	1
improved by modifications of the	1
improved by consistent modularity and	1
improved performance. A copy constructor	1
SSE and SSE2 instruction sets	1
SSE and later instruction sets.	1
SSE or SSE2 instruction set,	1
SSE or higher instruction set.	1
SSE instruction set (128 bit	1
SSE double 64 2 128	1
SSE 128 bit float vectors	1
SSE Store 4 bytes without	1
SSE Store 16 bytes without	2
SSE xmmintrin.h SSE2 emmintrin.h SSE3	1
discussed in the following sections.	1
discussed in manual 2: "Optimizing	1
discussed on page 60. In	1
discussed on page 158. This	1
discussed which of the advanced	1
discussed which method is fastest	1
discussed how to identify and	1
discussed how to overcome the	1
discussed below. Many libraries for	1
discussed below. Signed / unsigned	1
discussed below. Cannot optimize across	1
updates to the operating system.	1
updates are necessary then it	1
updates if the current version	1
updates may come unpredictably at	1
updates should be optional and	1
updates should be postponed until	1
updates each time the program	1
updates through the Internet at	1
updates every time the computer	1
updates Many software programs automatically	1
updates .................................................................................................... 19 3.5 Program	1
consider the following alternatives: Make	1
consider that the bit scan	1
consider it unwise to use	1
consider if the cost of	1
consider if it is possible	1
consider if there is something	1
consider if intermediate calculations can	1
consider which method is likely	1
consider making highly optimized code	1
consider whether it is possible	1
consider whether others have done	1
loading the entire floating point	1
loading a cache line. This	1
loading a cache line: static	1
loading of the code, cache	1
loading of several drivers, configuration	1
loading of modules or resource	1
loading can be a time-consumer	1
loading any cache lines for	1
loading files or accessing databases,	1
loading ....................................................................................................... 19 3.6 Dynamic	1
loading Often, it takes more	1
below the maximum value. There	1
below the diagonal is swapped	1
below the diagonal and swap	1
below the diagonal are accessed	1
below in example 16.1. This	1
below on page 134. The	1
below 2 GB, but not	1
below diagonal // swap elements	1
below diagonal swapd(a[r][c], a[c][r]); //	1
below shows. The best way	1
below shows. It is accessed	1
reading the value from a	1
reading the performance counters inside	1
reading of the counters when	1
reading of x must wait	1
reading and writing from the	1
reading and writing data files	1
reading or writing a small	1
reading or writing small bits	1
reading as well as writing	1
reading them again takes extra	1
reading disk files. See page	1
directly to the next step	1
directly to the CPU-specific versions	1
directly to memory without loading	1
directly // Writes "Hello 1"	1
directly if the target address	1
directly with the use of	1
directly into the code rather	1
directly without using the virtual	1
directly compiled code and intermediate	1
directly compiled version is preferred	1
directly compiled code. (Compile without	1
simplest and most clean solution	1
simplest possible user interface is	1
simplest possible implementation if possible,	1
simplest way to solve this	1
simplest code. If the number	1
simplest case is a sum	1
simplest cases, but its data	1
simplest cases, composite objects are	1
simplest expressions and operators. Make	1
simplest cases. See manual 5:	1
simplest method, but it doesn't	1
situation is a waste of	1
situation is more complex if	1
situation of the maximum possible	1
situation where the loop control	1
situation where the network is	1
situation where the logic structure	1
situation where a program has	1
situation where a program chooses	1
situation where a long sequence	1
situation where a task is	1
situation where they are unavoidable.	1
message is provoked here in	1
message and then calls exit.	1
message and stop the program	1
message in a protected operating	1
message in this case. The	1
message if it is. It	1
message when it sees a	1
message loop of a graphical	1
message loop in the main	1
message function. The following example	1
message systems. All of these	1
delay the subsequent instructions. The	1
delay the availability of x	1
delay is less than the	1
delay is just long enough	1
delay is significant if a	1
delay in the CPU (See	2
delay that the end user	1
delay on lazy binding leads	1
delay comes when a function	1
delay due to the so-called	1
condition is a simple integer	1
condition is known from a	1
condition is relatively expensive, while	1
condition The most efficient loop	1
condition can be calculated by	1
condition can be reduced to	1
condition will generate the value	1
condition i < 100. It	1
condition inside the loop does	1
condition terminates the program before	1
condition clause. Comparing an integer	1
monitor counter is a counter	1
monitor counter in Intel processors	1
monitor counters in all the	1
monitor counters are CPU-specific and	1
monitor counters when they are	1
monitor counters before running a	1
monitor counters instead of (or	1
monitor counters Many CPUs have	1
monitor counters .................................................................... 155 16.2	1
monitor counters. A performance monitor	1
monitor counters. My test tool	1
resource in 32-bit systems. Virtual	1
resource for many computer users	1
resource use in system code.	1
resource use on such systems	1
resource then it may be	1
resource files from disk. Memory-hungry	1
resource problems and compatibility problems	1
resource problems that cause the	1
resource files, help files etc.	1
resource files, configuration files, help	1
resource conflicts. But if a	1
cores is to divide the	2
cores is slow. If the	1
cores and leave them enabled	1
cores in order to reserve	1
cores that do not 123	1
cores are advantageous for applications	1
cores can run eight threads	1
cores or logical processors available	1
cores or logical processors usually	1
cores will grow in the	1
parallel if certain conditions are	1
parallel vector processing capabilities still	1
parallel because it defines electrical	1
parallel calculations on vectors of	1
parallel structure that can easily	1
parallel calculations. Examples are image	1
parallel processing in C++ and	1
parallel processing, OpenMP and automatic	2
parallel execution. Example: // Example	1
parallel processing. Scott Meyers: "Effective	1
either in the carry flag	1
either in the form of	1
either by making the constant	1
either on a graphics card	1
either as a runtime DLL	1
either as static link libraries	2
either C or C++ based	1
either way. Such a branch	1
either case. Intrinsic functions look	1
either sixteen integers of 8	1
implementations of the same algorithm,	1
implementations of this bit scan	1
implementations of string classes use	1
implementations of smart pointers are	1
implementations of Java are based	1
implementations of C++, directly compiled	1
implementations of C++, Pascal and	1
implementations of Pascal used an	1
implementations are less efficient and	1
implementations use just-in-time compilation. The	1
implementations reveal a zigzag course	1
calculating the value each time	1
calculating the address of an	2
calculating the addresses of array	1
calculating the physical movements of	1
calculating the logarithm again, but	1
calculating the movements of objects	1
calculating a new value of	1
calculating a polynomial. Scheduling A	1
calculating row addresses at each	1
calculating self- relative addresses in	1
ebx is then stored at	1
ebx is pushed on the	1
ebx that was saved in	1
ebx on stack ; ecx	1
ebx as a temporary register	1
ebx from stack ; return	1
ebx ; shift down sign	1
ebx ; top of loop	1
ebx contains i/2+r. The next	1
ebx ecx, DWORD PTR [esp+8]	1
ebx restores the value of	1
generation of processors is better.	1
generation of processors that support	2
generation of CPUs increased the	1
generation of computers and my	1
generation of identifier names. We	1
generation can cause complications with	1
generation class through a template	1
generation class gets information about	1
generation class (CGrandParent) contains any	1
generation class (CParent<>) contains any	1
enable the compiler to make	1
enable the compiler to do	1
enable the compiler to reduce	1
enable the SSE2 or later	1
enable the SSE2 instruction set	2
enable the desired instruction set	1
enable one or more performance	1
enable constant propagation and other	1
enable fast floating point calculations	1
enable optimizations across modules (See	1
instructions. The automatic vectorization works	1
instructions. The 512 512 matrix	1
instructions. The built-in code is	1
instructions. This is coded as	1
instructions. A further extension of	1
instructions. There are other cache	1
instructions. Example: // Example 12.1a.	1
instructions. Function Assembly name Intrinsic	1
instructions. Each type has advantages	1
instructions. My recommendation is to	1
instructions. Intrinsic functions are supported	1
copied to the new block.	1
copied to the disk cache.	1
copied to the parameter, and	1
copied to a local variable.	1
copied or transferred from one	1
copied or moved with a	1
copied by assignment, as a	1
copied from static memory to	1
copied because the same code	1
copied into registers. A class	1
copied simply by copying all	1
e.g. the option /QaxAVX or	1
e.g. a menu click becomes	1
e.g. Intel Math Kernel Library.	1
e.g. how often a part	1
e.g. four numbers, then you	1
e.g. four floats. The same	1
e.g. every millisecond. The profiler	1
e.g. C++, and a hardware	1
e.g. AVX, AVX2 Mathematical vector	1
e.g. .R. for AVX. These	1
e.g. /arch:SSE2. The compiler will	1
keep the same precision in	1
keep the two modules contiguous	1
keep multiple memory blocks, either	1
keep pointers to all allocated	1
keep up with the expected	1
keep up with the ever	1
keep their CPU dispatchers up	1
keep together on the stack.	1
keep adding new instructions to	1
keep track of the performance	1
keep track of when they	1
PTR [edx] DWORD PTR [eax+400]	1
PTR [edx] DWORD PTR[ecx+eax*4],ebx eax,	1
PTR [edx] adds, not edx	1
PTR [esp+8] DWORD PTR [edx]	1
PTR [esp+8] eax, eax edx,	1
PTR [eax+400] DWORD PTR [eax],	1
PTR [eax+4], ecx 86 add	1
PTR [esp+4] DWORD PTR [esp+8]	1
PTR [ecx+eax*4],ebx stores this result	1
PTR [esp+12] ; edx =	1
PTR [eax], ecx DWORD PTR	1
Automatic CPU dispatch Automatic vectorization	1
Automatic vectorization const int size	1
Automatic vectorization Automatic paralleli- zation	1
Automatic vectorization ......................................................................................... 107 12.4	1
Automatic vectorization Devirtualization ---x----- x	1
Automatic vectorization Good compilers such	1
Automatic updates Many software programs	1
Automatic updates .................................................................................................... 19 3.5	1
Automatic updating of software can	1
Automatic paralleli- zation by multiple	1
Automatic updates. Automatic updating of	1
Library functions are typically small	1
Library versions tested (not up	1
Library exp function of 4	1
Library (STL) which comes with	1
Library (MKL v. 7.2). This	1
Library __vrs4_expf __vrd2_exp AMD LIBM	1
Library (WTL). A WTL application	1
Library (WTL): // Example 7.43b.	1
Library (ATL) and Windows Template	1
Library (OWL). Several graphical interface	1
Library amd_vrs4_expf amd_vrd2_exp Agner's vector	1
? a : b; }	1
? a : b) y	1
? b : c (a&&b)	1
? b : c x-xx-----	1
? c + 2 :	2
? 1 : 0] in	1
? 1.0f : 2.5f; If	1
? 1.5f : 2.6f; The	1
? (cc[i] + 2) :	1
? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {	1
defined a constructor, an overloaded	1
defined in a different module	1
defined in a separate function	1
defined in other ways than	1
defined in Intel header files	1
defined in two libraries It	1
defined with enum, const, or	1
defined as powers of 2:	1
defined inside the function. This	1
defined inside a class definition.	1
defined outside any function) should	1
Visual Studio can build code	1
Visual Studio This is a	1
Visual Studio when compiling for	1
Visual Studio IDE. Has not	1
Visual Studio optimizes reasonably well,	1
Visual Studio 2008 version). This	1
Visual Basic .NET and the	1
Visual Basic .NET, which is	1
Visual Studio. This tool can	1
Visual studio 2008, v. 9.0	1
Visual Basic, etc. But program	1
align the arrays as required,	1
align by cache line size	1
align by 4 ; mangled	1
align data members to round	1
align table by 16 float	1
align its b member by	1
align large static arrays automatically	1
align large objects and arrays	1
align ; mark end of	1
align dynamically allocated memory. It	1
align arrays. // Example 12.5.	1
sizes of the data block	1
sizes of matrices. An efficient	1
sizes to 1024 bits is	1
sizes and array indices when	1
sizes are allocated and deallocated	2
sizes other than 8, 16,	1
sizes were measured on a	1
sizes 1, 2, 3, 4,	1
sizes Integers can be different	1
sizes (char, short int) are	1
temp; for (i = 0;	1
temp; for (r = 1;	2
temp; // Define size of	1
temp; } 70 Induction variables	1
temp; c = temp /	1
temp; temp = b *	1
temp; temp = 3; for	1
temp; temp = a+1; b	1
temp; temp += 9; }	1
temp; 104 } Microprocessors with	1
allow the compiler to optimize	1
allow you to define 64-bit	1
allow you to manipulate the	1
allow vector objects as function	1
allow variables to be stored	1
allow up to fourteen parameters	2
allow addition of integers with	1
allow lazy binding of function	1
allow compile- time if and	1
allow assembly-like intrinsic functions, inline	1
PathScale and Intel compilers for	1
PathScale and Gnu compilers. See	1
PathScale compiler for Unix applications	1
PathScale compilers can in most	1
PathScale compilers can automatically detect	1
PathScale C++ compiler for 32-	1
PathScale C++ v. 3.1, 2007.	1
PathScale Gnu Intel Borland Microsoft	1
PathScale compilers. Intel C++ compiler	1
PathScale compilers. 8.3 Obstacles to	1
PathScale compilers. (The PGI compiler	1
BSD and Mac systems normally	1
BSD and Mac OS X	1
BSD and Mac OS X,	1
BSD and Mac allow up	1
BSD are identical to Linux	1
BSD or Mac operating system	1
BSD work the same way	1
BSD systems. The Intel-based Mac	1
BSD comes at a high	1
BSD Instruction set control no	1
BSD Shared objects in BSD	1
f; The compiler may interleave	1
f; int i; } x;	1
f; int i; } u;	5
f; int i; } u,	1
f; } This calculation requires	1
f; unsigned int i; }	1
f; f=i; f = (float)i;	1
previous value as xn =	1
previous value as n! =	1
previous value than from the	1
previous link pointer has been	1
previous iteration (except for the	1
previous chapter (page 146). In	1
previous value. It does this	1
previous value. Example: // Example	1
previous branch. Example: // Example	1
previous one. It may neverthe-	1
previous iteration. This allows it	1
size; i += 2) {	1
size; i++) { // Get	1
size; i++) { a[i] =	1
size; i++) { temp =	1
size; i++) { j =	1
size; i++) { b[i] =	1
size; i++) { aa[i] =	1
size; i++) { ab[i].b =	1
size; i++) a[i] = 0.0;	1
size; i++) sum += list[i];	1
size; i++) b[i] = a[i];	1
rarely the other way is	1
rarely in Linux. Address calculation	1
rarely program their own graphical	1
rarely possible for the compiler	1
rarely necessary to use assembly	1
rarely needed anyway. You may	1
rarely needed. 11 Out of	1
rarely enough to justify such	1
rarely worth the effort to	1
rarely found in other languages.	1
rarely justifies the relatively small	1
way. The first count is	1
way. The fact that the	1
way. The Codeplay compiler has	1
way. A branch that goes	1
way. If the first operand	1
way. There is no checking	1
way. You may think that	1
way. See page and 90	1
way. Such a branch will	1
way. Here you have to	1
way. First you compile the	1
vector. The use of vector	1
vector. The other STL containers	1
vector. The simplest and most	1
vector. This is a simple	1
vector. It may be worthwhile	1
vector. If n = 4,	1
vector. You may even add	1
vector. For example, if a	1
vector. These units are used	1
vector. Organize the data with	1
vector. 6. If arrays are	1
easier to use vector classes,	1
easier to write a +	1
easier to write 2.0/3.0 than	1
easier to maintain. The time	1
easier to understand when we	1
easier to test, maintain and	1
easier for the compiler to	2
easier for the CPU. Algebraic	1
easier if we use hexadecimal	1
easier said than done to	1
identical to one of the	1
identical to some other variable	1
identical to Linux in almost	1
identical for the two functions.	1
identical code for the three	1
identical so that only one	1
identical performance for 32-bit software	1
identical branches The code can	1
identical branches Eliminate jumps Eliminate	1
identical constants in the entire	1
identical pieces of code. Example:	1
20 to 10 means that	1
20 clock cycles later and	1
20 clock cycles. The rules	1
20 clock cycles. It may	1
20 times and calls alternately	1
20 Copyright notice This series	1
20 Copyright notice .......................................................................................................... 164	1
20 3.8 System database ......................................................................................................	1
20 3.9 Other databases Many	1
20 3.9 Other databases .......................................................................................................	1
20 3.7 File access................................................................................................................ 20	1
well. The conversion from example	1
well. The reason is that	1
well. This is the first	1
well. This compiler is a	1
well. A loop with a	1
well. A switch statements is	1
well. Supports three different object	1
well. Even function calls can	1
well. Open Watcom Another open	1
well. Codeplay VectorC A commercial	1
well. Very poor performance for	1
program, and the runtime framework	1
program, and one for uninitialized	1
program, and while the program	1
program, for example when you	1
program, or between different parts	1
program, it is very likely	1
program, it is likely to	1
program, you will be loading	1
program, you should choose an	1
program, one for initialized variables	1
program, especially if the branches	1
list[i] is invalid when i	1
list[i] is equal to the	1
list[i] = i % 3;	1
list[i] = 0; list[i+1] =	1
list[i] += i / 3;	1
list[i] += 1.0f; } The	1
list[i] += 1.0f; } A	1
list[i] += i_div_3; list[i+1] +=	1
list[i] > 1.0) { ...	1
list[i] << endl; // Output	1
list[i] =0; list[i+1] = 1;	1
under the worst- case conditions.	1
under the framework, during start	1
under the best-case conditions. All	1
under this unit-test may have	1
under CPU cache (en.wikipedia.org/wiki/L2_cache). The	1
under test but also the	1
under test finishes in a	1
under advanced system performance options.	1
under worst-case conditions in order	1
under worst-case conditions. Programs that	1
under test, but is less	1
expect the compiler to be	1
expect the table to be	1
expect the && expression to	1
expect a compiler to always	1
expect a compiler to reduce	1
expect a particular compiler to	1
expect a directive for a	1
expect to use later in	1
expect to 99 read from	1
expect this to be the	1
expect 64-bit programs to run	1
except the sign bit are	1
except the sign bit: //	1
except in the long double	1
except in the simplest cases,	1
except in special mathe- matical	1
except for the cases described	1
except for some small low-power	1
except for small embedded systems.	1
except for char pointers. 144	1
except when several applications use	1
except perhaps for a very	1
loops are implemented as recursive	1
loops are predicted well only	2
loops // The purpose of	1
loops or compile-time generation of	1
loops if the loop count	1
loops if a high degree	1
loops by calls to memset	1
loops would make the access	1
loops (except in Fortran where	1
loops (less than 65 bytes	1
why the compiler doesn't make	1
why it is safe to	1
why this effect is so	1
why this delaying process is	1
why all modern computers have	1
why compilers do not make	1
why object oriented programs can	1
why there is virtually no	1
why such runtime frameworks are	1
why exception handling can be	1
why bookkeeping is needed: //	1
dispatching. The code in this	1
dispatching. This function is so	1
dispatching. For example, the latest	1
dispatching. For example, you may	1
dispatching. Many Intel library functions	1
dispatching. Unfortunately, the CPU detection	1
dispatching. Obviously, you should apply	1
dispatching. Add to this the	1
dispatching. Test if the program	1
dispatching. Underestimating the cost of	1
cout << 1; } };	2
cout << 2; } };	2
cout << list[i] << endl;	1
cout << "Hello "; //	1
cout << "Hello "; Disp();	1
cout << "Error: Index out	2
cout << x.f; // will	1
references. It is OK, however,	1
references. If we compile the	1
references. 64-bit Mac OS X	1
references. There is no need	1
references. You can change what	1
references. Therefore, it will run	1
references. Most importantly, it requires	1
references. Shared objects in BSD	1
references. Arrays are always transferred	1
references. References are safer to	1
come with the Intel C++	1
come with the operating system	1
come with compilers and development	1
come from example 15.1b to	1
come from operators that produce	1
come from unknown sources. The	1
come into force when I	1
come last in a structure	1
come first. If it is	1
come unpredictably at inconvenient times.	1
statements is a kind of	1
statements The high speed of	1
statements that you want them	1
statements are most efficient if	1
statements because switch statements often	1
statements should preferably be kept	1
statements often suffer from poor	1
statements like throw(A,B,C) to tell	1
statements within each clause are	1
statements (called static if), but	1
u; if (u.i & 0x7FFFFFFF)	1
u; if (u.i[1] < 0)	1
u; int n; u.i =	1
u; int n; 143 if	1
u; If you are certain	1
u; double d; d =	3
u; u.i ^= 0x80000000; //	1
u; u.i &= 0x7FFFFFFF; //	1
SSE4.1 and one for AVX2	1
SSE4.1 and integer division. Older	1
SSE4.1 // Function to load	1
SSE4.1 // AVX2 // specific	1
SSE4.1 instruction set is enabled.	1
SSE4.1 instruction set is available:	1
SSE4.1 some more vector instructions	1
SSE4.1 gives an advantage in	1
SSE4.1 instr. set AVX instr.	1
SSE4.1 smmintrin.h SSE4.2 nmmintrin.h (MS)	1
chapter is aiming at explaining	1
chapter in manual 2: "Optimizing	1
chapter 10 page 101 for	1
chapter (page 146). In the	1
chapter 12. If the code	1
chapter 12. Most modern CPUs	1
chapter describes how this works	1
chapter 9.10, then the nontemporal	1
chapter "Register usage in kernel	1
chapter 11. Using the vector	1
similar to the Gnu compiler	1
similar to a macro in	1
similar CPU dispatch mechanisms, and	1
similar objects of variable size	1
similar method can be used	1
similar methods are further described	1
similar functions, but less optimized.	1
similar thanks to heavy competition.	1
similar solutions may some day	1
similar utility for modifying the	1
course a considerable job, but	1
course that reflects the conflicting	1
course be the easiest and	1
course be a destructor that	1
course make the program do	1
course there is no such	1
course also time consuming, especially	1
course inefficient. Variables declared inside	1
course far from optimal. The	1
course system-specific. In order to	1
back to the $B1$2 label	1
back to single precision. These	1
back to around 1980 where	1
back to normal afterwards. The	1
back in the sequence, where	1
back into the for-loop: i++;	1
back again. This may take	1
back again. If there are	1
back again. Obviously, it is	1
back again. Accessing system devices	1
risk of memory leaks if	1
risk of overflow Integer to	1
risk of overflow, such as	1
risk of overflow: // Example	1
risk of underflow. The fact	1
risk of losing precision. The	1
risk of activating the very	1
risk that the programmer forgets	1
risk that several variables happen	1
risk factor in itself, and	1
garbage collection can occur at	1
garbage collection may start at	1
garbage collection when the heap	1
garbage collection takes a considerable	1
garbage collection. The allocated memory	1
garbage collection. A more efficient	1
garbage collection. Objects that are	1
garbage collector at inconvenient times.	1
garbage collector which is likely	1
garbage collection, as mentioned above.	1
templates in www.agner.org/optimize/cppexamples.zip. These may	1
templates for several different purposes.	1
templates for polymorphism A template	1
templates are available for many	1
templates // Place non-polymorphic functions	1
templates or modules with a	1
templates where the type of	1
templates makes the code difficult	1
templates (see p. 57). It	1
templates instead of virtual functions.	1
buffer is also a cache	1
buffer and read or write	1
buffer that some microprocessors have.	1
buffer can occur if a	1
buffer or send data from	1
buffer with fixed size to	1
buffer with fixed size, not	1
buffer than as a linked	1
buffer overflow on input data	1
buffer (BTB). Contentions in the	1
header for intrinsic functions //	1
header file for the instruction	1
header file for a higher	1
header file will give you	1
header file stdint.h or inttypes.h	1
header file timingtest.h from www.agner.org/optimize/testp.zip	1
header file mathimf.h that come	1
header files are as follows:	1
header files For example, a	1
header files. 121 13 Making	1
future compilers may be able	1
future compilers will do such	1
future version of C++ should	1
future we may also see	1
future processors. There are various	1
future processors. Consider the time	1
future CPUs. Half size execution	1
future models of the same	1
future processors, and choose this	1
future due to general improvements	1
whenever the objects they point	1
whenever a function of a	1
whenever a public variable in	1
whenever a smart pointer is	1
whenever it is possible. A	1
whenever it goes another way	1
whenever it feeds a branch	1
whenever an object is copied	1
whenever an instance of the	1
whenever they are available, i.e.	1
unrolling the loop and splitting	1
unrolling the loop in this	1
unrolling is not optimal because	1
unrolling in example 14.12b and	1
unrolling should only be used	1
unrolling should preferably be avoided	1
unrolling also has disadvantages: The	1
unrolling In some cases it	1
unrolling so that the memory	1
unrolling Some compilers will unroll	1
CriticalFunction is called in a	1
CriticalFunction is called once or	1
CriticalFunction in example 13.1 can	1
CriticalFunction in example 16.2. The	1
CriticalFunction = &CriticalFunction_386; } //	1
CriticalFunction = &CriticalFunction_SSE2; } else	1
CriticalFunction = &CriticalFunction_AVX; } else	1
CriticalFunction = &CriticalFunction_Dispatch; // Lowest	1
CriticalFunction when code and data	1
CriticalFunction (); __asm__ (".type CriticalFunction,	1
swap the order of the	3
swap the operands if the	1
swap memory to disk. Memory	1
swap two array elements: #define	1
swap two elements: #define swapd(x,y)	1
swap elements // align by	1
swap elements } } }	1
swap these elements with column	1
newer instruction set when compatibility	1
newer instruction sets enable the	1
newer Intel CPUs have family	1
newer version of the same	1
newer method of doing floating	1
newer versions of Linux and	1
newer processors. The following example	1
newer processors. Many processors can	1
newer microprocessors in the x86	1
newer models that were unknown	1
fraction is stored as the	1
fraction of the time goes	1
fraction of the total time.	1
fraction 2 63 . The	1
fraction 2 23 , doublevalue	1
fraction 2 52 , longdoublevalue	1
fraction : 23; // fractional	1
fraction : 52; // fractional	1
fraction : 63; // fractional	1
fraction bits: // Example 14.29	1
modify the program to use	1
modify the carry flag (e.g.	1
modify the ones that are	1
modify a double by modifying	1
modify an existing object rather	1
modify x *const_cast<int*>(&x) += 2;}	1
modify data members. It is	1
modify example 9.5 so that	1
modify objects simultaneously. In multithreaded	1
modify x, while other functions	1
seconds to access the system	1
seconds to zero at the	1
seconds and wait until the	1
seconds = 0; while (seconds	1
seconds or microseconds as a	1
seconds has been incremented to	1
seconds because it requires the	1
seconds count to 5 }	1
seconds was not declared volatile	1
seconds remains zero in the	1
unaligned integer vector from array	3
unaligned integer vector into array	3
unaligned arrays. There are various	1
unaligned reads and writes may	1
unaligned op. Intel Core 2	1
unaligned op. AMD Opteron K8	1
address. The address of list[i]	1
address. The linker will generate	1
address. A call from the	1
address. If this address is	1
address. There are two commonly	1
address. Pointer arithmetic operations are	1
address. Pointers can be invalid	1
address. (3) look up the	1
address. Step (1) is not	1
address. Relocation is done by	1
Store the result vector in	4
Store 4 bytes without cache	1
Store 8 bytes without cache	1
Store 16 bytes without cache	3
Store result // Update induction	1
sequence of operations can be	1
sequence of calculations then you	1
sequence of calculations without the	1
sequence of calculations forms a	1
sequence of consecutive variables. Example:	1
sequence of backwards compatible instruction	1
sequence to be moved. A	1
sequence in a temporary array	1
sequence are not necessarily stored	1
sequence where each label is	1
compiler, the assumption that signed	1
compiler, and the library has	1
compiler, or vice versa. But	1
compiler, you will notice that	1
compiler, then make sure the	1
compiler, which is available from	1
compiler, operating system and CPU	1
compiler, etc. #define Alignd(X) X	1
compiler, v. 10.1.020. Functions _intel_fast_memcpy	1
compiler, linker and loader (requires	1
significant if a parameter is	1
significant as long as it	1
significant bit of ebx. The	1
significant part of the fraction.	1
significant n bits of the	1
significant effect on older processors	1
significant amount of time. A	1
significant contribution to the total	1
significant improvements. Making too many	1
significant digits, so the value	1
might be a better solution.	1
might be possible to do	2
might not be able to	1
might have other values if	1
might also be used for	1
might check for overflow by	1
might store the floating point	1
might experience unacceptably long response	1
might clash with another dynamic	1
CPU. It can be advantageous	1
CPU. If the vector registers	1
CPU. If not, then it	1
CPU. See page 130 for	1
CPU. But it is possible	1
CPU. These virtual processors can	1
CPU. These methods also work	1
CPU. Algebraic reductions Most compilers	1
CPU. Unrolling a loop becomes	1
CPU. Should we try to	1
Vector class code with automatic	1
Vector class library Intel Agner	1
Vector class libraries 113 Number	1
Vector operations are useful when	1
Vector operations are available for	1
Vector operations are particularly fast	1
Vector classes defined in Intel	1
Vector classes defined in two	1
Vector class, Intel Vector class,	1
Vector class, Agner 8 8	1
length is not known at	1
length of the string is	1
length of the desired interval	1
length of a clock cycle	3
length of a row to	1
length of a string. The	1
length of each string is	1
length function scans a string	1
sets. The program should automatically	1
sets. The different versions of	1
sets. However, the Intel libraries	1
sets. Most compilers will use	1
sets. Supports only 32-bit Windows.	1
sets. Vector operations are particularly	1
sets. Likewise, the compiler can	1
sets. Does not optimize as	1
sets. Let me explain this	1
sets. Covers PC's, workstations and	1
linear function of a loop	1
linear function of i which	1
linear array for the following	1
linear array with a top-of-stack	1
linear array will be an	1
linear list with a simple	1
linear array. No link pointer	1
linear algebra and statistics, and	1
linear search, is fast enough.	1
linear algebra) require other access	1
something to clean up then	1
something in a separate subroutine	1
something in static memory can	1
something that can be improved.	1
something that can steal the	1
something on these data. It	1
something takes 10 clock cycles	1
something takes 10 s today,	1
something about it. Possible solutions	1
something about them. You should	1
f is set by using	1
f is zero } We	1
f is added to the	1
f is nonzero } else	1
f = 1; for (i	1
f = (float)i; f =	1
f = float(i); f =	1
f = static_cast<float>(i); // Implicit	1
f cout << x.f; //	1
f *= i; return f;	1
penalty is only a negligible	1
penalty of cache misses is	1
penalty of 10 - 20	1
penalty to using inheritance. There	1
penalty for using overloaded functions.	1
penalty for mixing different floating	1
penalty for mixing single and	1
penalty for organizing data into	1
penalty when going from AVX	1
penalty should be avoided by	1
F1 is prevented from cleaning	1
F1 is supposed to call	1
F1 will never throw any	1
F1 has to check for	1
F1 has saved all information	1
F1 only if all functions	1
F1 also have an empty	1
F1 without returning. F1 is	1
F1 calls another function which	1
F1 calls another function F2	1
invalid and cause fatal errors	1
invalid in a particular situation,	1
invalid if a thread jumps	1
invalid if a was zero	1
invalid as soon as the	1
invalid when i is not	1
invalid pointers can be avoided	1
invalid pointers, etc. And it	1
invalid pointers. The absence of	1
invalid pointers. This is a	1
reasons of mathematical purity. In	1
reasons of mathematical purity. For	1
reasons to use denormal numbers.	1
reasons for this shift in	1
reasons before leaving their workplace	1
reasons explained on page 8	1
reasons explained on page 146	1
reasons explained on page 72.	1
reasons explained on page 62.	1
reasons why object oriented programs	1
setting the sign bit to	1
setting the priority back to	1
setting the fraction bits: //	1
setting the flush-to-zero mode rather	1
setting a register to zero	1
setting a thread affinity mask.	1
setting an array to all	1
setting pointers to zero whenever	1
setting these variables to zero	1
setting up a stack frame,	1
module for correctness must be	1
module or a function library.	1
module by compiling the module	1
module then the compiler would	1
module then it is convenient	1
module then add the keyword	1
module static static static static	1
module (i.e. the current .cpp	1
module __attribute__ ((visibility ("internal"))) __attribute__	1
module with, e.g. the option	1
beginning of the object or	1
beginning of the new bigger	1
beginning of the structure or	1
beginning of the structure };	1
beginning of the program. The	1
beginning of the array. eax	1
beginning of the object, and	1
beginning of a cache line.	1
beginning of list plus i*sizeof(S1).	1
beginning rather than allocating more	1
within the same shared object.	1
within the same module (i.e.	1
within the first 128 bytes	1
within the DLL use absolute	1
within the lifetime of your	1
within a certain interval: //	1
within a block of 16	1
within a limited range then	1
within a year or two.	1
within each clause are separated	1
used, for example, to convert	1
used, it is recommended to	1
used, then use #pragma vector	1
used, then there may be	1
used, but not if static	1
used, but any of the	1
used, there is simply no	1
used, even when accessed from	1
used, while the speed of	1
used, though. Some instructions are	1
checks for such errors in	1
checks for array bounds violation,	1
checks which instruction set it	1
checks where necessary (see page	1
checks where necessary. Fast versions	1
checks makes the code execute	1
checks whether the code is	1
checks whether the processor is	1
checks whether the original pointer	1
checks both the CPU and	1
input and output should be	1
input in order to make	1
input or network resources. This	1
input or reading disk files.	1
input data is a common	1
input less efficient than necessary.	1
input check if the inputs	1
input never exceeds an acceptable	1
input data. A missing check	1
input file. The output goes	1
not. The loop can still	1
not. The Intel compiler allows	1
not. The following example shows	1
not. The advise of using	1
not. There are various profilers	1
not. You cannot rely on	1
not. See page 107 for	1
not. I will conclude this	1
not. Supports 32-bit and 64-bit	1
not. Static cast The static_cast	1
programmers to some of the	1
programmers and compiler makers. 4.	1
programmers and software developers who	1
programmers and they are not	1
programmers have little or no	1
programmers have discovered that there	1
programmers use a hash table	1
programmers do not know that	1
programmers write expressions like -(-a)	1
programmers rarely program their own	1
alternative is the Windows Template	1
alternative is to run the	1
alternative is to keep multiple	1
alternative to using new and	1
alternative solution is to make	1
alternative solution of making the	1
alternative implementations are less efficient	1
alternative version. The penalty of	1
alternative worth considering is the	1
alternative implementations. 7.22 Inheritance An	1
My vector class library has	1
My example is a function	1
My example is a cache	1
My test tool can be	1
My test tool supports both	1
My own function library made	1
My recommendation is to use	1
My recommendation for good code	1
My experimental results in table	1
My preference is for C++	1
organized in a first-in-last-out fashion.	1
organized if you are making	1
organized as a vector of	1
organized as a register stack.	1
organized as 32 sets 4	1
organized as follows: // Example	1
organized into lines and sets.	1
organized into vectors. A lot	1
organized so that the last	1
organized so that the amount	1
stride is a multiple of	2
stride is 8192 / 4	1
stride and cause contentions in	1
stride for the level-2 cache	1
stride can be calculated as	1
stride will contend for the	1
stride then this can cause	1
stride (see above, page 87)	1
stride causes all writes to	1
set, and a generic version	1
set, as listed in the	1
set, then you cannot assume	1
set, but it may be	1
set, but possibly not with	1
set, one for SSE4.1 and	1
set, using asmlib library int	2
set, another version for CPUs	1
set, e.g. /arch:SSE2. The compiler	1
current instruction set. Do not	1
current compilers may not vectorize	1
current compilers don't vectorize the	1
current Intel CPUs can be	1
current array element. Rather than	1
current version satisfies the user's	1
current operating systems need better	1
current CPUs optimally. The speed	1
current .cpp file) should be	1
current position. Windows DLLs use	1
'this' is incurred on all	1
'this' in a register rather	1
'this' pointer to a pointer	1
'this' pointer in member functions	1
'this' pointer which is transferred	1
'this' pointer which does the	1
'this' pointer takes up one	1
'this' pointer. It is recommended	1
'this' pointer. You may make	1
'this' pointer, common subexpressions, and	1
problem. The compiler sometimes uses	1
problem. The most important method	1
problem. The official C standard	1
problem. This new insight can	1
problem. If the number of	1
problem. If a function is	1
problem. These instructions write directly	1
problem. Whenever the code has	1
problem. 7.11 Type conversions The	1
problem. Vectors of 256-bit size	1
3 The latest versions of	1
3 for a list of	1
3 - 4 clock cycles	1
3 - 5 clock cycles	1
3 - 6 clock cycles,	1
3 breakpoint and show a	1
3 breakpoint again. The following	1
3 Finding the biggest time	2
3 1.1 The costs of	1
counts a one parameter. Further	1
counts for threads that jump	1
counts that you should look	1
counts that you measure are	1
counts are often fluctuating and	1
counts at the CPU clock	1
counts should be multiplied by	1
counts how many times an	1
counts give the execution time	1
counts represent the "worst case"	1
gain in performance can easily	1
gain in performance over other	1
gain in speed by using	2
gain in performance. There are	1
gain if such dependency chains	1
gain by optimizing database access.	1
gain by testing and analyzing	1
gain by unrolling the loop	1
gain depends on the number	1
processors, a loop that contains	1
processors, a switch statement with	1
processors, and it is available	1
processors, and choose this method	1
processors, and 3 - 4	1
processors, as explained on page	1
processors, only the innermost loop	1
processors, but is less important	1
processors, but not on Intel	1
processors, between PC's and mainframes,	1
happen to be equal to	1
happen to be spaced by	2
happen in the code cache	1
happen that a low-priority thread	1
happen that (b*c) overflows, even	1
happen if the size of	1
happen if the size parameter	1
happen with the loops if	1
happen quite often. This is	1
enough to be noticeable but	1
enough to be annoying. We	1
enough to hold the numbers	1
enough to identify a hot	1
enough to justify the method.	1
enough to justify such a	1
enough for the specific purpose	1
enough for a specific purpose,	1
enough registers then the pointer	1
enough bits for holding the	1
apply the empty throw() specification	1
apply to other platforms and	1
apply to other platforms as	1
apply to floating point expressions.	1
apply to very big data	1
apply to arrays that are	1
apply to modulo calculations: //	1
apply as to the AVX	1
apply CPU dispatching only to	1
apply to. It is advantageous	1
Obviously, the best way to	1
Obviously, the directly compiled version	1
Obviously, the initial value of	1
Obviously, a function should never	1
Obviously, it is more efficient	1
Obviously, you should apply CPU	1
Obviously, this is not possible	1
Obviously, this is only possible	1
Obviously, all these table lookup	1
Obviously, we loose the ability	1
version. The CPU dispatcher should	1
version. The Gnu compiler often	1
version. The examples are intended	1
version. The penalty of cache	1
version. See the vectorclass manual	1
version. For team projects, it	1
version. For one-man projects, it	1
version. 2. Check that all	1
version. Note that the dispatcher	1
version. Updating mechanisms often disturb	1
row is a constant known	1
row to the address of	1
row or column. The access	1
row by adding the length	1
row + column; Do not	1
row < NUMROWS; row++) for	1
row addresses at each access.	1
row length is not known	1
row 28 below the diagonal	1
row 28 share the same	1
Compiler has insufficient information about	1
Compiler optimization options All C++	1
Compiler optimization options ................................................................................... 81	1
Compiler directives and keywords relevant	1
Compiler v. 8.42n, 2004. Open	1
Compiler v. 11.1 for IA-32/Intel64,	1
Compiler v. 14.00 for 80x86	1
Compiler identification 16 bit platform	1
Compiler Documentation for details. Note	1
Compiler Documentation". Included with Intel	1
matter of programming style. The	2
matter of programming style. It	1
matter of programming style. Some	1
matter of interpreting the same	2
matter of convenience - there	1
matter of habit, it is	1
matter and there is no	1
matter if the size is	1
declaration of the table has	1
declaration of c1 before MemberPointer	1
declaration to tell the compiler	1
declaration and the most often	1
declaration and the object files	1
declaration may in some cases	1
declaration class CChild1 : public	1
declaration makes it easier for	1
declaration size, bits minimum value	1
declaration "static" or "__attribute__((visibility ("hidden")))".	1
allocate the final array size	1
allocate a new memory block	2
allocate a new bigger memory	1
allocate a small block for	1
allocate more memory blocks than	1
allocate more space than needed.	1
allocate more RAM than there	1
allocate one big block of	1
allocate variable-size arrays with alloca.	1
series of branches every time	1
series of statements that you	1
series of five manuals is	1
series of five manuals. See	1
series of five manuals: 1.	1
series of manuals. 7.1 Different	1
series of calculations: // Example	1
series of calculations, where each	1
series of experiments on seven	1
series float Exp(float x) {	1
features of the position-independent code.	1
features of Intel C++ compilers.	1
features of Java and C#	1
features to each new version	1
features and for code that	1
features for automatic CPU dispatching.	1
features it has. Assuming that	1
features as the Microsoft compiler.	1
features rarely found in other	1
features 80386 32 bit mode	1
added a bounds check on	1
added to the first sum,	1
added to the second sum,	1
added to the offset of	1
added to a pointer then	1
added to a variable declaration	1
added to p is not	1
added and then use binary	1
added at any time, then	1
added information about the function	1
user. The advantages of using	1
user. There may be situations	1
user. Dynamic linking works differently.	1
user. Time is a precious	1
user. Making exception-safe code Assume	1
user. With the high complexity	1
user. Installation problems. The procedures	1
user. Menus, buttons, dialog boxes,	1
user. Compatibility problems. All software	1
user. Feature bloat. It is	1
to: // Example 14.14b double	1
to: // Example 14.5b if	1
to: // Example 8.15b struct	1
to: // Example 7.10b char	1
to: // Example 8.13b int	1
to: // Example 8.11b int	1
to: // Example 14.17b double	1
to: // Example 8.10b a	1
to: // Example 8.12b int	1
to: // Example 8.14b int	1
waste a lot of time	1
waste of the user's time.	1
waste of the programmers' time,	1
waste of time in most	1
waste of time for software	1
waste of cache space. A	1
waste of cache space, as	1
waste of resources. For these	1
waste of resources. Consider running	1
waste of time, it also	1
metaprogramming is the only way	1
metaprogramming in C++: Preprocessor directives.	1
metaprogramming can be used to	1
metaprogramming // Template for pow(x,N)	1
metaprogramming so complicated? Because the	1
metaprogramming would be straightforward. The	1
metaprogramming implementation analogous to example	1
metaprogramming is. // Example 15.1d.	1
metaprogramming features, including the ability	1
metaprogramming tools to be available,	1
map is needed in this	1
map are prone to even	1
map can be used if	1
map or an assembly listing.	1
map may also be an	1
map file from the linker.	1
map file includes the addresses	1
map file tells the address	1
map file /Fm Generate optimization	1
map file" option for the	1
define a structure or class	1
define a macro to swap	1
define in this way is	1
define function type typedef void	1
define function names and variable	1
define 64-bit integers, but they	1
define matrix // call transpose	1
define your own error-handling function	1
define application-specific instructions that can	1
define fprintf // define function	1
returns. The next time a	1
returns. The preferred method for	1
returns. This is because the	1
returns. There is no need	1
returns. But what if an	1
returns. Make the function construct	1
returns. Alternatively, you may reuse	1
returns. alloca may not be	1
returns. Global or static storage	1
returns. Every time a function	1
Windows. The disadvantage of 64-bit	1
Windows. The integrated development environment	1
Windows. It is more efficient	1
Windows. In 64-bit Linux, the	1
Windows. Gnu Comes with the	1
Windows. 10 Multithreading The clock	1
Windows. Borland / CodeGear /	1
Windows. Does not support the	1
Windows. Does not, by default,	1
Windows. Integrates into the Microsoft	1
style that doesn't automatically check	1
style are that software projects	1
style if it is good	1
style with character arrays. Strings	1
style as character arrays. Note	1
style has both positive and	1
style floating point code. The	1
style string functions have no	1
style type-casting with a little	1
Load library at initialization. Each	1
Load eight consecutive elements from	6
Load eight consecutive elements c.load(cc+i);	1
Load eight consecutive elements b.load(bb+i);	1
3; for (i = 0;	1
3; or __asm ("int 3");	1
3; } The compiler may	1
3; } if (b) {	1
3; } This can be	2
3; } return a +	1
3; return a - 1;	1
3; return a + 1;	1
approximately two clock cycles after	1
approximately two clock cycles. Obviously,	1
approximately three times faster. The	1
approximately 12 - 25 clock	1
approximately six in 32-bit systems	1
approximately six integer registers available	1
approximately seven significant digits, so	1
approximately so. It may fail	1
approximately 500 clock cycles. You	1
order. The same applies to	1
order. The heap manager can	1
order. The advice of making	1
order. This makes data caching	1
order. If the code in	1
order. See page 103 for	1
order. Example: // Example 14.9	1
order. Some compilers have support	1
order. Long dependency chains in	1
3: "The microarchitecture of Intel,	8
3: printf("Delta"); break; } This	1
microarchitecture of Intel, AMD and	9
easy to make floating point	1
easy to trace with a	1
easy to port to different	1
easy way to control the	1
easy way to roll out	1
easy development of user interfaces	1
easy linking to assembly language	1
easy development. For example, the	1
easy GUI development, database integration,	1
situations to avoid that some	1
situations where the compiler is	1
situations where the number of	1
situations where a vector implementation	1
situations where a high level	1
situations where code caching is	1
situations where automatic vectorization leads	1
situations where pre-increment is more	1
situations like example 12.4a where	1
implement the functions that have	1
implement the many rules of	1
implement the dispatch on first	1
implement a microprocessor in an	1
implement a queue as a	1
implement a universal algorithm (e.g.	1
implement in a compiler. Many	1
implement this "override" feature. All	1
implement OneOrTwo5[b!=0] as OneOrTwo5[(b!=0) ?	1
65 8 Optimizations in the	2
65 bytes of code). If	1
65 65 33 11.8 127	1
65 65 13.6 80.9 512	1
65 33 11.8 127 127	1
65 13.6 80.9 512 512	1
65 7.32 Preprocessing directives .........................................................................................	1
65 7.33 Namespaces........................................................................................................... 65 8	1
chosen the wrong branch. Microprocessor	1
chosen for the sake of	1
chosen for the label. It	1
chosen as the basis for	1
chosen compiler doesn't provide the	1
chosen only when running on	1
chosen version return (*CriticalFunction)(parm1, parm2);	1
chosen based on the CPUID	1
chosen expression. Example 12.4b shows	1
256-bit vector as two 128-bit	1
256-bit vector register for the	1
256-bit integer vectors. Code that	1
256-bit size are only available	1
256-bit registers named YMM in	1
256-bit instructions were splitting 256-bit	1
256-bit read operations into two	1
256-bit YMM vectors are preferably	1
256-bit YMM registers. The first	1
slightly more efficient to make	1
slightly more efficient than Sum2	1
slightly more efficient because relative	1
slightly more time. Single precision	1
slightly more resources than C	1
slightly faster in 64-bit Linux	1
slightly less efficient. In many	1
slightly less compact. See page	1
slightly less efficiently. This method	1
scattered around in memory or	1
scattered around in memory then	1
scattered around in program memory.	1
scattered around in memory. Function	1
scattered around on the hard	1
scattered around at different memory	1
scattered around at different places	1
scattered everywhere in the source	1
scattered randomly around in the	1
contain the different versions of	1
contain is provided as a	1
contain a typical degree of	1
contain all data members within	1
contain many tips on advanced	1
contain pointers or addresses that	1
contain useful discussions about code	1
contain either sixteen integers of	1
contain pure function calls and	1
writes a file can be	1
writes to any other address	1
writes to matrix a in	1
writes to load a new	1
writes or reads to the	1
writes with normal writes or	1
writes may slow down the	1
writes automatically in vectorized code	1
writes only, then the effect	1
device is a chip that	1
device than in a microprocessor	1
device should preferably be done	1
device itself is a big	1
device drivers for 64-bit Windows).	1
device drivers for Windows. 10	1
device drivers are particularly critical	1
device drivers may need assembly	1
device driver. A call to	1
independent of the loop counter.	1
independent of the value in	1
independent of changes in the	1
independent and checks both the	1
independent code more efficient. 64	1
independent then you can have	1
independent code. The name "position-independent	1
independent code, see below. Installing	1
independent divisions. Example: // Example	1
allocation. The heap can easily	1
allocation. This method also involves	1
allocation. There is no reason	1
allocation. You should avoid these	1
allocation. See page 93 for	1
allocation. Some programming languages, such	1
allocation. Dynamic memory allocation may	1
allocation. Do not use a	1
allocation. Container classes can also	1
non-static data members or member	1
non-static data members or non-static	1
non-static variables and objects declared	2
non-static member function because it	2
non-static member functions. The 'this'	1
non-static member functions. A static	1
non-static access. 7.20 Virtual member	1
subsequent elements in the sequence	1
subsequent times because of lazy	1
subsequent instructions. The 512 512	1
subsequent counts give the execution	1
subsequent counts represent the "worst	1
subsequent sections describe various ways	1
subsequent manuals are for those	1
subsequent manuals. Please note that	1
subsequent counts. This is the	1
applies to the modulo operator	1
applies to an array of	1
applies to arrays of structure	1
applies to reading as well	1
applies to BSD systems. The	1
applies to default constructors, copy	1
applies to decrement operators on	1
applies to 3-dimensional geometry and	1
applies only when elements are	1
applied to a function prototype	1
applied to a class member	1
applied to a global variable	1
applied to a local const	1
applied to a non-member function,	1
applied to all instances of	1
applied to 32-bit integers, and	1
applied to integers. It is	1
applied to integers. 7.25 Bitfields	1
destructors of each object are	1
destructors to take care of	1
destructors to call. I have	1
destructors for local objects are	1
destructors are called and resources	1
destructors are called. The safe	1
destructors A constructor is implemented	1
destructors after jumping out of	1
destructors .................................................................................. 55 7.24 Unions	1
integers. The branch inside the	1
integers. The allocation and deallocation	1
integers. It is more efficient	1
integers. It is faster than	1
integers. It can contain either	1
integers. But there are a	1
integers. Many 32-bit systems allow	1
integers. 7.25 Bitfields Bitfields may	1
integers. 7.5 Booleans The order	1
terms of code size. In	1
terms of program performance because	1
terms of execution speed to	2
terms of specific processor models	1
terms of usability problems and	1
terms of speed. Assume that	1
terms of development, testing and	1
terms in one vector. It	1
help the compiler optimize example	1
help the CPU doing multiple	1
help the programmer choosing the	1
help of the compiler (see	1
help if you want to	1
help files and other resources	1
help files and databases. The	1
help files etc. scattered around	1
help files, data base access,	1
transfer is more efficient in	1
transfer is avoided for these	1
transfer is avoided. The disadvantage	1
transfer a pointer or reference	1
transfer of a parameter of	1
transfer for 'this' is incurred	1
transfer are eliminated. Code caching	1
transfer across all .cpp modules	1
transfer ownership of the memory	1
blocks is more efficient. The	1
blocks is faster than reading	1
blocks of memory. These methods	1
blocks of data", where it	1
blocks in order to utilize	1
blocks than there are objects	1
blocks such as gates, flip-flops,	1
blocks makes the access to	1
blocks rather than a small	1
away the variable in many	1
away the extra overhead of	1
away a const reference if	1
away and the result is	1
away in the future due	1
away in reusable and well-	1
away an overflow check. There	1
away p and inlining the	1
away cpuid // Read time	1
15.1b is easier to understand	1
15.1b is implemented. The recursion	1
15.1b to metaprogramming would be	1
15.1b to 15.1c was done	1
15.1b to 15.1c. We can	1
15.1b to 15.1c, but none	1
15.1b to 15.1c? We took	1
15.1b and the Gnu compiler	1
15.1b and d in assembly	1
low in order to save	1
low instruction set can still	1
low power consumption are actually	1
low positive result. The conversion	1
low repeat count may be	1
low priority of program efficiency	1
low priority thread, and only	1
low priority. In many cases,	1
low priority. Especially the memory	1
multiply a nonzero floating point	1
multiply and shift Floating point	1
multiply // square x //	1
multiply it by 100 so	1
multiply by a power of	1
multiply by - reciprocal n.a.	1
multiply by xx-xx--x- reciprocal Boolean	1
multiply integers of any size	1
multiply j by is (columns	1
share the same code and	1
share the same memory space.	1
share the same memory area.	1
share the same cache line.	1
share the same register because	1
share the same dynamic libraries	1
share the same cache. Multithreaded	1
share the same piece of	1
share the same cache, at	1
enabled. The compiler will choose	1
enabled. The advantage of using	1
enabled. A more primitive, but	1
enabled. There are no instructions	1
enabled. Conversion from integer to	1
enabled. Conversions between integers and	1
enabled. Typically, the conversion takes	1
enabled. Volatile The volatile keyword	1
enabled. Few compilers are able	1
explanation of the instruction sets	1
explanation of this option. Use	1
explanation of return prediction). 149	1
explanation of branch prediction. A	1
explanation of branch prediction. If	1
explanation of register stack versus	1
explanation and possible workaround. Supports	1
explanation if you are not	1
explanation why this delaying process	1
near the maximum repeat count	1
near then the even integer	1
near each other in the	2
near each other in memory.	1
near each other are also	2
near each other. See page	2
provided in the asmlib library	1
provided in an appendix to	1
provided in manual 4: "Instruction	1
provided that the function call	1
provided that the operands are	1
provided as a template parameter.	1
provided as an example in	1
provided several examples of suitable	1
provided below, on page 15.	1
latter is more efficient. 64-bit	1
latter is slightly more efficient	1
latter is executed even though	1
latter function also has something	1
latter has one operator less.	1
latter case the reading of	1
latter function, but it may	1
latter case, the calculation of	1
latter case, you may view	1
6 The 64-bit systems can	1
6 clock cycles, depending on	1
6 unused bytes // 8	1
6 unused bytes between a	1
6 integer, pointer or reference	1
6 Development process There is	1
6 Development process...................................................................................................... 25 7	1
6 2.3 Choice of operating	1
6 2.4 Choice of programming	1
stores the time consumption of	1
stores the result in a	1
stores the offset of a	1
stores the lower 16 bits	1
stores the thousand results in	1
stores a double without loading	1
stores a pointer to the	1
stores this result in a[i].	1
stores all the objects in	1
to. A const member function	1
to. A reference is the	1
to. It is advantageous to	1
to. It is safer to	1
to. For example: // Example	2
to. Example: // Example 8.9a	1
to. Therefore, it cannot inline	1
to. Now ebx contains i/2+r.	1
default in 64-bit mode. Therefore,	1
default integer size in cases	1
default size when doing calculations,	1
default unless there is a	1
default constructor is not needed	1
default constructor that does the	1
default constructor // constructor //	1
default anyway in 64-bit code.	1
default constructors, copy constructors, and	1
Instruction set SSE2 not supported");	1
Instruction set char 8 8	1
Instruction set needed _mm_shuffle_epi8 16	1
Instruction set control no yes	1
Instruction set Header file MMX	1
Instruction set Prefetch PREFETCH _mm_prefetch	1
Instruction set Important features 80386	1
Instruction sets A more detailed	1
Instruction tables: Lists of instruction	1
finding the most efficient library	1
finding the hot spots and	1
finding the right version of	1
finding the right formula in	1
finding the numerically largest element	1
finding a suitable pivot element.	1
finding problems that relate to	1
finding hot spots, but for	1
finding elements. A hash map	1
inefficient. The modern microprocessors are	1
inefficient. If a program has	1
inefficient. There is a large	1
inefficient. An allocated array may	1
inefficient. Dynamic memory allocation also	1
inefficient. Variables declared inside a	1
inefficient. Objects of a composite	1
inefficient. Division, square root and	1
inefficient. Linear arrays are faster	1
c, d; a = b	1
c, d; if (a !=	1
c, d; c = a	2
c, d; }; void Func()	1
c, temp; temp = a+1;	1
c, d, y; y =	2
c, d, e, f, x,	1
search for updates should be	1
search for updates every time	1
search for finding elements. A	1
search instructions AVX 256 bit	1
search times 24 dramatically for	1
search facilities are needed, and	1
search facilities are needed, but	1
search facilities, binary trees, hash	1
search requests for elements in	1
Modern compilers can do a	1
Modern CPUs are so fast	1
Modern CPUs are actually able	1
Modern CPUs are capable of	1
Modern CPUs can do a	1
Modern microprocessors in the x86	1
Modern microprocessors are using advanced	1
Modern microprocessors are able to	1
Modern microprocessors can do out-of-order	1
block. This is inefficient, of	1
block. This requires a compiler	1
block. A large block containing	1
block. A linked list is	1
block. There is a portability	1
block. Do not use one	1
block. Any pointers to data	1
block. Thread-local storage should be	1
block. Walking through a linked	1
critical. The branch target buffer	1
critical. The fastest execution is	1
critical. The worst problem of	1
critical. A very time-consuming function	1
critical. It is possible to	1
critical. However, there may be	1
critical. Therefore, the number of	1
critical. Optimizing for speed is	1
critical. 129 13.7 CPU dispatching	1
chains is stronger when they	1
chains in the code prevent	1
chains can be very long	1
chains can be broken up.	1
chains with long latencies. 8.5	1
chains then each thread will	1
chains (see p. 22). 159	1
chains Modern microprocessors can do	1
chains ................................................................................................ 22 3.16 Execution	1
time-consuming function in system code	1
time-consuming than a simple type	1
time-consuming data processing. Running multiple	1
time-consuming part of the program	1
time-consuming (see page 140). Mathematical	1
time-consuming parts of the program	1
time-consuming tasks because this would	1
time-consuming tasks into separate threads	1
time-consuming garbage collector at inconvenient	1
brands of C++ compilers to	1
brands of CPUs such as	1
brands of CPUs unequally can	1
brands of microprocessors are very	1
brands of CPUs. The performance	1
brands of CPUs, different types	1
brands and similarly sets the	1
brands or specific models then	1
brands or models that were	1
available. The most important disadvantage	1
available. The number of elements	1
available. The best compilers use	1
available. The older MMX registers,	1
available. It should be clear	1
available. See page 81 for	1
available. Some compilers offer profile-guided	1
available. Microsoft Comes with Microsoft	1
available. declaration size, bits minimum	1
Don't use an advanced and	1
Don't put a task into	1
Don't put something in a	1
Don't change && to &	1
Don't rely on longjmp in	1
Don't mix float and double	1
Don't mix float and double.....................................................................................	1
Don't mix nontemporal writes with	1
Don't panic if you don't	1
brand is likely to be	1
brand of CPU. These methods	1
brand or model the best	1
brand new today will be	1
brand check is bypassed by	1
brand simply by setting these	1
brand was less popular at	1
brand name and model number.	1
brand names and model numbers,	1
executed. The compiler can then	1
executed. This has the disadvantage	1
executed. It is therefore certain	1
executed. If the value of	1
executed. An example is Perl.	1
executed. However, the pipeline structure	1
executed. Furthermore, you may read	1
executed. Optimizes very well. This	1
executed. Without static, the logarithm	1
faster. The most important addition	1
faster. The advantage of using	1
faster. The logic of the	1
faster. It is assumed that	1
faster. In the case of	1
faster. In the above example,	1
faster. There may be two	1
faster. Division by a constant	1
faster. Of course, this works	1
diagonal is swapped with element	1
diagonal and swap these elements	1
diagonal are accessed column-wise. Assume	1
diagonal are accessed row-wise, then	1
diagonal // swap elements //	1
diagonal have been lost at	1
diagonal there is only half	1
diagonal remain unchanged. The problem	1
diagonal swapd(a[r][c], a[c][r]); // swap	1
n; static char const *	1
n; i++) { 92 DynamicArray[i]	1
n; i++) f *= i;	1
n; switch (n) { case	1
n; #if defined(__unix__) || defined(__GNUC__)	1
n; #endif return n;} This	1
n; x++) factorial *= x;	1
n; u.i = (n &	1
n; 143 if (u.i &	1
*p and calculate *p+2 a	1
*p = *p + 2;	1
*p = *p + 2;}	1
*p = string; int i,	1
*p = string; while (*p	1
*p or p->member is equally	1
*p + 2; } }	1
*p + 2; } void	1
*p + 2;} int a;	1
logic of the program may	1
logic may need extra overhead	1
logic structure of a program	1
logic allows parallel calculations. Examples	1
logic allows it, it may	1
logic device is a chip	1
logic device than in a	1
logic devices A programmable logic	1
logic behind the program or	1
Microsoft, Intel and Gnu compilers	1
Microsoft, Intel and Gnu compilers.	1
Microsoft, Intel and Gnu. There	1
Microsoft, Intel and Gnu). Other	1
Microsoft, Intel, Gnu and PathScale	2
Microsoft, Intel, Gnu and Clang	1
Microsoft, Intel, PathScale and Gnu	1
Microsoft, Gnu, Clang Supported operating	1
hard disk or other hardware	1
hard disk or network. Various	1
hard disk if the RAM	1
hard disk because of disk	1
hard disk often takes much	1
hard disk copying. Security. The	1
hard disk. A few files,	1
hard disk. Test with different	1
hard working software users. In	1
purposes the standard PC processors	1
purposes is beyond the scope	1
purposes is allowed. The code	1
purposes in 32-bit operating systems	1
purposes are also available. Microsoft	1
purposes than it is intended	1
purposes than rendering graphics on	1
purposes such as email and	1
purposes (www.boost.org). The "Intel Math	1
typical set of test data.	1
typical software project goes to	1
typical way to test this	1
typical uses of dynamic memory	1
typical application to calculate the	1
typical implementation of the factorial	1
typical repeat count is near	1
typical sources of frustration and	1
typical degree of randomness in	1
usability may be poor because	1
usability A better performing software	1
usability problem in interactive programs	1
usability problems and necessary support.	1
usability problems and desired new	1
usability problems that software developers	1
usability reasons. The programmer can	1
usability ............................................................................................... 23 5 Choosing	1
usability issues, and I believe	1
pure function is a function	1
pure function with the same	1
pure function calls and it	1
pure function calls. The Gnu	1
pure function calls. Unfortunately, the	1
pure if the function is	1
pure function. Example: // Example	1
pure functions, but unfortunately there	1
pure __attribute(( const)) __attribute(( const))	1
vectorize the code if we	1
vectorize the code automatically in	1
vectorize the code automatically or	1
vectorize the code automatically. It	1
vectorize the code explicitly. There	1
vectorize the loop in example	1
vectorize a loop or not.	1
vectorize code explicitly by using	1
vectorize automatically. The code has	1
problems. The performance monitor counters	1
problems. The procedures for installation	1
problems. It is not advantageous	1
problems. It is recommended to	1
problems. Some common problems with	1
problems. All software should be	1
problems. Avoid nested function calls	1
problems. Software developers should take	1
problems. More details about how	1
could be a member of	1
could be calculated by an	1
could be achieved more efficiently	1
could have been defined in	1
could calculate *p+2 and store	1
could possibly be relevant when	1
could free the memory when	1
could benefit from using registers	1
could benefit from register storage.	1
parameter. The order of inheritance	1
parameter. It can call the	1
parameter. If MultiplyBy in this	1
parameter. In other words, you	1
parameter. There is no performance	1
parameter. But it may be	1
parameter. No time is wasted	1
parameter. Templates may be used	1
parameter. Further details are given	1
derived class is implemented in	1
derived class in another source	1
derived class are stored together	1
derived class are called from	1
derived class (see page 51).	1
derived class through a pointer	1
derived class. This check makes	1
derived class, it checks whether	1
derived class: // Example 7.38a.	1
mentioned in the above sections	1
mentioned in table 9.2, such	1
mentioned in chapter 12. If	1
mentioned above for the 32-bit	1
mentioned below. Microsoft Visual Studio	1
mentioned above. The generality of	1
mentioned above. An object cannot	1
mentioned above. Now the code	1
mentioned here: A large array	1
Time is a precious resource	1
Time for transposition of different	1
Time for transposing and copying	1
Time // Serialize // Prevent	1
Time before test // Critical	1
Time difference for each test	1
Time per element Example 9.6a	1
Time per element Example 9.6b	1
Time per element 63 63	1
Optimization of Numerically Intensive Codes",	2
Optimization in embedded systems .............................................................................	1
Optimization in embedded systems Microcontrollers	1
Optimization method Function inlining x-xxxx--x	1
Optimization directives Some compilers have	1
Optimization directives .............................................................................................. 82 8.7	1
Optimization Guide for AMD Family	1
Optimization Reference Manual". developer.intel.com. Many	1
expressions. It is therefore necessary	1
expressions. There are lots of	1
expressions. See page 80 for	1
expressions. For example, a =	1
expressions. For example, only one	1
expressions. Most reductions involving integer	1
expressions. Floating point variables do	1
expressions. Whether the constants are	1
expressions. Operations that are only	1
include the appropriate header file	1
include a performance test that	1
include a few instructions that	1
include a profiler that can	1
include not only a single	1
include any part of the	1
include standard libraries for many	1
include C, C++, D, Pascal,	1
include JavaScript, PHP, ASP and	1
y; // x,y coordinates //	1
y; x = a +	1
y; } double xpow10(double x)	1
y; ... x.a = y.a	1
y; y = a +	3
y; y = (a +	1
y; bool b; if (b)	1
overflow. The exception is caught	1
overflow. This function is intended	1
overflow. For example, in the	1
overflow. Example: // Example 7.23	1
overflow. Example: // Example 14.22a	1
overflow. Table 8.1 (page 77)	1
overflow. Likewise, it is advantageous	1
overflow. Signed versus unsigned integers	1
overflow. Taking the logarithm of	1
element. The integer comparison is	1
element. The most common implementations	1
element. The table shows that	1
element. The multiplication by columns	1
element. In some cases this	1
element. I have confirmed this	1
element. 100 As table 9.3	1
element. Matrix size Total kilobytes	1
element. Rather than comparing i	1
oriented programming are dominating. At	1
oriented programming can be an	1
oriented programming as a means	1
oriented programming without paying the	1
oriented programming are: Non-static member	1
oriented programming style if it	1
oriented programming style has both	1
oriented programs can be less	1
oriented programs. If you can	1
fully compiled code. Compiled languages	1
fully optimized code because it	1
fully optimized yet. Supports both	1
fully compatible on the object	1
fully standardized and supported on	1
fully portable in the sense	1
fully optimized. Library functions are	1
fully utilize systems with multiple	1
fully utilizing its out-of- order	1
storage. The same register can	1
storage. Example 14.23b and 14.30	1
storage. If you access a	1
storage. See page 26. The	1
storage. All x86 platforms (Windows,	1
storage. No function or class	1
storage. Variables that are stored	1
storage. Optimizing file access is	1
storage. Live range analysis The	1
addition, a floating point addition,	1
addition, and a floating point	1
addition, set the denormals-are-zero mode	1
addition, fast approximate reciprocal, fast	1
addition, subtraction and multiplication are	1
addition, subtraction and multiplication (27	1
addition, subtraction and multiplication (20	1
addition, subtraction, multiplication, etc. is	1
addition, subtraction, comparison, bit operations	1
everything is double There is	1
everything is float 140 a	1
everything in case of an	1
everything that is allocated is	1
everything that has been allocated	1
everything that depends only on	1
everything happens at runtime). The	1
everything else. This normally belongs	1
everything else. System code has	1
involves the problems that the	1
involves the overhead of switching	1
involves the risk of memory	1
involves the risk of activating	1
involves eight or sixteen vector	1
involves eight floating point registers	1
involves allocation of memory or	1
involves multiplication or division. The	1
involves pure function calls. The	1
Here the iteration is repeated	1
Here is a list of	1
Here are some examples: strlen	1
Here it is possible to	1
Here you have to vectorize	1
Here you cannot swap the	1
Here we can eliminate one	1
Here we prefer a to	1
Here CParent is a template	1
factorial = 1.0; for (x	1
factorial = 1.0; int i;	1
factorial function looks like this:	1
factorial function (n!) as an	1
factorial } return sum; }	1
factorial (int n) { //	2
factorial *= x; This can	1
factorial *= x; Note the	1
OpenMP is a standard for	1
OpenMP and automatic vectorization. It	1
OpenMP and automatic vectorization. Optimizes	1
OpenMP and automatic parallelization. Supports	1
OpenMP and automatic parallelization of	1
OpenMP directives for parallel processing.	1
OpenMP directives for multi-core processing.	1
OpenMP directives 32 bit code	1
OpenMP directives. OpenMP is a	1
eax to the address of	1
eax = i = 0	1
eax with 100 and jumps	1
eax / sar ebx,1 adds	1
eax ebx, 1 ebx, DWORD	1
eax ebx, 31 ebx, eax	1
eax edx, DWORD PTR [esp+12]	1
eax holds the index, i.	1
eax $B2$2 ; Induction++; ;	1
bb[], short int cc[]) {	8
bb[], short int cc[]); //	1
mispredicted for this reason. A	1
mispredicted only when it goes	1
mispredicted only when it exits.	1
mispredicted only when it changes.	1
mispredicted only one time in	1
mispredicted even if they otherwise	1
mispredicted (See manual 3: "The	1
mispredicted whenever it goes another	1
mispredicted 50% of the time.	1
standardized and done by the	1
standardized and supported on all	1
standardized as possible for usability	1
standardized file formats should be	1
standardized allows us to manipulate	1
standardized installation tools. It should	1
standardized details in both compiler,	1
standardized across platforms. See the	1
standardized manner. 3.4 Automatic updates	1
(or in addition to) the	1
(or if a reasonable estimate	1
(or at least a large	1
(or part of it). This	1
(or malloc and free) causes	1
(or int) instead of bool	1
(or later) instruction set is	1
(or higher) is enabled. Volatile	1
(or eight) points with the	1
across the function call. Algebraic	1
across a call to a	1
across function calls. There are	1
across function calls. Example: //	1
across all .cpp modules that	1
across compilers. Fastcall is not	1
across modules The compiler doesn't	1
across modules (See page 81).	1
across platforms. See the compiler	1
cycle is the reciprocal of	2
cycle is 1 0.5ns. 2GHz	1
cycle if the source is	1
cycle on one computer is	1
cycle on most microprocessors. Multiplication	1
cycle on another computer. The	1
cycle counter is very useful	1
cycle counter (see below) 16.1	1
aliasing is to turn on	1
aliasing does not occur. See	1
aliasing (see page 78). A	1
aliasing (see page 78). Adding	1
aliasing When accessing a variable	1
aliasing rule of standard C,	2
aliasing (/Oa). The easiest way	1
aliasing /Oa -fno-alias Non-strict floating	1
aa[], short int bb[], short	9
tool is not a profiler.	1
tool is faster to use	1
tool is Microsoft Visual Studio.	1
tool for using the performance	1
tool for details (www.agner.org/optimize/testp.zip). A	1
tool can be used in	1
tool can make two different	1
tool can set up and	1
tool supports both Intel, AMD	1
parent and child are typically	1
parent and child class are	1
parent and child class. Members	1
parent class and a derived	1
parent class and derived class	1
parent class in one source	1
parent class data members is	1
parent classes in the same	1
parent class. The child class	1
care of the CPU dispatching.	1
care of the user interface,	1
care of the alignment. See	1
care of this alignment automatically.	1
care of all cleanup of	1
care of some of the	1
care of communication with a	1
care to calculate the table	1
care about the sign bit.	1
systems, and API's. Memory swapping.	1
systems, you may use 64-bit	1
systems, you cannot increase the	1
systems, this may work with	1
systems, but in registers in	1
systems, there is only a	1
systems, though these operating systems	1
systems, especially if the code	1
parm1, int parm2) { //	1
parm1, int parm2) {...} //	6
parm1, int parm2); // Function	1
included in the operating system	1
included in the profile. It	1
included in the representation, except	1
included in a single executable	1
included in compiler price GNU	1
included for the sake of	1
included with the Gnu compiler	1
included as part of the	1
false and 1 for true.	1
false = a a &&	1
false = false, a ||	1
false where it should be	1
false model number to reflect	1
false regardless of the value	1
false (0); and the second	1
false vendor string. In the	1
value. The loop would be	1
value. The copy constructor can	1
value. The keyword static, when	1
value. This is useful when	1
value. It does this by	1
value. There is no automatic	1
value. Example: // Example 8.14a	1
value. However, the const int	1
file. The output goes to	1
file. This enables the compiler	2
file. A console mode program	1
file. If the member functions	1
file. Use another function library	1
file. Only the executable file	1
file. Keep often used functions	1
*= i; return f; }	1
*= x; This can be	1
*= x; x *= x;	1
*= x; n >>= 1;	1
*= x; Note the difference	1
*= x; nfac *= n+1;	1
*= n+1; // Approximate exp(x)	1
*= xx4; // next four	1
temporary object for the intermediate	1
temporary array before calling the	1
temporary objects for intermediate results,	1
temporary variable outside the loop	1
temporary register for computing i/2+r.	1
temporary storage. Variables that are	1
temporary debug breakpoints at every	1
temporary intermediates, loop counters, function	1
12 or 16 8 or	1
12 - 25 clock cycles,	1
12 option -fno-builtin to get	1
12 Using vector operations Today's	1
12 Using vector operations............................................................................................... 105	1
12 bytes. The time it	1
12 2.7 Choice of user	1
12 $B1$1: push mov xor	1
memcpy is unsafe because serious	1
memcpy function implicitly when copying	1
memcpy rather than moving each	1
memcpy function. There are so	1
memcpy 16kB aligned operands Intel	1
memcpy 16kB aligned operands AMD	1
memcpy 16kB unaligned op. Intel	1
memcpy 16kB unaligned op. AMD	1
procedure to calculate self-relative addresses	1
procedure 4 Most of the	1
procedure linkage table (PLT) and	1
procedure linkage table (PLT) in	1
procedure linkage table (PLT) that	1
procedure linkage table (PLT). The	1
procedure linkage table (PLT). And	1
procedure linkage table. If a	1
PC and then transferred as	1
PC processors is not optimal	1
PC processors are preferred because	1
PC processors with CISC instruction	1
PC processors. The application program	1
PC platform with an Intel,	1
PC platforms. Graphics accelerators The	1
PC platform. However, with a	1
frequent if the time slices	1
frequent cause of unacceptably long	1
frequent allocation and de-allocation of	1
frequent source of errors in	1
frequent causes of compatibility problems	1
frequent updates are necessary then	1
frequent sources of compatibility problems	1
frequent sources of resource problems	1
unlimited 4 bytes = int	2
unlimited 4 bytes = float	2
unlimited 8 bytes = double	2
unlimited 8 bytes = int64_t	2
parallelism is the situation where	1
parallelism is obvious and the	1
parallelism is obvious. See the	1
parallelism and fine-grained parallelism when	1
parallelism than with fine-grained parallelism	1
parallelism when deciding whether it	1
parallelism because communication and synchronization	1
parallelism refers to the situation	1
detection function of the Intel	1
detection function in Intel function	1
detection function that I have	1
detection function as described below.	1
detection function In some cases,	1
detection mechanism in Intel compilers	1
detection function, one that discriminates	1
detection mechanism. The CPU dispatch	1
c2 and bc for each	1
c2 for elements inside sqaure:	1
c2 = _mm_add_epi16(c, two); //	2
c2 = _mm_and_si128(c2, mask); 110	1
c2 with the bit-mask: c2	1
c2 < c1+TILESIZE; c2++) {	1
c2 < r2; c2++) {	1
"The microarchitecture of Intel, AMD	8
throw() to the function prototype:	1
throw() statement can improve optimizations	1
throw() Assume function called only	1
throw() throw() Assume function called	1
throw() throw() throw() Assume function	1
throw() throw() throw() throw() Assume	1
throw() specification. The empty throw()specification	1
throw() specification to F1 only	1
prediction and misprediction of virtual	1
prediction are different for each	1
prediction or estimate of the	1
prediction into account in the	1
prediction (see p. 43). There	1
prediction turns out to be	1
prediction mechanism. See page 43	1
prediction mechanisms. Modern microprocessors are	1
polymorphic function goes in the	1
polymorphic class has a pointer	1
polymorphic member of its child	1
polymorphic member function is called.	1
polymorphic function. The } 59	1
polymorphic functions. The second generation	1
polymorphic child function: (static_cast<MyChild*>(this))->Disp(); }	1
polymorphic classes. Each instance of	1
#if is more efficient than	1
#if is resolved at compile	1
#if instead of if. This	1
#if directives are useful for	1
#if directives around it so	1
#if INSTRSET == 2 //	1
#if INSTRSET == 2 #define	1
#if defined(__unix__) || defined(__GNUC__) //	1
now that we are running	1
now be vectorized as follows	1
now as follows. The first	1
now used in some embedded	1
now contains the address of	1
now contains only six instructions	1
now overlap. Compilers do not	1
now discontinued Object Windows Library	1
unit is clock cycles per	1
unit is pipelined, as explained	1
unit of received data in	1
unit for other purposes than	1
unit as additions. Divisions take	1
unit intended for calculating the	1
unit throughput There is an	1
unit throughput ....................................................................................... 22 4	1
conventions for different C++ compilers	6
conventions for functions that are	1
conventions are different. 64-bit Windows	1
register. The library function will	1
register. The above example sets	1
register. This advantage comes automatically.	1
register. If the carry bit	1
register. In example 12.2, the	1
register. Factors that make vectorization	1
register. Everything that is said	1
register. Registers are a scarce	1
kind of branch that can	1
kind of instructions for fast	1
kind of error is to	1
kind of problems you must	1
kind of optimizations is that	1
kind of registers. There are	1
kind of branch. After each	1
kind of exceptions a function	1
graphical user interface and use	1
graphical user interface can use	1
graphical user interface (OnIdle in	1
graphical user interface. A console	1
graphical user interface. Otherwise the	1
graphical user interfaces from scratch.	1
graphical interface calls. The usability	1
graphical interface frameworks are available	1
lower than a certain tolerance.	1
lower instruction set. The preprocessing	1
lower 8 or 16 bits	1
lower 16 bits of the	1
lower priority than the user	1
lower priority level, typically in	1
lower priority. If the different	1
lower case: // Example 7.31a	1
label is equal to the	1
label if i < 100.	1
label ; return from Func	1
label ; save ebx on	1
label ; restore ebx from	1
label plus one, because it	1
label $B1$2:. This is just	1
label ;eax=addressofa ;edx=addressinr ; ecx	1
iterations is not divisible by	1
iterations of redesign. Some software	1
iterations and start the calculation	1
iterations in one. The compiler	1
iterations such as Taylor expansions	1
iterations are: No loop-carried dependency	1
iterations back. The method of	1
iterations ahead. It is less	1
misprediction is approximately 12 -	1
misprediction of virtual function calls	1
misprediction long before the floating	1
misprediction before it is too	1
misprediction every time the function	1
misprediction penalty is only a	1
misprediction penalty of 10 -	1
misprediction penalty. Branches are relatively	1
integer, and the fraction is	1
integer, and this pointer is	1
integer, or an integer can	1
integer, then you can generally	1
integer, pointer or reference parameters).	1
integer, so that the result	1
integer, signed or unsigned 8	1
integer, usually 32. In 64-bit	1
binding is that the address	1
binding of function calls. The	1
binding can be useful for	1
binding by default, which makes	1
binding by default, even when	1
binding should therefore be used	1
binding definitely degrades performance for	1
binding leads to a usability	1
just-in-time compiler can optimize specifically	1
just-in-time compilation of the most	1
just-in-time compilation of an intermediate	1
just-in-time compilation may be a	1
just-in-time compilation. The program code	1
just-in-time compilation. Some early implementations	1
just-in-time compilers, system database, and	1
just-in-time compilers, etc., as is	1
try to do as much	1
try to run two threads	1
try to optimize this loop?	1
try to fix the problem	1
try { F1(); } catch	1
try different libraries and see	1
try block or function call	1
try block. There is a	1
background is further explained in	1
background are unnecessary for the	1
background calculations piece by piece	1
background process running when it	1
background job can be divided	1
background processes running, and a	1
background services under advanced system	1
background jobs. The context switches	1
converted to a pointer of	1
converted to a pointer to	1
converted to a longer size	1
converted to a pointer. It	1
converted to an integer, or	1
converted to unsigned. // Example	1
converted to OMF format. Alternatively,	1
converted by the compiler to	1
pointed to is a power	1
pointed to is identical to	1
pointed to is known. Example:	1
pointed to can be accessed	1
pointed to can be accessed.	1
pointed to by r is	1
pointed to by p is	1
pointed to. For example: //	1
CPUs, as described in this	1
CPUs, as described in chapter	2
CPUs, not for other brands	1
CPUs, different types of graphics	1
CPUs, but it uses more	1
CPUs, but not on AMD	1
CPUs, but event-counters do. This	1
account in the software. Smaller	1
account for unaligned arrays. There	1
account that each value is	1
account when optimizing multithreaded applications:	1
account when deciding whether to	2
account when deciding whether it	1
account when choosing a container	1
p) { int i; for	1
p) { return _mm_loadu_si128((__m128i const*)p);	2
p) { return _mm_loadu_si128((__m128i const*)p);}	1
p) { return _mm_load_si128((__m128i const*)p);	1
p) { *p = *p	2
p) {return p->a + p->b;}	1
chain is a series of	1
chain of function calls and	1
chain in two: // Example	1
chain may fill up the	1
chain has a latency which	1
chain which prevents out-of-order execution.	1
chain where each addition has	1
chain would make the induction	1
algorithms is that it makes	1
algorithms to predict which way	1
algorithms and data structures for	1
algorithms in the planning phase	1
algorithms in order to find	1
algorithms for different purposes is	1
algorithms are described in detail	1
algorithms used for branch prediction	1
PLT and GOT. The symbol	1
PLT for all functions and	1
PLT for internal references. Therefore,	1
PLT tables are not used	2
PLT entry with the pointer	1
PLT entry initially points to	1
PLT lookups for local references.	1
heavy work to do immediately	1
heavy mathematical calculations, should be	1
heavy graphics application is preferably	1
heavy graphics calculations. In some	1
heavy background calculations piece by	1
heavy marketing of 64-bit software,	1
heavy competition. Processors with multiple	1
heavy traffic and a server	1
once the hot spots have	1
once The bitwise operators &,	1
once for each function call	1
once for each version void	1
once or multiple times in	1
once more by the loader	1
once then the compiler may	1
once made a Windows program	1
additions and no multiplications. The	1
additions and shift operations. Multiplying	1
additions and multiplications. Subtractions use	1
additions in the same time	1
additions in one operation. A	1
additions are independent then you	1
additions by the use of	1
additions with double's. It is	1
hash table for even the	1
hash table can improve search	1
hash table increases the size	1
hash map is needed in	1
hash map can be used	1
hash map may also be	1
hash maps etc. It is	1
hash map. Do objects have	1
ecx and edx can be	1
ecx and edx, respectively. (In	1
ecx = a ; parameter	1
ecx = Induction ; edx	1
ecx contains the address of	1
ecx DWORD PTR [eax+4], ecx	1
ecx now contains the address	1
ecx 86 add add cmp	1
system. The number of logical	1
system. The best performance is	1
system. This is very problematic	1
system. It will crash on	1
system. See page 122 for	1
system. See page 29 for	1
system. AVX is supported in	1
system. Note that the system	1
variables, and for saving registers	1
variables, if possible. See page	1
variables, loop counters, etc. In	1
variables, but will save temp	1
variables, integer Register variables, float	1
variables, floating point constants, string	1
variables, float Live range analysis	1
variables, arrays and objects. Storage	1
equally efficient because they are	1
equally efficient because, in most	1
equally likely to be predicted	1
equally fast whether p is	1
equally efficient. If you look	1
equally efficient. Simple function parameters	1
equally near then the even	1
equally fast. In general, you	1
however, to pass a pointer	1
however, and it may be	1
however, if the array or	1
however, when b is a	1
however, there is a single	1
however, where there are different	1
however, where template metaprogramming is	1
however, often write expressions that	1
designed to handle only known	1
designed to solve this problem.	1
designed for a higher clock	1
designed for this purpose. It	1
designed for generality and flexibility,	1
designed by Intel but is	1
designed so as to make	1
designed program. 6 Development process	1
profiling and debugging. A command-line	1
profiling (see page 16) shows	1
profiling support in the optimized	1
profiling support. Then you make	1
profiling tools that fit their	1
profiling instruments in the code	1
profiling feasible. Interference from other	1
profiling methods: Instrumentation: The compiler	1
fragmented and caching becomes inefficient.	1
fragmented and scattered around in	1
fragmented and involve a high	1
fragmented when the code is	1
fragmented when objects of different	2
fragmented hard disk. Test with	1
fragmented thanks to the first-in-last-out	1
inputs is limited and there	1
inputs to the calculations are	1
inputs for a console mode	1
inputs are the integers from	1
inputs have any other value	1
inputs when the program is	1
inputs give overflow and negative	1
inputs give infinity. A typical	1
fast. The result of the	1
fast. The lesson we can	1
fast. This can be useful	1
fast. In general, you can	1
fast. All optimizing compilers will	1
fast. Simple integer operations such	1
fast. Value of b will	1
fast. Calculating the difference between	1
family of microprocessors from Intel,	1
family and model numbers are	1
family and model number. I	1
family and model number. Failure	1
family can run in both	1
family have two different types	1
family number 6! The speed	1
family number, which is 15	1
4, we have: // Example	1
4, while all newer Intel	1
4, 8, 16, 32, 64,	1
4, Wednesday = 8, Thursday	1
4, 6, 9 and 13	1
4, 2007 (www.intel.com/technology/itj/). 10.1 Hyperthreading	1
4, etc.). Older operating systems	1
4, anda * 17is calculated	1
Virtual function // Call to	1
Virtual functions and function pointers	1
Virtual functions in C++ take	1
Virtual functions are used for	1
Virtual member functions are less	1
Virtual member functions Virtual functions	1
Virtual member functions ........................................................................................ 53	1
Virtual call to C1::f }	1
j = order(i); matrix[j][0] =	1
j = order(i); list[j].a =	1
j by is (columns *	1
j as index then the	1
j * 32 with j	1
j * (columns * sizeof(float)).	1
j < columns; j++) 39	1
j << 5. If columns	1
interrupt the user but only	1
interrupt should preferably be responded	1
interrupt 3 breakpoint and show	1
interrupt 3 breakpoint again. The	1
interrupt occurs in each part	1
interrupt 3. The code is	1
interrupt service routine should do	1
interrupt service routines, system core	1
-1 = a, a &	1
-1 = a, a |	1
-1 = -1 - n.a.	1
-1 = -1 x -	1
-1 = ~a a ^a	1
-1 - n.a. - -	1
-1 x - - -	1
-1 (a&~b)|(~a&b)=a^b --------- ~a ^	1
8, but not any other	1
8, 16 or 32 bits	1
8, last byte at 15	1
8, last byte at 11	1
8, 16, 32 and 64	1
8, 16, 32, 64, ...).	1
8, 10, 12 or 16	1
8, Thursday = 0x10, Friday	1
units. The size of vector	1
units. The problem is that	1
units. This means that it	1
units. If any of the	1
units. For example, a loop	1
units. Each 128-bit operation was	1
units. Any floating point operation	1
units. Typically, there are two	1
who is still frustrated by	1
who are satisfied with making	1
who have sent me corrections	1
who has to invest in	1
who want to make their	1
who want to go deeper	1
who would like to put	1
who would know that a	1
fastest on different processors. In	1
fastest because you can avoid	1
fastest possible access to the	1
fastest way to set an	1
fastest way to handle strings	1
fastest execution is no doubt	1
fastest solution on future CPUs.	1
fastest first. However, you must	1
__restrict or #pragma optimize("a",on). Specifies	1
__restrict or __restrict__, if supported	1
__restrict #pragma ivdep Assume function	1
__restrict #pragma ivdep __restrict #pragma	1
__restrict __restrict __declspec( noalias) __restrict	1
__restrict __declspec( noalias) __restrict #pragma	1
__restrict aa, int * __restrict	1
__restrict bb) { for (int	1
arithmetic A pointer is in	1
arithmetic operations are therefore as	1
arithmetic operations with pointers. The	1
arithmetic calculations go outside the	1
arithmetic operations. The most common	1
arithmetic operations. When an integer	1
arithmetic units, etc. and the	1
arithmetic expression. The size conversion	1
DLL is relocated (rebased) once	1
DLL can be accessed from	1
DLL or a static library.	1
DLL with the best compiler	1
DLL use absolute references in	1
DLL at the same time.	1
DLL takes more memory resources	1
DLL goes through an import	1
factors in the early planning	1
factors for the performance then	1
factors that can make dynamic	1
factors that can prevent the	1
factors that decide how advantageous	1
factors are explained in detail	1
factors are generated from the	1
factors as template parameters then	1
Gnu, Intel and PathScale compilers	1
Gnu, Clang and Intel compilers	1
Gnu, Clang and Intel compilers.	1
Gnu, Clang Supported operating systems	1
Gnu, Clang, Intel or Microsoft	1
Gnu, Clang, Intel or PathScale	1
Gnu, Clang, Intel or PathScale.	1
Gnu, Clang, Intel, Microsoft and	1
arrays. // Example 12.5. Aligned	1
arrays. It is the responsibility	1
arrays. There are various things	1
arrays. I have no explanation	1
arrays. An array overflow can	1
arrays. Note that the C	1
arrays. Array size divisible by	1
arrays. Strings can be manipulated	1
devices and using advanced facilities	1
devices and machines with embedded	1
devices are becoming more popular	1
devices are CPLDs and FPGAs.	1
devices if you avoid the	1
devices with limited resources. Most	1
devices A programmable logic device	1
devices typically have much less	1
branch. The common excuse that	1
branch. It may seem illogical	1
branch. If it is poorly	1
branch. There is nothing to	1
branch. See the preceding paragraph	1
branch. Example: // Example 8.11a	1
branch. After each iteration it	1
branch. Microprocessor designers have gone	1
required is not known at	1
required a PC. Similarly, we	1
required for performance reasons. Use	1
required for finding the right	1
required for putting the right	1
required // This function adds	1
required amount of memory space	1
required amount of space on	1
(unsigned int if (i >=	1
(unsigned int)b / 10; a	1
(unsigned int)b / 16; //	1
(unsigned int)b % 10; a	1
(unsigned int)b % 16; //	1
(unsigned int)size) { cout <<	1
(unsigned int)a / 10; //	1
(unsigned int)(max - min)) {	1
almost the entire level-1 cache	1
almost all modern microprocessors and	1
almost all respects relevant to	1
almost always advantageous to use	1
almost certain to become obsolete	1
almost certain that this part	1
almost identical performance for 32-bit	1
almost independent of changes in	1
GOT and PLT for internal	1
GOT and PLT tables are	2
GOT and PLT lookups for	1
GOT for all public and	1
GOT through a self-relative address.	1
GOT lookup process is used	1
GOT entry. You can avoid	1
array. The values are then	1
array. The disadvantage of using	1
array. The constructor sets all	1
array. // Example 9.6a const	1
array. This method requires that	1
array. But the same errors	1
array. No link pointer can	1
array. eax holds the index,	1
listed in the compiler manual	1
listed in the table. The	1
listed in table 19 in	1
listed in table 8.1 below.	1
listed in table 9.2. All	1
listed in manual 4: "Instruction	1
listed on page 164 below.	1
listed below in example 16.1.	1
general function libraries that are	1
general method is to wrap	1
general case where you want	1
general statement can be made	1
general purposes in 32-bit operating	1
general case, but in this	1
general literature on algorithms and	1
general improvements in microprocessor hardware	1
preferred to use the smallest	1
preferred to use a container	1
preferred to declare objects and	1
preferred when speed is important.	1
preferred because of their superior	1
preferred method for transferring composite	1
preferred programming language when the	1
preferred language will often be	1
cycles, then this loop will	1
cycles, then we can roughly	1
cycles, but it can take	1
cycles, depending on the processor	1
cycles, depending on the processor.	1
cycles, depending on the microprocessor.	2
cycles, depending on the processor).	1
explicitly in many cases. Integer	1
explicitly that pointers do not	1
explicitly if data access can	1
explicitly by using the so-called	1
explicitly by writing: __declspec(align(64)) int	1
explicitly as in example 13.1	1
explicitly when alloca is used.	1
explicitly what kind of exceptions	1
space. The syntax in example	1
space. A floating point constant	1
space. A union can be	1
space. A situation where a	1
space. It may be possible	1
space. It should therefore preferably	1
space. Excessive use of templates	1
space. Putting simple variables into	1
fixed size to avoid dynamic	1
fixed size array or container	1
fixed size arrays inside the	1
fixed address might clash with	1
fixed repeat count and no	1
fixed size, not as a	1
fixed breakpoint in the code	1
fixed strides. Uncached memory store	1
Memory and string manipulation Mathematical	1
Memory access Accessing data from	1
Memory allocated with new or	2
Memory swapping is a frequent	1
Memory copying. There are several	1
Memory swapping. Software developers typically	1
Memory access....................................................................................................... 22 3.14 Context	1
zero. The [] operator will	1
zero. A good implementation uses	1
zero. It is not necessary	1
zero. You may remove the	1
zero. An OR combination of	1
zero. Execution time too small	1
zero. 14.3 Use bitwise operators	1
zero. Zero can be represented	1
non-sequential which makes the data	1
non-sequential order in order to	1
non-sequential access and you want	1
non-sequential order. The same applies	1
non-sequential order. The advice of	1
non-sequential order. Example: // Example	1
non-sequential manner then it is	1
non-sequential manner. It is usually	1
multiplying the index by 8.	1
multiplying by other constants because	1
multiplying by 3, 5 and	1
multiplying with the double precision	1
multiplying with the constant 2.5,	1
multiplying with the reciprocal: //	1
multiplying with a constant. The	1
multiplying them. This would require	1
Conversion of a floating point	1
Conversion of a signed integer	1
Conversion of an unsigned integer	1
Conversion of unsigned integers to	1
Conversion of integers to floating	1
Conversion to floating point is	1
Conversion from integer to floating	1
Conversion from floating point to	1
down the execution to the	1
down the execution considerably. Another	1
down a program for the	1
down to zero than making	1
down to 36. There may	1
down and restarted anyway. Updates	1
down sign bit of i	1
down dependency chains (see p.	1
software. This is annoying to	1
software. A negative list, on	1
software. It may even have	1
software. You should be aware	1
software. For more on this	1
software. Such an extra framework	1
software. Smaller microcontrollers have no	1
software. Background services. Many services	1
interpreted in the following way.	1
interpreted as a very large	1
interpreted as an unsigned integer	1
interpreted version of Basic was	1
interpreted line by line when	1
interpreted languages where everything happens	1
interpreted again and again for	1
interpreted script languages, it is	1
exactly the same thing and	1
exactly the same effect. Which	1
exactly the same. If the	1
exactly as efficient as using	1
exactly as efficient as integers.	1
exactly what you want when	1
exactly identical for the two	1
exactly identical code for the	1
jump to a different code	1
jump to top of loop	1
jump by copying the return	1
jump from a=a*2; to return	1
jump between multiple CPU cores.	1
jump through a pointer in	1
jump targets. A switch statement	1
jump tables, and virtual function	1
determined in advance, because a	1
determined by the floating point	1
determined by the operating system,	1
determined by the requirements of	1
determined by a system call	1
determined by considerations such as	1
determined with system calls (e.g.	1
determined where the object of	1
cc[]) { for (int i	1
cc[]) { // Make a	3
cc[]) { // go to	1
cc[]) { // Define vector	1
cc[]) { // Detect supported	1
cc[]) { Vec16s a, b,	1
line. The cache line size	1
line. The delay is less	1
line. This is advantageous in	1
line. Some compilers will align	1
line. But these eight elements	1
line. Only one of the	1
line. 132 Table lookup cannot	1
line. Time-based sampling: The profiler	1
easily be implemented as vector	1
easily be organized into vectors.	1
easily be obtained. In the	1
easily available from a website.	1
easily optimize away a const	1
easily become fragmented when objects	1
easily justify a possible minor	1
easily ported to systems with	1
identification 16 bit platform __GNUC__	1
identification adds extra information to	1
identification (RTTI) If any of	1
identification (RTTI) Runtime type identification	1
identification (RTTI) /GR -fno-rtti /GR-	1
identification (RTTI) ........................................................................... 54 7.22	1
identification (RTTI). See page 54.	1
identification (RTTI), which affects other	1
vectors. The following example shows	1
vectors. The operators are inlined	1
vectors. This data conversion and	1
vectors. A lot of code	1
vectors. There are also other	1
vectors. These function libraries are	1
vectors. 12.10 Conclusion There is	1
vectors. Code that is compiled	1
2) { // abs(u.f) >	1
2) { a[i] = Induction;	1
2) { sum1 += list[i];	1
2) { FuncA(i); FuncC(i); FuncB(i+1);	1
2) 2 - n.a. a+a+a+a	1
2) 2 a+a+a+a=a*4 -(-a)=a --xxxxxx-	1
2) : (bb[i] * cc[i]);	1
2) SelectAddMul_pointer = &SelectAddMul_SSE2; //	1
applications. The string classes allocate	1
applications. The choice of compiler	1
applications. Some systems have a	1
applications. But we do have	1
applications. Therefore, it is worthwhile	1
applications. Alternatively, use a negative	1
applications. Remember that container classes	1
applications. 2.8 Overcoming the drawbacks	1
volatile is that it makes	1
volatile int DontSkip; long long	1
volatile int seconds; // incremented	1
volatile then an optimizing compiler	1
volatile doesn't mean atomic. It	1
volatile keyword makes sure that	1
volatile keyword specifies that a	1
volatile volatile int seconds; //	1
misses is not seen in	1
misses and branch mispredictions. When	1
misses and branch mispredictions. Test	1
misses in the level-2 cache.	1
misses in the level- 1	1
misses are very expensive. A	1
misses by making the code	1
misses have occurred. This makes	1
tables of mathematical functions that	1
tables are not used for	2
tables are particular advantageous as	1
tables can be useful for	1
tables if this prevents a	1
tables Reading a value from	1
tables ................................................................................................. 132 14.2 Bounds	1
random than normal. 157 17	1
random number generators. In general,	1
random times and make parts	1
random access. Reading or writing	1
random order. The heap manager	1
random order. This makes data	1
random manner. This applies to	1
random events that are not	1
X The code section is	1
X make position-independent code and	1
X operating system is based	1
X operating systems, though these	1
X Compilers for 32-bit Mac	1
X #else // Gnu compiler,	1
X (Darwin) are part of	1
X __attribute__((aligned(16))) #endif const int	1
Conversions of float or double	1
Conversions between different precisions take	1
Conversions between floating point numbers	2
Conversions between integers and floating	1
Conversions between signed and unsigned	1
Conversions between float, double and	1
Conversions involving class objects (rather	1
YMM in the AVX instruction	1
YMM register state. This penalty	1
YMM registers The 128-bit XMM	1
YMM registers are available if	1
YMM registers ................................................................. 107 12.2	1
YMM vectors are preferably aligned	1
YMM registers. The first processors	1
YMM registers. Disadvantages are: Long	1
resolved when the program is	1
resolved when the library is	1
resolved at compile time rather	1
resolved at compile time while	1
resolved at compile time. Templates	1
resolved at runtime. #define directives	1
resolved before the program is	1
purpose is to detect if	1
purpose of the while loop	1
purpose of this is to	1
purpose of using smart pointers	1
purpose of finding a suitable	1
purpose in order to make	1
purpose libraries are also available,	1
-fpic is much faster, except	1
-fpic and it will not	1
-fpic in 32-bit Linux is	1
-fpic in 64 bit mode,	1
-fpic because the relocations in	1
-fpic according to the Gnu	1
-fpic option. Then we get	1
D is compiled to binary	1
D are not yet as	1
D has many of the	1
D language allows compile-time if	1
D : public B1 {	1
D : public B1, public	1
D language. D has many	1
had the full 128-bit execution	1
had a different type by	1
had in fact only 64-bit	1
had not been a power	1
had an interpreter for Basic.	1
had used intrinsic functions. It	1
had read from different addresses	1
parameters. This is called name	1
parameters. A template with many	1
parameters. In 64-bit Windows, the	1
parameters. There is no difference	1
parameters. Therefore, make sure that	1
parameters. Floating point parameters are	1
parameters. Or it might be	1
ebx, 1 ebx, DWORD PTR	1
ebx, DWORD PTR [edx] DWORD	1
ebx, DWORD PTR [edx] adds,	1
ebx, eax / sar ebx,1	1
ebx, eax ebx, 1 ebx,	1
ebx, eax ebx, 31 ebx,	1
ebx, 31 ebx, eax ebx,	1
measure the clock count before	1
measure that is almost independent	1
measure are much higher than	1
measure // Number of times	1
measure how long time it	1
measure how much time each	1
measure exactly what you want	1
poorly for the end user.	1
poorly designed program. 6 Development	1
poorly predictable then replace it	1
poorly predictable branch by a	1
poorly predictable. It may be	1
poorly predictable. For example: //	1
poorly predictable, then it is	1
this: // Example 16.2 #include	1
this: // Example 14.1a int	1
this: // Example 12.4e. Same	1
this: // Example 7.9b char	1
this: // Example 12.9a. Taylor	1
this: // Example 14.4a const	1
this: Use assembly language Use	1
sections are dominating and there	1
sections can be shared. Any	1
sections below. The stack is	1
sections SSE instruction set (128	1
sections /Gy -ffunction- sections SSE	1
sections describe some of the	1
sections describe various ways to	1
Software that relies on network	1
Software should use standard API	1
Software developers should take installation	1
Software developers typically have more	1
Software Developers Manual", Volume 1,	1
Software Developers Manual", Volume 2A	1
Software distributors are often abusing	1
Even function calls can be	1
Even with all relevant optimization	1
Even some of the best	1
Even big software companies often	1
Even worse, many software products	1
Even better, you may make	1
Even better: store the reciprocal	1
19 in manual 5: calling	1
19 }; S1 ArrayOfStructures[100]; Here,	1
19 Avoid an excessive number	1
19 Literature Other manuals by	1
19 Literature ..................................................................................................................... 163 20	1
19 3.5 Program loading .......................................................................................................	1
19 3.6 Dynamic linking and	1
important. This can be permissible	1
important. This manual does not	1
important. A language based on	1
important. A virtual processor may	1
important. Some systems allow lazy	1
important. An important disadvantage of	1
important. 9.2 Cache organization It	1
carry and zero flags on	1
carry bit is kept in	1
carry bit can be saved	1
carry bit must be saved	1
carry flag or in a	1
carry flag then the loop	1
carry flag (e.g. DEC, JNZ).	1
lazy loading of the code,	1
lazy binding is that the	1
lazy binding of function calls.	1
lazy binding by default, which	1
lazy binding by default, even	1
lazy binding definitely degrades performance	1
lazy binding leads to a	1
xn is calculated from the	1
xn = x; float sum	1
xn = xxn-1, and each	1
xn as x4xn-4. There is	1
xn / nfac; xn *=	1
xn n 0 n! 117	1
xn *= x; nfac *=	1
stamp counter in the CPU,	1
stamp counter can be obtained	1
stamp counter // For unused	1
stamp counter before and after	1
stamp counter becomes invalid if	1
stamp counter. The test tool	1
stamp counter. This is a	1
debugging and exception handling. Omitting	1
debugging and profiling support in	1
debugging and maintaining such code	1
debugging if required for performance	1
debugging support which is used	1
debugging options prevent optimization. The	1
debugging facilities, easy GUI development,	1
10; a = b /	1
10; a = b %	1
10; a = (unsigned int)b	2
10; // Convert to unsigned	1
10; int i; long long	1
10; Templates are instantiated at	1
table. The 16-byte instructions MOVNTPS,	1
table. If the standard header	1
table. If a dispatched function	1
table. Unfortunately, few compilers are	1
table. Optimization method Function inlining	1
table. Even better: store the	1
table. Type size, bytes alignment,	1
1, but operators that have	1
1, 2, 4 or 8,	1
1, 2, 6, 24, 120,	2
1, 2, 3, 4, 6,	1
1, Monday = 2, Tuesday	1
1, 2A, 2B, and 3A	1
vector, the four G values	1
vector, and the four B	1
vector, such as 32-bit integer	1
vector, bits Vector class, Intel	1
vector, bits Instruction set char	1
vector, while you can only	1
vector, uses SSE3. // (This	1
(b) { a = a	4
(b) { return a +	1
(b) { y = sin(x);	2
object, and a member function	1
object, and ownership is transferred	1
object, you may consider the	1
object, then the version in	1
object, then the instance in	1
object, unless there is a	1
object, except for char pointers.	1
allowed to have constructors and	1
allowed to change the value	1
allowed and which not. You	1
allowed in C++ so you	1
allowed in assembly names. The	1
allowed only for classes. The	1
allowed inputs are the integers	1
delete the object. 7.17 Structures	1
delete is to allocate variable-size	1
delete to allocate a new	1
delete or with the functions	1
delete or malloc and free	1
delete it and create a	1
delete (or malloc and free)	1
Likewise, the compiler can automatically	1
Likewise, a pointer can be	1
Likewise, it is advantageous to	1
Likewise, if the first operand	1
Likewise, you cannot replace a	1
Likewise, when a global variable	1
Likewise, all non-static variables and	1
follows: // Example 9.1b int	1
follows: struct Sfloat { unsigned	1
follows: Instruction set Header file	1
follows: Instruction set Important features	1
follows: Type of elements Size	1
follows: Matrix size Time per	1
follows: floatvalue ( 1)sign 2exponent	1
simultaneously. This is also called	1
simultaneously. This processor has four	1
simultaneously. If the microprocessor has	1
simultaneously. If the computer has	1
simultaneously. In multithreaded applications it	1
simultaneously. Each thread will get	1
simultaneously. Actually, only the code	1
itself is a very useful	1
itself is a big waste	1
itself and take more time	1
itself and recompile it. I	1
itself in order to emulate	1
itself when running. Programs using	1
itself is. The 64-bit version	1
solution. The compiler is likely	1
solution. It might be possible	1
solution. Many containers use linked	1
solution. (In my tests, the	1
solution. Is a multidimensional structure	1
solution. Is searching needed before	1
solution. Sort the array after	1
algebra and statistics, and the	1
algebra in a compiler. Some	1
algebra are the same in	1
algebra reductions: x-- x x--	1
algebra reductions: a+b = b+a	1
algebra reductions: a+b=b+a a*b=b*a a+b+c=a+(b+c)	1
algebra reductions: !(!a)=a x-xxxxxxx ---x-----	1
suitable for example 9.5 because	1
suitable functions in a module	1
suitable set of test data	1
suitable choice of n. The	1
suitable containers class templates in	1
suitable pivot element. The integer	1
suitable duration. The best way	1
Template for pow(x,N) where N	1
Template Library (STL) which comes	1
Template Library (WTL). A WTL	1
Template Library (WTL): // Example	1
Template Library (ATL) and Windows	1
Template meta- programming is so	1
Template Library) and other container	1
spend a lot of time	1
spend on redesigning a program	1
spend time on deciding which	1
spend time doing the division.	1
spend more CPU time on	1
spend most of their time	1
spend most of their execution	1
switches is smaller in a	1
switches and garbage collection can	1
switches are more frequent if	1
switches can reduce the performance	1
switches by making longer time	1
switches A context switch is	1
switches after each time slice	1
disk. A big file containing	1
disk. A few files, preferably	1
disk. Memory swapping is a	1
disk. Software that relies on	1
disk. Test with different brands	1
disk. Provoke cache misses by	1
disk. Memory-hungry applications force the	1
serious when n is an	1
serious problem with the C++	1
serious errors can happen if	1
serious legal issue. See my	1
serious legal issue, as you	1
serious limitations to what the	1
serious burden is the calculation	1
c); // Store the result	2
c); // Compare each element	2
c); ... return 0; }	2
c); a.store(aa+i); } } #if	1
Studio can build code for	1
Studio This is a very	1
Studio when compiling for Windows	1
Studio IDE. Has not been	1
Studio optimizes reasonably well, but	1
Studio 2008 version). This wasteful	1
Studio 2005). Borland C++ 5.82	1
a[100]; for (i = 0;	1
a[100]; // 400 bytes. first	1
a[100]; int i; float i2;	1
a[100]; int i; for(i=0; i<100;	1
a[100]; int i, sum =	1
a[100]; float sum = 0;	1
a[100]; float s0 = 0,	1
trick is to roll out	1
trick of using a common	1
trick of using bitwise operators	1
trick that N1 = N&(N-1)	1
trick will fail if the	1
trick which is used in	1
trick violates the strict aliasing	1
disadvantages of using pointers and	1
disadvantages of dynamic memory allocation	1
disadvantages that make developers choose	1
disadvantages when C++ is chosen	1
disadvantages when deciding whether to	1
disadvantages mentioned above for the	1
disadvantages compared to 32 bit	1
eax, 8 edx, eax $B2$2	1
eax, 1 eax, 100 $B1$2	1
eax, 100 / jl $B1$2	1
eax, 100 $B1$2 ebx ;	1
eax, eax edx, DWORD PTR	1
eax, ecx and edx can	1
eax, edx, ecx, edx, DWORD	1
distributed to the end user.	2
distributed and stored as it	1
distributed as it is and	1
distributed as object or library	1
distributed as binary executable code.	1
distributed between multiple dynamic libraries.	1
generally not thread safe if	1
generally used that most function	1
generally possible on Linux platforms,	1
generally very fast. Simple integer	1
generally faster and more compact	1
generally assume that the compiler	1
generally assume that the overall	1
mode, the parameters would be	1
mode, and an error condition	1
mode, and more efficient in	1
mode, for reasons explained on	1
mode, as explained below. Shared	1
mode, where it still uses	1
mode, we encounter another problem.	1
Linux. The compiler comes with	1
Linux. It can also be	1
Linux. 32-bit Mac OS X	1
Linux. Has many good optimization	1
Linux. 82 Keywords that work	1
Linux. Asmlib My own function	1
Linux. Address calculation is more	1
C1 or C2, then we	1
C1 { public: ... ~C1();	1
C1 : public CHello {	1
C1 : public C0 {	1
C1 x; ... } void	1
C1 obj1; C0 * p	1
C1 Object1; C2 Object2; CHello	1
instances of the same logical	1
instances of the class. Calling	1
instances of S1 aligned //	1
instances of structures and classes.	1
instances that take up cache	1
instances will be joined into	1
instances makes the compiled code	1
called, a dispatch is made	1
called, or what a function	1
called, it is necessary to	1
called, it can use the	1
called, it allocates the required	1
called, even if the dispatched	1
called, while the Gnu mechanism	1
update the program that calls	1
update or even telling the	1
update when the next new	1
update automatically when the computer	1
update mechanism to advertise new	1
update process should run in	1
update process. 3.5 Program loading	1
<= n < 223 to	1
<= n; i++) f *=	1
<= n; x++) factorial *=	1
<= (unsigned int)(max - min))	1
<= 16; n++) { sum	1
<= u.f < 2.0 This	1
<= max) { ... can	1
integer. The compiler does not	1
integer. The conversion time is	1
integer. If a loop needs	1
integer. If two integers are	1
integer. But the & operator	1
integer. Floating point precision conversion	1
integer. 158 Integer variables can	1
body is very small or	1
body is defined inside a	1
body of the called function.	1
body of a loop is	1
body inside the class definition.	1
body now contains only six	1
body begins at the label	1
definition code in addition to	1
definition language is that the	1
definition language is inherently parallel	1
definition language in the same	1
definition language defines hardware circuits	1
definition language. Such a processor	1
definition language, such as VHDL	1
Java and C# and avoids	1
Java are based on an	1
Java virtual machine are frameworks	1
Java virtual machine. The best	1
Java machines use just-in-time compilation	1
Java implementations. However, these languages	1
Java today. But this language	1
Math core library contains optimized	1
Math Library __vrs4_expf __vrd2_exp AMD	1
Math Kernel Library (MKL v.	1
Math Kernel Library" and "Integrated	1
Math Kernel Library" contains many	1
Math Kernel Library, available from	1
Math Kernel Library. The multiple	1
generates the following assembly code	2
generates is to use a	1
generates to see how well	1
generates no extra code at	1
generates too little data for	1
generates 127. The calculation of	1
executing the same piece of	1
executing the critical code. A	1
executing a critical piece of	1
executing library functions. Time- consuming	1
executing instructions are less likely	1
executing instructions out of order.	1
executing instructions during this time	1
Open files and network connections.	1
Open source library. Supports x86	1
Open database connections. Open files	1
Open BSD are identical to	1
Open Watcom Another open source	1
Open Watcom C/C++ v. 1.4,	1
Open source. Supports all x86	1
256; // Array size Alignd	1
256; i += 8) {	4
256; i += 16) {	1
256; i++) { aa[i] =	1
optimizations. The keyword static, when	1
optimizations. The results are summarized	1
optimizations. In most cases it	1
optimizations. See page 80. The	1
optimizations. Most C++ compilers are	1
optimizations. Do not use the	1
optimizations. Loops with a very	1
Cache control instructions. There are	1
Cache contentions in large data	2
Cache contentions expected. Use square	1
Cache misses are very expensive.	1
Cache organization It is useful	1
Cache organization ................................................................................................... 87 9.3	1
slower or require more resources,	1
slower than the subsequent times	1
slower than a thread that	1
slower than a dedicated microprocessor	1
slower than static link libraries.	1
slower than intended because of	1
slower than truncation when the	1
free the memory when exiting	1
free the memory used by	1
free and open source. It	1
free in the Microsoft platform	1
free register left for transferring	1
free are: There is very	1
free E-book Usability for Nerds	1
consuming because it may go	1
consuming because it may involve	1
consuming library functions often belong	1
consuming calculations into a separate	1
consuming parts only. Critical pieces	1
consuming updates may come unpredictably	1
consuming features of the position-independent	1
hold the value of the	1
hold the numbers in question	1
hold only one element then	1
hold many renamed instances of	1
hold 8 double's of 8	1
hold four double precision or	1
hold e.g. four numbers, then	1
memory, as in example 7.22.	1
memory, at least temporarily. Using	1
memory, but not if it	1
memory, using new. The purpose	1
memory, such as DOS and	1
memory, depending on how they	1
memory, windows, mutexes, database connections,	1
p. 43). There is no	1
p. 87). There is no	1
p. 104). The table of	1
p. 22). 159 18 Overview	1
p. 28) The threads have	1
p. 26). Variables stored on	1
p. 57). It is possible	1
SIZE; r++) { for (c	3
SIZE; r++) { // loop	1
SIZE; c++) { StoreNTD(&a[c][r], b[r][c]);	1
SIZE; c++) { a[c][r] =	1
SIZE; r1 += TILESIZE) {	1
case. The best solution is	1
case. The -fpie option is	1
case. A binary tree may	1
case. You cannot expect a	1
case. Loop unrolling should preferably	1
case. Intrinsic functions look clumsy	1
case. Inlined functions have a	1
( short int bb[size] );	1
( short int cc[size] );	1
( short int aa[size] );	1
( ; i < arraysize;	1
( 1)sign 2exponent 127 1	1
( 1)sign 2exponent 16383 one	1
( 1)sign 2exponent 1023 1	1
expensive and more error prone.	1
expensive in some compilers. If	1
expensive that it is very	1
expensive if they are often	1
expensive - in terms of	1
expensive than an uncached read	1
expensive cache contentions, as explained	1
rounding and truncation. The missing	1
rounding and truncation. Efficient conversion	1
rounding mode has to be	1
rounding unless the SSE2 instruction	1
rounding instead of truncation and	1
rounding instead of truncation. This	1
rounding 137 errors must be	1
130 for an explanation and	1
130 for how to make	1
130 for how to overcome	1
130 for details). The Intel	1
130 14 Specific optimization topics	1
130 14.4 511 511 2040	1
130 Compile for a specific	1
far from the server. These	1
far from each other is	1
far from optimal. The branches	1
far data segment by using	1
far pointers, and far procedures	1
far procedures are inefficient. If	1
far (arrays can also be	1
They can be accessed from	1
They can be joined into	1
They can detect that the	1
They may be scattered around	1
They have not been tested	1
They have worked well in	1
They sometimes give misleading results	1
exceptions is to return from	1
exceptions a function can throw.	1
exceptions in this block: 62	1
exceptions are indeed of the	1
exceptions can be ruled out	1
exceptions throw() throw() throw() throw()	1
exceptions thrown by F2 and	1
system, the more important it	1
system, and therefore the system	1
system, and 512 bits when	1
system, as explained below. Shared	1
system, not by the application	1
system, this requires static linking	1
system, but you can reduce	1
absolute value of the floating	1
absolute value of the residual	1
absolute value by setting the	1
absolute addresses that need relocation,	1
absolute references in 32 bit	1
absolute addresses. This works in	1
absolute values: // Example 14.28	1
(a + b) + (c	1
(a * c > b)	1
(a > b / c)	1
(a > b ? a	1
(a >= b) - n.a.	1
(a == 0) { if	1
(a != 0) { if	1
machine are frameworks that typically	1
machine code is the same.	1
machine code to the device.	1
machine code and how the	1
machine code becomes the same	1
machine instructions executed, cache misses,	1
machine instructions. Intrinsic functions are	1
Induction = r; for (i	1
Induction variables for other integer	1
Induction variables for float expressions	1
Induction variables for array elements	1
Induction variables are often used	1
Induction variables An expression that	1
Induction ; edx = point	1
120 for how to align	1
120 for discussion of aligning	1
120 However, there are many	1
120 13 Making critical code	1
120 ms by selecting optimize	1
120 12.10 Conclusion .......................................................................................................... 120	1
120 12.9 Aligning RGB video	1
hardly any performance penalty to	1
hardly any speed advantage in	1
hardly any effect on the	1
hardly any loss of efficiency.	1
hardly relevant to optimization. Prefetching	1
hardly worth the effort to	1
hardly ever used, though. Some	1
CPUID is artificially changed to	1
CPUID instruction doesn't give the	1
CPUID instruction was certain to	1
CPUID instruction directly, or use	1
CPUID information that we can	1
CPUID information about supported instruction	1
CPUID was manipulated to fake	1
saved in the beginning. ret	1
saved in a special cache	1
saved in registers, not in	1
saved from one iteration to	1
saved all information about the	1
saved variable members of the	1
saved either in the carry	1
changes the function pointer and	1
changes the function calling method	1
changes of the function pointer	1
changes in the clock frequency.	1
changes for each version. The	1
changes then you may get	1
changes fastest: // Example 7.17	1
integers, and they always evaluate	1
integers, as long as you	1
integers, then the expression y	1
integers, which is less efficient.	1
integers, but they are in	1
integers, while the multiplication is	1
integers, depending on the processor).	1
collection of a variable number	1
collection of example container classes	1
collection can occur at random	1
collection may start at unpredictable	1
collection when the heap space	1
collection takes a considerable amount	1
collection contains well-tested libraries for	1
manuals is copyrighted by Agner	1
manuals are for those who	1
manuals are used by thousands	1
manuals are always available from	1
manuals can be used without	1
manuals by Agner Fog The	1
manuals from Intel: "IA-32 Intel	1
processor. The CPU dispatcher checks	1
processor. This is called the	1
processor. However, this involves the	1
processor. Such a soft processor	1
processor. Extra time is needed	1
processor. Nested loops are predicted	2
Shared objects in 64 bit	1
Shared objects in 32 bit	1
Shared objects in Linux, BSD	1
Shared objects in BSD work	1
Shared objects in BSD Shared	1
Shared objects in Unix-like systems	1
Shared objects are normally compiled	1
storing the elements consecutively in	1
storing function return addresses (i.e.	1
storing data without caching is	1
storing user data. A database	1
storing intermediate results as floating	1
storing strings in character arrays	1
storing text or input data.	1
developers may therefore fail to	1
developers should be aware of.	1
developers should take installation time	1
developers typically have more powerful	1
developers choose other programming languages.	1
developers who want to make	1
developers feel that a particular	1
parm2) { // Get supported	1
parm2) {...} // SSE2 version	2
parm2) {...} // AVX version	2
parm2) {...} // Dispatcher. Will	1
parm2) {...} // Prototype for	1
T is a class with	1
T to T+5, then it	1
T // Constructor // Initialize	1
T const & b) {	1
T & operator[] (unsigned int	1
T max(T const & a,	1
T a[N]; public: SafeArray() {	1
eliminate this jump by copying	1
eliminate one division by making	1
eliminate i and use the	1
eliminate common subexpressions that contain	1
eliminate common sub-expressions. Why is	1
eliminate everything that depends only	1
eliminate branches, as explained in	1
2: // Example 14.7b. Testing	1
2: template <bool IsPowerOf2, int	1
2: 12 $B1$1: push mov	1
2: "Optimizing subroutines in assembly	3
2: printf("Gamma"); break; case 3:	1
composite objects to a function	1
composite objects are returned by	1
composite type is more complex	1
composite type is most efficient	1
composite type can be returned	1
composite type such as a	1
composite object, you may consider	1
profilers are not always accurate,	1
profilers are often unreliable. They	1
profilers are useful for identifying	1
profilers such as AQtime, Intel	1
profilers available which are useful	1
profilers require that the code	1
profilers are: Coarse time measurement.	1
highly system dependent and therefore	1
highly optimized for the Intel	1
highly optimized for large data	1
highly optimized code with CPU	1
highly optimized program is often	1
highly compatible with Gnu. It	1
highly optimized, using assembly language	1
again and again for every	1
again and again. If there	1
again for every iteration of	1
again from address 0x2710 will	1
again two times the first	1
again takes extra time. The	1
again before the cache line	1
127 int CriticalFunction_AVX(int parm1, int	1
127 will generate -128, and	1
127 bytes is slightly less	1
127 1 fraction 2 23	1
127 127 126 12.2 128	1
127 126 12.2 128 128	1
127 int8_t short int in	1
language. It is important to	1
language. C++ takes only slightly	1
language. In fact, you may	1
language. See page 141 for	1
language. Such a processor will	1
language. Here are some examples:	1
language. D has many of	1
aware of when type-casting pointers:	1
aware of possible overflow on	1
aware of these obstacles and	1
aware of situations where the	1
aware that there is often	1
aware that there are inherent	1
aware of. Big runtime frameworks.	1
Alternatively, you can use the	1
Alternatively, you may call the	1
Alternatively, you may define a	1
Alternatively, you may reuse the	1
Alternatively, you may actively invalidate	1
Alternatively, use a negative list	1
Alternatively, make a DLL with	1
capabilities of modern CPUs, as	1
capabilities for 32-bit and 64-bit	1
capabilities are very smart. They	1
capabilities can overlap the iterations	1
capabilities (see page 103) will	1
capabilities still have a niche	1
capabilities (except in device drivers	1
4) { // SSE2 supported	2
4) { // Check that	1
4) { s0 += a[i];	1
4) + a. You can	1
4) | ((C & 3)	1
4) | (C << 6);	1
linker to a specific load	1
linker to remove unreferenced functions.	1
linker and the loader. 2.	1
linker and loader (requires binutils	1
linker will generate an error	1
linker makes an error message	1
linker extracts the functions that	1
int64_t 2 AVX2 _mm256_i64gather_epi32 unlimited	1
int64_t 4 AVX2 _mm_i32gather_ps unlimited	1
int64_t 64 I64vec1 8 16	1
int64_t 128 I64vec2 Vec2q 64	1
int64_t 256 uint64_t 256 float	1
int64_t MS compiler: __int64 64	1
int64_t 29 64-bit Linux: long	1
bits. The vector instructions cannot	1
bits. The unsigned integer type	1
bits. The method is somewhat	1
bits. This is only an	1
bits. This is usually done	1
bits. This makes data caching	1
bits. There is no check	1
measurements to avoid this. (In	1
measurements to see if our	1
measurements are unstable due to	1
measurements can become imprecise or	1
measurements on this part of	1
measurements as accurate and reproducible	1
measurements may require a very	1
representation is particularly tricky. I	1
representation of the exponent is	1
representation of float, double and	1
representation of &list[100] is (int)(&list[100])	1
representation of N: #define N1	1
representation directly with the use	1
representation according to the IEEE	1
SomeFunction (int a, int x[])	1
SomeFunction (int a, bool b)	4
SomeFunction (int x) { static	1
SomeFunction (int n) { if	1
size, not as a linked	1
size, because these are incompatible	1
size, which is typically 64	1
size, bits minimum value maximum	1
size, while high-level languages are	1
size, bytes alignment, bytes bool	1
size, etc. There are a	1
is. The 64-bit version is	1
is. The type __m128i defines	1
is. // Example 15.1d. Integer	1
is. This above code will	1
is. It is important to	1
is. ecx contains the address	1
is. Factors that make vectorization	1
reductions: Common subexpression elimination x	1
reductions: x-- x x-- x	1
reductions: a+b = b+a a*b	1
reductions: a+b=b+a a*b=b*a a+b+c=a+(b+c) (a+b)+c=a+(b+c)	1
reductions: !(!a)=a x-xxxxxxx ---x----- x--xx----	1
reductions: a+b=b+a, a*b=b*a x n.a.	1
reductions: ~(~a) = a -	1
waiting for each other in	1
waiting for user input or	2
waiting for better metaprogramming tools	1
waiting for response from a	1
waiting for disk operations to	1
waiting for response. It is	1
available, one from Intel and	1
available, such as the "Intel	1
available, we may choose the	1
available, 256 bits (YMM) if	1
available, though less user friendly.	1
available, e.g. AVX, AVX2 Mathematical	1
available, i.e. in 64-bit mode	1
automatically. The code has a	1
automatically. The development time and	1
automatically. The alignment of structure	1
automatically. It is also useful	1
automatically. There is no reason	1
automatically. For example, let's look	1
automatically. However, there are a	1
powers of 2 if a	1
powers of 2 when multiplying	1
powers of 2 does not	1
powers of 2 applies only	1
powers of 2 (i.e. 2,	1
powers of 2. Using hexadecimal	1
powers of 2: // Example	1
debug and maintain. Most compiler	1
debug version of the code	1
debug version of the code.	1
debug version and a release	1
debug version with full debugging	1
debug information in order to	1
debug breakpoints at every function	1
polymorphism is needed only if	1
polymorphism that is obtained with	1
polymorphism or with compile-time polymorphism.	1
polymorphism with virtual functions class	1
polymorphism with templates // Place	1
polymorphism A template class can	1
polymorphism effect with templates instead	1
Clang and Intel compilers can	1
Clang and Intel compilers. We	1
Clang The Clang compiler combined	1
Clang compiler is a good	1
Clang compiler combined with the	1
Clang compilers. The code is	1
Clang Supported operating systems Windows,	1
measured in this way includes	1
measured with millisecond resolution and	1
measured on a Pentium 4	1
measured time is interpreted in	1
measured simply by removing the	1
measured results were as follows:	1
measured separately. The fallacy of	1
details. The behavior of the	1
details. The funny looking name	1
details. // Example 12.7. Vector	1
details. Use function libraries with	1
details. Note that the CPU	1
details. Development time Some developers	1
details. Inheritance from multiple parent	1
factor is a power of	1
factor of 1, 2, 4	1
factor to multiply j by	1
factor in itself, and the	1
factor 4 in the best	1
factor rather than the product	1
factor sizeof(S1) = 16 is	1
x); // x^1, x^2, x^3,	1
x); } // Branch/loop function	1
x); } void SelectAddMul(short int	1
x); } 112 Vectorized table	1
x); const int size =	1
x); s = _mm_hadd_ps(s, s);	1
x); 136 ... for (i	1
core. It is the responsibility	1
core. It is often necessary	1
core. There are four kinds	1
core. For example, a Core	1
core. Unfortunately, contemporary operating systems	1
core. Two threads running in	1
core. Try to allocate more	1
rules of algebra in a	1
rules of algebra are the	1
rules of algebra, we may	1
rules for prediction and misprediction	1
rules about register use, as	1
rules apply to modulo calculations:	1
rules apply as to the	1
speed. This includes languages such	1
speed. A simple solution to	1
speed. In the same way,	1
speed. In this case there	1
speed. Assume that you have	1
speed. Optimizing for size is	1
speed. Delays or glitches in	1
vectorization. The compiler will vectorize	1
vectorization. The Gnu compiler can	1
vectorization. The newest instruction sets	1
vectorization. It is possible to	1
vectorization. 3. Use appropriate compiler	1
vectorization. Optimizes reasonably well. Very	1
vectorization. Optimizes moderately well. Supports	1
anyway. The exception is costly	1
anyway. It may be advantageous	1
anyway. If we modify example	1
anyway. You may preferably avoid	1
anyway. Software distributors are often	1
anyway. Pure function. __attribute__((const)) (Linux	1
anyway. Updates to the operating	1
smallest data size that fits	1
smallest integer size that is	2
smallest integer size that doesn't	1
smallest list of data. A	1
smallest members last: // Example	1
smallest devices, you don't even	1
responsibility of the operating system	1
responsibility of the exception handler	1
responsibility of the programmer to	5
Mathematical vector function libraries. Use	1
Mathematical functions The most common	1
Mathematical functions for vectors There	1
Mathematical functions for vectors........................................................................ 119	1
Mathematical functions must use a	1
Mathematical functions ....................................................................................... 145 14.11	1
Mathematical functions Encryption, decryption, data	1
MMX to 128-bit XMM and	1
MMX int 32 2 64	1
MMX long long 64 1	1
MMX short int 16 4	1
MMX char 8 16 128	1
MMX registers, which are 64	1
MMX mmintrin.h SSE xmmintrin.h SSE2	1
reliable and reproducible results. If	1
reliable than third party security	1
reliable source so that it	1
reliable results for branch mispredictions.	1
reliable solution. (In my tests,	1
reliable results. If you are	1
reliable decision. 13.4 Test and	1
Borland and Digital Mars compilers	1
Borland compiler with other compilers	1
Borland C++ builder. Not optimized	1
Borland C++ 5.82 (Embarcadero/CodeGear/Borland C++	1
Borland / CodeGear / Embarcadero	1
Borland Microsoft Constant propagation Pointer	1
Borland bcc, v. 5.5 Mac:	1
sense to dispatch by CPU	1
sense that the template parameters	1
sense that the syntax is	1
sense that all operators that	1
sense that each calculation depends	1
sense that each intrinsic function	1
sense that C++ compilers exist	1
latest instruction set and one	1
latest instruction set extensions. If	1
latest compilers from Microsoft, Intel	1
latest version of the application	1
latest version of the compiler.	1
latest version of Mathcad (v.	1
latest versions of these manuals	1
Now the code will run	1
Now the two parentheses can	1
Now it is the responsibility	1
Now call the chosen version	1
Now ebx contains i/2+r. The	1
Now s0, s1, s2 and	1
Now 1.0 <= u.f <	1
units and hence higher speed.	1
units in the CPU. It	1
units are used twice for	1
units can be used as	1
units same size as vector	1
units rather than by the	1
units smaller than the vector	1
do. The following sections describe	1
do. The reason why compilers	1
do. This is called stack	1
do. This results in meaningless	1
do. It is important for	1
do. All the reductions that	1
do. Hence, it is hardly	1
reciprocal of the clock frequency.	1
reciprocal of the clock frequency,	1
reciprocal in the code, so	1
reciprocal n.a. - n.a. -	1
reciprocal Boolean algebra reductions: !(!a)=a	1
reciprocal square root, RGB color	1
reciprocal factorials so that we	1
d, __m128i const & x)	4
d, y; y = a	1
d, y; y = (a	1
d, e, f, x, y;	1
threads. The compiler supports CPU	1
threads. The use of threads	1
threads. The overhead of semaphores,	1
threads. There are two main	1
threads. Each thread can then	1
threads. Don't put a task	1
threads. Out-of-order execution (chapter 11)	1
log is a library function	1
log are pure functions, but	1
log on with a password.	1
log on process is known	1
log on process may take	1
log off the computer for	1
log (b[i] * c[i]); }	1
thousand cache misses have occurred.	1
thousand so the misprediction penalty	1
thousand times then the loop	1
thousand times lower; and the	1
thousand numbers as a parameter	1
thousand results in another array.	1
thousand numbers. With a long	1
compile-time if statements (called static	1
compile-time constant n, then we	1
compile-time while loops, then the	1
compile-time whether the object belongs	1
compile-time generation of identifier names.	1
compile-time polymorphism. It is sometimes	1
compile-time polymorphism, which is more	1
remove the const restriction on	1
remove the interrupt 3 breakpoint	1
remove the memset line if	1
remove or modify objects simultaneously.	1
remove all disturbing influences in	1
remove any objects if no	1
remove unreferenced functions. It is	1
Intel's CPU dispatcher. See page	2
Intel's compilers and invoked with	1
Intel's profiler is called VTune;	1
Intel's Math Kernel Library (MKL	1
Intel's Math Kernel Library, available	1
Intel's term for running multiple	1
16. This is a problem	1
16. This method is useful	1
16. If you read the	1
16. In example 12.1a, the	1
16. You can generally assume	1
16. Library versions tested (not	1
16. Alignment of data structures	1
registers, and possibly save exception	1
registers, not in memory. The	1
registers, not on variables in	1
registers, which are 64 bits	1
registers, regardless of whether they	1
registers, whereas 64-bit Linux, BSD	1
registers, totaling up to fourteen	1
transpose the matrix when the	1
transpose a matrix when contentions	1
transpose a matrix using example	1
transpose and copy matrix void	2
transpose function swapd(a[r][c], a[c][r]); void	1
transpose matrix // define a	1
wait for the new value	1
wait for the result of	1
wait for a result then	1
wait for another memory access.	1
wait until the value has	1
wait until a few clock	1
wait until seconds has been	1
number. The only CPUID information	1
number. If the offset relative	1
number. If a and b	1
number. I have seen many	1
number. Therefore, it is slightly	1
number. We can convert an	1
number. Failure to handle unknown	1
break a few times may	1
break a dependency chain. 3.16	1
break will occur in this	1
break at the interrupt 3	1
break while the program is	1
break down dependency chains (see	1
constant. The compilers also have	1
constant. // General case, N	1
constant. It is therefore necessary	1
constant. If the loop count	1
constant. Example: // Example 14.12a	1
constant. 14.2 Bounds checking In	1
linkage table (PLT) and a	1
linkage table (PLT) in the	1
linkage table (PLT) that is	1
linkage table (PLT). The memory	1
linkage table (PLT). And whenever	1
linkage table. If a dispatched	1
possible, and the dispatching should	1
possible, and make sure you	1
possible, and avoid dynamic memory	1
possible, and replaced by storage	1
possible, or the error code	1
possible, so that the value	1
scan instruction is executed only	1
scan instruction and have implemented	1
scan instruction and expect this	1
scan instructions. My recommendation is	1
scan instruction. Programmers that have	1
scan forward) instruction to localize	1
systems: The number of registers	1
systems: int 16 -32768 32767	1
systems: long int 32 -231	1
systems: unsigned int 16 0	1
systems: unsigned long 32 0	1
systems: Pointers, references, and stack	1
predictable the branch inside the	1
predictable than the other, then	1
predictable than integer comparisons. The	1
predictable then replace it by	1
predictable branch by a table	1
predictable operand first. If one	1
"Hello 2" The dispatching to	1
"Hello 2" Here CParent is	1
"Hello "; // call polymorphic	1
"Hello "; Disp(); class C1	1
"Hello 1" // Writes "Hello	2
equal to the time it	1
equal to the number of	1
equal to the address of	1
equal to the critical stride,	1
equal to the preceding label	1
equal amount of work into	1
CodeGear compiler cannot make floating	1
CodeGear / Embarcadero Comes with	1
CodeGear Microsoft Table 2.1. Comparing	1
CodeGear Borland bcc, v. 5.5	1
CodeGear compiler). Fastcall functions are	1
CodeGear compiler) integer parameters are	1
compact and efficient if the	1
compact and takes little space	1
compact if the offset of	1
compact by joining identical pieces	1
compact than an MFC application.	1
compact so that the code	1
polynomial of the loop counter	1
polynomial The calculation of this	1
polynomial can be done with	1
polynomial // Polynomial coefficients //	1
polynomial with induction variables const	1
polynomial (Vec4f const & x)	1
Common subexpression elimination x n.a.	1
Common subexpression elimination If the	1
Common subexpression elimin., integer Common	1
Common subexpression elimin., float Register	1
Common devices are CPLDs and	1
Common Language Runtime, CLR, to	1
reads to the same memory	1
reads and writes may slow	1
reads or writes a file	1
reads or writes to any	1
reads from address 0x2710 and	1
reads from addresses 0x2F00, 0x3700,	1
plus the costs to other	1
plus a constant plus an	1
plus an index multiplied by	1
plus 6 integer, pointer or	1
plus one, because it can	1
plus i*sizeof(S1). This is a	1
5: calling conventions. The dot	1
5: "Calling conventions for different	5
increase the time slices to	1
increase the size of a	1
increase the speed or not.	1
increase the throughput of CPU-intensive	1
increase the likelihood that certain	1
increase in develop- ment time	1
casting of pointers may not	1
casting of pointers because this	1
casting // C++ casting operator	1
casting // Constructor-style type casting	1
casting operator that specifies how	1
casting operator These different methods	1
course, and causes the heap	1
course, that you compile the	1
course, if the value of	1
course, this works only if	1
course, because you will get	1
course, but this is permissible	1
scope of the function where	1
scope of a variable even	1
scope of this manual. You	1
scope of this manual. 2.3	1
scope of this manual, but	1
scope or namespaces. Therefore, you	1
principle is useful whenever a	1
principle of table lookup can	1
principle of lazy binding is	1
principle for a 2'nd order	1
principle for objects stored in	1
principle as in example 16.2	1
throughput of the execution units	1
throughput of an execution unit.	1
throughput of CPU-intensive programs when	1
throughput There is an important	1
throughput (see p. 104). The	1
throughput ....................................................................................... 22 4 Performance	1
spent in the program under	1
spent in the innermost loop	1
spent on function calls in	1
spent on reading and writing	1
spent on executing instructions are	1
spent fighting with the problems	1
16; a = (unsigned int)b	2
16; // This is slow	2
16; int i; float list[size];	1
16; n++) { sum +=	1
Func is executed. This has	1
Func is executed. Without static,	1
Func with a lot of	1
Func 87 used cache line	1
Func () { static const	1
Func ;a ;r ; unused	1
identify the critical parts of	1
identify the circumstances around the	1
identify a hot spot. Use	1
identify and isolate the most	1
identify performance bottlenecks is to	1
identify individual functions or code	1
15 on the old Pentium	1
15 clock cycles (depending on	1
15 Integer overflow is another	1
15 byte at 16, last	1
15 Metaprogramming Metaprogramming means to	1
15 Metaprogramming ....................................................................................................... 150 16	1
14 - 45 clock cycles.	1
14 3 Finding the biggest	1
14 2.8 Overcoming the drawbacks	1
14 Specific optimization topics .........................................................................................	1
14 Specific optimization topics 14.1	1
14 Portability C++ is fully	1
this. The Intel compiler is	1
this. It also prevents the	1
this. See page 140 for	1
this. Unfortunately, the syntax is	1
this. My example is a	1
this. (In Windows, SetThreadAffinityMask, in	1
Register variables The most commonly	1
Register allocation and function inlining	1
Register storage A limited number	1
Register ebx is pushed on	1
Register variables, integer Register variables,	1
Register variables, float Live range	1
complex and often inefficient. Objects	1
complex if the parameter has	1
complex integer expressions. See page	1
complex cases it might not	1
complex framework requiring many files	1
complex digital operation can often	1
Intrinsic function name Instruction set	1
Intrinsic function Size of each	1
Intrinsic functions for vectorized table	1
Intrinsic functions are supported by	1
Intrinsic functions are primitive operations	1
Intrinsic functions look clumsy and	1
call. The function is called	1
call. A branch tree or	1
call. I have implemented a	1
call. Load library at initialization.	1
call. Algebraic reduction Most compilers	1
call. (2) find the GOT	1
notice is that the value	1
notice is that it does	1
notice that the code is	1
notice that some compilers will	1
notice This series of five	1
notice .......................................................................................................... 164 1 Introduction	1
Add the keyword static to	1
Add to this the time	2
Add to 122 this the	1
Add 2 to each element	2
prediction. The time it takes	1
prediction. A loop with a	1
prediction. A Pentium M processor	1
prediction. If one operand is	1
prediction. Example: // Example 14.3a	1
prediction. Modern microprocessors are using	1
expected to be available in	1
expected to be higher due	1
expected to replace the Gnu	1
expected for further expansions of	1
expected that the number of	1
expected real-time speed. Delays or	1
declare the function inline. Replacing	1
declare the table static. This	1
declare it locally in the	1
declare an int, without specifying	1
declare all functions static or	1
declare objects and fixed size	1
application. The integer size is	1
application. The development time for	1
application. The availability of various	1
application. If hyperthreading is not	1
application. In example 12.3a, for	1
application. You may use single	1
here. The compiler option -fno-pic	1
here. The address of x	1
here. It may be more	1
here. It reveals a funda-	1
here. You cannot use ~	1
here. Any code that accesses	1
largest vector register size is	1
largest available register size. In	1
largest element in a matrix	1
largest element in an array,	1
largest element (approximately): if (absvalue	1
largest vector. These units are	1
dispatched function is never called.	1
dispatched function then the dispatch	1
dispatched function call inline void	1
dispatched function calls another dispatched	1
dispatched version return (*SelectAddMul_pointer)(aa, bb,	2
members. The code that accesses	1
members. This alignment can cause	1
members. A simple constructor may	1
members. It is recommended to	1
members. If the class has	1
members. But each member function	1
fits the microprocessor it is	1
fits the application. In example	1
fits into a single register	1
fits into a 128-bit XMM	1
fits best into the algorithm	2
x-xxxx--x x-xxxx--x x-xx----- x--x----- ---x-----	1
x-xxxx--x x-xx----- x--x----- ---x----- x---x---x	1
x-xxxx--x Profile-guided optimization Whole program	1
x-xxxx--x ~a&~b=~(a|b) --xxxx--- a &	1
x-xxxx--x (a|b)&(a|c) = a|(b&c) x-xxxx--x	1
x-xxxx--x Constantfolding xxxxxxxxx Codeplay Watcom	1
giving the function a different	1
giving it some heavy work	1
giving this example only to	1
giving each constant a value	1
giving access to low-level optimizations.	1
giving specific optimization instructions at	1
comparisons are more predictable than	1
comparisons are slow unless the	1
comparisons are inefficient when the	1
comparisons by one makes the	1
comparisons more efficient. This instruction	1
comparisons i < 0 and	1
Performance and usability A better	1
Performance and usability ............................................................................................... 23	1
Performance for further explanation. The	1
Performance Primitives (IPP). Works with	1
Performance Primitives" library contains many	1
Performance Primitives". These function libraries	1
above, the maximum loop count	1
above, it is clear that	1
above, but read one or	1
above, page 87) is likely	1
above, so that it can	1
above, p. 26). Variables stored	1
above. The generality of the	1
above. A shared object compiled	1
above. An object cannot be	1
above. Now the code will	1
above. Examples are provided in	1
above. 7. If the arrays	1
Pointer type conversion A pointer	1
Pointer aliasing When accessing a	1
Pointer arithmetic A pointer is	1
Pointer arithmetic operations are therefore	1
Pointer elimination A pointer or	1
Pointer elimination Common subexpression elimin.,	1
detect the misprediction before it	1
detect that the value of	1
detect if any objects declared	1
detect an error if the	1
detect which instruction set is	1
detect opportunities for parallelization in	1
normal on some microprocessors when	1
normal return route. This mechanism	1
normal unsigned int exponent :	1
normal writes or reads to	1
normal array. The constructor sets	1
normal afterwards. The clock counts	1
Several function libraries published by	1
Several other programming languages are	1
Several modern programming languages use	1
Several special purpose libraries are	1
Several graphical interface frameworks are	1
Several internet forums and newsgroups	1
convenient to have the member	1
convenient to make a test	1
convenient to calculate the table	1
convenient to rely on compiler	1
convenient for adding bounds-checking to	1
convenient way of making the	1
show the values of all	1
show a discrete icon signaling	1
show a disassembly, probably without	1
show that it takes six	1
show how tortuous and convoluted	1
show various ways of reducing	1
column to the diagonal. The	1
column < NUMCOLUMNS; column++) matrix[row][column]	1
column 28 because the cache	1
column 28 above the diagonal.	1
column 29 with line 29.	1
column 28, the cache will	1
{...} // SSE2 version int	2
{...} // AVX version int	1
{...} // AVX version 127	1
{...} // Dispatcher. Will be	1
{...} // Prototype for the	1
Test the whole software package,	1
Test and maintenance There are	1
Test and maintenance .......................................................................................... 126	1
Test if the program runs	1
Test with different brands of	1
Test Processor memcpy 16kB aligned	1
c1 for all squares: for	1
c1 { const int x;	1
c1 other than its name	1
c1 < r1; c1 +=	1
c1 before MemberPointer is declared.	1
c1 += TILESIZE) { //	1
x- x x x x	1
x- x x x x-	1
x- x x x --	1
x- x ----- - x-xxx	1
x- x (x) x (x)	1
x- x- x (x) x	1
Number of elements in vector	1
Number of elements Total size	1
Number of times to test	1
Number of simultaneous lookups Max.	1
Number 18 will evict number	1
Number 17 will evict number	1
portability is important. This manual	1
portability to 64-bit mode, as	1
portability and development time. Interpreted	1
portability and ease of development	1
portability could be achieved more	1
portability issue to catching hardware	1
SSE3 instruction set Suppl. SSE3	1
SSE3 required // This function	1
SSE3 instr. set SSE4.1 instr.	1
SSE3 tmmintrin.h SSE4.1 smmintrin.h SSE4.2	1
SSE3 pmmintrin.h Suppl. SSE3 tmmintrin.h	1
SSE3 horizontal add, etc. SSSE3	1
evaluate the loop control statement	1
evaluate a only when b	1
evaluate and are equally likely	1
evaluate b when a is	1
evaluate whether it is optimal	1
evaluate both operands. Nevertheless, the	1
embedded systems ............................................................................. 158 18	1
embedded systems Microcontrollers used in	1
embedded systems. A look in	1
embedded systems. Today (2013) both	1
embedded applications have less computing	1
embedded microcontrollers. I am not	1
Agner vector classes #include "vectorclass.h"	1
Agner 8 8 char 64	1
Agner Available from Intel and	1
Agner Fog. Technical University of	1
Agner Fog. Public distribution and	1
Agner Fog The present manual	1
availability of an update, or	1
availability of x for approximately	1
availability of these instruction sets.	1
availability of good development tools,	1
availability of various instruction sets	1
availability of powerful development tools.	1
13.1 can be placed in	1
13.1 // CPU dispatching on	1
13.1 CPU dispatch strategies........................................................................................ 122	1
13.1 CPU dispatch strategies It	1
13.1 page 127. The Intel	1
13.1 below. 126 Make pointer	1
reference, the compiler may not	1
reference, a const reference allows	1
reference, or the function could	1
reference, or void. Returning objects	1
reference, 64-bit mode 8 8	1
reference, 32-bit mode 4 4	1
.NET and the best Java	1
.NET framework and the Java	1
.NET framework are based on	1
.NET framework as well as	1
.NET framework should definitely be	1
.NET framework. Obviously, the directly	1
!= 0; 35 This is	1
!= 0) { if (n	1
!= 0) { if (b	1
!= 0) { c =	1
!= 0) *(p++) |= 0x20;	1
!= INVALID_HANDLE_VALUE && WriteFile(handle, ...))	1
files, data base access, etc.	1
files, preferably in the same	1
files, resource files, help files	1
files, help files and databases.	1
files, help files etc. scattered	1
files, configuration files, help files	1
Pointers to contained objects? It	1
Pointers and references are equally	1
Pointers and references Pointers versus	1
Pointers and references ............................................................................................ 36	1
Pointers can be invalid and	1
Pointers versus references Pointers and	1
half the size of the	1
half the single-thread speed. In	1
half a square. // This	1
half of it, for example	1
half speed or full speed.	1
half speed because of cache	1
converting the data to the	1
converting a to double before	1
converting a to unsigned in	1
converting a pointer to one	1
converting to floating point: //	1
converting to double In example	1
occurs in the innermost function,	1
occurs in each part of	1
occurs more than once then	1
occurs because the addresses are	1
occurs during execution of CriticalFunction.	1
occurs somewhere in F1? Then	1
Set function pointer if else	1
Set pointer to the appropriate	2
Set sign bit of x	1
Set flush-to-zero and denormals-are-zero mode	1
Set flush-to-zero mode (SSE): #include	1
costly to many users. Firewalls,	1
costly and which are cheap,	1
costly if XMM registers are	1
costly when it occurs, but	1
costly because all caches have	1
costly because they must be	1
newest CPU of a particular	1
newest CPU model, which quite	1
newest instruction set is that	1
newest instruction sets include a	1
newest instruction set. High precision	1
newest processors. Supports all x86	1
specifying the type and size	1
specifying the size. Integers of	1
specifying that two pointers of	1
specifying that pointers of different	1
specifying parallel processing in C++	1
specifying otherwise. In difficult cases	1
follows the mathematical notion of	1
follows a simple regular pattern,	1
follows a simple periodic pattern	2
follows in 64-bit mode or	1
follows (using Intel vector classes):	1
comparing the loop counter with	1
comparing it to any other	1
comparing i with 100 in	1
comparing bits 32-62. This can	1
comparing signed with unsigned integers	1
comparing them as integers: //	1
efficient, and sometimes it does	1
efficient, and that's what they	1
efficient, but the syntax is	1
efficient, but not safe unless	1
efficient, but risky. The returned	1
efficient, way of doing whole	1
computers to keep up with	1
computers and my manual will	1
computers with more RAM than	1
computers have memory caches. Typically,	1
computers have very different speeds.	1
computers have become more powerful.	1
B and C are too	1
B = 2.2, C =	2
B value in the last	1
B before the calculation of	1
B values. The choice of	1
System code has to obey	1
System code should be written	1
System programming .......................................................................................... 150 15	1
System programming Device drivers, interrupt	1
System database It can take	1
System database ...................................................................................................... 20 3.9	1
five or ten years old.	1
five values have to be	1
five manuals is copyrighted by	1
five times. Thread-local storage Most	1
five manuals. See page 3	1
five manuals: 1. Optimizing software	1
step of the sequence in	1
step of interpretation or compilation	1
step in the sequence of	1
step by step. In most	1
step where the compilation is	1
step rather than the complicated	1
poor if data are scattered	1
poor because it lacks the	1
poor CPU dispatching. For example,	1
poor performance for vector intrinsics.	1
poor branch prediction. Example: //	1
poor documentation and lack of	1
prefetch the data. The effect	1
prefetch more than one line	1
prefetch data for regular access	1
prefetch data automatically thanks to	1
prefetch data explicitly if data	1
prefetch instruction can be used	1
9 and 13 objects, respectively	1
9 and 64, depending on	1
9 + 3; } The	1
9 extra overhead which consumes	1
9 Optimizing memory access .............................................................................................	1
9 Optimizing memory access 9.1	1
deciding which version to use	1
deciding whether to use dynamic	1
deciding whether to store help	1
deciding whether to base a	1
deciding whether it is advantageous	1
deciding whether it is profitable	1
self-relative addresses is much simpler	1
self-relative references in 32-bit mode.	1
self-relative address. (3) look up	1
self-relative addressing of data. The	1
self-relative addressing of data. This	1
self-relative addressing. In 32-bit Linux	1
(float const x) { return	1
(float x) { return x	2
(float x) { return square(x)	1
(float a) { return a	1
(float *)alloca(n * sizeof(float)); //	1
Core and later Intel processors.	1
Core 2 0.12 0.18 0.12	1
Core 2 0.77 0.89 0.40	1
Core 2 0.63 0.75 0.18	1
Core Math Library __vrs4_expf __vrd2_exp	1
Core i7 processor with four	1
debugger is not the optimized	1
debugger to identify the circumstances	1
debugger and press break while	1
debugger can execute a code	1
debugger then it will break	1
debugger cannot set a breakpoint	1
^ b ---xx---- a<<b<<c=a<<(b+c) x-xxx--xx	1
^ 1; You cannot replace	1
^ -1 = ~a a	1
^ ~a = -1 (a&~b)|(~a&b)=a^b	1
^ operator. The & operator	1
^ ~b = a ^	1
regardless of the value of	1
regardless of the size. However,	1
regardless of precision on most	1
regardless of whether you are	1
regardless of whether they are	1
regardless of scope or namespaces.	1
truncation and make a round	1
truncation and back again. If	1
truncation when the SSE2 instruction	1
truncation takes much longer time	1
truncation so the floating point	1
truncation towards zero, rather than	1
base is not guaranteed to	1
base a software package on	1
base class is converted to	1
base address plus a constant	1
base classes. You may avoid	1
base access, etc. The problem	1
result. The conversion between signed	1
result. A compiler can eliminate	1
result. You can assume that	1
result. Example: // Example 8.2a	1
result. An overflow of an	1
result. An uncaught overflow condition	1
How compilers optimize Modern compilers	1
How compilers optimize ............................................................................................ 66	1
How much is a clock	2
How much you gain in	1
How was it possible to	1
chain. A microprocessor with out-of-order	1
chain. If a floating point	1
chain. We want the CPU	1
chain. Such dependency chains can	1
chain. 3.16 Execution unit throughput	1
chain. Nothing in the calculation	1
Reading a value from a	1
Reading or writing a variable	1
Reading or writing a file	1
Reading or writing to a	1
Reading or writing big blocks	1
Reading again from address 0x2710	1
compilation is finished. Register allocation	1
compilation of the most used	1
compilation of an intermediate code.	1
compilation or interpretation on the	1
compilation may be a viable	1
compilation before it can run.	1
spots and measuring the overall	1
spots in the program by	1
spots in the code. For	1
spots have been identified. My	1
spots Before you start to	1
spots .................................................................................. 16 3.3 Program	1
behavior of the Intel compiler	1
behavior of the first application	1
behavior of static libraries. A	1
behavior of signed integers in	1
behavior can be prevented by	1
behavior well-defined with option -fwrapv	1
happens if the program uses	1
happens when a task switch	1
happens at runtime). The following	1
happens inside the loop, for	1
happens quite often because the	1
happens rarely. The above code	1
7 and Windows Server 2008	1
7 The efficiency of different	2
7 int d; // 4	1
7 program can take advantage	1
7 through 14, with some	1
87 for a discussion of	1
87 used cache line then	1
87 about memory caching. 3.14	1
87 9.3 Functions that are	1
87 9.1 Caching of code	1
87 9.2 Cache organization ...................................................................................................	1
Type of elements Total size	1
Type of elements Size of	1
Type conversions The C++ syntax	1
Type size, bytes alignment, bytes	1
Type casting of pointers may	1
Type conversions.................................................................................................... 40 7.12 Branches	1
places in the code. Many	1
places when the heap has	1
places making the dispatch decision	1
places back in the sequence,	1
places back. Thus, we will	1
places back, where n is	1
unwinding The preceding paragraph described	1
unwinding that is used by	1
unwinding information can be left	1
unwinding mechanism is also used	1
unwinding mechanism may be used	1
unwinding .............................................................................. 65 7.32 Preprocessing	1
static, the logarithm would be	1
static, as explained on page	1
static, when applied to a	4
am not making any specific	1
am not going to recommend	1
am using this for testing	1
am using CPU clock cycles	1
am always happy to receive	1
am giving this example only	1
leaf function is a function	1
leaf function is simpler than	1
leaf function by inlining all	2
leaf functions and frame functions.	1
leaf function. Leaf functions are	1
evaluated in the following way.	1
evaluated if a is true.	1
evaluated if a is false.	1
evaluated at all because the	1
evaluated only when needed. The	1
evaluated every time they are	1
completely because of technical problems.	1
completely independent divisions. Example: //	1
completely rule out the possibility	1
completely contained in a DLL.	1
completely unrolled to avoid the	1
completely absent in a use	1
again. The following example shows	1
again. This may take up	1
again. If there are no	1
again. If there are floating	1
again. Obviously, it is more	1
again. Accessing system devices and	1
powerful and may be sufficient	1
powerful solution is the combination	1
powerful development tools. One popular	1
powerful computers to keep up	1
powerful computers with more RAM	1
powerful facilities that do much	1
form a logical sequence. If	1
form of a linked list	1
form of a re- usable	1
form of error reporting. For	1
form of templates where the	1
form than if the data	1
deallocated in all possible cases	1
deallocated in random order. The	1
deallocated in random order. This	1
deallocated when the function returns.	2
deallocated when returning from the	1
times. This is because we	1
times. This can be a	1
times. A queue should be	1
times. It is often useful	1
times. Then again two times	1
times. Thread-local storage Most compilers	1
32- and 64-bit Windows and	1
32- and 64-bit Windows, Linux	1
32- and 64-bit Linux. Has	1
32- bit version for the	1
32- bit x86 instruction set	1
32- bit mode, where it	1
edx can be changed freely.	1
edx = point to end	1
edx = r ebx, eax	1
edx as a memory pointer.	1
edx but the variable whose	1
edx contains the address of	1
rule of standard C, specifying	2
rule out the possibility that	2
rule out the theoretical possibility	1
rule out aliasing (see page	1
one. The compiler has replaced	1
one. The existing object can	1
one. This prevents the CPU	1
one. It may neverthe- less	1
one. You can improve this	1
one. I have provided several	1
permissible to assume that *p+2	1
permissible in all cases, while	1
permissible for reasons of mathematical	2
permissible if the unsafe code	1
permissible when it is outside	1
worst possible case and make	1
worst possible performance. We must	1
worst case is a branch	1
worst case situation is a	1
worst case situation of the	1
worst problem of the x86	1
job of the application programmer.	1
job can be divided into	1
job into multiple threads. Each	1
job before you. Optimized function	1
job optimizing a particular piece	1
job fast enough. For example,	1
due to the so-called partial	1
due to the design of	1
due to general improvements in	1
due to poor documentation and	1
due to interrupts and task	1
due to controversies over the	1
1.0; for (x = 2.0;	1
1.0; int i; for (i	1
1.0; } }; // Function	1
1.0; while (n != 0)	1
1.0; list[i].b = 2.0; }	1
1.0; temp->b = 2.0; }	1
depend on the result of	1
depend on the hardware platform	1
depend on the system, as	1
depend on x so we	1
depend on network resources are	1
depend on system-specific graphical interface	1
biggest time consumers ................................................................................ 16	1
biggest time consumers 3.1 How	1
biggest possible vector objects //	1
biggest disadvantage of using an	1
biggest vectors: for (int i	1
biggest time-consumer in the program.	1
?Func@@YAXQAHAAH@Z is the name of	1
?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROCNEAR ; parameter	1
?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROC NEAR ;	1
?Func@@YAXQAHAAH@Z ENDP + esp ebx	1
?Func@@YAXQAHAAH@Z PROCNEAR ; parameter 1:	1
?Func@@YAXQAHAAH@Z PROC NEAR ; parameter	1
defines a 128 bit vector	3
defines an algorithm of sequential	1
defines hardware circuits consisting of	1
defines electrical connections rather than	1
overlap. If c = b	1
overlap. You can save a	1
overlap. You should use this	1
overlap. See page 89 for	1
overlap. Compilers do not normally	1
overlap. 27 The number of	1
processing, and mathematical operations on	1
processing, data compression and cryptography	1
processing, OpenMP and automatic vectorization.	2
processing, signal processing, data compression	1
processing, sound processing, and mathematical	1
SelectAddMul(short int aa[], short int	6
users and much time is	1
users in many different applications.	1
users with nagging pop-up messages	1
users as well as important	1
users will prefer to run	1
users have. The developers may	1
soon be obsolete. But if	1
soon as the function returns.	1
soon as you have even	1
soon also 512 bits (ZMM).	1
soon get a lot of	1
soon became available because the	1
six in 32-bit systems and	1
six integer registers available for	1
six integer parameters and the	1
six instructions rather than nine,	1
six times as long time	1
six years old version of	1
Testing the speed of a	1
Testing for the overflow condition	1
Testing multiple conditions using &	1
Testing multiple conditions enum Weekdays	1
Testing speed Testing the speed	1
Testing speed.............................................................................................................. 153 16.1 Using	1
general, the out-of-order execution mechanism	1
general, it is faster to	1
general, you can assume that	1
general, you can expect 64-bit	1
general, you have this problem	1
general, there is no cost	1
roll out the loop and	1
roll out the loop by	2
roll out the calculation of	1
roll out a loop if	1
roll out a big loop	1
(i.e. the current .cpp file)	1
(i.e. if the member function	1
(i.e. where the function was	1
(i.e. variables defined outside any	1
(i.e. 2, 4, 8, 16,	1
(i.e. Microsoft, Intel and Gnu).	1
edx, to ebx. The square	1
edx, DWORD PTR [esp+4] DWORD	1
edx, DWORD PTR [esp+12] ;	1
edx, eax $B2$2 ; Induction++;	1
edx, ecx, edx, DWORD PTR	1
edx, respectively. (In 64-bit mode,	1
C++, and a hardware definition	1
C++, and other languages in	1
C++, it is often necessary	1
C++, directly compiled code and	1
C++, Pascal and Fortran are	1
C++, D, Pascal, Fortran and	1
i); // result = b	1
i); // Load eight consecutive	3
i); // Add 2 to	2
mixed with x87 style floating	1
mixed language 11 programming, etc.	1
mixed precision require precision conversion	1
mixed implementation can be a	1
mixed types or sizes? It	1
mixed sizes. For example: //	1
protection means are among the	1
protection schemes are based on	2
protection schemes are annoying to	1
protection against overflow is needed:	1
protection scheme should be weighed	1
counter. The test tool can	1
counter. This is a counter	1
counter. A microprocessor with out-of-order	1
counter. Example: // Example 8.13a	1
counter. Example: // Example 7.32a	1
counter. Any expression that is	1
structure. The extra time may	1
structure. The situation is more	1
structure. This is equally efficient.	1
structure. It is important to	1
structure. For example: // Example	1
structure. Incrementing or decrementing a	1
4. The if branch is	1
4. The reason is that	1
4. Instruction tables: Lists of	1
4. Even worse, many software	1
4. So the address of	1
4. Align arrays and big	1
security reason for updating. The	1
security reasons before leaving their	1
security problem. The official C	1
security software. Background services. Many	1
security advices in critical parts	1
security matters. Problems with invalid	1
branches. The following methods may	1
branches. The algorithms used for	1
branches. A simple periodic pattern	1
branches. If you are making	1
branches. They can be joined	1
branches. Manual 3: "The microarchitecture	1
Is16vec8 a = select_gt(b, zero,	1
Is16vec8 b = LoadVector(bb +	1
Is16vec8 c = LoadVector(cc +	1
Is16vec8 Vec8s 16 8 unsigned	1
Is16vec8 two(2,2,2,2,2,2,2,2); // Roll out	1
Is16vec8 zero(0,0,0,0,0,0,0,0); // Make a	1
cores. A process or thread	1
cores. You may have to	1
cores. You may need to	1
cores. Each thread should then	1
cores. 3.15 Dependency chains Modern	1
cores. 60 The cost of	1
communication and synchronization between the	1
communication and synchronization between threads,	1
communication with a remote database,	1
communication between different threads, but	1
communication between threads is minimized.	1
communication between threads becomes faster	1
avoiding the virtual function dispatch	1
avoiding the costs of position-independent	1
avoiding pointer arithmetics and pointer	1
avoiding any public variables. All	1
avoiding this. The Intel compiler	1
avoiding infinite loop if powN	1
anything it has allocated with	1
anything by using the keyword	1
anything else on a computer.	1
anything else than finding the	1
anything else being initialized. The	1
anything here because we are	1
INSTRSET is used for giving	1
INSTRSET == 2 // make	1
INSTRSET == 2 #define FUNCNAME	1
INSTRSET == 2 12.6 Transforming	1
INSTRSET == 8 #define FUNCNAME	1
INSTRSET == 5 #define FUNCNAME	1
Accessing a data member of	1
Accessing a variable or object	1
Accessing a member of a	1
Accessing an object by *p	1
Accessing data from RAM memory	1
Accessing system devices and using	1
internal functions in a single	1
internal variables and internal functions	1
internal references. 64-bit Mac OS	1
internal references. There is no	1
internal references. Therefore, it will	1
internal multi-threading, e.g. Intel Math	1
type-casting with a little more	1
type-casting i to unsigned int	1
type-casting without adding any extra	1
type-casting its 'this' pointer to	1
type-casting its address: // Example	1
type-casting pointers: The trick violates	1
requirements of the task in	1
requirements of optimizing the software	1
requirements of compatibility with legacy	1
requirements for strict floating point	1
requirements are less strict when	1
requirements are often conflicting with	1
profiler. The result will be	1
profiler. This does not solve	1
profiler. A simple alternative is	1
profiler. It is not intended	1
profiler. For Intel CPUs use	1
__fastcall or __attribute__((fastcall)). The fastcall	1
__fastcall keyword is not recognized	1
__fastcall changes the function calling	1
__fastcall __attribute(( fastcall)) __fastcall Noncached	1
__fastcall Noncached write #pragma vector	1
loss of precision for reasons	1
loss of precision. Let's repeat	1
loss of precision, as explained	1
loss of precision, especially in	1
loss of efficiency. The expression	1
cleanup of allocated resources. The	1
cleanup that may be necessary.	1
cleanup before terminating a thread.	1
cleanup jobs is to make	1
cleanup jobs to do. This	1
Functions that are used together	2
Functions Function calls may slow	1
Functions _intel_fast_memcpy and __intel_new_strlen in	1
Functions ................................................................................................................ 48 7.15 Function	1
handling. It is recommended to	1
handling. You have to distinguish	1
handling. See the manual for	1
handling. 8.6 Optimization directives Some	1
handling. Omitting the standard stack	1
Fortran is also quite efficient,	1
Fortran and several other less	1
Fortran are based on compilers.	1
Fortran where the storage order	1
Fortran code. The main focus	1
increment the loop counter ahead	1
increment and decrement operators. 7.7	1
increment an integer variable, it	1
increment operators also applies to	1
increment i++. cmp eax, 100	1
drivers for 64-bit Windows). The	1
drivers for Windows. 10 Multithreading	1
drivers are particularly critical because	1
drivers may need assembly language.	1
drivers differ a lot in	1
economize the use of the	1
economize the use of RAM	1
economize the library function calls.	1
economize the resource use on	1
economize resource use in system	1
Templates are efficient because the	1
Templates are instantiated at compile	1
Templates may be used for	1
Templates A template is similar	1
Templates make the source code	1
28 because the cache lines	1
28 above the diagonal. The	1
28 Dynamic memory allocation Dynamic	1
28 below the diagonal and	1
28 share the same cache	1
seven memory allocations of sizes	1
seven different compilers. The results	1
seven different brands of C++	1
seven times faster than example	1
seven significant digits, so the	1
turned into a leaf function	1
turned up to cause seven	1
turned on, the compilers will	1
turned on, including relaxed floating	1
turned on. Most IDE's (Integrated	1
inheritance is now as follows.	1
inheritance by making objects inside	1
inheritance class B1; class B2;	2
inheritance where a much more	1
overcome the dangers of a	1
overcome the obstacle of possible	1
overcome by defining a container	1
overcome this limitation). 14.11 Static	1
overcome these disadvantages when C++	1
maintain. The time you spend	1
maintain. If the compiler is	1
maintain. Most compiler packages include	1
maintain. Any specific bottleneck or	1
maintain. And it is unlikely	1
fourteen in 64-bit systems. 67	1
fourteen integer registers in 64-bit	1
fourteen register parameters. In 64-bit	1
fourteen parameters to be transferred	2
122 for how to test	1
122 for how to check	1
122 this the time before	1
122 13.1 CPU dispatch strategies........................................................................................	1
122 13.2 Model-specific dispatching ....................................................................................	1
consuming. A collection of a	1
consuming. There is a lot	1
consuming. Therefore, the data and	1
consuming. Therefore, you should avoid	1
consuming. Sometimes it takes hours	1
method. // This is the	1
method. A longer loop- carried	1
method. When the function is	1
method. 7.29 Threads Threads are	1
method. Your measurement code should	1
backwards and much less efficiently	1
backwards compatible with 16-bit programs.	1
backwards compatible instruction sets is	1
backwards compatibility with a lineage	1
backwards though the 61 function	1
remote or removable media such	1
remote data locally. Access to	1
remote help files, data base	1
remote databases usually requires log	1
remote database, and a third	1
int, without specifying the size.	1
int, signed or unsigned 2	1
int, signed or unsigned 4	1
int, float, double, bool, enum	1
int, float. Similar operations on	1
bc for each element __m128i	1
bc = _mm_mullo_epi16 (b, c);	2
bc = _mm_andnot_si128(mask, bc); //	1
bc with the inverted bit-mask:	1
tools. The simplest possible user	1
tools. A popular user interface	1
tools. It should be possible	1
tools. Automatic updates. Automatic updating	1
tools. One popular development tool	1
operation. A good compiler will	1
operation. For example, if each	1
operation. For example,a * 16is	1
operation. Example: // Example 14.7a.	1
operation. x*8 is replaced by	1
future. If a future version	1
future. 6 The 64-bit systems	1
future. Typically, the full advantage	1
future. To use multiple CPUs	1
future. 12.3 Automatic vectorization Good	1
swapping the order of Boolean	1
swapping is a frequent cause	1
swapping of memory to disk.	1
swapping and other resource problems	1
swapping column 29 with line	1
AVX512 instruction set is available.	1
AVX512 double 64 8 512	1
AVX512 float 32 16 512	1
AVX512 long long 64 8	1
AVX512 Table 12.1. Vector classes	1
considerable amount of time. The	1
considerable delay comes when a	1
considerable improvement in performance if	1
considerable job, but it may	1
considerable debate about which software	1
memset is deprecated. This is	1
memset and memcpy is unsafe	1
memset and memcpy, at least	1
memset and memcpy: // Example	1
memset line if you don't	1
rest of the code. This	1
rest of the program. 3	1
rest of the installation process	1
rest of the code, including	1
rest of the present manual	1
on, the compilers will not	1
on, then it will run	2
on, while it is more	1
on, including relaxed floating point	1
Agner's vector class library can	1
Agner's vector class library makes	1
Agner's vector class library exp	1
Agner's vector class library. Open	1
Agner's vector classes looks like	1
Digital Mars This is a	1
Digital Mars compiler is mostly	1
Digital Mars compilers produce less	1
Digital Mars Compiler v. 8.42n,	1
Digital Mars PGI PathScale Gnu	1
third thread can do mathematical	1
third thing that can be	1
third generation class through a	1
third party security software. Background	1
third generations classes contain the	1
Roll out loop by 16	1
Roll out loop by eight	4
Critical function to test //	1
Critical parts of the code	1
Critical innermost loop: for (i	1
Critical device drivers may need	1
Critical pieces of code can	1
"Calling conventions for different C++	5
CISC instruction set is better	1
CISC instruction set may actually	1
CISC instruction set (called x86)	1
CISC instruction sets have got	1
CISC processors, between PC's and	1
22 one or two floating	1
22 4 Performance and usability	1
22 3.14 Context switches..................................................................................................... 22	1
22 3.15 Dependency chains ................................................................................................	1
22 3.16 Execution unit throughput	1
AND each element in vector	2
AND operator (&) and the	1
AND operation isolates the least	1
AND operations: __m128i a =	1
effort is concentrated on CPU	1
effort is concentrated on arranging	1
effort to make a CPU	1
effort to make special versions	1
effort on that particular part.	1
numbers. The exponent is stored	1
numbers. It can also be	1
numbers. You may, in addition,	1
numbers. Therefore, 64-bit Linux is	1
numbers. With a long vector	1
popular and used for an	1
popular at the time the	1
popular version of Basic is	1
popular user interface library for	1
popular development tool is Microsoft	1
SIZE = 512; // number	2
SIZE = 64; // number	1
SIZE must be divisible by	1
SIZE % 128 == 0)	1
Runtime type identification adds extra	1
Runtime type identification (RTTI) Runtime	1
Runtime type identification (RTTI) ...........................................................................	1
Runtime polymorphism is needed only	1
Runtime polymorphism with virtual functions	1
principles of software develop- ment	1
principles to use. I am	1
principles in order to prevent	1
principles are the same for	1
principles here: functional decomposition and	1
context switch is a switch	1
context switches is smaller in	1
context switches can reduce the	1
context switches by making longer	1
context switches after each time	1
names. The details about name	1
names. Use fastcall functions The	1
names. But a highly optimized	1
names. We can only hope	1
names. Remember to remove the	1
reducing the time spent on	1
reducing the number of branches.	1
reducing the performance because the	1
reducing integer expressions than floating	1
reducing example 15.1d to 15.1c	1
benefit from the larger address	1
benefit from using registers for	1
benefit from register storage. Live	1
benefit from its many optimization	1
benefit from setting the flush-to-zero	1
worth the effort to make	2
worth the effort. 7.21 Runtime	1
worth the effort. Square blocking	1
worth considering is the D	1
manual. The subsequent manuals are	1
manual. This option makes the	1
manual. There are various discussion	1
manual. You have to consult	1
manual. 2.3 Choice of operating	1
specifies the calculation of A	1
specifies that a variable can	1
specifies that all floating point	1
specifies how to do the	1
specifies truncation so the floating	1
searching and parsing are provided	1
searching for updates each time	1
searching for vacant spaces. This	1
searching needed before all objects	1
searching needed after all objects	1
versus unsigned integers In most	1
versus dynamic libraries Function libraries	1
versus dynamic libraries............................................................................ 146 14.12	1
versus XMM registers. Example: //	1
versus references Pointers and references	1
propagation is not possible if	1
propagation and other optimizations. In	1
propagation and reduce a to	1
propagation An expression or subexpression	1
propagation Pointer elimination Common subexpression	1
reduction is a complicated process	1
reduction in this case. You	1
reduction would be invalid in	1
reduction would cause overflow or	1
reduction Most compilers can do	1
effects of object oriented programming	2
effects or if the first	1
effects into account. You can	1
effects are: Variables that are	1
1.; } The compiler may	1
1.; } else { y	1
1.; } Here, the Gnu	1
1.; Eliminate jumps Jumps can	1
1.; x.b = y.b +	1
live range of a variable	1
live ranges do not overlap.	3
live ranges now overlap. Compilers	1
multidimensional array is less efficient	1
multidimensional array should be stored	1
multidimensional array should be organized	1
multidimensional array sequentially. Some applications	1
multidimensional structure needed? A matrix	1
install a program package is	1
install a software package and	1
install a large runtime framework	1
install this important new update	1
install automatic updates to the	1
development, and a release version	1
development, and that computers have	1
development, each new generation of	1
development, database integration, web application	1
development, testing and maintenance -	1
strict when compiling for the	1
strict floating point calculations unless	1
strict aliasing rule of standard	2
strict formalism that requires several	1
(c = 0; c <	4
(c + d); Now the	1
Position-independent code is used in	1
Position-independent code is inefficient, especially	1
Position-independent code Shared objects in	1
Position-independent code. All addresses in	1
Position-independent code.................................................................................. 148 14.13 System	1
obvious to the programmer that	1
obvious to do so. See	1
obvious and the code contains	1
obvious reductions as 0/a =	1
obvious thing to do. The	1
swapped to the hard disk	1
swapped to disk. Software that	1
swapped with element matrix[c][r] at	1
swapped with element matrix[c][r]. //	1
swapped then both can be	1
21 3.10 Graphics ................................................................................................................. 21	1
21 3.11 Other system resources	1
21 3.13 Memory access Accessing	1
21 3.13 Memory access....................................................................................................... 22	1
21 3.12 Network access ......................................................................................................	1
vectors: for (int i =	5
OR the results of the	1
OR operator (|) works even	1
OR operator (^) may give	1
OR combination of these two	1
OR operator, which can only	1
Array of 100 doubles: union	1
Array with N elements of	1
Array with bounds checking template	1
Array size divisible by vector	1
Array size Alignd ( short	1
processes or threads simultaneously. If	1
processes because it often contains	1
processes running on the same	1
processes simultaneously. Actually, only the	1
processes running, and a slow	1
portable to systems with big-endian	1
portable to platforms that use	1
portable in the sense that	2
portable way of defining integer	1
consume a lot of CPU	1
consume a lot of extra	1
consume a significant amount of	1
consume time at unpredictable intervals	1
consume more time than anything	1
schemes are based on hardware	1
schemes are based on hacks	1
schemes are frequent sources of	1
schemes are annoying to the	1
schemes cause problems when the	1
80 for an example of	1
80 into a and b.	1
80 clock cycles for 32-bit	1
80 clock cycles, depending on	1
80 Unfortunately, this method doesn't	1
Arrays that are too large	1
Arrays are often used as	1
Arrays are always transferred as	1
Arrays An array is implemented	1
Arrays ..................................................................................................................... 38 7.11 Type	1
lists the available vector classes.	1
lists of specific CPU models	1
lists and other data structures	1
lists in most cases. The	1
lists that are so small	1
event of an exception. The	1
event that it becomes full.	1
event that it attempts to	1
event it is servicing. A	1
event counts for threads that	1
computer. The Pentium 4 (NetBurst)	1
computer. The measured results were	1
computer. The proxy is smaller	1
computer. Big supercomputers with massively	1
computer. Security software that is	1
Static linking includes only the	1
Static linking (multithreaded) /arch:AVX /openmp	1
Static versus dynamic libraries Function	1
Static versus dynamic libraries............................................................................ 146	1
Static cast The static_cast operator	1
becoming more and more important.	1
becoming more popular and used	1
becoming better and better at	1
becoming increasingly important. A virtual	1
becoming increasingly blurred as the	1
select the most efficient integer	1
select the best implementation for	1
select all installation options at	1
select between two simple expressions.	1
select function, and the AVX2	1
list, the compiler must calculate	1
list, on the other hand,	1
list, set and map are	1
list, database, or other data	1
list, rolled out by 4	1
executed as it is, but	1
executed only once for each	1
executed faster in a programmable	1
executed even though the CPU-type	1
executed 10 times rather than	1
actual clock frequency that the	1
actual values before it is	1
actual load address. Relocation is	1
actual calculations. This should be	1
actual processor. However, this involves	1
case, the performance is limited	1
case, the calculation of the	1
case, you may view the	1
case, but in this case	1
case, N is not a	1
over the disadvantages when deciding	1
over the C99 standard. An	1
over other programming languages can	1
over new and delete or	1
over 32 bit systems: The	1
realistic set of data in	1
realistic set of test data.	1
realistic number of cache misses	1
realistic performance test should include	1
realistic goal is to make	1
abc is a power of	1
abc is 12 bytes. The	1
abc can be increased to	1
abc * p; int i;	1
abc {int a; int b;	1
finished. The optimal number of	1
finished. This method is advantageous	1
finished. Example: // Example 11.3	1
finished. Obviously, this is only	1
finished. Register allocation and function	1
hand, the compiler may in	1
hand, a just-in-time compiler can	1
hand, it is not necessary	1
hand, if your optimization effort	1
hand, does not need updating	1
_WIN64 not _WIN64 64 bit	1
_WIN64 64 bit platform _WIN64	1
_WIN64 _M_X64 _M_X64 162 19	1
_WIN64 _LP64 Windows platform _WIN32	1
_WIN64 _LP64 _WIN64 _LP64 Windows	1
recover in the event of	1
recover from a branch misprediction	1
recover from errors. The following	1
recover from errors. If you	1
recover from exceptions. See page	1
console or to an output	1
console mode program is useful	1
console mode program is fast,	1
console mode program are typically	1
console mode program. The inputs	1
advice of making the number	1
advice in the rest of	1
advice given here may apply	1
advice given above. 7. If	1
advice applies to arrays of	1
ways. The critical stride for	1
ways. The first way is	1
ways. This means that a	1
ways. Example: // Example 7.39	1
ways. Switch statements are most	1
16.2 The pitfalls of unit-testing	2
16.2 calls the critical function	1
16.2 #include <stdio.h> #include <asmlib.h>	1
16.2 above, but read one	1
pow and log are pure	1
pow The method used in	1
pow function when the exponent	1
pow function uses logarithms in	1
pow at compile- time, but	1
split the tasks into multiple	1
split into two 64-bit operations	1
split between several execution units.	1
split up the data into	1
split up into multiple functions.	1
generated by the compiler you	1
generated by the compiler have	1
generated by the Intel and	1
generated by the compiler, you	1
generated from the same few	1
created a file by calling	1
created or modified. This can	2
created it will generate a	1
created by one function and	1
hundred or even a thousand	1
hundred clock cycles to fetch	1
hundred clock cycles if it	1
hundred times because the value	1
hundred times. This is because	1
250 times with four numbers	1
250 s is less than	1
250 s on a 2	1
250 ms. This delay is	1
250 ms. If the response	1
computing power than PCs. Therefore,	1
computing mathematical functions such as	1
computing resources than standard PCs.	1
computing resources. Typically, a specific	1
computing i/2+r. The instructions mov	1
pointers, and far procedures are	1
pointers, by initializing pointers to	1
pointers, etc. And it is	1
pointers, references, 'this' pointer, common	1
pointers, e.g.: // Example 12.1b.	1
limit the range of an	1
limit to the length of	1
limit to the required amount	1
limit can be set then	1
limit can be defined. The	1
90 for a further discussion	1
90 for examples of how	1
90 9.6 Dynamic memory allocation	1
90 9.7 Container classes .....................................................................................................	1
90 Gives a more clear	1
follow the advice given above.	1
follow the guidelines below. You	1
follow the track backwards though	1
follow the rows, not the	1
follow a sequence where each	1
loop-carried dependency chains with long	1
loop-carried dependency chain. A microprocessor	1
loop-carried dependency chain. Such dependency	1
loop-carried dependency chain. Nothing in	1
loop-carried dependency chains, namely the	1
library, you are feeding an	1
library, you divide the data	1
library, but this is often	1
library, except when several applications	1
library, SSE4.1 gives an advantage	1
recommendation is to use the	1
recommendation of which one is	1
recommendation for good code performance	1
recommendation about which platforms and	1
recommendation was the opposite: Don't	1
Objects of a composite type	1
Objects and arrays can be	1
Objects that are allocated in	1
Objects inside containers should be	1
Objects bigger than 16 bytes	1
compromise on the advanced principles	1
compromise when portability and ease	1
compromise between development time, usability,	1
compromise between efficiency, portability and	1
compromise safety is to store	1
Mars This is a cheap	1
Mars compiler is mostly compatible	1
Mars compilers produce less optimal	1
Mars Compiler v. 8.42n, 2004.	1
Mars PGI PathScale Gnu Intel	1
already in the cache so	1
already been allocated. If the	1
already works is of course	1
already known then it is	1
already known at this place.	1
nothing to gain by unrolling	1
nothing to clean up in	1
nothing between 8 bit and	1
nothing while seconds count to	1
nothing inside the loop can	1
(a&&b) || (a&&c) = a&&(b||c)	1
(a&&b) || (a&&c) || (a&&b&&c)	1
(a&&b) || (a&&b&&c) = a&&b	1
(a&&b) || (!a&&c) = a	1
(a&&b) || (!a&&c) || (b&&c)	1
physical register to temp even	1
physical processors and the number	1
physical processors but eight logical	1
physical movements of objects in	1
physical factors. The way to	1
((unsigned int)i < 10) {	1
((unsigned int)i >= (unsigned int)size)	1
((unsigned int)n < 4) {	1
((unsigned int)n < 13) {	1
((unsigned int)(i - min) <=	1
xxxxxxxxx Codeplay Watcom Digital Mars	1
xxxxxxxxx x-xxx---- a-(-b)=a+b a-a =	1
xxxxxxxxx -- - xx x	1
xxxxxxxxx 0/a=0 ---x---xx (-a==-b)=(a==b) ---xx----	1
xxxxxxxxx xxxxxxx-x xxxxxxxxx x-xxx---- a-(-b)=a+b	1
constructors and overloaded operators. Function	1
constructors and destructors of each	1
constructors and destructors to call.	1
constructors and destructors. The copy	1
constructors are called. Therefore, the	1
increased the available instruction set.	1
increased to 16 bytes by	1
increased by more than 33%	1
increased when the work load	1
increased from 64-bit MMX to	1
programming, compiler technology, and microprocessor	1
programming, but in applications without	1
programming, how to avoid hard-to-find	1
programming, etc. In cases where	1
programming, modularity, reusability and systematization	1
factor. A little math is	1
factor. If a and b	1
factor. If not, then you	1
factor. For example, if the	1
factor. Loop unrolling should only	1
i.e. in 64-bit mode or	1
i.e. if there is a	1
i.e. each element matrix[r][c] is	1
i.e. stored at a memory	2
nonzero and normal unsigned int	1
nonzero } else { //	1
nonzero floating point number by	1
nonzero floating point numbers can	1
nonzero u.i += n <<	1
unacceptably long response times to	2
unacceptably long response times for	1
unacceptably long response times, even	1
unacceptably long. Lazy binding should	1
process. This can be done	1
process. A dynamic library can	1
process. These requirements are often	1
process. Obviously, we loose the	1
process. 3.5 Program loading Often,	1
Calculate x to the power	1
Calculate integer power using loop	1
Calculate integer power, loop unrolled	1
Calculate polynomial The calculation of	1
Calculate polynomial with induction variables	1
Only the registers eax, ecx	1
Only the executable file needs	1
Only for SSE2 or x64	1
Only one of the 32	1
Only available for 64-bit Linux	1
adds the elements of a	1
adds an extra level of	1
adds this to i and	1
adds 16 to the integer	1
adds extra information to all	1
() { // Table of	1
() { static const double	1
() { C1 Object1; C2	1
() { CChild1 Object1; CChild2	1
() { __declspec(__align(64)) double matrix[SIZE][SIZE];	1
Division of a loop counter	1
Division by a constant is	2
Division by a constant: Unsigned	1
Division takes 14 - 45	1
pitfalls of CPU dispatching are:	1
pitfalls of unit-testing It is	1
pitfalls of unit-testing ...................................................................................... 156	1
pitfalls here. You cannot use	1
pitfalls here: The inequality sign	1
package is not traditionally considered	1
package and make it work	1
package in order to increase	1
package on a complex framework	1
package several times in order	1
equivalent to a function. Using	1
equivalent to const definitions when	1
equivalent expression b && a	1
equivalent reductions at their own	1
equivalent if(!(a || b)) even	1
understand and therefore difficult to	1
understand when we roll out	1
understand how variables are stored.	1
understand it. I am giving	1
understand compiler-generated assembly code. Let	1
Fortunately, the solution to these	1
Fortunately, it is rarely necessary	1
Fortunately, all compilers are able	1
Fortunately, most compilers will do	1
Fortunately, there are more efficient	1
command or do other input/output	1
command line or a make	1
command line or an input	1
command line with all the	1
command received by an interrupt	1
a[i]; The above code is	1
a[i]; // Return a null	1
a[i]; It is often faster	1
a[i]; s1 += a[i+1]; s2	1
a[i]; Converting an integer to	1
relatively small gain in performance.	1
relatively costly because they must	1
relatively cheap if they are	1
relatively primitive programming style that	1
relatively expensive, while the type	1
priority. The gain in performance	1
priority. If the different tasks	1
priority. In many cases, however,	1
priority. Other tasks such as	1
priority. Especially the memory allocation	1
files. This can actually reduce	1
files. See page 16 for	1
files. Use 64-bit mode Parameter	1
files. 13.2 Model-specific dispatching There	1
files. 121 13 Making critical	1
inefficient, of course, and causes	1
inefficient, and it will generate	1
inefficient, especially in 32-bit mode,	1
inefficient, however, when b is	1
inefficient, (4) get a compiler	1
guidelines are provided below, on	1
guidelines can be used for	1
guidelines by using a constant	1
guidelines should be obeyed. Copy	1
guidelines below. You may choose	1
Kernel Library (MKL v. 7.2).	1
Kernel Library" and "Integrated Performance	1
Kernel Library" contains many functions	1
Kernel Library, available from www.intel.com.	1
Kernel Library. The multiple CPU	1
necessarily stored sequentially in memory.	1
necessarily accessed through a pointer.	1
necessarily done by the constructor	1
necessarily stay in the same	1
necessarily newer. The CPU family	1
returns a pointer to the	1
returns a reference to the	1
returns // Volatile to prevent	1
returns from the function. The	1
returns even though it could	1
jobs is to make a	1
jobs to do. This is	1
jobs and 10 ms for	1
jobs simultaneously. Each thread will	1
jobs simultaneously or seemingly simultaneously.	1
Data that are read-only can	1
Data caching is poor if	1
Data members of a class	1
Data members of a parent	1
Data alignment. __declspec(align(16)) or __attribute__((aligned(16))).	1
frameworks that typically take much	1
frameworks are used at all	1
frameworks are available for Linux	1
frameworks are frequent sources of	1
frameworks typically used on bigger	1
excessive memory swapping and other	1
excessive loop unrolling so that	1
excessive number of function calls	1
excessive number of separate layers	1
excessive number of DLLs, configuration	1
safer to use a union,	1
safer to use than pointers	1
safer to do this optimization	1
safer to calculate the table	1
safer implementation would only read	1
Aligning data Loading data into	1
Aligning dynamically allocated memory Memory	1
Aligning dynamically allocated memory................................................................. 120	1
Aligning RGB video or 3-dimensional	2
execution. The most important thing	1
execution. This means that if	1
execution. It is often more	1
execution. There is no need	1
execution. Example: // Example 8.16	1
a[size], b[size]; // set a	2
a[size], b[size]; // ... for	1
a[size], b[size], i; ... for	1
a[size], b[size], c[size]; float register	1
latency of the multiplication of	1
latency of a floating point	1
latency and the throughput of	1
latency or by memory access.	1
latency which is the same	1
specify the compiler option -fno-pic	1
specify the options for fast	1
specify the alignment explicitly by	1
specify an option that allows	1
specify static linking for any	1
for(i=0; i<300; i++){ list[i] =	1
for(i=0; i<300; i++){ list[i] +=	1
for(i=0; i<300; i+=3){ list[i] =0;	1
for(i=0; i<100; i++)a[i]=2*i; The conversion	1
for(i=0; i<301; i+=3){ list[i] =	1
larger than the largest available	1
larger memory footprint than the	1
larger vector size. Later models	1
larger floating point vectors. There	1
larger address space of the	1
-(-a) to a. I don't	1
-(-a) = a - n.a.	1
-(-a) = a - a-a	1
-(-a) = a, but they	1
-(-a) very often, but such	1
Multiple calls to a pure	1
Multiple applications running simultaneously can	1
Multiple inheritance class B1; class	1
Multiple divisions can be combined.	1
Multiple threads? Container classes are	1
unfortunately the unit-test does not	1
unfortunately it prevents certain optimizations.	1
unfortunately this is not always	1
unfortunately there is no way	1
unfortunately very common. Even some	1
n! is calculated from the	1
n! // Table of factorials:	1
n! = n(n-1)!. If we	1
n! int i, f =	1
n! 117 A C++ implementation	1
pieces of a suitable duration.	1
pieces of code that are	1
pieces of code can be	1
pieces of data that are	1
pieces of code. Example: //	1
Basic is Visual Basic .NET,	1
Basic was too slow. Today,	1
Basic .NET and the best	1
Basic soon became available because	1
Basic .NET, which is implemented	1
(In the above example, the	1
(In 64-bit mode, the parameters	1
(In Windows you can increase	1
(In my tests, the Intel	1
(In Windows, SetThreadAffinityMask, in Linux,	1
microprocessors. The function is also	1
microprocessors. Integer division takes 40	1
microprocessors. Many of the advices	1
microprocessors. 7.13 Loops The efficiency	1
microprocessors. Multiplication and division take	1
modules. This may cause a	1
modules. This makes inlining more	1
modules. This enables interprocedural optimizations.	1
modules. You may add the	1
modules. 3.12 Network access Some	1
s = (short int)i; This	1
s = _mm_hadd_ps(x, x); s	1
s = _mm_hadd_ps(s, s); return	1
s += xxn * _mm_load_ps(coef+i);	1
s += x^n/n! xxn *=	1
project at hand. Low-level languages	1
project together and tested it.	1
project goes to the user	1
project window or makefile. You	1
project built with another compiler.	1
divided into multiple threads that	1
divided into many small subtasks,	1
divided into threads with different	1
divided into small pieces of	1
divided into three parts: one	1
www.agner.org/optimize/asmlib.zip. The following example shows	1
www.agner.org/optimize/asmlib.zip. The name of this	1
www.agner.org/optimize/asmlib.zip. // Example 16.1 #include	1
www.agner.org/optimize/asmlib.zip. If you want to	1
www.agner.org/optimize/asmlib.zip. Currently includes optimized versions	1
Wednesday = 8, Thursday =	1
Wednesday or Friday is set	1
Wednesday | Friday) in example	1
Wednesday | Friday)) { DoThisThreeTimesAWeek();	1
Wednesday || Day == Friday)	1
mispredictions. The performance measurement should	1
mispredictions. Boolean vector operations An	1
mispredictions. When the most time-consuming	1
mispredictions. Test the whole software	1
mispredictions. 44 In some cases	1
relies on the CPU family	1
relies on exception handling. 8.6	1
relies on network resources and	1
relies on structured exception handling	1
relies on non- standardized details	1
And it is discussed which	1
And it is unlikely that	1
And here is a list	1
And whenever a public variable	1
And who would know that	1
platforms, and in some cases	1
platforms, it is recommended to	1
platforms, different screen resolutions, different	1
platforms, different screen resolutions, etc.	1
platforms, including 32-bit and 64-bit	1
compare the performance of two	1
compare it to the tolerance	1
compare with end of array	1
compare two positive floating point	1
compare absolute values: // Example	1
valid only until the next	1
valid values or if they	1
valid address. Pointers can be	1
valid 63 number (e.g. with	1
valid addresses, or if pointers	1
CPU-intensive software is to find	1
CPU-intensive code. But many programs	1
CPU-intensive programs when the clock	1
CPU-intensive applications with many function	1
CPU-intensive code, as described in	1
Is the size known at	1
Is the size known before	1
Is a multidimensional structure needed?	1
Is searching needed before all	1
Is searching needed after all	1
so. The compilers are better	1
so. It may fail to	1
so. See page 73. Runtime	1
so. These containers should definitely	1
so. 58 If it is	1
seen in the broader perspective	1
seen in the unit- test	1
seen in 64 bit Windows	1
seen can reduce them all.	1
seen many examples of poor	1
Typically, the conversion takes 50	1
Typically, the full advantage of	1
Typically, a specific graphics framework	1
Typically, there is a level-1	1
Typically, there are two or	1
107 for how to use	1
107 number of elements per	1
107 12.2 AVX-512 instruction set	1
107 12.4 Using intrinsic functions	1
107 12.3 Automatic vectorization .........................................................................................	1
contiguous in program memory. This	1
contiguous with other objects on	1
contiguous with other local variables	1
contiguous memory block. Do not	1
contiguous memory. See the discussion	1
gets the new version of	1
gets the latest version of	1
gets from the dispatcher function.	1
gets information about the third	1
gets information about its child	1
manuals. See page 3 for	1
manuals. I want to thank	1
manuals. I am always happy	1
manuals. 7.1 Different kinds of	1
manuals. Please note that my	1
tells the compiler that the	1
tells the CPU to generate	1
tells the address of each	1
tells the operating system to	1
tells that a variable is	1
wrap the allocated memory into	1
wrap the allocated array into	1
wrap around on overflow and	1
wrap around. Adding 1 to	1
wrap around, (3) trap integer	1
separately and test their functionality.	1
separately in software development. This	1
separately if there are no	1
separately with the appropriate instruction	1
separately through multiple function calls.	1
__attribute(( aligned(16))) Assume pointer is	1
__attribute(( aligned(16))) __declspec( align(16)) __attribute((	1
__attribute(( const)) Assume function does	1
__attribute(( const)) __attribute(( const)) Assume	1
__attribute(( fastcall)) __fastcall Noncached write	1
necessary. A virtual destructor is	1
necessary. If F1 calls another	1
necessary. 101 Multithreading works more	1
necessary. Take the example: //	1
necessary. Fast versions of common	1
increasing the thread priority before	1
increasing function of the absolute	1
increasing number of purposes such	1
increasing number of devices and	1
increasing faster than the speed	1
16, 32 and 64 bits	1
16, last byte at 19	1
16, i.e. stored at a	2
16, 32, 64, ...). We	1
threads, but the compiler may	1
threads, but it can also	1
threads, but that's about the	1
threads, such as semaphores, mutexes	1
threads, while data that are	1
Development in C++ is quite	1
Development time Some developers feel	1
Development process There is a	1
Development Environments) have facilities for	1
Development process...................................................................................................... 25 7 The	1
AND'ed with the inverted mask.	1
AND'ed with this mask, and	1
AND'ed with all 0's gives	1
AND'ed with all 1's is	1
AND'ed b with 1 for	1
elimination and loop-invariant code motion.	1
elimination x n.a. Constant folding	1
elimination A pointer or reference	1
elimination If the same subexpression	1
elimination Common subexpression elimin., integer	1
all. This makes the code	1
all. This method can be	1
all. In the case of	1
all. Fortunately, there are more	1
all. Can only run on	1
.......................................................................................... 21 3.12 Network access	1
.......................................................................................... 96 9.10 Cache contentions	1
.......................................................................................... 126 13.5 Implementation .....................................................................................................	1
.......................................................................................... 150 15 Metaprogramming .......................................................................................................	1
.......................................................................................... 66 8.1 How compilers	1
upper 32 bits of a	1
upper 32 bits of a[i]	1
upper limit to the required	1
upper limit can be set	1
upper limit can be defined.	1
addresses. The names of inlined	1
addresses. This works in the	1
addresses. If caching is a	1
addresses. Therefore, the code section	1
addresses. Especially the use of	1
loop-invariant code that can be	1
loop-invariant code containing pure function	1
loop-invariant code motion manually when	1
loop-invariant code motion. See page	1
loop-invariant expression that it can	1
sum1 and sum2 are called	1
sum1 = 0, sum2 =	1
sum1 from time T to	1
sum1 += list[i]; sum2 +=	1
sum1 += sum2; If the	1
~a a ^a = 0	1
~a = 0 a &	1
~a = 0 - n.a.	1
~a = -1 (a&~b)|(~a&b)=a^b ---------	1
~a ^ ~b = a	1
Compilers and IDE's for D	1
Compilers for 32-bit Mac OS	1
Compilers will usually unroll a	1
Compilers do not normally use	1
Compilers cannot make floating point	1
); // Function to load	1
); // Make three aligned	1
); #else // 32-bit Windows,	1
); Alignd ( short int	1
); 7.26 Overloaded functions The	1
18 will evict number 2,	1
18 software optimization is to	1
18 3.4 Automatic updates ....................................................................................................	1
18 Overview of compiler options	1
18 Overview of compiler options.......................................................................................	1
them. The hardware definition language	1
them. This would require two	1
them. You should therefore be	1
them. Some important obstacles to	1
them. Pure functions A pure	1
point. The reason is, I	1
point. // After first call	1
point. This does not fit	1
point. Use 64-bit mode or	1
point. Conversion of unsigned integers	1
consumption of different type conversions	1
consumption of each run in	1
consumption are actually quite powerful	1
consumption as the difference between	1
consumption was down to 36.	1
8. The size should always	1
8. The number of unused	1
8. There are also 4	1
8. Avoid branches at the	1
8. 71 The compilers I	1
key in the container rather	1
key or moving the mouse.	1
key values are confined to	1
key press or mouse move.	1
key press. 19 Avoid an	1
explanation. The value of i&15	1
explanation. The following example explains	1
explanation. Note that these directives	1
explanation. (The Microsoft compiler supports	1
explanation. Please skip the following	1
itself. You may add counter	1
itself. But a solution where	1
itself. Function addresses are obscured	1
itself. Another disadvantage of intermediate	1
itself. Constructors are therefore as	1
updated to a new version	1
updated every time a new	1
updated since 2004. Can do	1
updated 2014-08-07. Contents 1 Introduction	1
updated lately. Vector class library	1
appear to take longer time	1
appear in the class declaration.	1
appear in the source code.	1
appear in the project window	1
appear as a large positive	1
Codeplay and Watcom compilers are	1
Codeplay compiler has some support	1
Codeplay Watcom Digital Mars PGI	1
Codeplay VectorC A commercial compiler	1
Codeplay VectorC v. 2.1.7, 2004.	1
(except in device drivers for	1
(except in Fortran where the	1
(except for the loop counter,	1
(except for the <, <=,	1
(except for char pointers). An	1
combined by some formula into	1
combined with the LLVM is	1
combined size of code and	1
combined size of all data	1
combined into a 128-bit vector	1
definitely the preferred programming language	1
definitely be avoided when speed	1
definitely be avoided unless you	1
definitely be avoided. 37 A	1
definitely degrades performance for the	1
jumps between different CPU cores.	1
jumps back to the $B1$2	1
jumps to. Example: // Example	1
jumps Eliminate branches Remove branch	1
jumps Jumps can be avoided	1
elements. The instruction add eax,1	1
elements. The size of each	1
elements. A hash map may	1
elements. Example: // Example 8.15a	1
elements. 12.1 AVX instruction set	1
.cpp files into a single	2
.cpp modules that make up	1
.cpp modules into one by	1
.cpp file) should be made	1
features, and you may want	1
features, and current operating systems	1
features, but also very expensive.	1
features, see http://www.agner.org/optimize/ - vectorclass	1
features, including the ability to	1
flag and don't modify the	1
flag in the compiler. Remember,	1
flag or in a register.	1
flag then the loop branch	1
flag (e.g. DEC, JNZ). This	1
8) { // Load eight	4
8) SelectAddMul_pointer = &SelectAddMul_AVX2; (iset	1
ever more powerful computers to	1
ever bigger software packages and	1
ever used, though. Some instructions	1
ever seen can reduce them	1
ever happens. This is the	1
Writes to a printer or	1
Writes "Hello 2" The dispatching	1
Writes "Hello 2" Here CParent	1
Writes "Hello 1" // Writes	2
13 // 2 unused bytes	1
13 Making critical code in	2
13 Asmlib Gnu 64 bit	1
13 objects, respectively (MS Visual	1
b[i] and c[i] are so	1
b[i] and c[i] are too	1
b[i] = a[i]; It is	1
b[i] = Func(a[i]); } The	1
b[i] + 2; } A	1
doubled. The time it takes	1
doubled. The length of a	1
doubled. This makes it possible	1
doubled. A thread that shares	1
doubled. Thin clients that depend	1
written in C, C++ or	1
written in Java, C#, Visual	1
written as 2eee 1.fffff, where	1
written table may go undetected.	1
written back. The so-called nontemporal	1
languages, it is often possible	1
languages, but also less safe.	1
languages, such as Java, use	1
languages, operating systems, and API's.	1
languages, profiling and debugging. A	1
malloc is typically aligned by	1
malloc and free are: There	1
malloc and free. This can	1
malloc and free. These operators	1
malloc and free) causes the	1
runs most of the time	1
runs quite fast on such	1
runs under the framework, during	1
runs alone in the core.	1
runs satisfactorily on a non-Intel	1
true, and all 0's when	1
true, if any of the	1
true, then the second operand	1
true, which is only 10%	1
true, which is 50% of	1
division. The compiler will always	1
division. Some compilers will replace	1
division. Older CPUs with execution	1
division. 12.4 Using intrinsic functions	1
division. Correction for the FDIV	1
C; } polynomial // Polynomial	1
C; double Z = A	1
C; Assuming that the values	1
C; x.abc = A |	1
C; x.a = A; x.b	1
0.18 0.18 0.18 0.11 memcpy	1
0.18 0.18 0.11 memcpy 16kB	1
0.18 0.11 memcpy 16kB unaligned	1
0.18 0.11 1.21 0.57 0.44	1
0.18 0.12 0.11 0.18 0.18	1
MS compiler Windows Gnu compiler	3
MS compiler: unsigned __int64 64-bit	1
MS compiler: __int64 64 -263	1
#endif // SSE2 // SSE4.1	1
#endif // INSTRSET == 2	1
#endif double Func1(double) pure_function ;	1
#endif return n;} This code	1
#endif const int size =	1
present in the old version.	1
present processors rather than future	1
present manual is number one	1
present manual is also relevant	1
present manual. There are various	1
15.1c is faster than 15.1b,	1
15.1c as intended, while the	1
15.1c would of course be	1
15.1c was done by me	1
15.1c automatically, and only the	1
1000; int i; float a[size],	1
1000; int List[ArraySize]; ... for	1
1000; float a[size], b[size]; //	1
1000; unsigned int dummy; double	1
1000; i++) { ... a	1
strlen function in isolation have	1
strlen function for CPUs with	1
strlen function. The string length	1
strlen 128 bytes Intel Core	1
strlen 128 bytes AMD Opteron	1
__asm int 3; or __asm	1
__asm fistp dword ptr n;	1
__asm fld qword ptr x;	1
__asm ("fldl %1 \n fistpl	1
__asm ("int 3"); or __debugbreak();.	1
cycle. The operators &, |,	1
cycle. The OR operator (|)	1
cycle. The highest performance that	1
cycle. This means that if	1
cycle. In 64-bit systems, there	1
11 clock cycles on Pentium	1
11 short int a; //	1
11 programming, etc. In cases	1
11 Out of order execution	2
belong to the same set	1
belong to the thread in	1
belong to one of these	1
belong to set number 0x1C.	1
belong to each compiler with	1
50 - 100 clock cycles.	1
50 clock cycles per element	1
50 simple cases, the compiler	1
50 7.16 Function return types	1
50 7.17 Structures and classes............................................................................................	1
facilities of the operating system	1
facilities for making a debug	1
facilities that do much of	1
facilities are needed, and new	1
facilities are needed, but only	1
5. The loop count should	1
5. If columns had not	1
5. But the compiler doesn't	1
5. Calling conventions for different	1
5. www.amd.com. 163 Internet forums	1
currently not up to date.	1
currently only supported on AMD	1
currently used for calculating self-	1
currently doesn't works (gcc v.	1
currently available, one from Intel	1
here: The inequality sign must	1
here: A large array can	1
here: return *(T*)0; } //	1
here: a[i] = log (b[i]	1
here: functional decomposition and data	1
Does not support the SSE	1
Does not optimize as good	1
Does not optimize well. Open	1
Does not allocate more space	1
Does not, by default, conform	1
macros is that the name	1
macros are sometimes more efficient	1
macros with short or common	1
macros instead of functions A	1
macros Compiler identification 16 bit	1
prefer is a matter of	1
prefer a to be signed.	1
prefer to use the Intel	1
prefer to run a speed-critical	1
prefer to write if(!a &&	1
divisor is a power of	2
divisor is not known at	1
divisor is known at compile	1
divisor that is a power	1
Program installation The time it	1
Program installation .................................................................................................. 18 3.4	1
Program loading ....................................................................................................... 19 3.6	1
Program loading Often, it takes	1
better. The loop body now	1
better. If the problem is	1
better. Whenever a processor has	1
better. Remember again, that most	1
BSD, the slow GOT lookup	1
BSD, but the compiler uses	1
BSD, Windows and Mac. The	1
BSD, Intel-based Mac OS, etc.)	1
bit-mask: __m128i mask = _mm_cmpgt_epi16(b,	2
bit-mask: c2 = _mm_and_si128(c2, mask);	1
bit-mask: bc = _mm_andnot_si128(mask, bc);	1
two. In the preceding example,	1
two. Some other compilers (Microsoft,	1
two. Some compilers will use	1
two. Often, it is sufficient	1
up, as explained below. There	1
up, which is a total	1
up, which happens quite often	1
up, even if the program	1
up. The two summation variables	1
up. This is a common	1
up. If an error handler	1
up. Some modules may be	1
reasons. The programmer can use	1
reasons. This may cause the	1
reasons. C++ is supported by	1
reasons. Use these example containers	1
103 for examples of how	1
103 // Example 11.1b float	1
103 12 Using vector operations...............................................................................................	1
103 11 Out of order	1
Choosing the optimal platform ...........................................................................................	1
Choosing the optimal platform 2.1	1
Choosing the optimal algorithm The	1
Choosing the optimal algorithm .......................................................................................	1
slices is determined by the	1
slices of typically 30 ms	1
slices to 120 ms by	1
slices allocated to each task	1
exception. The costs of this	1
exception. A frame function can	1
exception. 64 If you make	1
exception. Therefore, you should apply	1
enum is simply an integer	1
enum as well as pointers	1
enum Weekdays { Sunday, Monday,	1
enum Weekdays { Sunday =	1
repeats a thousand times then	1
repeats 20 times and calls	1
repeats 1000 times and that	1
repeats 1000 times then we	1
highest instruction set in order	1
highest performance that can possibly	1
highest efficiency is obtained when	1
highest level of optimization is	1
96 void transpose(double a[SIZE][SIZE]) {	1
96 9.9 Access data sequentially	1
96 9.11 Explicit cache control	1
96 9.10 Cache contentions in	1
recommend that no function or	1
recommend that every function that	1
recommend object oriented programming as	1
recommend any specific model. Instead,	1
lead to a more well-structured	1
lead to a better understanding	1
lead to a dramatic degradation	1
lead to a complete redesign	1
additional integer counter. Example: //	1
additional floating point variable: //	1
additional information about a variable,	1
additional parameters. Therefore, make sure	1
51 for the pros and	1
51 performance penalty for organizing	1
51 7.19 Class member functions	1
51 7.18 Class data members	1
56 public: float x, y;	1
56 7.27 Overloaded operators .............................................................................................	1
56 7.28 Templates...............................................................................................................57 7.29 Threads	1
56 7.26 Overloaded functions ..............................................................................................	1
type. The example on page	1
type. Likewise, a pointer can	1
type. References are useful for	1
type. Interrupt service routines and	1
place the user interface and	1
place to the right in	1
place in the program. Small	1
place indicated by the caller	1
preferable to make a lookup-table	1
preferable to keep the same	1
preferable to allocate the final	1
preferable for speed-critical functions. Many	1
overlap the call and return	1
overlap the calculations of loop	1
overlap the iterations and start	1
overlap or if they are	1
eight-element vectors: for (int i	4
40 - 80 clock cycles,	1
40 i = s; An	1
40 clock cycles. If you	1
40 7.12 Branches and switch	1
43 for an explanation of	1
43 about branch prediction. A	1
43 7.13 Loops...................................................................................................................... 45 7.14	1
43 speculatively executing instructions during	1
sixteen in 64-bit operating systems.	1
sixteen in 64-bit systems. Some	1
sixteen vector registers (XMM or	1
sixteen integers of 8 bits	1
turning the frame function into	1
turning off the exception handling	1
turning off the position-independent code	1
turning off all optimizations of	1
initialization. The compiler may report	1
initialization. The program or library	1
initialization. A copy constructor is	1
initialization. Each code version is	1
Graphics and sound processing Memory	1
Graphics A graphical user interface	1
Graphics accelerators The choice of	1
Graphics ................................................................................................................. 21 3.11 Other	1
obstacles to efficient use of	1
obstacles to optimization are discussed	1
obstacles to optimization are. Dynamic	1
obstacles and to know how	1
asmlib function library and the	1
asmlib library int level =	2
asmlib library at www.agner.org/optimize/asmlib.zip. If	1
Furthermore, it is not uncommon	1
Furthermore, you may read the	1
Furthermore, this solution is using	1
Furthermore, most C++ compilers allow	1
obtain the desired polymorphism effect	1
obtain the desired functionality without	1
obtain most of the advantages	1
obtain much more by choosing	1
ebx. The next two instructions	1
ebx. The square brackets mean	1
ebx. 9 Optimizing memory access	1
ebx. Only the registers eax,	1
estimate is correct or if	1
estimate of the final size	1
estimate that the loop will	1
estimate can be made) then	1
enabled in 64-bit mode. A	1
enabled there is no difference	1
enabled (there is one set	1
enabled (single precision requires only	1
enables the compiler to do	1
enables the compiler to optimize	1
enables interprocedural optimizations. The keyword	1
enables interprocedural optimizations. See page	1
Obstacles to optimization by compiler	2
Obstacles to optimization by CPU	1
Obstacles to optimization by CPU.............................................................................81	1
r) { int i; int	1
r) { int i; 84	1
r) { r = r	1
r) {return r.a + r.b;}	1
regular time intervals. Some programs	1
regular access patterns containing multiple	1
regular patterns with fixed strides.	1
regular pattern, while Pentium 4	1
m is transferred to the	1
m is transferred at runtime	1
m is replaced by its	1
m and therefore cannot do	1
Metaprogramming can be useful in	1
Metaprogramming means to make code	1
Metaprogramming Metaprogramming means to make	1
Metaprogramming ....................................................................................................... 150 16 Testing	1
explain the above code in	1
explain the difference, let's say	1
explain this with an example.	1
explain how metaprogramming can be	1
Dispatch on first call. The	1
Dispatch on every call. A	1
Dispatch at load time. The	1
Dispatch at installation time. Each	1
well, of course. A branch	1
well, but the examples have	1
well, but it is not	1
well, others are not. Supports	1
sufficiently large to handle the	2
sufficiently fast on a hard	1
sufficiently accurate for the purpose	1
126 Make pointer at initialization.	1
126 12.2 128 128 128	1
126 13.6 CPU dispatching in	1
126 13.5 Implementation ..................................................................................................... 126	1
bad The C/C++ standard specifies	1
bad on a particular processor	1
bad CPU dispatching. Obviously, you	1
bad dilemma. You may prefer	1
p(double x) { // Remove	1
p(double x) { return x;	1
p(double x) { return 1.0;	1
p(double x) { return powN<true,N/2>::p(x)	1
said that the use of	1
said than done to choose	1
said here about Linux also	1
said here about increment operators	1
modulo operator %. Conversion to	1
modulo 16. This method is	1
modulo calculations: // Example 14.11	1
modulo operations: // Example 14.13a	1
databases with lots of data.	1
databases Many software applications use	1
databases usually requires log on	1
databases ....................................................................................................... 21 3.10 Graphics	1
_EM_OVERFLOW); // if above doesn't	1
_EM_OVERFLOW); // if above line	1
_EM_OVERFLOW); // _controlfp(0, _EM_OVERFLOW); //	2
against the costs in terms	1
against this problem: (1) check	1
against overflow is needed: //	1
against overkill. Don't use an	1
Vectorized with SSE2 #include <emmintrin.h>	1
Vectorized code is more difficult	1
Vectorized code often contains a	1
Vectorized table lookup Lookup tables	1
break; } This can be	1
break; case 3: printf("Delta"); break;	1
break; case 2: printf("Gamma"); break;	1
break; case 1: printf("Beta"); break;	1
loader to a different address.	1
loader will have more references	1
loader calls the dispatcher function	1
loader (requires binutils version 2.20,	1
Failure to do so is	2
Failure to do so will	1
Failure to handle unknown processors	1
declared. If the variable is	1
declared. An object of a	1
declared. Therefore, it has to	1
declared. Avoid multiple inheritance, virtual	1
resources, and the transitions between	1
resources, such as cache and	1
resources, even if the user	1
resources, databases, etc. The efficiency	1
true. The program may have	1
true. The trick of using	1
true. Boolean variables are overdetermined	1
true. template<> class powN<true,0> {	1
objects. The size (in bytes)	1
objects. This is of course	1
objects. STL vector stores all	1
objects. Storage on the stack	1
parallel. Modern CPUs are actually	1
parallel. Small lightweight processors with	1
parallel. Fine-grained parallelism is the	1
parallel. Coarse-grained parallelism refers to	1
one, and only one, auto_ptr	1
one, because it can be	1
one, into an STL vector	1
one, auto_ptr that owns the	1
list[300]; int i; for(i=0; i<300;	3
list[300]; int i, i_div_3; for(i=i_div_3=0;	1
r++) { for (c =	3
r++) { // loop through	1
parabola (float x) { return	3
parabola (2.0f); b = a	1
x^4 // Define vectors of	1
x^4 // x^8 // x^10	1
x^4 F32vec4 xx4(x4); // x^4	1
x^4 F32vec4 s(0.f, 0.f, 0.f,	1
mouse inputs when the program	1
mouse move or key press.	1
mouse input. It is possible	1
mouse move. It is unacceptable	1
specialization is allowed only for	1
specialization for N a power	1
specialization for N = 0	1
specialization for N = 1.	1
index. The data cache is	1
index. The integer division prevents	1
index. A good compiler can	1
index. Are objects identified by	1
options. CPU vendors are offering	1
options. I don't know if	1
options. Many optimization options are	1
options. Supports parallel processing, OpenMP	1
c++) { // loop through	1
c++) { // loop columns	1
c++) { StoreNTD(&a[c][r], b[r][c]); }	1
c++) { a[c][r] = b[r][c];	1
are. For example, you get	1
are. However, there are disadvantages	1
are. Dynamic memory allocation Any	1
are. Declare the function inline.	1
needed, and new objects can	1
needed, or they may be	1
needed, but only after all	1
needed, however, if the array	1
declaring the function body inside	1
declaring the table inside a	1
declaring it inside {} brackets.	1
declaring an integer of a	1
SVML and LIBM libraries are	1
SVML + ia32intrin.h _mm_exp_ps _mm_exp_pd	1
SVML v.10.3 & later __svml_expf4	1
SVML v.10.2 & earlier vmlsExp4	1
*.so). The program has an	1
*.so). The mechanism of static	1
*.so). The installation program makes	1
*.so). There are several factors	1
(u.i * 2 > v.i	1
(u.i & 0x7FFFFFFF) { //	2
(u.i > v.i) { //	1
support. There is a performance	1
support. Make a member function	1
support. Then you make a	1
support. Hardware updating. The change	1
subtraction and multiplication are permissible	1
subtraction and multiplication (27 -	1
subtraction and multiplication (20 -	1
subtraction (3 - 10 clock	1
Multiply by constant = shift	1
Multiply b and c __m128i	2
Multiply (int x, int m)	1
|= 0x80000000; // set sign	1
|= 0x80000000; // Set sign	1
|= 0x20; If the length	1
|= 0x20; 46 A common	1
pool. See the examples in	1
pool. See www.agner.org/optimize/cppexamples.zip. If the	1
pool. 15 Integer overflow is	1
pool. Alignment? Some applications require	1
performs best under this unit-test	1
performs better on very small	1
performs well. The reason is	1
performs poorly. It is not	1
"Intel 64 and IA-32 Architectures	1
"Intel Math Kernel Library" and	1
"Intel Math Kernel Library" contains	1
"Intel Performance Primitives" library contains	1
Are objects accessed in a	2
Are objects identified by a	1
Are objects numbered consecutively? If	1
pre-increment is more efficient than	1
pre-increment to post-increment. There are	1
pre-increment or post-increment. The effect	1
pre-increment operator ++i and the	1
ownership is transferred from one	1
ownership of the memory block	2
ownership of the memory block.	1
88 for details. Inheritance from	1
88 9.5 Alignment of data	1
88 Object oriented programming can	1
88 9.4 Variables that are	1
0x80000000; // set sign bit	1
0x80000000; // Set sign bit	1
0x80000000; // flip sign bit	1
0x80000000; because this is likely	1
move the object in case	1
move or key press. 19	1
move out loop-invariant code containing	1
move outside the loop. Most	1
Can the container be recycled?	1
Can be reduced to: //	1
Can only run on Mac	1
Can do automatic vectorization. Optimizes	1
defining a container class that	1
defining integer types of a	1
defining constants. For example, #define	1
defining _mm_malloc and _mm_free. A	1
produces a string and then	1
produces a negative result. An	1
produces a low positive result.	1
produces another C++ program (or	1
precision, and intermediate results are	1
precision, as explained on page	1
precision, but there is a	1
precision, especially in floating point	1
non-inlined copy is dead code	1
non-inlined copy of the function,	1
non-inlined copy of the inlined	1
non-inlined copy Function inlining has	1
drawbacks of the C++ language	1
drawbacks of the C++ language......................................................	1
drawbacks of using dynamic memory	1
drawbacks of C++. Yet, D	1
__declspec(align(16)) or __attribute__((aligned(16))). Specifies alignment	1
__declspec(align(16)) static const float coef[16]	1
__declspec(align(16)) struct S1 { float	1
__declspec(align(16)) X #else // Gnu	1
u.f and v.f are both	1
u.f < 2.0 This method	1
u.f We can take the	1
u.f > v.f if both	1
commercial compiler for 32-bit Windows.	1
commercial compilers due to controversies	1
commercial compilers. Mixing object files	1
commercial license Table 12.4. Vector	1
configuration files and system modules.	1
configuration files (*.ini files). 20	1
configuration files, resource files, help	1
configuration files, help files and	1
134 and 135 show various	1
134 on bounds checking). An	1
134 } else { list[i]	1
134 14.3 Use bitwise operators	1
lines. The critical stride can	1
lines. The 17 debug version	1
lines. This makes code caching	1
lines. A few decades ago,	1
restrictions on using the instructions	1
restrictions on using alloca. 9.7	1
restrictions on alignment and the	1
restrictions on mixing code compiled	1
Constant propagation Pointer elimination Common	1
Constant folding and constant propagation	2
Constant folding - n.a. a+b	1
manager for each allocated block.	1
manager can spend a lot	1
manager will start garbage collection	1
manager has a garbage collector	1
pattern can also be predicted	1
pattern can be, for example,	1
pattern or if it is	1
pattern history, etc. may have	1
x86-64 instruction set supports self-relative	1
x86-64 platform _M_IX86 and _WIN64	1
x86-64 platforms. AMD AMD Math	1
x86-64 platforms. Comparison of function	1
*p+2 is a loop-invariant code	1
*p+2 is a loop-invariant expression	1
*p+2 a hundred times because	1
*p+2 and store it in	1
Watcom compilers are not compatible	1
Watcom Another open source compiler	1
Watcom Digital Mars PGI PathScale	1
Watcom C/C++ v. 1.4, 2005.	1
round function using assembly language.	1
round memory addresses divisible by	1
round addresses in order to	1
round addresses. Especially the use	1
cores, and a processing speed	1
cores, and it can be	1
cores, vector processing instructions, multiple	1
cores, we need to divide	1
chooses the least recently 4	1
chooses between two or more	1
chooses between two expressions for	1
chooses between two constants can	1
running. The main reason why	1
running. If there is a	1
running. Such frameworks are frequent	1
running. Programs using such a	1
serial in the sense that	1
serial code for vectorization Not	1
serial code for vectorization............................................................. 117	1
serial because each value of	1
cc into vector c: CPU	1
cc into vector c: __m128i	2
cc into vector c: Is16vec8	1
Header file for InstructionSet() #include	2
Header file MMX mmintrin.h SSE	1
Header files for intrinsic functions	1
150 for further discussion of	1
150 you want as static	1
150 16 Testing speed.............................................................................................................. 153	1
150 15 Metaprogramming ....................................................................................................... 150	1
thanks to the availability of	1
thanks to the first-in-last-out nature	1
thanks to out-of-order execution and	1
thanks to heavy competition. Processors	1
2.0; x <= n; x++)	1
2.0; } The factor sizeof(S1)	1
2.0; } In order to	1
2.0; i >= 0; i--,	1
pipeline and later discovers that	1
pipeline then the error is	1
pipeline where instructions are fetched	1
pipeline structure has one big	1
n) { // n! //	1
n) { // n! int	1
n) { if (n >	1
n) { double y =	1
input. The time used for	1
input. It is possible to	1
input. Many programs spend most	1
input. (In Windows you can	1
8.1 below. Devirtualization An optimizing	1
8.1 How compilers optimize Modern	1
8.1 How compilers optimize ............................................................................................	1
8.1 (page 77) shows which	1
conditions. A dispatcher function decides	1
conditions. For example, if you	1
conditions. All disturbing influences are	1
conditions. Programs that produce streaming	1
choosing the most efficient alternative.	1
choosing the best algorithm than	1
choosing a programming language that	1
choosing a container for a	1
146 below. Position-independent code is	1
146 below. 3.7 File access	1
146 Multiple applications running simultaneously	1
146 14.12 Position-independent code.................................................................................. 148	1
.............................................................................................. 50 7.17 Structures and	1
.............................................................................................. 56 7.27 Overloaded operators	1
.............................................................................................. 82 8.7 Checking what	1
.............................................................................................. 99 10 Multithreading.............................................................................................................. 101	1
_mm256_zeroupper() before any transition from	1
_mm256_zeroupper() before calling the library	1
_mm256_zeroupper() before leaving the AVX	2
Making critical code in multiple	2
Making too many branches. If	1
Making exception-safe code Assume that	1
flush-to-zero and denormals-are-zero mode (SSE2):	1
flush-to-zero mode rather than generating	1
flush-to-zero mode unless you have	1
flush-to-zero mode (SSE): #include <xmmintrin.h>	1
Taylor series float Exp(float x)	1
Taylor expansions and Newton-Raphson iterations.	1
Taylor series, vectorized #include <dvec.h>	1
Taylor series. The exponential function	1
SelectAddMul_pointer = &SelectAddMul_AVX2; (iset >=	1
SelectAddMul_pointer = &SelectAddMul_dispatch; // Dispatcher	1
SelectAddMul_pointer = &SelectAddMul_SSE2; // Error:	1
SelectAddMul_pointer = &SelectAddMul_SSE41; (iset >=	1
dispatcher. The dispatcher changes the	1
dispatcher. // After first call	1
dispatcher. See page 131. Intel	1
dispatcher. See page 131. AMD	1
Clang, Intel or Microsoft compiler	1
Clang, Intel or PathScale compiler	1
Clang, Intel or PathScale. 2.	1
Clang, Intel, Microsoft and PathScale	1
14.9 is changed so that	1
14.9 Using integer operations for	2
14.9 struct S1 { int	1
n, then we need metaprogramming.	1
n, including the while loop,	1
n, factorial = 1.0; for	1
n, factorial = 1.0; int	1
14.8 and 14.9 is changed	1
14.8 const int rows =	1
14.8 Conversions between floating point	2
overflow, and the code takes	1
overflow, and invalid pointers. The	1
overflow, this code can be	1
overflow, such as simple variables,	1
x++) { Table[x] = A*x*x	1
x++) { Table[x] = Y;	1
x++) factorial *= x; This	1
x++) factorial *= x; Note	1
optimal. The branches may take	1
optimal. There are certain restrictions	1
optimal. Use 12 option -fno-builtin	1
optimal. Best-case testing is useful	1
*)d, x); } // Branch/loop	1
*)d, x); } void SelectAddMul(short	1
*)d, x); } 112 Vectorized	1
*)d, x);} void SelectAddMul(short int	1
class, it checks whether the	1
class, Intel Vector class, Agner	1
class, structure or union can	1
class, Agner 8 8 char	1
z = y + 1.;	3
z != 0; 35 This	1
advance and the multiplication is	1
advance and stored in edx.	1
advance which of the two	1
advance rather than allocating piecewise	1
c: CPU dispatching with vector	1
c: __m128i c = LoadVector(cc	2
c: Is16vec8 c = LoadVector(cc	1
guaranteed to be in the	1
guaranteed to be less than	1
guaranteed to be 0 or	1
guaranteed to wrap around, (3)	1
think that it is necessary	1
think that you can make	1
think that exception handling takes	1
think that programmers write expressions	1
example. The only allowed inputs	1
example. A union can also	1
example. We might check for	1
example. My example is a	1
older processors and on Intel	1
older microprocessors is lost. This	1
older processors, a switch statement	1
older MMX registers, which are	1
commonly the case with programs	1
commonly used set of containers	1
commonly used variables are stored	1
commonly used methods for dealing	1
queue of pending instructions in	1
queue as a circular buffer	1
queue should be implemented as	2
{} which would be an	1
{} brackets in which the	1
{} brackets. However, most compilers	1
{} vector(float a, float b)	1
1.0f; The compiler may replace	1
1.0f; This needs a little	1
1.0f; } The two comparisons	1
1.0f; } A possible negative	1
ALIGN 4 PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z	2
ALIGN ; mark_end; This solution	1
ALIGN ?Func@@YAXQAHAAH@Z ENDP + esp	1
modification is profitable. On the	1
modification of the program under	1
modification to compensate for the	1
modification if implemented on other	1
solutions to this problem are	1
solutions are now used in	1
solutions may some day be	1
solutions are: Avoid the conversions	1
guide for assembly programmers and	1
guide for x86 platforms. 3.	1
guide for Windows, Linux and	2
appendix to this manual at	3
appendix at www.agner.org/optimize/cppexamples.zip for how	1
17 will evict number 1.	1
17 Optimization in embedded systems	2
17 debug version of the	1
empty throw() statement can improve	1
empty throw() specification. The empty	1
empty throw() specification to F1	1
empty throw()specification is useful for	1
maintenance - to make a	1
maintenance There are two things	1
maintenance .......................................................................................... 126 13.5 Implementation	1
maintenance easier. I have done	1
1: // Example 7.10a bool	1
1: 4 + esp ;alignby4	1
1: 8 + esp ;	1
1: printf("Beta"); break; case 2:	1
Out of order execution All	1
Out of order execution .................................................................................................	1
Out (FIFO) basis then use	1
Out (FILO) basis then use	1
protected operating system if the	1
protected operating system, but you	1
protected mode and back again.	2
Container classes are generally not	1
Container classes can also be	1
Container classes Whenever dynamic memory	1
Container classes ..................................................................................................... 93 9.8	1
alternatives to the standard template	1
alternatives to using a profiler.	1
alternatives to exception handling in	1
alternatives that can be used	1
modifications of the source code,	1
modifications to the code in	1
modifications in the code. Let's	1
modifications actually increase the speed	1
i_div_3; } 138 A similar	1
i_div_3; list[i+1] += i_div_3; list[i+2]	1
i_div_3; list[i+2] += i_div_3; }	1
i_div_3; for(i=i_div_3=0; i<300; i+=3,i_div_3++){ list[i]	1
s; An integer is converted	1
s; s = (short int)i;	1
s; s = _mm_hadd_ps(x, x);	1
s; 40 i = s;	1
case" and "best case" values.	1
case" counts that you should	1
case" counts. In any event,	1
case" values. Which of these	1
distinguish between coarse-grained parallelism and	1
distinguish between recoverable and non-recoverable	1
distinguish elements with a relative	1
distinguish these two versions and	1
missing in the instruction set	1
missing in many commercial compilers	1
missing functions can be implemented	1
missing check for buffer overflow	1
subroutines in assembly language". The	1
subroutines in assembly language". While	1
subroutines in assembly language", section	1
subroutines in assembly language: An	1
tools to be available, we	1
tools for supporting multi-threaded software	1
tools that fit their CPUs.	1
tools have powerful facilities that	1
0x2710 and later reads from	1
0x2710 and (set) = (0x2710	1
0x2710 will cause the cache	1
0x2710 will cause a cache	1
spot and make measurements on	1
spot that uses 90% of	1
spot has been identified, then	1
spot but also the innermost	1
powN is // erroneously called	1
powN { public: static double	1
powN template is a class	1
powN template is calling itself	1
C-style method of storing strings	1
C-style type casting // Constructor-style	1
C-style type-casting without adding any	1
C-style type-casting. It is used,	1
While an empty throw() statement	1
While C++ has many advantages	1
While we are waiting for	1
While some of the difference	1
Bitfield { int a:4; int	1
Bitfield { struct { int	1
Bitfield x; int A, B,	2
clean up in case of	1
clean up then it must	1
clean up everything in case	1
clean solution is to rely	1
according to the Gnu compiler	1
according to the table. Optimization	1
according to the rules of	1
according to the IEEE standard	1
Bounds checking is included for	1
Bounds checking In C++, it	1
Bounds checking (see page 134)	1
Bounds checking .................................................................................................. 134 14.3	1
u.i = (n & 0x7FFFFF)	1
u.i += n << 23;	1
u.i ^= 0x80000000; // flip	1
u.i &= 0x7FFFFFFF; // set	1
dramatic when contentions occur in	1
dramatic effect on the execution	1
dramatic degradation of performance on	1
dramatic consequences. I once made	1
IDE. It is intended as	1
IDE. Does not optimize well.	1
IDE. Has not been updated	1
IDE. Free trial versions are	1
lengths of the time slices	1
lengths to reduce this problem.	1
lengths in the same memory	1
lengths that are not known	1
expensive. A variable can be	1
expensive. A limited "express" edition	1
expensive. You may use an	1
expensive. Using complicated techniques like	1
efficiency. The expression (Tuesday |	1
efficiency. For example, x =	1
efficiency. These are available as	1
efficiency. Using unaligned reads and	1
Copyright conditions are listed on	1
Copyright notice This series of	1
Copyright notice .......................................................................................................... 164 1	1
Copyright  2004 - 2014.	1
extended to the general case	1
extended to 64 bits. This	1
extended to 256-bit registers named	1
extended number of bits. The	1
size) = (total cache size)	1
size) { cout << "Error:	1
size) / (number of ways).	1
size) % (number of sets).	1
(Gnu) all intrin.h (MS) x86intrin.h	1
(Gnu) AMD FMA4 fma4intrin.h (Gnu)	1
(Gnu) Table 12.2. Header files	1
(Gnu) AES, PCLMUL wmmintrin.h AVX	1
contained in a DLL. Another	1
contained in p1 and p2	1
contained object because the container	1
contained objects? It may not	1
transferring the variable as function	1
transferring 'this' in a register	1
transferring composite objects to a	1
transferring additional parameters. Therefore, make	1
Access to static or global	1
Access to remote databases usually	1
Access data sequentially A cache	1
Access data sequentially .......................................................................................... 96	1
saving a backup copy of	1
saving and restoring registers, and	1
saving memory space by allowing	1
saving registers that have to	1
years to come. Even big	1
years before your code is	1
years old version of Intel's	1
years old. The CPU market	1
y, a1, a2, b1, b2;	2
y, z; a = x	1
y, z; bool b; if	1
structured and object-oriented programming, modularity,	1
structured software development and the	1
structured exception handling and you	1
structured exception handling. See the	1
documentation and lack of advanced	1
documentation for the size of	1
documentation for detailed instructions. Example:	1
documentation Intel: "IA-32 Intel Architecture	1
CChild1 * p1; p1 =	1
CChild1 : public CParent<CChild1> {	2
CChild1 Object1; CChild2 Object2; CChild1	1
PGI compiler supports intrinsic functions,	1
PGI C++ compiler for 32-	1
PGI C++ v. 7.1-4, 2008.	1
PGI PathScale Gnu Intel Borland	1
As we can see, it	1
As table 9.3 shows, the	1
As explained above, the maximum	1
As soon as you have	1
(RTTI) If any of these	1
(RTTI) Runtime type identification adds	1
(RTTI) /GR -fno-rtti /GR- -fno-rtti	1
(RTTI) ........................................................................... 54 7.22 Inheritance	1
default, which makes it less	1
default, so 1.2 in this	1
default, even when shared objects	1
default, conform to the standard	1
xpow10(double x) { double x2	1
xpow10(double x) { return pow(x,10);	1
xpow10(double x) { return IntegerPower<10>(x);	1
xpow10(double x) { return ipow(x,10);	1
a2, b1, b2; y =	2
a2, b1, b2, y1, y2;	1
a2, b1, b2, y1, y2,	1
inconvenient to the end user.	1
inconvenient times when a user	1
inconvenient times. This can be	1
inconvenient times. A queue should	1
expressed as a 32-bit number	1
expressed as a base address	1
expressed as an 8-bit signed	1
expressed as follows: struct Sfloat	1
bottleneck is file access or	1
bottleneck is elsewhere then there	1
bottleneck or any particularly slow	1
bottleneck than memory access and	1
directive to tell the compiler	1
directive for a Windows compiler	1
directive never takes memory space.	1
directive __declspec(cpu_dispatch(...)). See the Intel	1
not, and therefore fail to	1
not, by default, conform to	1
not, then it may be	1
not, then you must do	1
scarce resources. However, the CISC	1
scarce resource in 32-bit systems.	1
scarce resource. Do not use	1
scarce resource, especially in 32-bit	1
12.4b and 12.4c is quite	1
12.4b can be replaced by	1
12.4b shows how this can	1
12.4b executes three to seven	1
lrint function is given in	1
lrint (double const x) {	2
lrint function: // Example 14.20	1
versions. The x86 processors are	1
versions. This method is faster	1
versions. A 32- bit version	1
versions. It is recommended to	1
............................................................................................. 87 9.1 Caching of	1
............................................................................................. 56 7.28 Templates...............................................................................................................57 7.29	1
............................................................................................. 136 14.5 Integer division......................................................................................................	1
............................................................................................. 113 12.6 Transforming serial	1
Alignment of data A variable	1
Alignment of data structures to	1
Alignment of data members. This	1
Alignment of data ...................................................................................................... 90	1
going to be very long	1
going to recommend any specific	1
going from AVX code to	1
going either way. Such a	1
underflow and give the result	1
underflow in XMM registers can	1
underflow except in special mathe-	1
underflow neutralize each other. This	1
ranges do not overlap. If	1
ranges do not overlap. You	1
ranges do not overlap. See	1
ranges now overlap. Compilers do	1
splitting the dependency chain in	1
splitting of software into an	1
splitting of N into the	1
splitting 256-bit read operations into	1
user's time. The time it	1
user's time. Other programs use	1
user's needs. The search for	1
user's computers. At this time,	1
__INTEL_COMPILER n.a. n.a. _MSC_VER and	1
__INTEL_COMPILER __INTEL_COMPILER n.a. n.a. _MSC_VER	1
__INTEL_COMPILER __INTEL_COMPILER 161 32 bit	1
__INTEL_COMPILER 161 32 bit platform	1
cleaned up in case of	1
cleaned up include: Memory allocated	1
cleaned up, as explained below.	1
cleaned up. If an error	1
cached. The subsequent counts give	1
cached. This can have quite	1
cached. See page 26 about	1
cached. Usually it takes only	1
video or 3-dimensional vectors RGB	1
video or 3-dimensional vectors .......................................................	1
video should also be tested	1
video processing, signal processing, data	1
aa: StoreVector(aa + i, a);	3
aa: a.store(aa+i); } } The	1
information. It is often possible	1
information. Each function call statement	1
information. They have worked well	1
information. 1.1 The costs of	1
Whenever the code has a	1
Whenever a function in a	1
Whenever a processor has a	1
Whenever dynamic memory allocation is	1
area is usually divided into	1
area of system programming, but	1
area for a and b	1
area for different objects even	1
consequence is that the microprocessor	1
consequence of such contentions is	1
consequence of n being out	1
consequence that it allows the	1
a1, a2, b1, b2; y	2
a1, a2, b1, b2, y1,	2
unsigned. The following table summarizes	1
unsigned. The following guidelines can	1
unsigned. // Example 7.4. Signed	1
unsigned. This typically takes one	1
pointers. The advantages of using	1
pointers. The absence of such	1
pointers. This is a frequent	1
pointers. 144 The above examples	1
26 point constants, string constants,	1
26 about data storage and	1
26 7.2 Integers variables and	1
26 7.1 Different kinds of	1
Smaller microprocessors have no native	1
Smaller microcontrollers have no cache	1
Smaller microcontrollers have no branch	1
Smaller microcontrollers have no out-of-order	1
29 for details. Development time	1
29 with line 29. Each	1
29 64-bit Linux: long int	1
29 7.3 Floating point variables	1
sum2 are called accumulators. Current	1
sum2 = 0; int i;	1
sum2 from time T+1 to	1
sum2 += list[i+1];} sum1 +=	1
(n & 1) y *=	1
(n & 0x7FFFFF) | 0x3F800000;	1
(n > 0) { //	1
(n != 0) { if	1
(b + c) The creation	1
(b == 0) { d	1
(b == 0) ? 1.0f	1
(b != 0) { c	1
2n and not negative by	1
2n by adding n to	1
2n by subtracting n from	1
2n -1. The bitwise AND	1
idea to make a positive	1
idea to put time- consuming	1
idea to collect the functions	1
idea how a piece of	1
...................................................................................................... 20 3.9 Other databases	1
...................................................................................................... 21 3.13 Memory access.......................................................................................................	1
...................................................................................................... 90 9.6 Dynamic memory	1
...................................................................................................... 37 7.8 Member pointers.......................................................................................................37	1
C, C++ or assembly language.	1
C, specifying that two pointers	1
C, specifying that pointers of	1
C, C++, D, Pascal, Fortran	1
Same as example 13.1, Requires	1
Same example, using Intel vector	1
Same example, using Agner vector	1
Same example, vectorized with SSE4.1	1
disable it in order to	1
disable exception handling for the	1
disable exception handling for a	1
disable power-save options in the	1
assumption is that the variables	1
assumption that the variable always	1
assumption that signed integer overflow	1
assumption about an unknown CPU	1
treated as an integer. But	1
treated as different functions. There	1
treated as bigger than it	1
treated like a parameter, so	1
Fastcall is not needed in	1
Fastcall function __fastcall __attribute(( fastcall))	1
Fastcall functions are not compatible	1
Fastcall functions /Gr Function level	1
RGB video or 3-dimensional vectors	2
RGB image data have three	1
RGB color difference. Newest instruction	1
avoids the branch inside the	1
avoids the overflow. Taking the	1
avoids many of the drawbacks	1
avoids overflow: a[i] = log(b[i])	1
prevented in other ways, as	1
prevented by calling vector::reserve with	1
prevented from assuming that *p+2	1
prevented from cleaning up because	1
....................................................................................... 5 2.2 Choice of	1
....................................................................................... 22 4 Performance and	1
....................................................................................... 145 14.11 Static versus	1
....................................................................................... 24 6 Development process......................................................................................................	1
seldom used branches such as	1
seldom used functions, and put	1
seldom used. It is more	1
seldom occur and recovering from	1
mixing code compiled for AVX	1
mixing code compiled with and	1
mixing different floating point precisions	1
mixing single and double precision	1
Branches and switch statements The	1
Branches and switch statements............................................................................. 43	1
Branches are implemented by (partial)	1
Branches are relatively cheap if	1
double. The intrinsic vector functions	1
double. Another problem with accessing	1
double. Here we prefer a	1
double. Misaligned data. Extra data	1
16.1 const int NumberOfTests =	1
16.1 Using performance monitor counters	2
16.1 #include <intrin.h> long long	1
(r = 0; r <	2
(r = 1; r <	2
50% of the time and	1
50% of the time. A	1
50% of the cases. The	1
50% or less each time.	1
suboptimal way has become a	1
suboptimal code. Intrinsic functions are	1
suboptimal way. The fact that	1
suboptimal way. Here you have	1
16kB aligned operands Intel Core	1
16kB aligned operands AMD Opteron	1
16kB unaligned op. Intel Core	1
16kB unaligned op. AMD Opteron	1
tasks. A critical innermost loop	1
tasks. For example, in a	1
tasks. Sometimes it is necessary	1
tasks. Before you start to	1
image data have three values	1
image base is not guaranteed	1
image processing, sound processing, and	1
image processing. Yeppp. Open source	1
worst-case conditions in order to	1
worst-case maximum repeat count and	1
worst-case conditions. Programs that produce	1
worst-case performance: The first time	1
(1) is not needed in	1
(1) or false (0); and	1
(1) get its own address	1
(1) check for overflow before	1
float, but not if b	1
float, double and long double	2
float, double, bool, enum as	1
9.5 because we are reading	1
9.5 so that it writes	1
9.5 Alignment of data A	1
9.5 Alignment of data ......................................................................................................	1
Induction; ; parameter $B1$1: mov	1
Induction; ; a[i+1] = Induction;	1
Induction; a[i+1] = Induction; Induction++;	1
Induction; Induction++; } } The	1
uncached or even swapped to	1
uncached memory and we do	1
uncached write is more expensive	1
uncached read because the write	1
individual functions or code lines.	1
individual array elements more complicated	1
individual bits of its binary	1
individual installation tools. Automatic updates.	1
begin the calculation of B	1
begin with _mm. These functions	1
begin at an address divisible	1
begin calculating a new value	1
interface. A console mode program	1
interface. It is 102 also	1
interface. Applications that are not	1
interface. Otherwise the program will	1
9.3 #include <malloc.h> void SomeFunction	1
9.3 Functions that are used	2
9.3 shows, the method of	1
option. This requires that you	1
option. Use the option for	1
option. Then we get rid	1
option. 8.4 Obstacles to optimization	1
diagonal. The elements at the	1
diagonal. The first eight elements	1
diagonal. The c loop in	1
diagonal. Each element matrix[r][c] below	1
interfaces to network resources, databases,	1
interfaces and system calls. These	1
interfaces and interfaces to network	1
interfaces from scratch. This would	1
floats for (int i =	1
floats A structure of four	1
floats F32vec4 xxn(x4, x2*x, x2,	1
floats exp function of 2	1
another. The object that looses	1
another. These costs are higher	1
another. Therefore, it can often	1
another. Therefore, micro- processors have	1
N> class powN { public:	1
N> class SafeArray { protected:	1
N> class powN<true,N> { public:	1
N> static inline double IntegerPower	1
Class data members (properties) The	1
Class data members (properties) ............................................................................	1
Class member functions (methods) Each	1
Class member functions (methods)......................................................................... 53	1
Small data types: char, short	1
Small functions are often inlined	1
Small hand-held devices are becoming	1
Small lightweight processors with low	1
N1 = N&(N-1) gives the	1
N1 } }; // Partial	1
N1 could have been defined	1
N1 (N & (N-1)) return	1
alloca is used. The advantages	1
alloca may not be compatible	1
alloca was called. There is	1
alloca over new and delete	1
aliasing. The only way to	1
aliasing. See page 78 for	1
aliasing. Operations that are missing	1
aliasing. __declspec(noalias) or __restrict or	1
eliminated if the target pointed	1
eliminated if the condition is	1
eliminated if the condition can	1
eliminated completely. For example: //	1
detailed optimization more difficult. On	1
detailed instructions. Example: // Example	1
detailed explanation of the instruction	1
detailed overview of the problem	1
F32vec4 xx4(x4); // x^4 F32vec4	1
F32vec4 xxn(x4, x2*x, x2, x);	1
F32vec4 F64vec2 F32vec8 F64vec4 Table	1
F32vec4 s(0.f, 0.f, 0.f, 1.f);	1
mask to choose between c2	1
mask = _mm_cmpgt_epi16(b, zero); //	2
mask out multiple bits with	1
original is destroyed. In 50	1
original pointer actually points to	1
original object is not modified.	1
original method of doing floating	1
caches and cause large delays.	1
caches are organized into lines	1
caches have to adapt to	1
caches work can be found	1
recognize that the two constants	1
recognize that the values of	1
recognize that 10 is an	1
recognize VIA processors because this	1
513 513 58.7 168.3 Table	1
513 513 2056 38.1 97	1
513 58.7 168.3 Table 9.3.	1
513 2056 38.1 97 Table	1
Threads are used for doing	1
Threads are useful for assigning	1
Threads Threads are used for	1
Threads .................................................................................................................. 60 7.30 Exceptions	1
Overloaded functions The different versions	1
Overloaded functions .............................................................................................. 56 7.27	1
Overloaded operators An overloaded operator	1
Overloaded operators ............................................................................................. 56 7.28	1
Contentions in the branch target	1
Contentions in the level-2 cache	1
Contentions in the level-1 cache	1
Contentions in the BTB can	1
illustrated in this example: 38	1
illustrated in example 13.1 below.	1
illustrated in example 9.5b. //	1
illustrated by the following example:	1
words, the program must clean	1
words, it is inefficient to	1
words, you need to test	1
words, you must make sure	1
returned in registers only in	1
returned in registers. Except for	1
returned by copying them into	1
returned pointer or reference is	1
existing object can be made	1
existing object rather than making	1
existing systems and a 64-bit	1
existing program. Weighing the above	1
Let's take the integer factorial	1
Let's look at the possible	1
Let's look at what happens	1
Let's repeat the above example	1
is, and is compiled when	1
is, in order to force	1
is, but must go through	1
is, I guess, that compiler	1
illustrates the difference between a	1
illustrates such a case: //	1
illustrates how to use SafeArray:	1
illustrates this. My example is	1
unit-testing is necessary for verifying	1
unit-testing is unfortunately very common.	1
unit-testing It is common practice	1
unit-testing ...................................................................................... 156 16.3 Worst-case	1
i<300; i++){ list[i] = i	1
i<300; i++){ list[i] += i	1
i<300; i+=3){ list[i] =0; list[i+1]	1
i<300; i+=3,i_div_3++){ list[i] += i_div_3;	1
{return a + b;} };	1
{return b;} }; The offset	1
{return r.a + r.b;} The	1
{return p->a + p->b;} int	1
b2; This can be changed	1
b2; int c; }; 7.23	1
b2; y = a1/b1 +	1
b2; y = (a1*b2 +	1
Remember to insert a switch	1
Remember to remove the interrupt	1
Remember that container classes in	1
Remember again, that most software	1
explicit use of memset and	1
explicit CPU dispatching in the	1
explicit induction variable. (This eliminates	1
explicit checks for such errors	1
mirror the entire file in	1
mirror the remote data locally.	1
mirror elements matrix[c][r] above the	1
mirror position above the diagonal.	1
dedicated test server. Use large	1
dedicated microprocessor and therefore not	1
dedicated microprocessor core and an	1
dedicated physics processor for calculating	1
Disp() { cout << 1;	2
Disp() { cout << 2;	2
r, c; for (r =	2
r, c; double temp; for	2
8.26a by rolling out the	1
8.26a void Func(int a[], int	1
8.26a compiled to assembly: ALIGN	1
8.26a (32-bit mode): ; Example	1
breakpoint and show a disassembly,	1
breakpoint in the code with	1
breakpoint in the fully optimized	1
breakpoint again. The following example	1
b1, b2; y = a1/b1	1
b1, b2; y = (a1*b2	1
b1, b2, y1, y2; y1	1
b1, b2, y1, y2, reciprocal_divisor;	1
appears to be an obvious	1
appears to be profitable (see	1
appears in the machine code	1
appears on the market. Such	1
functionality of an optimized function,	1
functionality to an existing program.	1
functionality and a well-defined interface	1
functionality without polymorphism or with	1
languages. This section discusses how	1
languages. But the C++ language	1
languages. My preference is for	1
languages. www.yeppp.info And here is	1
sequential order and it can	1
sequential order. If the code	1
sequential labels is simply predicted	1
sequential instructions, where a hardware	1
www.agner.org/optimize/cppexamples.zip for how to store	1
www.agner.org/optimize/cppexamples.zip for examples of how	1
www.agner.org/optimize/cppexamples.zip contains examples of arrays	1
www.agner.org/optimize/cppexamples.zip containing container classes and	1
style. The time consumption of	1
style. The advantages of using	1
style. It is often preferable	1
style. Some compilers make Sum1	1
MOVNTQ instruction cannot be used	1
MOVNTQ instruction must be followed	1
MOVNTQ _mm_stream_pi SSE Store 16	1
MOVNTQ _mm_empty(); // EMMS }	1
optimized. We cannot change its	1
optimized. Note that the Intel	1
optimized. Library functions are typically	1
optimized. Jumps between CPU cores.	1
......................................................................................... 65 7.33 Namespaces........................................................................................................... 65	1
......................................................................................... 87 9.2 Cache organization	1
......................................................................................... 107 12.4 Using intrinsic	1
......................................................................................... 132 14.1 Use lookup	1
CHello { public: void NotPolymorphic();	1
CHello { public: virtual void	2
CHello * p; p =	1
found in other languages. But	1
found in my vector class	1
found in Wikipedia under CPU	1
found elsewhere. 13.5 Implementation The	1
me explain the above code	1
me explain this with an	1
me corrections and suggestions for	1
me manually, but if we	1
counts. The value of the	1
counts. This is the time	1
counts. It is measured simply	1
counts. In any event, the	1
measurement code should have #if	1
measurement should not include any	1
measurement instruments into the program	1
measurement instruments directly into the	1
layers of abstraction is a	1
layers of abstraction in the	1
layers and it needs to	1
layers and frameworks typically used	1
handler to call the destructor	1
handler in the program if	1
handler calls exit(), abort(), _endthread(),	1
handler needs all information about	1
coded in a hardware definition	2
coded as an 8-bit signed	1
coded as _mm_empty() as shown	1
changing the dividend to unsigned	1
changing in the innermost loop.	1
changing this to: // Example	1
changing then the CPU may	1
unit-test may have a larger	1
unit-test but has a smaller	1
unit-test without taking cache effects	1
unit-test does not give the	1
implicit pointer known in 36	1
implicit parameter to the function.	1
implicit 'this' pointer in member	1
implicit 'this' pointer which does	1
smaller. The lengths of the	1
smaller. This manual discusses how	1
smaller. It is faster to	1
smaller. Structure and class objects	1
interval is a power of	1
interval from 0 to 15.	1
interval 0 <= n <	1
interval [1.0, 2.0) by setting	1
33 result is known to	1
33 7.5 Booleans................................................................................................................... 33 7.6	1
33 7.6 Pointers and references	1
33 11.8 127 127 126	1
31 for more discussion of	1
31 ebx, eax ebx, 1	1
31 7.3 Floating point variables	1
31 11.6 64 64 32	1
int)b / 10; a =	1
int)b / 16; // This	1
int)b % 10; a =	1
int)b % 16; // This	1
3. The code is __asm	1
3. The Gnu compiler allows	1
3. The microarchitecture of Intel,	1
3. Use appropriate compiler options	1
s is less than 1/50	1
s on the next generation	1
s on a 2 GHz	1
s today, then it may	1
module. The compiler has to	1
module. The size of integers	1
module. The static declaration makes	1
module. This non-inlined copy is	1
cast The dynamic_cast operator is	1
cast The const_cast operator is	1
cast The reinterpret_cast operator is	1
cast The static_cast operator does	1
8-bit integers with the value	1
8-bit integers which range from	1
8-bit signed number. If the	1
8-bit signed number, or no	1
Integers of smaller sizes (char,	1
Integers can be different sizes,	1
Integers variables and operators Integer	1
Integers variables and operators............................................................................... 29	1
Calling a function through a	1
Calling a member function is	1
Calling conventions for different C++	1
Calling exit may not be	1
(double const x) { //	1
(double const x) { return	1
(double x) { // (N	1
(double x, unsigned int n)	1
Weekdays { Sunday, Monday, Tuesday,	1
Weekdays { Sunday = 1,	1
Weekdays Day; if (Day &	1
Weekdays Day; if (Day ==	1
application-specific code. The best function	1
application-specific code. If you consider	1
application-specific instructions that can be	1
application-specific information in a separate	1
first. If it is not	1
first. If one operand is	1
first. However, you must be	1
first. b+c = 100000001.23456. The	1
considerations of efficiency, platform independence,	1
considerations that are particularly important	1
considerations should be taken into	1
considerations such as price, compatibility,	1
63 number (e.g. with _finite())	1
63 31 11.6 64 64	1
63 63 31 11.6 64	1
63 . The value is	1
represented with or without the	1
represented with 64 bits, but	1
represented as an integer. 158	1
represented as two 32-bit integers,	1
force the operating system to	1
force the swapping of memory	1
force a member function to	1
force when I die. See	1
manually. The effect of dependency	1
manually. This principle is useful	1
manually. It must be emphasized	1
manually. I have tested the	1
identified by a key? If	1
identified by a unique key.	1
identified by their index or	1
identified by consecutive indices or	1
www.agner.org/optimize/cppexamples.zip. If the number and	1
www.agner.org/optimize/cppexamples.zip. An array using the	1
www.agner.org/optimize/cppexamples.zip. These may be used	1
www.agner.org/optimize/cppexamples.zip. 9.9 Access data sequentially	1
virus scanners to consume more	1
virus scanners and other protection	1
virus scanner that scans all	1
virus attacks and other abuse	1
structures. For example, if a	1
structures. On the contrary, you	1
structures. Accessing a data member	1
structures. Useful for vector operations,	1
exp function of 2 double	1
exp function of 4 floats	1
exp exp 12.8 Aligning dynamically	1
exp 12.8 Aligning dynamically allocated	1
(in bytes) is a high	1
(in bytes) of the objects	1
(in bytes) of each array	1
(in Windows: __rdtsc()). The time	1
pointer, a reference, or void.	1
pointer, but it is not	1
pointer, but this feature is	1
pointer, common subexpressions, and induction	1
kept in the carry flag	1
kept in different source files	1
kept small in the critical	1
kept entirely inside one function,	1
Y and Z. Each dependency	1
Y // Update induction variable	1
Y = C; double Z	1
Y += Z; Z +=	1
interprocedural optimization is enabled. A	1
interprocedural optimizations of the whole	1
interprocedural optimizations. The keyword static,	1
interprocedural optimizations. See page 80.	1
incompatible or error prone. All	1
incompatible with floating point code.	1
incompatible with old CPUs. The	1
incompatible with debugging. A debugger	1
bytes) is a high power	1
bytes) of the objects should	1
bytes) of each array element	1
bytes) on future processors. There	1
selected if the processor is	1
selected instruction set. Make two	1
selected version FuncType * SelectAddMul_pointer	1
selected during the installation process	1
multiplied by the size of	1
multiplied by the size (in	1
multiplied by the clock period	1
multiplied by a factor of	1
reproducible as possible. However, there	1
reproducible time measurements: warm up	1
reproducible results. This is because	1
reproducible results. If you want	1
normally use the so-called position-	1
normally use this principle for	1
normally compiled with the option	1
normally belongs to the area	1
constants. For example, a branch	1
constants. For example, #define ABC	1
constants. Integer constants are usually	1
constants. Register storage A limited	1
cache, code cache, branch target	1
cache, at least at the	1
cache, where it is accessed	1
cache, branch target buffer, branch	1
entry with the pointer it	1
entry point extern "C" int	1
entry point. // After first	1
entry initially points to the	1
inferior to the Intel libraries.	1
inferior to their 32-bit counterparts.	1
inferior version of the code	1
inferior version on the processors	1
obsolete. But if I write	1
obsolete. Programmers very often underestimate	1
obsolete. Microprocessor documentation Intel: "IA-32	1
obsolete. Rick Booth: "Inner Loops:	1
simultaneously can share the same	1
simultaneously or out of order.	1
simultaneously or seemingly simultaneously. If	1
simultaneously prefetching the code of	1
routine that is called before	1
routine that loads the appropriate	1
routine should do as little	1
routine sets a function pointer	1
auto_ptr to another by assignment.	1
auto_ptr and shared_ptr. auto_ptr has	1
auto_ptr that owns the allocated	1
auto_ptr has the feature that	1
tree or a hash map	1
tree or a hash map.	1
tree or switch statement leads	1
tree may be used if	1
unable to access the file	1
unable to predict which variables	1
unable to vectorize the code	1
unable to respond quickly to	1
Optimizes very well. This compiler	1
Optimizes reasonably well. Codeplay VectorC	1
Optimizes reasonably well. Very poor	1
Optimizes moderately well. Supports three	1
constants, and initialized arrays. I	1
constants, array initializer lists, switch	1
constants, string constants, and initialized	1
constants, string constants, array initializer	1
techniques of multithreading. 7.30 Exceptions	1
techniques in the present manual.	1
techniques can be considered metaprogramming	1
techniques like square blocking for	1
otherwise can only be applied	1
otherwise would be predicted well.	1
otherwise optimize across the function	1
otherwise go undetected. Converting class	1
Smart pointers are used only	1
Smart pointers can be useful	1
Smart pointers A smart pointer	1
Smart pointers .......................................................................................................... 38 7.10	1
opens the possibility for further	1
opens the possibility for significant	1
opens a file in exclusive	1
opens and closes the file	1
modified by the program. The	1
modified by the program, and	1
modified by the program, one	1
modified should be separate for	1
15.1a to an inlined 15.1b	1
15.1a to 15.1c would of	1
15.1a to 15.1c). 16 Testing	1
15.1a to 151 15.1c automatically,	1
Comparison of function libraries Test	1
Comparison of different compilers I	1
Comparison of different compilers............................................................................. 74	1
Comparison of optimizations in different	1
finished the calculations on the	1
finished the calculation of (a+b).	1
finished the time-consuming data processing.	1
finished using the previous value.	1
run. The time it takes	1
run. Some implementations of Java	1
run. Examples include JavaScript, PHP,	1
run. Both the executable file	1
sequentially in memory if organized	1
sequentially in memory. They may	1
sequentially A cache works most	1
sequentially .......................................................................................... 96 9.10 Cache	1
Intel: "Intel 64 and IA-32	1
Intel: "IA-32 Intel Architecture Software	2
Intel: "Intel C++ Compiler Documentation".	1
format. The intermediate files are	1
format. The formats can be	1
format. Other compilers offer the	1
format. Alternatively, make a DLL	1
programs. The profiler identifies any	1
programs. It is not recommended	1
programs. If you can avoid	1
programs. Writing past the end	1
manner to make sure the	1
manner by returning a null	1
manner then it is likely	1
manner where the critical stride	1
work. The C++ language is	1
work. The updating mechanism should	1
work. The recommendations are based	1
work. Data alignment. __declspec(align(16)) or	1
uint64_t 128 Vec2uq 8 32	1
uint64_t 256 float 128 double	1
uint64_t Table 7.1. Sizes of	1
uint64_t MS compiler: unsigned __int64	1
(level >= 4) { //	2
(level >= 11) { //	2
tests are done under the	1
tests with the sizeof operator.	1
tests on Intel compiler versions	1
tests were carried out with	1
Then you make a test	1
Then we are breaking out	1
Then we get rid of	1
Then again two times the	1
soft processor is much slower	1
soft processor activates critical application-	1
soft cores that do not	1
soft processor. Such a soft	1
100, c = 100, y;	1
100, y; y = a	1
100, max = 110; int	1
100, NUMCOLUMNS = 100; int	1
results. This is because modern	1
results. If you are not	1
results. If you want to	1
results. Integer operators Integer operations	1
hyperthreading is not advantageous then	1
hyperthreading or not in a	1
hyperthreading by using only the	1
hyperthreading processor to give higher	1
operators. Function parameters that are	1
operators. Make a C++ program	1
operators. Vectorized code often contains	1
operators. 7.7 Function pointers Calling	1
simpler in 64-bit mode because	1
simpler than a frame function	1
simpler when using references. References	1
simpler because it needs only	1
format is not standardized. It	1
format is standardized allows us	1
format and getting them into	1
format instead of the usual	1
reasonable solution is to have	1
reasonable upper limit to the	1
reasonable upper limit can be	1
reasonable estimate can be made)	1
resolution of the CPU clock	1
resolution and the critical functions	1
resolution can be obtained with	1
resolution if time intervals are	1
units, and 22 one or	1
units, memory ports, etc. of	1
units, one or two floating	1
units, etc. and the wires	1
12.2 128 128 128 17.4	1
12.2 __declspec(align(16)) struct S1 {	1
12.2 AVX-512 instruction set and	2
b: from cc into vector	1
b: __m128i b = LoadVector(bb	2
b: Is16vec8 b = LoadVector(bb	1
processing. Visual Studio optimizes reasonably	1
processing. Yeppp. Open source library.	1
processing. Running multiple threads on	1
processing. Scott Meyers: "Effective C++".	1
well-defined with option -fwrapv or	1
well-defined interface to the calling	1
well-defined interface to the rest	1
well-defined functionality and a well-defined	1
Still faster if unsigned The	1
Still faster if unsigned //	2
Still faster if unsigned You	1
45 for (i = 0;	1
45 clock cycles. Floating point	1
45 clock cycles). Floating point	1
45 7.14 Functions ................................................................................................................ 48	1
bb into vector b: from	1
bb into vector b: __m128i	2
bb into vector b: Is16vec8	1
detail in manual 3: "The	1
detail in manual 2: "Optimizing	1
detail on page 146 below.	1
advices in critical parts of	1
advices on optimization of C++	1
advices may apply to other	1
conclusion is that the choice	1
conclusion is that we can	1
conclusion to this argument is	1
deleted by another function and	1
deleted when the pointer is	1
deleted properly and the memory	1
49 and manual 5: "Calling	1
49 for a discussion. 7.33	1
49 first eight floating point	1
parameters, as example 7.15b below	1
parameters, local variables, and for	1
parameters, pointers, references, 'this' pointer,	1
Storing the parameters on the	1
Storing variables in a class	1
Storing something in static memory	1
(set) = (memory address) /	1
(set) = (10000 / 64)	1
(set) = (0x2710 / 0x40)	1
fine-grained parallelism when deciding whether	1
fine-grained parallelism because communication and	1
fine-grained parallelism. The way to	1
Execution time too small or	1
Execution unit throughput There is	1
Execution unit throughput ....................................................................................... 22	1
LoadVector(cc + i); // result	1
LoadVector(cc + i); // Add	2
arbitrary memory address and shared	1
arbitrary cache line. Only one	1
arbitrary name that the compiler	1
Which of these two values	1
Which method you use is	1
Which solution you prefer is	1
behave according to the table.	1
behave differently on different test	1
behave differently because there are	1
bits, and the result will	1
bits, but 32-bit systems do	1
bits, so you can have	1
compact. The biggest disadvantage of	1
compact. See page 52. The	1
compact. Accessing a member of	1
behaves like a pointer. It	1
behaves like an array with	1
behaves differently on signed and	1
FPGA in the same chip.	1
FPGA as a so-called soft	1
FPGA soft cores that do	1
earlier Intel processors are not	1
earlier CPUs. The sequence of	1
earlier vmlsExp4 vmldExp2 Intel SVML	1
5) { // do nothing	1
5) SelectAddMul_pointer = &SelectAddMul_SSE41; (iset	1
5) {} which would be	1
&, |, ^, ~ are	1
&, |, ^, ~, <<,	1
&, |, ~. The Boolean	1
101 for further discussion of	1
101 Multithreading works more efficiently	1
101 10.1 Hyperthreading ..................................................................................................... 103	1
reasons: The function call makes	1
reasons: The size of the	1
reasons: Each object is allocated	1
consecutively and can calculate the	1
consecutively in the order in	1
consecutively in memory. No information	1
Extra time is needed for	1
Extra memory space is used	1
Extra data conversion, shuffling, packing,	1
error. The calculations may take	1
error. The allocated memory may	1
error. // You may insert	1
carried out with all relevant	1
carried out independently of other	1
carried dependency chain would make	1
reordering the data members. If	1
reordering has made the structure	1
reordering easier for the CPU.	1
platform. Intel The Intel compiler	1
platform. However, with a well	1
platform. 14.8 Conversions between floating	1
satisfied with the way a	1
satisfied with more heuristic guidelines.	1
satisfied with making software in	1
catch an exception in case	1
catch programming errors that would	1
catch (...) { ... }	1
/arch:AVX etc. for Windows, -msse2,	1
/arch:AVX /openmp /MT -msse3 /arch:SSE3	1
/arch:AVX /QaxSSE3, etc. -msse3 -mssse3	1
93 for discussion of efficient	1
93 9.8 Strings ...................................................................................................................... 96	1
93 themselves. But implementing a	1
53 function at runtime. Polymorphism	1
53 7.21 Runtime type identification	1
53 7.20 Virtual member functions	1
#else // 32-bit Windows, Intel/MASM	1
#else // Gnu compiler, etc.	1
#else #define pure_function #endif double	1
addition. This is small enough	1
addition. If the size of	1
addition. Comparing two pointers requires	1
Text strings and similar objects	1
Text strings are particularly problematic	1
Text strings typically have variable	1
big-endian storage. Example 14.23b and	1
big-endian storage. All x86 platforms	1
big-endian storage. Optimizing file access	1
54 class D : public	1
54 7.22 Inheritance .............................................................................................................. 54	1
54 7.23 Constructors and destructors	1
119 The function names in	1
119 for more information about	1
119 12.8 Aligning dynamically allocated	1
!a = true a &&	1
!a = false, a ||	1
!a && !b = !(a	1
abstraction is a common cause	1
abstraction in the logical architecture	1
abstraction which makes detailed optimization	1
each, or two integers of	1
each, four integers of 32	1
each, eight integers of 16	1
11) and vector operations (chapter	1
11) { // AVX supported	2
code). The source code is	1
code). If the repeat count	1
code). Supports 32-bit and 64-bit	1
...................................................................................... 16 3.2 Use a	1
...................................................................................... 90 9.7 Container classes	1
...................................................................................... 156 16.3 Worst-case testing	1
wrong branch is fed into	1
wrong branch. Microprocessor designers have	1
wrong type. References are useful	1
LoadVector(bb + i); // Load	3
alias any elements in the	1
alias anything by using the	1
alias upon the double. Another	1
blocks, for example: Use a	1
blocks, or if the 7	1
blocks, either in the form	1
feedback should be handled in	1
feedback comes from testing. Here,	1
feedback seriously. User complaints should	1
pure_function ; double Func2(double x)	1
pure_function #endif double Func1(double) pure_function	1
pure_function __attribute__((const)) #else #define pure_function	1
a-a = 0 - n.a.	1
a-a = 0 - a+0	1
a-a = 0 a+0=a a*0=0	1
chains. A dependency chain is	1
chains. In this case, the	1
chains. Another thing that you	1
prefetching the code of the	1
prefetching data for the other	1
prefetching so this feature is	1
compiler-generated code in the disassembly	1
compiler-generated code by making another	1
compiler-generated assembly code. Let me	1
redesign of the program, for	1
redesign of a program that	1
redesign can not only improve	1
differently on different test examples.	1
differently on signed and unsigned	1
differently because there are different	1
B, and the calculation of	1
B, C; x.abc = A	1
B, C; x.a = A;	1
reasonably well. Codeplay VectorC A	1
reasonably well. Very poor performance	1
reasonably well, but it is	1
Two or more template instances	1
Two libraries of predefined vector	1
Two threads running in the	1
55 In this example, the	1
55 7.24 Unions .................................................................................................................... 55	1
55 7.25 Bitfields ................................................................................................................... 56	1
libraries: Intel vector math library	1
libraries: Intel short vector math	1
libraries: long vector libraries and	1
projects can be improved by	1
projects have become bigger and	1
projects made with Microsoft or	1
1)sign 2exponent 127 1 fraction	1
1)sign 2exponent 16383 one fraction	1
1)sign 2exponent 1023 1 fraction	1
14.6 float list[16]; int i;	1
14.6 Floating point division Floating	1
14.6 Floating point division ...........................................................................................	1
combination of a dedicated microprocessor	1
combination of these two gives	1
combination of additions and shift	1
libraries, but who would like	1
libraries, also called shared objects	2
mean use the value in	1
mean good performance). Aligned operands	1
mean atomic. It doesn't prevent	1
inserts extra code at each	1
inserts temporary debug breakpoints at	1
inserts built-in code instead of	1
const*)p); } // Function to	3
hidden by using the declaration	1
hidden pointer. The copy constructor,	1
hidden behind the C++ syntax	1
x*x*x*x*x*x*x*x = ((x2) 2) 2	2
x*x*x*x*x*x*x*x = ((x2)2)2 a+a+a+a=a*4 -(-a)=a	1
errors. The following example illustrates	1
errors. If you just want	1
errors. See page 90 for	1
One may argue that it	1
One popular development tool is	1
One kilobyte is 1024 bytes,	1
blocking and similar methods are	1
blocking for the level-1 cache	1
blocking or tiling. This technique	1
Faster if divisor is a	2
Faster than most other libraries	1
sources of compatibility problems and	1
sources of resource problems and	1
sources of frustration and waste	1
well-tested libraries for many common	1
well-tested container classes. The standard	1
well-tested functions, classes, templates or	1
devices, as discussed on page	1
devices, you don't even have	1
devices, but there are some	1
multiplication, to mix simple integer	1
multiplication, etc. is still the	1
multiplication, etc.) inside the loop.	1
part. It is discussed how	1
part. If a function is	1
part. If a piece of	1
API and the application software.	1
API function which then calls	1
API calls rather than self-styled	1
starts running and before any	1
starts up, even if the	1
starts up. Some modules may	1
only. The following algorithm is	1
only. This can be done	1
only. Critical pieces of code	1
counters, function parameters, pointers, references,	1
counters, as in example 7.32b.	1
counters, etc. In large arrays,	1
execution, as explained on page	1
execution, you have to avoid	1
execution, even if the variable	1
list[i+1] = 1; list[i+2] =	2
list[i+1] += i_div_3; list[i+2] +=	1
distance the critical stride. Variables	1
distance in memory is a	1
distance between rows in a	1
14.28 can be implemented like	1
14.28 will shift out the	1
14.28 union { float f;	1
zero, by setting pointers to	1
zero, rather than rounding. This	1
zero, c + two, b	1
r1 and c1 for all	1
r1 < SIZE; r1 +=	1
r1 += TILESIZE) { for	1
r2 and c2 for elements	1
r2 < r1+TILESIZE; r2++) {	2
(MS) smmintrin.h (Gnu) AES, PCLMUL	1
(MS) xopintrin.h (Gnu) AMD FMA4	1
(MS) x86intrin.h (Gnu) Table 12.2.	1
aligning the data optimally, or	1
aligning data #ifdef _MSC_VER //	1
aligning dynamically allocated memory. 9.6	1
assuming that the occurrence is	1
assuming that *p+2 is a	1
assuming no pointer aliasing (/Oa).	1
r; for (i = 0;	1
r; c++) { // loop	2
analysis of the data structure,	1
analysis The live range of	1
analysis Join identical branches Eliminate	1
seem a little odd here.	1
seem to do so. The	1
seem illogical that the compiler	1
perhaps for a very large	1
perhaps }; // constant data	1
perhaps Mac OS. See page	1
service routine should do as	1
service routines and device drivers	1
service routines, system core and	1
Comes with the Gnu compiler.	1
Comes with the Borland C++	1
Comes with Microsoft compiler. Some	1
esp ; align by 4	1
esp ebx ecx, DWORD PTR	1
esp ;alignby4 ; mangled function	1
features. The programmer typically thinks	1
features. User feedback should be	1
features. Take user feedback seriously.	1
---xx---- (a+c==b+c)=(a==b) ----x---- !(a<b)=(a>=b) (a<b	1
---xx---- a<<b<<c=a<<(b+c) x-xxx--xx a |	1
---xx---- (-a>-b)=(a<b) ---xx---x Divide by	1
............................................................................................... 4 2 Choosing the	1
............................................................................................... 50 7.16 Function return	1
............................................................................................... 23 5 Choosing the	1
C/C++ standard specifies that all	1
C/C++ standard specifies truncation so	1
C/C++ v. 1.4, 2005. Codeplay	1
100. It compares eax with	1
100. pop ebx restores the	1
100. Now, according to the	1
b;}; S1 list[100]; int i;	1
b;}; S1 list[100], *temp; for	1
b;}; Sab ab[size]; int i;	1
consumes a lot of resources,	1
consumes CPU time. But this	1
consumes most of the resources.	1
numbers, then you have to	1
numbers, but on what instruction	1
numbers, we have a =	1
129 130 14.4 511 511	1
129 129 130 14.4 511	1
129 13.7 CPU dispatching in	1
reload the value from memory	1
reload the level-1 cache from	1
reload *p and calculate *p+2	1
124 2 13.4 Test and	1
124 necessary information about which	1
124 13.3 Difficult cases........................................................................................................ 124	1
motion A calculation may be	1
motion Induction variables for array	1
motion manually when it involves	1
speed-critical program on the newest	1
speed-critical functions by using the	1
speed-critical functions. Many function libraries	1
numbers: // Example 11.2a const	1
numbers: // Example 8.18 float	1
numbers: // Example 12.8a. Sum	1
(page 77) shows which reductions	1
(page 131) shows a way	1
(page 146). In the cases	1
12. If the code is	1
12. Most modern CPUs have	1
12. Higher inputs give overflow	1
1000 * 100 * 5	1
1000 times and that there	1
1000 times then we have	1
long. This is often the	1
long. If the program under	1
long. Lazy binding should therefore	1
organization for different processors are	1
organization It is useful to	1
organization ................................................................................................... 87 9.3 Functions	1
slow, you know). The code	1
slow, then the microprocessor can	1
slow, difficult to use, incompatible	1
performed with a realistic set	1
performed on a sequence of	1
performed on multiple data elements	1
high-level language with a wealth	1
high-level language need only read	1
high-level languages are good for	1
advance. The frequent allocation and	1
advance. The disadvantages of dynamic	1
advance. This reduces the code	1
anyway and you want the	1
anyway in 64-bit code. However,	1
anyway if you are using	1
(*.dll or *.so). The program	1
(*.dll or *.so). The installation	1
(*.dll or *.so) that belong	1
Intel-based Mac OS and Itanium	1
Intel-based Mac OS X operating	1
Intel-based Mac OS, etc.) have	1
main() are compiled without any	1
main() { int a, b,	2
x2 = x * x;	1
x2 = x *x; double	1
x2 * x2; // x^4	1
database, and a third thread	1
database, and other extra software	1
database, or other data structure	1
Works with all x86 platforms.	2
Works well with non-Intel CPUs.	1
calculations: for ( ; i	1
calculations: // Example 14.11 int	1
calculations: // Example 8.3a float	1
basis for this manual for	1
basis then use a linear	1
basis then use a queue.	1
updating of software can cause	1
updating in the likely case	1
updating mechanism should never interrupt	1
manipulation is required for putting	1
manipulation Mathematical functions Encryption, decryption,	1
manipulation tricks Michael Abrash: "Zen	1
28. The calculation becomes easier	1
28. This means that a	1
28. We take the elements	1
C0 { public: virtual void	2
C0 * p = &	1
access, as given in the	1
access, etc. The problem here	1
access, sort and search facilities,	1
calculations, and then use only	1
calculations, should be scheduled in	1
calculations, where each calculation depends	1
multi-core CPUs, as described in	1
multi-core CPUs, but event-counters do.	1
multi-core processing. Visual Studio optimizes	1
level, and the Digital Mars	1
level, and in some cases	1
level, typically in a message	1
Exception handling is not necessary	1
Exception handling is intended for	1
Exception Specifications, Dr Dobbs Journal,	1
optimization, the compiler needs to	1
optimization, it does have some	1
optimization, which will enable optimizations	1
Whether the constants are defined	1
Whether you want to make	1
Whether you choose to use	1
contents of the old memory	1
contents of data cache, code	1
contents copied to the new	1
books and manuals. I want	1
books contain many tips on	1
books 1994. Mostly obsolete. Rick	1
removed the contentions and the	1
removed from the above example,	1
removed after debugging if required	1
164 1 Introduction This manual	1
164 below. Those who are	1
matrix[rows][columns]; int i; float x;	1
matrix[rows][columns]; int i, j; int	1
matrix[rows][columns]; int i, j; float	1
list. Each element in a	1
list. Do not use STL	1
list. 94 Are objects accessed	1
exponential function can be calculated	1
exponential functions, trigonometric functions, etc.	2
generality of the STL also	1
generality and flexibility of the	1
generality and flexibility, while execution	1
takes. The version that performs	1
takes. See page 153 for	1
takes. Debugging. The profiler inserts	1
multithreaded applications it is much	1
multithreaded program, or between different	1
multithreaded applications: The cost of	1
list[i+2] = 2; } The	1
list[i+2] = 2; } list[300]	1
list[i+2] += i_div_3; } 138	1
Total size of vector, bits	2
Total kilobytes Time per element	1
explicitly. In example 8.21, you	1
explicitly. There are various ways	1
explicitly. Divisions can sometimes be	1
programs, more than 99% of	1
programs, except for small embedded	1
programs, 99% of the time	1
optimizes the code. Sometimes the	1
optimizes a piece of code.	1
optimizes reasonably well, but it	1
instruments in the code itself	1
instruments into the program itself.	1
instruments directly into the code	1
After each iteration it decides	1
After first call it will	1
After first call it points	1
involving integer addition, subtraction and	1
involving class objects (rather than	1
involving division and relational operators	1
(vector) reductions: Common subexpression elimination	1
(vector) reductions: a+b=b+a, a*b=b*a x	1
(vector) reductions: ~(~a) = a	1
unfortunate because truncation takes much	1
unfortunate method that delays execution	1
unfortunate consequence that it allows	1
"Optimizing subroutines in assembly language".	2
"Optimizing subroutines in assembly language",	1
parameter, and the destructor, if	1
parameter, or as a function	1
parameter, so there may be	1
exceptions. The function that detects	1
exceptions. The mechanism relies on	1
exceptions. See page 61. It	1
time- consuming calculations into a	1
time- consuming features of the	1
time- consuming. There is a	1
K8 0.24 0.25 0.24 n.a.	1
K8 1.09 1.25 1.61 n.a.	1
K8 0.38 0.44 0.40 n.a.	1
loaded. This makes a critical	1
loaded. This method requires OS	1
loaded. 21 3.13 Memory access	1
(i=0; i<100; i++) sum +=	1
(i=0; i<n; i++) is the	1
(i=0; i<n; ++i). But when	1
14.30 will therefore need modification	1
14.30 const int size =	1
14.30 finds the numerically largest	1
b;} vector operator + (vector	1
b;} }; The offset of	1
b;} }; int Sum2(S3 *	1
wasteful in the STL. Some	1
wasteful copying of memory blocks,	1
wasteful behavior can be prevented	1
Return the size of the	1
Return a null reference to	1
Return reference to a[i] More	1
StoreVector(void * d, __m128i const	3
microcontrollers have no cache (see	1
microcontrollers have no branch prediction	1
microcontrollers have no out-of-order execution.	1
character arrays is fast and	1
character arrays. Note that the	1
character arrays. Strings can be	1
implemented. The highest efficiency is	1
implemented. The recursion must always	1
implemented. Use the option that	1
fact, the compiler may actually	1
fact, the STL has been	1
fact, you may get a	1
runtime. Example 7.43 on page	1
runtime. #define directives are equivalent	1
runtime. Polymorphism is one of	1
manually by the programmer. 79	1
manually when it involves pure	1
manually unless there is a	1
xxn * _mm_load_ps(coef+i); // s	1
xxn rather than the throughput	1
xxn *= xx4; // next	1
|, ^, ~ are useful	1
|, ^, ~, <<, >>	1
|, ~. The Boolean operators	1
7.2 a = b *	1
7.2 Integers variables and operators	1
7.2 Integers variables and operators...............................................................................	1
Thread-local storage is inefficient because	1
Thread-local storage should be avoided,	1
Thread-local storage Most compilers can	1
81 for an explanation of	1
81 optimization is to join	1
81 8.6 Optimization directives ..............................................................................................	1
7.1 float SomeFunction (int x)	1
7.1 Different kinds of variable	2
signal an error simply by	1
signal processing and image processing.	1
signal processing, data compression and	1
circular buffer with fixed size	1
circular buffer with fixed size,	1
circular buffer than as a	1
7.4 we are converting a	1
7.4 Enums An enum is	1
7.4 Enums ...................................................................................................................... 33 7.5	1
ignore the problem and assume	1
ignore a request for inlining	1
ignore overflow or assume that	1
keywords and directives which are	1
keywords relevant to optimization MS	1
keywords Fast function calling. __fastcall	1
7.8 if (handle != INVALID_HANDLE_VALUE	1
7.8 Member pointers In simple	1
7.8 Member pointers.......................................................................................................37 7.9 Smart	1
once. The reasons for this	1
once. Example: // Example 8.6a	1
once. One may argue that	1
89 for an example of	1
89 for an example. A	1
89 int a[1000]; float b[1000];	1
list[100]; int i; for (i	1
list[100]; Func1(list, &list[8]); } Here,	1
list[100]; memset(list, 0, sizeof(list)); A	1
considered a software optimization issue.	1
considered a container that contains	1
considered metaprogramming in C++: Preprocessor	1
Windows). The XMM vector registers	1
Windows). There are several ways	1
Windows). Alternatively, you may call	1
for. The names of the	1
for. In other words, you	1
for. Some systems also have	1
divisions are given on page	1
divisions can be combined. For	1
divisions (Division is slow, you	1
8; // exponent + 0x7F	1
8; // SIZE must be	1
8; float matrix[rows][columns]; int i,	1
reflects the floating point value	1
reflects the order in which	1
reflects the conflicting considerations of	1
..................................................................................................... 103 11 Out of	1
..................................................................................................... 126 13.6 CPU dispatching	1
..................................................................................................... 93 9.8 Strings ......................................................................................................................	1
lies in the way microprocessors	1
lies in the way m	1
lies r places back in	1
trigonometric functions. The code is	1
trigonometric functions, etc. in vectors.	1
trigonometric functions, etc. are implemented	1
manipulate the data cache. These	1
manipulate the different parts of	1
manipulate all the bits of	1
fractional part unsigned int exponent	2
fractional part 142 unsigned int	1
-128 to +127. An integer	1
-128 generates 127. The calculation	1
-128 127 int8_t short int	1
spaced a multiple of 0x800	1
spaced by a multiple of	2
approximate reciprocal square root, RGB	1
approximate comparison of doubles by	1
approximate reciprocal, fast approximate reciprocal	1
comparisons, which are relatively costly	1
comparisons, such as <. The	1
comparisons, etc. For example: //	1
User work that needs to	1
User feedback should be handled	1
User complaints should be regarded	1
dividend is unsigned Examples: //	1
dividend is unsigned. The following	1
dividend to unsigned if you	1
unpredictable times and cause delays	1
unpredictable errors elsewhere in the	1
unpredictable intervals which may interfere	1
LoadVector(void const * p) {	3
step. The intermediate file format	1
step. In most systems, you	1
step. With a short vector	1
Z = A + B;	1
Z } The loop in	1
Z += A2; // Table	1
separated by commas. There should	1
separated by semicolons, while multiple	1
separated from the application code.	1
64, but the alignment requirements	1
64, depending on the processor.	1
64, ...). We can make	1
copies the table to stack	1
copies the sign bit of	1
copies them into the executable	1
brand. The version that works	1
brand. Critical parts of the	1
brand. Future processors will support	1
annoying to the user and	1
annoying to the user. Compatibility	1
annoying time consumer to many	1
CodeAnalyst. There are several different	1
CodeAnalyst. These profilers are useful	1
CodeAnalyst. Unfortunately, profilers are often	1
Literature on code optimization Intel:	1
Literature Other manuals by Agner	1
Literature ..................................................................................................................... 163 20 Copyright	1
study the code that a	1
study the available options for	1
study of how compilers and	1
stack, which is very likely	1
stack, which makes data caching	1
stack, except for the cases	1
collection. The allocated memory is	1
collection. A more efficient solution	1
collection. Objects that are allocated	1
occurs, but this is not	1
occurs, even for arrays bigger	1
occurs, (2) use unsigned integers	1
-fno-pic and link with the	1
-fno-pic when compiling for 32-bit	1
-fno-pic apparently has no effect.	1
_M_IX86 and _WIN64 _M_X64 _M_X64	1
_M_IX86 x86-64 platform _M_IX86 and	1
_M_IX86 _M_IX86 x86-64 platform _M_IX86	1
elsewhere and get a good	1
elsewhere in the program that	1
elsewhere then there is no	1
bypassing the dispatch mechanism even	1
bypassing the so-called CPU-dispatcher that	1
bypassing syntax checks. These conversions	1
0x273F will be evicted when	1
0x273F into one of the	1
0x273F would still be in	1
135 The if statement in	1
135 show various ways of	1
135 14.4 Integer multiplication .............................................................................................	1
looks like this: // Example	3
{double a; double b;}; S1	2
{double d; unsigned int u[2]}	1
implementing a matrix in STL	1
implementing a compile-time polymorphism, which	1
implementing polymorphic classes. Each instance	1
int. A short int is	1
int. Therefore, it is advantageous	1
int. Reinterpret cast The reinterpret_cast	1
space, if necessary, by using	1
space, as explained in example	1
space, even when it has	1
skip the following explanation if	1
skip this section if you	1
skip large expressions when not	1
137 about division). The object	1
137 errors must be added.	1
137 14.6 Floating point division	1
132 Table lookup cannot be	1
132 14.2 Bounds checking ..................................................................................................	1
132 14.1 Use lookup tables	1
position- independent code more efficient.	1
position- independent code. The name	1
position- independent code, see below.	1
Index out of range"; }	1
Index out of range"; 134	1
Index out of range. The	1
Specifies a function to be	1
Specifies that pointer aliasing does	1
Specifies alignment of arrays and	1
residual error is lower than	1
residual error and compare it	1
residual error for each iteration	1
operations, and to mix mathematical	1
operations, as explained on page	1
operations, see page 105. 8.7	1
C++. This typically happens if	1
C++. Critical device drivers may	1
C++. Yet, D is compiled	1
input/output than the specific event	1
input/output operations. It can be	1
input/output Graphics and sound processing	1
packages and who is still	1
packages faster and smaller. This	1
packages include a profiler that	1
operations: // Example 14.13a int	1
operations: // Example 7.41b a.x	1
operations: __m128i a = _mm_or_si128(c2,	1
Explicit CPU dispatching works only	1
Explicit cache control .............................................................................................. 99	1
Explicit cache control Microprocessors with	1
purpose. The clumsy AND-OR construction	1
purpose. It is possible to	1
purpose. It just happened to	1
reciprocal_divisor; y2 = a2 *	1
reciprocal_divisor; 14.7 Don't mix float	1
reciprocal_divisor; reciprocal_divisor = 1. /	1
compilation. The program code is	1
compilation. The following example illustrates	1
compilation. Some early implementations of	1
(number of sets). Here, /	1
(number of sets) (line size)	1
(number of ways). If a	1
endian systems you have to	1
endian storage (e.g. PowerPC). We	1
endian storage. If you access	1
allocates the required amount of	1
allocates memory on the stack	1
allocates one memory block for	1
136 and 137, respectively. Increment	1
136 ... for (i =	1
136 14.5 Integer division...................................................................................................... 137	1
reveals a funda- mentally flawed	1
reveals that similar solutions may	1
reveals three things that can	1
filled up if the threads	1
filled up, which happens quite	1
filled up. This is a	1
(requires a microprocessor that supports	1
(requires no specific option) better:	1
(requires binutils version 2.20, glibc	1
offer the choice between optimizing	1
offer the possibility of compiling	1
offer profile-guided optimization. This works	1
Bitfields may be useful for	1
Bitfields Bitfields may be useful	1
Bitfields ................................................................................................................... 56 7.26 Overloaded	1
At the diagonal there is	1
At this time, any processor	1
At least, it can be	1
up-to-date function library that has	1
up-to-date version. The CPU dispatcher	1
up-to-date solution. The compiler is	1
leaving the AVX part. If	2
leaving their workplace and the	1
Inheritance from multiple parent classes	1
Inheritance An object of a	1
Inheritance .............................................................................................................. 54 7.23 Constructors	1
153 for further discussion of	1
153 16.1 Using performance monitor	1
153 spends most of its	1
degree of optimization is requested.	1
degree of randomness in order	1
degree polynomial of the loop	1
_mm_storeu_si128((__m128i *)d, x); } //	1
_mm_storeu_si128((__m128i *)d, x); } void	1
_mm_storeu_si128((__m128i *)d, x);} void SelectAddMul(short	1
automatically, and only the Gnu	1
automatically, but as long as	1
automatically, although it appears to	1
sequentially. The opposite order of	1
sequentially. It works somewhat less	1
sequentially. Some applications (e.g. in	1
Enums are exactly as efficient	1
Enums An enum is simply	1
Enums ...................................................................................................................... 33 7.5 Booleans...................................................................................................................	1
Algebraic reductions Most compilers can	1
Algebraic reduction is a complicated	1
Algebraic reduction Most compilers can	1
A, B and C are	1
A, B, C; x.abc =	1
A, B, C; x.a =	1
operands. The advantages of using	1
operands. You cannot swap the	1
operands. Nevertheless, the bitwise operators	1
i<100; i++) sum += a[i];	1
i<100; i++,i2+=2.0f)a[i]=i2; 41 Float to	1
i<100; i++)a[i]=2*i; The conversion of	1
0.11 memcpy 16kB unaligned op.	1
0.11 0.18 0.18 0.18 0.11	1
0.11 1.21 0.57 0.44 0.12	1
0.12 memcpy 16kB aligned operands	1
0.12 0.18 0.12 0.11 0.18	1
0.12 0.11 0.18 0.18 0.18	1
nearest integer int n; #if	1
nearest element to x?" or	1
nearest integer. If two integers	1
To use multiple CPUs or	1
To prevent this kind of	1
To explain the difference, let's	1
x-- x x-- x x--	1
x-- x x-- x ---	1
x-- x --- - -----	1
language, all conversions from floating	1
language, such as VHDL or	1
language, e.g. C++, and a	1
145 and 119 for more	1
145 SSE2 instruction set is	1
145 14.11 Static versus dynamic	1
140 a = b *	1
140 for further discussion. Integer	1
140 14.8 Conversions between floating	1
141 for details about rounding.	1
141 #include <emmintrin.h> static inline	1
141 14.9 Using integer operations	1
RISC and CISC processors, between	1
RISC in situations where code	1
RISC cores, vector processing instructions,	1
Consider the time it takes	1
Consider the following example, which	1
Consider running the services only	1
text or input data. A	1
text strings in the old	1
text strings in classes like	1
Object Windows Library (OWL). Several	1
Object files generated by the	1
Object oriented programming can be	1
14.10 int a, b, c;	1
14.10 Mathematical functions The most	1
14.10 Mathematical functions ....................................................................................... 145	1
14.11 int a, b, c;	1
14.11 Static versus dynamic libraries	1
14.11 Static versus dynamic libraries............................................................................	1
<int N> class powN<true,N> {	1
<int N> static inline double	1
<int m> int MultiplyBy (int	1
back. The method of induction	1
back. The so-called nontemporal write	1
back. Thus, we will calculate	1
8.4 double a = sin(0.8);	1
8.4 Obstacles to optimization by	2
8.7 int SomeFunction (int a,	1
8.7 Checking what the compiler	2
listing to see if the	1
listing reveals three things that	1
listing /FA -S - masm=intel	1
twice for handling a full	1
twice because the macro is	1
twice because both the pointers	1
Pascal and Fortran are based	1
Pascal has many of the	1
Pascal used an intermediate code	1
expected. The 64 64 matrix	1
expected. I believe that the	1
expected. Use square blocking: int	1
14.4 Integer multiplication Integer multiplication	1
14.4 Integer multiplication ............................................................................................. 136	1
14.4 511 511 2040 38.7	1
Vec16s when compiling for AVX2,	1
Vec16s a, b, c; //	1
Vec16s Vec16us Vec8i Vec8ui Vec4q	1
Simple function parameters are transferred	1
Simple integer operations such as	1
Simple member pointers /vms Fastcall	1
Manual", Volume 1 - 5.	1
Manual", Volume 1, 2A, 2B,	1
Manual", Volume 2A and 2B.	1
leave the last 8 columns	1
leave a background process running	1
leave them enabled (there is	1
solved by making the most	1
solved by making sure that	1
solved this problem by defining	1
supplied in the library www.agner.org/optimize/asmlib.zip.	1
supplied in Intel's Math Kernel	1
supplied with Intel's compilers and	1
Available from Intel and Microsoft	1
Available from www.agner.org/optimize/asmlib.zip. Currently includes	1
Available protocols and standardized file	1
translated to the instruction xor	1
translated to just one or	1
translated into machine code and	1
Linux: long int unsigned char	1
Linux: unsigned long int 64	1
Linux: -ffunction-sections) which allows the	1
With the high complexity of	1
With a long vector library,	1
With a short vector library,	1
Has not been updated since	1
Has an IDE with many	1
Has many good optimization options.	1
overriding of public functions and	1
overriding Intel's CPU dispatcher. See	2
Opteron K8 0.24 0.25 0.24	1
Opteron K8 1.09 1.25 1.61	1
Opteron K8 0.38 0.44 0.40	1
systems". The parameters a and	1
systems". For this reason, you	1
systems". 7.16 Function return types	1
correct or if the calculation	1
correct result because the overflow	1
correct child class name as	1
caching. This problem can be	1
caching. Smaller microcontrollers have no	1
caching. 3.14 Context switches A	1
overflow: // Example 7.25 unsigned	1
overflow: a[i] = log(b[i]) +	1
overflow: _controlfp_s(&dummy, 0, _EM_OVERFLOW); //	1
scans a string of bytes	1
scans all files on access.	2
way: // Example 7.40b union	1
way: There are two or	1
way: bool a, b, c,	1
Sometimes the compiler does quite	1
Sometimes it is necessary to	1
Sometimes it takes hours to	1
-fno-builtin to get library versions	1
-fno-builtin Gnu 32-bit Mac Intel	1
-fno-builtin Gnu 32-bit -fno-builtin Gnu	1
justify the method. A longer	1
justify a possible minor increase	1
justify such a complicated code	1
contrary, the code becomes simpler	1
contrary, you should by all	1
contrary, each thread may run	1
conventions. The dot in the	1
conventions. Optimizes reasonably well. Codeplay	1
conventions. FreeBSD and Open BSD	1
initialization routine that is called	1
initialization routine that loads the	1
initialization routine sets a function	1
Internet at regular time intervals.	1
Internet where you can get	1
Internet forums Several internet forums	1
cover the worst case situation	2
cover graphics processors. 5 Programmable	1
Constructors and destructors A constructor	1
Constructors and destructors .................................................................................. 55	1
Constructors are therefore as efficient	1
PC's and mainframes, and between	1
PC's in a network may	1
PC's had an interpreter for	1
7.21 int i; short int	1
7.21 Runtime type identification (RTTI)	2
delays in the program flow	1
delays if the distance between	1
delays execution by causing return	1
a); } } The same	1
a); } } The resulting	1
a); } 111 } You	1
c[i] are so big that	1
c[i] are too big before	1
c[i] = temp * temp;	1
cleaning up and calling any	1
cleaning up because it has	1
cleaning up spaces that are	1
way, the first processors that	1
way, then many times the	1
way, etc. The worst case	1
Big arrays should be declared	1
Big runtime frameworks. The .NET	1
Big supercomputers with massively parallel	1
ZMM registers The first processors	1
ZMM registers by 64, but	1
ZMM registers .......................................................... 107 12.3	1
coefficients is calculated at compile	1
coefficients // Table // Loop	1
coefficients double Table[100]; int x;	1
DOS and Windows 3.x. These	1
DOS and 16-bit Windows, allow	1
DOS compilers). The representation of	1
-fpie because the linker makes	1
-fpie option is less useful	1
-fpie instead of -fpic. This	1
labels is simply predicted to	1
labels that have values far	1
labels follow a sequence where	1
6, 9 and 13 objects,	1
6, 24, 120, 720, 5040,	2
ret returns from the function.	1
ret ALIGN ; mark_end; This	1
ret ALIGN ?Func@@YAXQAHAAH@Z ENDP +	1
Signed and unsigned integers int	1
Signed / unsigned conversion //	1
Signed versus unsigned integers In	1
logarithms and trigonometric functions. The	1
logarithms in the general case,	1
logarithms take a long time	1
stored. The storage principles are	1
stored. This makes the use	1
stored. All identical constants in	1
manner. This applies to reading	1
manner. It is usually much	1
manner. 3.4 Automatic updates Many	1
Today, the 8 most popular	1
Today, the choice of hardware	1
Today, it is not uncommon	1
easiest and the most reliable	1
easiest way to make thread-specific	1
easiest way to overcome the	1
pop ebx restores the value	1
pop ebx. 9 Optimizing memory	1
pop ret ALIGN ?Func@@YAXQAHAAH@Z ENDP	1
3.5 will be stored in	1
3.5 Program loading ....................................................................................................... 19	1
3.5 Program loading Often, it	1
-S or /Fa for assembly	1
-S - masm=intel /FA -S	1
-S Generate map file /Fm	1
inlined. An alternative solution is	1
inlined. But beware that macro	1
inlined. (In the above example,	1
cmp eax, 100 / jl	1
cmp jl $B1$3: pop ret	1
cmp ja $B2$3: ret ALIGN	1
flow and the number of	1
flow and algorithms in the	1
flow at inconvenient times when	1
directives. This is sure to	1
directives. For example use #if	1
directives. OpenMP is a standard	1
deallocated. The program logic may	1
deallocated. Failure to do so	2
(128 or 256 bytes) on	1
(128 bit float vectors) /arch:SSE	1
(128 vectors of inte- ger	1
Programmers that have tested the	1
Programmers very often underestimate this	1
Programmers do, however, often write	1
focus the optimization efforts on	1
focus is on mathematical applications	1
focus on the costs of	1
definition. This will prevent the	1
definition. This tells the compiler	1
definition. Inlining a function is	1
track of the performance during	1
track of when they are	1
track backwards though the 61	1
condition. In general, the out-of-order	1
condition. Replacing two comparisons by	1
condition. Things that may need	1
s3 can be combined into	1
s3 = 0, sum; for	1
s3 += a[i+3]; } sum	1
s2 and s3 can be	1
s2 = 0, s3 =	1
s2 += a[i+2]; s3 +=	1
contemporary operating systems are not	1
contemporary processors. The cache line	1
contemporary 106 CPUs if the	1
66 float a, b; a	1
66 8.1 How compilers optimize	1
66 8.2 Comparison of different	1
probably the most common cause	1
probably be improved by inlining	1
probably without information about function	1
longjmp is used for jumping	1
longjmp in time-critical code. 7.32	1
longjmp if possible. Don't rely	1
2exponent 127 1 fraction 2	1
2exponent 16383 one fraction 2	1
2exponent 1023 1 fraction 2	1
leads to the appropriate version	1
leads to a usability problem	1
leads to suboptimal code. Intrinsic	1
Alignd ( short int bb[size]	1
Alignd ( short int cc[size]	1
Alignd ( short int aa[size]	1
improving the code. // Example	1
improving code that contains integer	1
improving performance. Stefan Goedecker and	1
sizes. The results of my	1
sizes. For example: // Example	1
sizes. Fortunately, the solution to	1
....................................................................................................... 19 3.6 Dynamic linking	1
....................................................................................................... 21 3.10 Graphics .................................................................................................................	1
....................................................................................................... 150 16 Testing speed..............................................................................................................	1
holds the index, i. This	1
holds a memory address. Pointer	1
holds a precision of approximately	1
competing for the same resources.	1
competing brands of microprocessors are	1
competing product is Borland's now	1
questions to me. You will	1
questions if you cannot find	1
questions from everybody. So please	1
register, not even temporarily. This	1
register, do an addition with	1
register, add the constant vector	1
etc., and if an exception	1
etc., can be implemented in	1
etc., as is commonly the	1
ReadTSC as a library function	1
ReadTSC function. 154 // Print	1
ReadTSC listed below in example	1
with: // Example 14.12b int	1
with: // Example 14.13b int	1
with: // Example 7.38b. Alternative	1
kernel in the so-called commpage.	1
kernel version 2.6.30 and later.	1
kernel code" in manual 5:	1
CPUs"). This is one of	1
CPUs"). This can be avoided	1
CPUs"). Const cast The const_cast	1
j; int order(int x); 136	1
j; float x; for (i	1
j; ... for (i =	1
natural order and there are	1
natural parallelism. The gain depends	1
natural ordering? If you need	1
Examples are provided in an	1
Examples are image processing, sound	1
Examples include JavaScript, PHP, ASP	1
(iset >= 2) SelectAddMul_pointer =	1
(iset >= 8) SelectAddMul_pointer =	1
(iset >= 5) SelectAddMul_pointer =	1
F2 and call the std::unexpected()	1
F2 that can possibly throw	1
F2 actually throws an exception.	1
moving the mouse. The .NET	1
moving the mouse. This task	1
moving each object separately if	1
9.6b. The MOVNTQ instruction cannot	1
9.6b. The MOVNTQ instruction must	1
9.6b. #include "xmmintrin.h" // header	1
-O3 or (requires no specific	1
-O3 or -Ofast /O3 -O3	1
-O3 Interprocedural optimization /Og Whole	1
unusual for the installation process	1
unusual for the reinstallation work	1
unusual that a user has	1
misses, branch mispredictions, floating point	1
misses, branch mispredictions, etc. These	1
misses, branch misprediction, or long	1
Divide by constant = multiply	3
sorted list is the most	1
sorted list can be very	1
sorted list or a binary	1
efficiency, then you may also	1
efficiency, platform independence, and easy	1
efficiency, portability and development time.	1
same. The maximum loop count	1
same. This is called register	1
same. If the template parameters	1
(STL) is a useful source	1
(STL) if the full generality	1
(STL) which comes with most	1
rid of the branch. It	1
rid of the GOT and	1
rid of all the problems	1
ms for background jobs. The	1
ms for foreground jobs and	1
ms by selecting optimize performance	1
arrays, a and b, and	1
arrays, it may be preferred	1
arrays, then it is almost	1
matrix[r][c] is swapped with element	1
matrix[r][c] below the diagonal is	1
matrix[r][c] below the diagonal are	1
issue to catching hardware exceptions.	1
issue an error message and	1
issue because an optimizing compiler	1
solve this problem is to	1
solve this problem. These instructions	1
solve all the problems associated	1
since the CPU was started.	1
since we are assuming that	1
since 2004. Can do automatic	1
beyond the scope of this	3
readable and not easily ported	1
readable when you are using	1
readable but unfortunately it prevents	1
infinity or NAN (not a	1
infinity or NAN (Not A	1
infinity or NAN. Avoiding the	1
bookkeeping is needed: // Example	1
bookkeeping in order to know	1
bookkeeping depends very much on	1
formula in each case. Inlined	1
formula into a single result.	1
formula a[i] = log(b[i]) +	1
technical problems or performance problems.	1
technical details of instruction timing,	1
technical problems. Some common problems	1
instr. set AVX instr. set	1
instr. set Automatic CPU dispatch	1
instr. set SSE4.1 instr. set	1
specified on a command line	1
specified instruction set. The examples	1
specified types (See Sutter: A	1
organizing the data as an	1
organizing the data. A complete	1
organizing data into classes or	1
9.5a on a Pentium 4	1
9.5a const int SIZE =	1
9.5a goes from the leftmost	1
false, a || true =	1
false, a || !a =	1
false, then the second operand	1
open the possibility for other	1
open source compiler for 32-bit	1
open source. It comes with	1
decomposition of the data. Use	1
decomposition and data decomposition. Functional	1
decomposition here means that different	1
measuring the time it takes	1
measuring the overall performance of	1
measuring performance by unit-testing is	1
File access Reading or writing	1
File input/output Graphics and sound	1
File access................................................................................................................ 20 3.8 System	1
negligible when the number of	1
negligible because there is no	1
negligible contribution to the total	1
took several minutes to write	1
took advantage of the fact	1
took 50 clock cycles per	1
on. Most IDE's (Integrated Development	1
on. Replace or bypass the	1
on. 7.31 Other cases of	1
Hyperthreading is Intel's term for	1
Hyperthreading Some versions of Intel	1
Hyperthreading ..................................................................................................... 103 11 Out	1
30 // f is nonzero	1
30 ms for foreground jobs	1
30 Overflow behaves differently on	1
initially points to the dispatcher	1
initially points to the dispatcher.	1
initially points to a dispatcher.	1
occur. The reason why this	1
occur. In the case of	1
occur. See page 78 for	1
Strings can be manipulated with	1
Strings Text strings typically have	1
Strings ...................................................................................................................... 96 9.9 Access	1
Preprocessing directives ......................................................................................... 65 7.33	1
Preprocessing directives Preprocessing directives (everything	1
Preprocessing directives (everything that begins	1
utilize the multiple processor cores.	1
utilize the computational power of	1
utilize systems with multiple CPU	1
(0,0,0,0,0,0,0,0) __m128i zero = _mm_set1_epi16(0);	2
(0,0,0,0,0,0,0,0) Is16vec8 zero(0,0,0,0,0,0,0,0); // Make	1
38 // Example 7.15a. Array	1
38 7.11 Type conversions.................................................................................................... 40	1
38 7.10 Arrays ..................................................................................................................... 38	1
reference. This will provoke an	1
reference. A const reference makes	1
reference. Registers are a scarce	1
FUNCNAME SelectAddMul_SSE41 #elif INSTRSET ==	1
FUNCNAME SelectAddMul_SSE2 #elif INSTRSET ==	1
FUNCNAME SelectAddMul_AVX2 #endif // SSE2	1
history of that branch and	1
history of CPU development, each	1
history of programming languages and	1
CChild2 * p2; p2 =	1
CChild2 : public CParent<CChild2> {	1
CChild2 Object2; CChild1 * p1;	1
bit: // Example 14.23 union	1
bit: // Example 14.25 union	1
bit: absvalue = a[i].u[1] *	1
forums and newsgroups contain useful	1
forums on the Internet where	1
forums Several internet forums and	1
addressing of data. The code	1
addressing of data. The need	1
addressing of data. This makes	1
1024; int a[size], b[size]; //	1
1024; int a[size], b[size], i;	1
1024; struct Sab {int a;	1
C#, Visual Basic .NET and	1
C#, Visual Basic, etc. But	1
C#, managed C++, and other	1
allocating more space 91 step	1
allocating when a memory block	1
allocating piecewise or re- allocating	1
a+b is calculated first, then	1
a+b = b+a a*b =	1
a+b = b+a, a*b =	1
taken into account when deciding	2
taken into account when choosing	1
microprocessor. These algorithms are described	1
microprocessor. Integer division is faster	1
microprocessor. Multiplication takes 4 -	1
argument is that the order	1
argument to be an expression	1
argument does not apply to	1
Func1 and Func2 were in	1
Func1 when compiling module2.cpp. The	1
Func1 (int a[], int *	1
Unix-like systems use position-independent code	1
Unix-like systems. Mac systems often	1
Unix-like platforms. Clang The Clang	1
----- - x-xxx - xx(-)x-	1
----- x---- x---- ----- ~(~a)=a	1
----- ~(~a)=a x-xxxxx-- (a&b)|(a&c) =	1
2.5 may be changed to	1
2.5 Choice of compiler There	1
2.5 Choice of compiler ....................................................................................................	1
read-only can be shared between	1
read-only data sections can be	1
read-only data. The disadvantage is	1
well-structured code and for fast	1
well-structured program that is easier	1
well-structured C++ program are in	1
represent the "worst case" and	1
represent a known CPU model	1
represent a monotonically increasing function	1
elsewhere. In this example, we	1
elsewhere. Faster than most other	1
elsewhere. 13.5 Implementation The CPU	1
micro-op cache (e.g. Sandy Bridge)	1
micro-op cache. The Core2 processor	1
micro-op cache. Compilers will usually	1
best. Some common function libraries	1
best. These cases are usually	1
best. 3.11 Other system resources	1
returning a composite object, you	1
returning a null reference. This	1
returning from the function in	1
Long double precision is not	1
Long double precision takes only	1
Long dependency chains in the	1
r1; c2 < r2; c2++)	1
r1; c1 += TILESIZE) {	1
r1; r2 < r1+TILESIZE; r2++)	1
CPU- specific functions have names	1
CPU- specific optimizations in precompiled	1
CPU- specific profiler. For Intel	1
top of loop ; a[i]	1
top of loop ; unused	1
top of loop ; compute	1
decide to do some measurements	1
decide which programming language is	1
decide how advantageous vectorization is.	1
other. This is the reason	1
other. See page 51 for	1
other. See page 88 for	1
brackets in which the variable	1
brackets mean use the value	1
brackets index, just as a	1
2004. No differences were observed	1
2004. Open Watcom C/C++ v.	1
2004. Can do automatic vectorization.	1
odd and you unroll by	1
odd number then we would	1
odd here. The address of	1
7.7 unsigned int i; const	1
7.7 Function pointers ...................................................................................................... 37	1
7.7 Function pointers Calling a	1
Documentation of the OpenMP directives	1
Documentation for details. Note that	1
Documentation License shall automatically come	1
prone. The vectorized code should	1
prone. A discussion of different	1
prone. All these problems are	1
compile- time if and compile-time	1
compile- time loops or compile-time	1
compile- time, but not the	1
Global or static storage Variables	1
Global variables are stored in	1
Global variables may be needed	1
lookups for local references. If	1
lookups are needed even when	1
lookups Max. number of elements	1
Whole program optimization cannot be	1
Whole program optimization Integer algebra	1
Whole program optimization /GL --combine	1
a*b = b*a - n.a.	1
a*b = b*a (a+b)+c=a+(b+c) a+b+c=c+b+a	1
a*b - n.a. !(a <	1
linker. The delay on lazy	1
linker. The map file tells	1
linker. Both code cache use	1
security. b & 1 is	1
security. There are no checks	1
security. Standard C++ imple- mentations	1
lookup. For example: // Example	1
lookup. These instructions are summarized	1
lookup. Lookup tables are particular	1
78 for an explanation. Note	1
78 for an explanation. (The	1
78 Therefore, it is necessary	1
handled in a systematic manner	1
handled at half speed or	1
handled separately: for (r2 =	1
a[], int * p) {	1
a[], int & r) {	2
implicitly when copying a large	1
implicitly when calculating the address	1
implicitly converting a to double	1
terminating a thread. You cannot	1
terminating zero and to make	2
_WIN32 n.a. MS compiler Windows	1
_WIN32 Linux platform n.a. __unix__	1
_WIN32 _WIN32 Linux platform n.a.	1
(2n / b) is calculated	1
(2n / b) etc. at	1
(2n / b) >> n	1
measures the number of clock	1
measures the speed of each	1
measures not only the time	1
multiplications. The following example shows	1
multiplications. How was it possible	1
multiplications. Subtractions use the same	1
intensive may very well spend	1
intensive program is achieved when	1
intensive applications. Some systems have	1
moved with a single call	1
moved out of the loop.	1
moved out of a loop	1
ReadTSC() - time1; // This	1
ReadTSC() { int dummy[4]; volatile	1
ReadTSC() from library asmlib.. //	1
valid. For example, when a	1
valid. For example: // Example	1
valid. Re-interpreting the type of	1
b[size]; // set a to	2
b[size]; // ... for (int	1
Not all code has a	1
Not optimized for SSE2 and	1
Not optimized as good as	1
none of the compilers I	1
none of the compilers reduced	1
none of the time-consumers mentioned	1
"what is the nearest element	1
"what works best on processors	1
"what works best on processor	1
Comparing an integer to zero	1
Comparing two pointers requires only	1
Comparing performance of different function	1
instructions, but these are hardly	1
instructions, multiple cores, and a	1
instructions, where a hardware definition	1
Microprocessor documentation Intel: "IA-32 Intel	1
Microprocessor designers have gone to	1
Microprocessor producers keep adding new	1
metaprogramming. The next example shows	1
metaprogramming. Don't panic if you	1
metaprogramming. None of the compilers	1
Size of each table element	1
Size of each element, bits	2
metaprogramming, as explained at page	1
metaprogramming, but this method is	1
metaprogramming, loops are implemented as	1
bypass the CPU detection function	1
bypass the virtual table lookup	1
bypass the check for CPU	1
output. The assembly output option	1
output. The optimized code looks	1
output. On most compilers you	1
........................................................................................... 5 2.1 Choice of	1
........................................................................................... 6 2.3 Choice of	1
........................................................................................... 139 14.7 Don't mix	1
numerically largest element in a	1
numerically largest element in an	1
numerically largest element (approximately): if	1
expression. The size conversion often	1
expression. Example 12.4b shows how	1
expression. Assume, for example, that	1
.......................................................................................................... 120 13 Making critical	1
.......................................................................................................... 164 1 Introduction This	1
.......................................................................................................... 38 7.10 Arrays .....................................................................................................................	1
InstructionSet() function is available in	1
InstructionSet() #include "asmlib.h" // Define	1
InstructionSet() #include "asmlib.h" // Lowest	1
Eliminate branches Remove branch that	1
Eliminate jumps Eliminate branches Remove	1
Eliminate jumps Jumps can be	1
backup copy of every intermediate	1
backup copying without effectively preventing	1
backup features, and current operating	1
13.6 CPU dispatching in Gnu	2
13.6 80.9 512 512 378.7	1
Get supported instruction set, using	2
Get upper 32 bits of	1
throw an exception then F1	1
throw any exception so that	1
throw exceptions throw() throw() throw()	1
More complicated cases cannot be	1
More examples of container classes	1
More details about how caches	1
---x----- x - x x	1
---x----- x--xx---- (a&&b)||(a&&!b)=a x--xx---- (a&&b)	1
---x----- x---x---x x-xxx---- a*b*c=a*(b*c) a+b+c+d	1
_mm_loadu_si128((__m128i const*)p); } // Function	2
_mm_loadu_si128((__m128i const*)p);} // Function to	1
Before you start to optimize	1
Before you start to code,	1
Before starting a new software	1
Applications that are not computationally	1
Applications that use large amounts	1
Applications that generate floating point	1
25 clock cycles, depending on	1
25 7 The efficiency of	1
25 Since most development methods	1
AVX-512 instruction set and ZMM	2
AVX-512 instruction set are expected	1
23 5 Choosing the optimal	1
23 software. This is annoying	1
23 , doublevalue ( 1)sign	1
evict the cache line that	1
evict number 1. Number 18	1
evict number 2, etc. This	1
Copying the table takes extra	1
Copying or clearing arrays It	1
Copying constant data from static	1
(x = 0; x <	2
(x = 2.0; x <=	1
being out of range is	1
being initialized. The dispatcher function	1
being said, I must warn	1
sum, then the first result	1
sum, then f is added	1
sum, initialize to x^0/0! //	1
unrolled to avoid the loop	1
unrolled loop takes up more	1
unrolled double xpow10(double x) {	1
slow. If the granularity is	1
slow. Today, the 8 most	1
slow. Value of a will	1
StoreVector(aa + i, a); }	3
7.11 bool a; float x,	1
7.11 Type conversions The C++	1
7.11 Type conversions.................................................................................................... 40 7.12	1
market the application program. Add	1
market is developing so fast	1
market for many years to	1
vectors, and these operations are	1
vectors, as is often seen,	1
vectors, but the asmlib function	1
resource. The C++ way of	1
resource. The CISC instruction set	1
resource. Do not use a	1
Architecture Software Developers Manual", Volume	2
Architecture Programmers Manual", Volume 1	1
7.12 void FuncA (int *	1
7.12 Branches and switch statements	1
7.12 Branches and switch statements.............................................................................	1
limited. There are approximately six	1
limited. Example: // Example 8.7	1
limited. Dynamic memory allocation can	1
11.3 is independent of the	1
11.3 const int size =	1
11.3 even without the register	1
typedef int CriticalFunctionType(int parm1, int	1
typedef void FuncType(short int aa[],	1
typedef instead of a template	1
0x2700 to 0x273F will be	1
0x2700 to 0x273F into one	1
0x2700 to 0x273F would still	1
Replace or bypass the CPU	1
Replace macro by template template	1
Replace with: // Example 7.38b.	1
Instead, the following work-around can	1
Instead, you can make a	1
Instead, I will make a	1
frameworks, rather than isolating a	1
frameworks, intermediate code, interpreters, just-in-time	1
frameworks, interpreters, just-in-time compilers, system	1
*(p++) is more efficient than	1
*(p++) |= 0x20; If the	1
*(p++) |= 0x20; 46 A	1
(Intel CPU only) -O3 or	1
(Intel CPU only) (Intel CPU	1
(Intel Atom). The following example	1
nearby address again before the	1
nearby parts of the code	1
nearby branches. The algorithms used	1
fragmented. This makes data caching	1
fragmented. This garbage collection may	1
fragmented. An alternative is to	1
truncation. The missing functions can	1
truncation. This is approximately three	1
truncation. Efficient conversion from float	1
Different compilers behave differently because	1
Different kinds of variable storage	1
Different kinds of variable storage.............................................................................	1
logarithm of each factor rather	1
logarithm would be re-calculated every	1
logarithm again, but it would	1
Day for signifying one of	1
Day == Wednesday || Day	1
Day == Friday) { DoThisThreeTimesAWeek();	1
ported to multiple operating systems.	1
ported to systems with big-endian	1
ported to another platform. 14.8	1
inline. This may enable the	1
inline. This will enable the	1
inline. Replacing a function with	1
big. The compiler is more	1
big. In the above example,	1
big. 7.14 Functions Function calls	1
deallocation of memory takes much	1
deallocation of big memory blocks	1
deallocation and garbage collection takes	1
(PLT) and a table of	1
(PLT) in the following way:	1
(PLT) that is initialized when	1
7.22 short int a[100]; int	1
7.22 Inheritance An object of	1
7.22 Inheritance .............................................................................................................. 54 7.23	1
Context switches are more frequent	1
Context switches A context switch	1
Context switches..................................................................................................... 22 3.15 Dependency	1
7.23 int i; short int	1
7.23 Constructors and destructors A	1
7.23 Constructors and destructors ..................................................................................	1
services that run in the	1
services only when activated by	1
services under advanced system performance	1
7.20 int i; if ((unsigned	1
7.20 Virtual member functions Virtual	1
7.20 Virtual member functions ........................................................................................	1
extremely complicated and clumsy, as	1
extremely costly to many users.	1
extremely inefficient, (4) get a	1
kb = 8192 bytes, 4	1
kb size with a line	1
kb / 8 = 64	1
joining the operations: // Example	1
joining a and b in	1
joining identical pieces of code.	1
decrement operators The pre-increment operator	1
decrement operators on integer variables.	1
decrement operators. 7.7 Function pointers	1
0x1C. If the program afterwards	1
0x1C. There are only four	1
0x1C. Reading or writing a	1
free. This can be useful	1
free. These operators and functions	1
free. Visual Studio can build	1
Check that all code versions	1
Check that index is not	1
Check if level-2 cache contentions	1
double, then the code will	1
double, then sizeof(S1) would be	1
double, bool, enum as well	1
periodic pattern can also be	1
periodic pattern can be, for	1
periodic pattern or if it	1
7.27 float x; *(int*)&x |=	1
7.27 Overloaded operators An overloaded	1
7.27 Overloaded operators ............................................................................................. 56	1
7.24 float a; double b;	1
7.24 Unions A union is	1
7.24 Unions .................................................................................................................... 55 7.25	1
product is one that saves	1
product is Borland's now discontinued	1
product makes sure that no	1
7.25 unsigned int u; double	1
7.25 Bitfields Bitfields may be	1
7.25 Bitfields ................................................................................................................... 56 7.26	1
7.28 class c1 { const	1
7.28 Templates A template is	1
7.28 Templates...............................................................................................................57 7.29 Threads ..................................................................................................................	1
references, and stack entries use	1
references, which can be stored	1
references, 'this' pointer, common subexpressions,	1
CPUs" for an explanation of	2
CPUs" gives more details on	1
experience to get used to	1
experience before trying the techniques	1
experience unacceptably long response times	1
determine the worst-case maximum repeat	1
determine if the processor has	1
determine whether it is advantageous	1
<typename T, unsigned int N>	1
<typename T> static inline T	1
<typename MyChild> class CParent :	1
Generate optimization report /Qopt-report -opt-report	1
Generate assembly listing /FA -S	1
Generate map file /Fm Generate	1
certainly a very inefficient solution.	1
certainly more convenient to rely	1
certainly something that can steal	1
Devirtualization class C0 { public:	1
Devirtualization An optimizing compiler can	1
Devirtualization ---x----- x - x	1
pivot in a Gauss elimination.	1
pivot element. The integer comparison	1
pivot search: // Example 14.30	1
__declspec( align(16)) __attribute(( aligned(16))) Assume	1
__declspec( align(16)) __attribute(( aligned(16))) __declspec(	1
__declspec( noalias) __restrict #pragma ivdep	1
mispredictions if the critical part	1
mispredictions by making the data	1
mispredictions (see page 43). The	1
a[100], b; for (i =	1
a[100], b, temp; temp =	1
a[100], temp; temp = 3;	1
allocations is limited. Dynamic memory	1
allocations of large memory blocks,	1
allocations of sizes 1, 2,	1
necessary, to fit the actual	1
necessary, by using the smallest	1
necessary, each compiled for the	1
9.4 const int NUMROWS =	1
9.4 Variables that are used	2
float. The type __m128d defines	1
float. (Both use 32 bits	1
float. Similar operations on all	1
1.0f;} The compiler may replace	1
1.0f;} The advantages of function	1
1.0f;} 66 float a, b;	1
indeed a very contrived example,	1
indeed of the specified types	1
indeed vectorized as intended (see	1
9.1 show that it takes	1
9.1 Caching of code and	2
(not a number). Different compilers	1
(not member of the same	1
(not up to date): Microsoft	1
built-in code is not optimal.	1
built-in code instead of the	1
built-in test feature called performance	1
n. The constant (2n /	1
n. You can divide by	1
n. But not if the	1
complete code examples for these	1
complete redesign of the program,	1
complete redesign of a program	1
(x) x x - x	1
(x) x (x) x-xx--xx- x--x-----	1
(x) x-xx--xx- x--x----- --xx----- x-xxx---x	1
ecx, 1 eax, 8 edx,	1
ecx, DWORD PTR [esp+8] eax,	1
ecx, edx, DWORD PTR [esp+4]	1
modified. This can be quite	1
modified. This can cause the	1
modified. Unlike a pointer or	1
folding and constant propagation is	1
folding and constant propagation An	1
folding - n.a. a+b =	1
expects a GOT entry. You	1
expects an immediate response to	1
expects immediate responses to simple	1
Call to virtual function }	1
Call critical function a =	1
Call critical function through function	1
joined into a single branch	1
joined into one if the	1
joined together in order to	1
classes, as explained in the	1
classes, such as string or	1
classes, templates or modules with	1
compute a / b as	1
compute (FuncRow(i)*columns + FuncCol(i)) *	1
compute i/2 in ebx ;	1
interpreting the same bits in	1
interpreting the same bits differently.	1
interpreting or compiling the intermediate	1
LIBM libraries are not well	1
LIBM library. Only available for	1
LIBM Library amd_vrs4_expf amd_vrd2_exp Agner's	1
accesses to functions and public	1
accesses data members with a	1
accesses b through a pointer	1
$B1$2 is the loop condition	1
$B1$2 ebx ; top of	1
$B1$2 label if i <	1
copying. The benefits of a	1
copying. There are several different	1
copying. Security. The vulnerability of	1
Volume 1 - 5. www.amd.com.	1
Volume 1, 2A, 2B, and	1
Volume 2A and 2B. There	1
placed in a separate C	1
placed in separate modules if	1
placed immediately before the loop	1
spot. Use the call stack	1
spot. Sometimes, the best way	1
spot. Repeating the break a	1
variable, for example 32 bits	1
variable, it makes no difference	1
variable, pointer or member function	1
jumping out of a function	1
jumping out of a function.	1
jumping around and less efficient	1
compared to the time it	1
compared to 32 bit systems:	1
compared with the time it	1
3-dimensional vectors RGB image data	1
3-dimensional vectors ....................................................... 120 12.10	1
3-dimensional geometry and other odd-sized	1
x. The compiler is not	1
x. This is only possible	1
x. It is a way	1
a. This operation will then	1
a. You can take advantage	1
a. I don't think that	1
post-increment. The effect is simply	1
post-increment. There are also situations	1
post-increment. For example, in the	1
sufficient to have just two	1
sufficient to make a zip	1
sufficient for less intensive applications.	1
evicted when we read from	1
evicted from the cache between	1
evicted before we need the	1
flags on certain Intel CPUs,	1
flags register into the carry	1
flags stall because the CPU	1
Sum2 and Sum3 in 32-bit	1
Sum2 and Sum3 are doing	1
Sum2 and Sum3. Whether you	1
(2,2,2,2,2,2,2,2) __m128i two = _mm_set1_epi16(2);	2
(2,2,2,2,2,2,2,2) Is16vec8 two(2,2,2,2,2,2,2,2); // Roll	1
[edx] DWORD PTR [eax+400] DWORD	1
[edx] DWORD PTR[ecx+eax*4],ebx eax, 1	1
[edx] adds, not edx but	1
7.14 class c1; int c1::*MemberPointer;	1
7.14 Functions Function calls may	1
7.14 Functions ................................................................................................................ 48 7.15	1
7.16 float list[100]; memset(list, 0,	1
7.16 Function return types The	1
7.16 Function return types ..............................................................................................	1
7.17 const int rows =	1
7.17 Structures and classes Nowadays,	1
7.17 Structures and classes............................................................................................ 51	1
templates. The powN template is	1
templates. Two or more template	1
templates. Ready made container class	1
7.13 struct abc {int a;	1
7.13 Loops The efficiency of	1
7.13 Loops...................................................................................................................... 45 7.14 Functions	1
7.19 int i; float f;	1
7.19 Class member functions (methods)	1
7.19 Class member functions (methods).........................................................................	1
beware of the pitfalls here:	1
beware that these functions have	1
beware that macro parameters are	1
7.18 int FuncRow(int); int FuncCol(int);	1
7.18 Class data members (properties)	2
card for other purposes than	1
card or integrated in the	1
(4) access the data object	1
(4) get a compiler warning	1
elements: #define swapd(x,y) {temp=x; x=y;	2
viable solution in such cases.	1
viable compromise when portability and	1
7.10 Arrays An array is	1
7.10 Arrays ..................................................................................................................... 38 7.11	1
_mm_set1_epi16(2); // Roll out loop	2
templates, as explained on page	1
templates, such as list, set	1
complexity of modern software, it	1
complexity (en.wikipedia.org/wiki/Standard_Template_Library). The objects stored	1
511 511 2040 38.7 512	1
511 2040 38.7 512 512	1
Member pointers In simple cases,	1
Member pointers.......................................................................................................37 7.9 Smart pointers	1
modifying the name in the	1
modifying only half of it,	1
undesired results. Integer operators Integer	1
undesired effects. This effect can	1
7.15 Function parameters Function parameters	1
7.15 Function parameters ............................................................................................... 50	1
symbol interposition is intended to	1
symbol interposition feature that allows	1
problematic because there may be	1
problematic because these time consuming	1
invest in ever more powerful	1
invest more efforts in optimizing	1
memcpy, at least in simple	1
memcpy, memmove, memset, or mathematical	1
Sum3 in 32-bit Windows by	1
Sum3 are doing exactly the	1
Pure functions A pure function	1
Pure function. __attribute__((const)) (Linux only).	1
impossible to work for very	1
impossible with references. You can	1
B1; class B2; class D	1
B1; class B2; 54 class	1
forwarding delay in the CPU	2
storage, but other systems may	1
storage, far pointers, and far	1
107). The Gnu function libraries	1
107). Agner's vector class library	1
64) can improve performance in	1
64) % 32 = 28.	1
static. This makes sure that	1
static. Example: // Example 7.1	1
_M_X64 _M_X64 162 19 Literature	1
_M_X64 162 19 Literature Other	1
CriticalFunction(); ... // Use ReadTSC()	1
CriticalFunction(); timediff[i] = ReadTSC() -	1
x-xxx---x x - x x	1
x-xxx---x x-xxx---x x - x	1
shown in the above table.	1
shown in example 9.6b. The	1
lack the necessary functions for	1
lack of advanced development tools.	1
a2 * b1 * reciprocal_divisor;	1
a2 / b2; This can	1
a1 * b2 * reciprocal_divisor;	1
a1 / b1; y2 =	1
16) { b.load(bb+i); c.load(cc+i); a	1
16) shows that a particular	1
debugger. You may replace this	1
debugger. However, the code that	1
mostly compatible with these. The	1
mostly relative references in 64	1
a) { return a *	1
a) { return vector(x +	1
ptr x; __asm fistp dword	1
ptr n; #endif return n;}	1
fastcall functions The keyword __fastcall	1
fastcall modifier can make function	1
accumulators for floating point addition	1
accumulators if there is no	1
aliasing" if you are sure	1
aliasing" (if valid) can possibly	1
Implementation The CPU dispatch mechanism	1
Implementation ..................................................................................................... 126 13.6 CPU	1
significantly simply by using a	1
significantly just by turning off	1
parallelism. The way to use	1
parallelism. The gain depends on	1
479001600}; if ((unsigned int)n <	1
479001600}; ... int i, a,	1
"Performance Optimization of Numerically Intensive	2
type-casted to a pointer to	1
type-casted to a wrong type.	1
x4 = x2 * x2;	1
x4 = x2*x2; double x8	1
frequency. The core clock cycle	1
frequency. For example, if the	1
interpretation or compilation before it	1
interpretation on the device itself	1
(chapter 11) and vector operations	1
(chapter 12) are more useful	1
research, not on publicly available	1
research, I have developed a	1
SIAM 2001. 9.11 Explicit cache	1
SIAM 2001. Advanced book on	1
a[i+1] = Induction; ; parameter	1
a[i+1] = Induction; Induction++; }	1
x-xxx---- a-(-b)=a+b a-a = 0	1
x-xxx---- a*b*c=a*(b*c) a+b+c+d = (a+b)+(c+d)	1
send data from a buffer.	1
send your programming questions to	1
string[100], *p = string; int	1
string[100], *p = string; while	1
SSSE3 a few more integer	1
SSSE3 _mm_perm_epi8 32 1 byte	1
expressions, but no compiler I	1
expressions, even though the rules	1
CriticalFunctionType * CriticalFunction = &CriticalFunction_Dispatch;	1
CriticalFunctionType CriticalFunction_Dispatch; // Function pointer	1
71). The conclusion is that	1
71). In this case it	1
ASCII string to lower case:	1
ASCII form. A disadvantage of	1
overlapping or aliasing, but the	1
overlapping calculations. The loop branch	1
computationally intensive may very well	1
computationally intensive program is achieved	1
executes a series of branches	1
executes three to seven times	1
window of a debugger. However,	1
window or makefile. You can	1
ten times and stores the	1
ten years old. The CPU	1
Structure of 4 floats A	1
Structure and class objects can	1
jobs. The context switches after	1
jobs. For example, one tread	1
please don't send your programming	1
please install this important new	1
Unions A union is a	1
Unions .................................................................................................................... 55 7.25 Bitfields	1
AMD: "Software Optimization Guide for	1
AMD: "AMD64 Architecture Programmers Manual",	1
((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x = ((x2) 2)	1
((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x = ((x2)2)2 a+a+a+a=a*4	1
9.2 Cache organization It is	1
9.2 Cache organization ................................................................................................... 87	1
1024 bits is likely in	1
1024 bytes, so we can	1
programmed. But if the software	1
programmed. Therefore, it is important	1
Aligned arrays // Define macro	1
Aligned operands means that source	1
past the end of an	1
past history of that branch	1
9.6 Dynamic memory allocation Objects	1
9.6 Dynamic memory allocation ......................................................................................	1
object's class or structure. This	1
object's class. Make the function	1
b2, y1, y2; y1 =	1
b2, y1, y2, reciprocal_divisor; reciprocal_divisor	1
partial template specialization is allowed	1
partial flags stall because the	1
(a+b)+(c+d) a*b+a*c=a*(b+c) a*x*x*x + b*x*x	2
(16 or 32 bytes). This	1
(16 bits), unless the SSE4.1	1
xor mov $B1$2: mov shr	1
xor eax,eax. This is a	1
again, that most software runs	1
again, but it would be	1
9.9 Access data sequentially A	1
9.9 Access data sequentially ..........................................................................................	1
resolve any branch misprediction long	1
resolve compatibility problems. Software developers	1
context. The keyword static, when	1
context. It is possible to	1
(May use a table //	2
131. Intel Performance Primitives (IPP).	1
131. AMD LIBM library. Only	1
goal is to make a	1
goal of 18 software optimization	1
discovered that there are smarter	1
discovered that many common programs	1
Exp(float x) { float xn	1
Exp(float x) { __declspec(align(16)) static	1
9.8 Strings Text strings typically	1
9.8 Strings ...................................................................................................................... 96 9.9	1
_MSC_VER and not __INTEL_COMPILER __INTEL_COMPILER	1
_MSC_VER // If Microsoft compiler	1
16.3 Worst-case testing Most performance	1
16.3 Worst-case testing ................................................................................................ 157	1
chance of going either way.	1
chance that the break will	1
manipulated to fake an Intel	1
manipulated with C functions such	1
c+b can be reused elsewhere.	1
c+b will generate an overflow	1
override the CPU dispatching and	1
override public symbols, but this	1
branches, as explained in the	1
branches, provided that the operands	1
applications, but it is important	1
applications, but not always for	1
developed a test tool for	1
developed as C++ compilers. 2.5	1
7.29 Threads Threads are used	1
7.29 Threads .................................................................................................................. 60 7.30	1
CriticalFunction. If your optimization effort	1
CriticalFunction. You cannot avoid this	1
discusses how to make a	1
discusses how to overcome these	1
#elif INSTRSET == 8 #define	1
#elif INSTRSET == 5 #define	1
7.26 Overloaded functions The different	1
7.26 Overloaded functions .............................................................................................. 56	1
"Instruction tables". There are certain	1
"Instruction tables". Tips about how	1
400 bytes. first byte at	1
400 here. Any code that	1
invariant code motion A calculation	1
invariant code motion Induction variables	1
c*x + d = x-	1
c*x + d = ((a*x+b)*x+c)*x+d	1
carefully to make sure that	1
carefully optimized and fine-tuned for	1
CriticalInnerFunction is called. The compiler	1
CriticalInnerFunction () { // Table	1
a/1=a xxxxxxxxx 0/a=0 ---x---xx (-a==-b)=(a==b)	1
a/1=a x-xxx-x-- 0/a=0 ---xx--xx (-a==-b)=(a==b)	1
__m128 defines a 128 bit	1
__m128 s; s = _mm_hadd_ps(x,	1
operator; and you can toggle	1
operator; you can clear or	1
subexpression. A constant can be	1
subexpression. For example, b*2.0/3.0 will	1
freed when the function returns.	1
freed before the function returns.	1
operator, or an over- loaded	1
operator, which can only be	1
p->Hello(); } // Non-polymorphic functions	1
p->Hello(); p = &Object2; p->Hello();	1
CPUs: use the core clock	1
CPUs: An optimization guide for	1
0's when false. The value	1
0's gives zero. An OR	1
chip that can be programmed	1
chip can be a very	1
operator. The code for accessing	1
operator. The & operator is	1
proceed in a standardized manner.	1
proceed unattended. Uninstallation should also	1
CriticalFunction_386(int parm1, int parm2) {...}	2
scientific vector processors. Henry S.	1
scientific computing, but for most	1
biased allows us to compare	1
biased binary integer, and the	1
minor error in the oldest	1
minor increase in develop- ment	1
screen. There is no way	1
screen. However, such applications are	1
market. But the cost of	1
market. Such a list is	1
aligned(16))) Assume pointer is aligned	1
aligned(16))) __declspec( align(16)) __attribute(( aligned(16)))	1
justified in case of large	1
justified for general function libraries	1
exit the loop. The loop-branch	1
exit may not be safe	1
cos(x); } z = y	1
cos(x); z = y +	1
having the same name, regardless	1
having different types. A disadvantage	1
for-loop or while-loop is also	1
for-loop has three clauses: initialization,	1
char, short int, float. Similar	1
char, signed or unsigned 1	1
a/a=1 --------x a/1=a x-xxx-x-- 0/a=0	1
a/a=1 ----x---x a/1=a xxxxxxxxx 0/a=0	1
legal issue. See my blog	1
legal issue, as you can	1
resource, such as dynamically allocated	1
resource, especially in 32-bit mode.	1
parallelization. The Gnu, Intel and	1
parallelization. Supports vector intrinsics and	1
keeping a CPU dispatcher updated.	1
keeping data together. Data members	1
sampling: The profiler tells the	2
12.5. Vector classes defined in	1
12.5. Aligned arrays // Define	1
reduces the code to: //	1
reduces example 15.1a to 15.1c	1
non-member functions. 80 Unfortunately, this	1
non-member function, means that the	1
vectorized, because a float uses	1
vectorized, but the code will	1
y=temp;} // Check if level-2	1
y=temp;} int r, c; double	1
influences in order to make	1
influences are removed, all resources	1
explains the logic behind the	1
explains why bookkeeping is needed:	1
emulate the while loop in	1
emulate a 256-bit vector as	1
four, we will have to	1
four, depending on the CPU.	1
believe that the portability could	1
believe that software performance should	1
stdint.h or inttypes.h is available	1
stdint.h char 8 -128 127	1
elimin., integer Common subexpression elimin.,	1
elimin., float Register variables, integer	1
instance. The function code is	1
instance. Non-static members of the	1
TransposeCopy(double a[SIZE][SIZE], double b[SIZE][SIZE]) {	2
insufficient information about pointer alignment	1
insufficient amount of RAM, a	1
dangers of a relatively primitive	1
dangers to be aware of	1
aligned. It is preferred to	1
aligned. See page 120 for	1
external libraries. www.agner.org/optimize/#vectorclass All these	1
external clock. This gives a	1
"Error: Index out of range";	2
smmintrin.h (Gnu) AES, PCLMUL wmmintrin.h	1
smmintrin.h SSE4.2 nmmintrin.h (MS) smmintrin.h	1
frameworks. The .NET framework and	1
frameworks. This is often a	1
Monday, etc. are defined as	1
Monday, Tuesday, Wednesday, Thursday, Friday,	1
X, 32-bit and 64-bit. Supports	1
X, unless you are making	1
GNU General Public License, optional	1
GNU Free Documentation License shall	1
127. The Intel compilers and	1
127. The calculation of c+b	1
FuncType * SelectAddMul_pointer = &SelectAddMul_dispatch;	1
FuncType SelectAddMul, SelectAddMul_SSE2, SelectAddMul_SSE41, SelectAddMul_AVX2,	1
C1::f } 73 Without optimization,	1
C1::f directly without using the	1
Splitting up a function into	1
Splitting up a function just	1
Algorithms that are inherently serial,	1
Algorithms that rely heavily on	1
-mAVX /arch:AVX /QaxSSE3, etc. -msse3	1
-mAVX -axSSE3, etc. (Intel CPU	1
worry about loss of precision.	1
worry much about overflow and	1
instruction. The CPU supports this	1
instruction. Programmers that have tested	1
x^2 // x^4 // x^8	1
x^2 float x4 = x2	1
disabled in the final version	1
disabled will crash the program.	1
CPU-specific and each CPU model	1
CPU-specific versions of the library	1
8.26b void Func(int a[], int	1
8.26b compiled to assembly: ALIGN	1
preprocessing directives that select the	1
preprocessing macro INSTRSET is used	1
strides. Therefore, you don't have	1
strides. Uncached memory store An	1
15. If i is outside	1
15. C++ is definitely the	1
develop and market the application	1
develop and publish a function	1
Full template specialization for N	2
(N & N-1)==0 if N	1
(N & (N-1)) return powN<(N1&(N1-1))==0,N1>::p(x)	1
Enable the AVX or later	1
Enable exception for floating point	1
cases: The CPU dispatcher should	1
cases: If part of a	1
non-AVX code because of a	1
non-AVX code. This can be	1
a+(b+c) - n.a. a*b+a*c =	1
a+(b+c) - a*b+a*c = a*(b+c)	1
mouse. The .NET framework should	1
mouse. This task must have	1
www.amd.com. 163 Internet forums Several	1
www.amd.com. Advices on optimization of	1
-56 which will generate an	1
-56 rather than 200. Next,	1
difficult. The functions must have	1
difficult. On the other hand,	1
-msse3 -mssse3 -msse4.1 -mAVX -axSSE3,	1
-msse3 /arch:SSE3 -mssse3 /arch:SSSE2 -msse4.1	1
(32-bit or 64-bit systems). 28	1
(32-bit mode): ; Example 8.26a	1
values. The choice of which	1
values. Which of these two	1
/arch:SSE2 -msse2 SSE3 instruction set	1
/arch:SSE2 -msse2 /arch:SSE2 -msse2 SSE3	1
Vec8s 16 8 unsigned short	1
Vec8s a, b, c; //	1
CParent is a template class	1
CParent : public CGrandParent {	1
Adding the compiler option "assume	1
Adding 1 to 127 will	1
developer.intel.com. Many advices on optimization	1
developer.intel.com. AMD: "AMD64 Architecture Programmers	1
frame- pointer No runtime type	1
frame- pointer -fomit- frame- pointer	1
<stdio.h> // define fprintf //	1
<stdio.h> #include <asmlib.h> void CriticalFunction();	1
9.11 Explicit cache control ..............................................................................................	1
9.11 Explicit cache control Microprocessors	1
relocations in the code section	2
NAN (not a number). Different	1
NAN (Not A Number) if	1
9.10 Cache contentions in large	2
2" The dispatching to C1::Disp()	1
2" Here CParent is a	1
sum; for (int i =	1
sum; } Here, each value	1
12.10 Conclusion There is a	1
12.10 Conclusion .......................................................................................................... 120 13	1
semaphores, mutexes, etc. is considerable.	1
semaphores, mutexes and message systems.	1
Multiplication and division take longer	1
Multiplication takes 4 - 8	1
N&(N-1) is 0. The constant	1
N&(N-1) gives the value of	1
assembly: ALIGN 4 PUBLIC ?Func@@YAXQAHAAH@Z	2
regularly. Intel: "Intel C++ Compiler	1
regularly. AMD: "Software Optimization Guide	1
vacant then the DLL is	1
vacant spaces. This is called	1
early implementations of Pascal used	1
early planning stage that a	1
non-polymorphic functions in the grandparent	1
non-polymorphic member functions. The second	1
3.3; // Polynomial coefficients double	1
3.3; double Table[100]; int x;	1
users. In some cases, the	1
users. Firewalls, virus scanners and	1
extern "C" int CriticalFunction ();	1
extern "C" declaration and the	1
heap. The space is automatically	1
heap. The heap manager has	1
formats can be expressed as	1
formats should be used. Web	1
ruled out or if there	1
ruled out by the program	1
reused again and again. If	1
reused elsewhere. In this example,	1
Organize the data with all	1
Organize the data into groups	1
CParent<CChild1> { has the same	1
CParent<CChild1> { public: void Disp()	1
14.12b and 14.13b works only	1
14.12b int list[300]; int i,	1
types: long long, double. Misaligned	1
types: char, short int, float.	1
FDIV bug is a minor	1
FDIV bug causes floating point	1
decimal point is 1. This	1
decimal point in your program,	1
nfac = 1.f; for (int	1
nfac *= n+1; // Approximate	1
connections. Open files and network	1
connections. Temporary files that need	1
PC. Nevertheless, it is possible	1
PC. Similarly, we are seeing	1
hacks and direct hardware access.	1
hacks that violate or circumvent	1
24 6 Development process...................................................................................................... 25	1
24 dramatically for very large	1
suffer from poor branch prediction.	1
suffer from mispredictions. 44 In	1
throw. It is more efficient	1
throw. In fact, the compiler	1
differently. The link to a	1
differently. A negative integer will	1
align(16)) __attribute(( aligned(16))) Assume pointer	1
align(16)) __attribute(( aligned(16))) __declspec( align(16))	1
element, bits Number of elements	2
Often, it is sufficient to	1
Often, it takes more time	1
Replacing a function with a	1
Replacing two comparisons by one	1
b*x*x + c*x + d	2
language". The method is faster	1
language". While we are waiting	1
that's about the only situation	1
that's what they are. However,	1
13.3 Difficult cases In most	1
13.3 Difficult cases........................................................................................................ 124 2	1
inherent performance costs to such	1
inherent support for 64-bit integers.	1
-static Generate assembly listing /FA	1
-static /MT 160 /Qparallel -parallel	1
ArrayOfStructures[100]; This reordering has made	1
ArrayOfStructures[100]; Here, there are 6	1
13.2 Model-specific dispatching There may	1
13.2 Model-specific dispatching .................................................................................... 124	1
comparison is likely to be	1
comparison of doubles by comparing	1
hint and the compiler may	1
hint about no pointer aliasing.	1
13.5 Implementation The CPU dispatch	1
13.5 Implementation ..................................................................................................... 126 13.6	1
13.4 Test and maintenance There	1
13.4 Test and maintenance ..........................................................................................	1
13.7 CPU dispatching in Intel	2
code" in manual 5: "Calling	1
code" actually implies more than	1
course. A branch that goes	1
course. It is the responsibility	1
<dvec.h> // Define vector classes	2
loop, the if statement and	1
loop, for example when r	1
number, or no offset at	1
number, which is 15 on	1
case: // Example 7.31a char	1
case: // Example 7.45 //	1
rolling out the loop by	2
loop: for (i = 0;	1
loop: // Example 14.13c int	1
2.0f; } 115 from bb	1
2.0f; x.i |= 0x80000000; //	1
52. The member functions of	1
52. You may choose to	1
supporting multiple platforms or multiple	1
supporting multi-threaded software are available	1
thrown by F2 and call	1
thrown exceptions are indeed of	1
invoking the compiler from the	1
invoking the overhead of the	1
{1, 1, 2, 6, 24,	2
construct an object with new	1
construct obscure examples where the	1
compiled. This is the reason	1
compiled. #if directives are useful	1
transpose(double a[SIZE][SIZE]) { // function	1
transpose(double a[SIZE][SIZE]) { // Define	1
Checking what the compiler does	2
elimination, constant propagation, and loop-invariant	1
elimination, constant propagation, etc. Whether	1
StringLength; for (i = StringLength;	1
StringLength; i > 0; i--)	1
integration, mixed language 11 programming,	1
integration, web application integration, mixed	1
kilobytes at a time. You	1
kilobytes Time per element 63	1
got low priority. Especially the	1
got RISC cores, vector processing	1
locally in the thread function	1
locally or remotely. If frequent	1
it, for example if you	1
it, it may be more	1
32. This is a power	1
32. In 64-bit systems we	1
minimum value maximum value in	1
minimum supported instruction set for	1
thread-specific data is to declare	1
thread-specific data and make one	1
a[2]; for (i = 0;	1
a[2]; a[0] = 1; a[1]	1
can't be reached with a	1
can't have public variables in	1
Vec4f polynomial (Vec4f const &	1
Vec4f Vec2d Vec8f Vec4d 16	1
(2) use unsigned integers -	1
(2) find the GOT through	1
paragraph and manual 3: "The	1
paragraph described a mechanism called	1
remain unchanged. The problem with	1
remain locked after the program	1
scanners to consume more time	1
scanners and other protection means	1
calculates the sum of 100	1
calculates four consecutive terms in	1
databases, etc. The efficiency of	1
databases, network and other resources	1
C++". Addison-Wesley, 1996. These two	1
C++". Addison-Wesley. Third Edition, 2005;	1
2008 version). This wasteful behavior	1
2008 R2 as well as	1
/Gy -ffunction- sections SSE instruction	1
/Gy -ffunction- sections /Gy -ffunction-	1
Assuming that the values of	1
Assuming that processor model numbers	1
search, is fast enough. A	1
search, or even a linear	1
......................................................................... 128 13.7 CPU dispatching	1
......................................................................... 130 14 Specific optimization	1
constructs are costly and which	1
constructs Most programmers have little	1
screen resolutions, different system color	1
screen resolutions, etc. Accessibility guidelines	1
Loops The efficiency of a	1
Loops with a very low	1
Plus2 (int * p) {	1
Plus2 (&a); The compiler may	1
a*0 = 0 - n.a.	1
a*0 = 0 - a*1	1
a*1 = a - n.a.	1
a*1 = a - a/1	1
"vectorclass.h" // vector class library	1
"vectorclass.h" // Define vector classes	1
b[size], i; ... for (i	1
b[size], c[size]; float register temp;	1
Table[100]; int x; for (x	1
Table[100]; int x; const double	1
describe some of the compiler	1
describe various ways to avoid	1
GOT. The symbol interposition feature	1
GOT. Another possibility is to	1
dynamic_cast more time-consuming than a	1
dynamic_cast operator is used for	1
Finding the biggest time consumers	2
120, 720, 5040, 40320, 362880,	2
uninitialized or come from unknown	1
uninitialized variables that may be	1
77 Pointer aliasing When accessing	1
77 8.4 Obstacles to optimization	1
string. The old C-style method	1
string. In the future we	1
74 x x x x-	1
74 8.3 Obstacles to optimization	1
73 and 72 for discussions.	1
73 Without optimization, the compiler	1
Object2; CChild1 * p1; p1	1
Object2; CHello * p; p	1
destination both have addresses divisible	1
destination array. But the same	1
lookup: // Example 7.29b floata;	1
lookup: // Example 14.2b float	1
72 for discussions. Turn on	1
72 This may be useful	1
(Tuesday | Wednesday | Friday)	1
(Tuesday | Wednesday | Friday))	1
b:2; int c:2; }; char	1
b:2; int c:2; }; Bitfield	1
string; int i, StringLength; for	1
string; while (*p != 0)	1
putting the right data into	1
putting the smallest members last:	1
14.14b double a, b; a	1
14.14b automatically but only if	1
non- standardized details in both	1
non- sequential order. If the	1
15.1c. We can only hope	1
15.1c. Calculate integer power, loop	1
73). It is therefore safer	1
73). Current compilers are not	1
....................................................... 20 3.7 File access................................................................................................................	1
....................................................... 120 12.10 Conclusion ..........................................................................................................	1
mutexes, etc. is considerable. If	1
mutexes, database connections, etc. The	1
volatile. The volatile keyword makes	1
volatile. This prevents the compiler	1
relocation. The DLLs are relocated	1
relocation. All public functions and	1
(~a&c) | (b&c) = (a&b)	1
(~a&c) a&b&c&d = (a&b)&(c&d) a	1
90% of the CPU time	1
90% chance that the break	1
MultiplyBy in this example is	1
MultiplyBy (int x) { return	1
suited for the project at	1
suited for vector operations. Algorithms	1
Developers Manual", Volume 1, 2A,	1
Developers Manual", Volume 2A and	1
y1, y2; y1 = a1	1
y1, y2, reciprocal_divisor; reciprocal_divisor =	1
14.14a with 14.14b automatically but	1
14.14a double a, b; a	1
settings and different user access	1
settings are lost. It is	1
Compile for a specific instruction	1
Compile once for each version	1
Provoke cache misses by making	1
Provoke branch mispredictions by making	1
import table and possibly also	1
import table or a pointer.	1
turns out to be too	2
0x4700. These addresses all belong	1
0x4700. Reading again from address	1
x---- ----- ~(~a)=a x-xxxxx-- (a&b)|(a&c)	1
x---- x---- ----- ~(~a)=a x-xxxxx--	1
Overcoming the drawbacks of the	2
a*1=a (-a)*(-b)=a*b a/a=1 ----x---x a/1=a	1
a*1=a x-xxxxx-x (-a)*(-b)=a*b ---xxx--- a/a=1	1
Take the example: // Example	1
Take user feedback seriously. User	1
shuffling, such as many encryption	1
shuffling, packing, unpacking needed. Predictable	1
priorities to different tasks. For	1
priorities then the user might	1
range"; } else { list[i]	1
range"; 134 } else {	1
corrections and suggestions for my	1
corrections for sign and rounding	1
safe. This safety problem can	1
safe. In other words, the	1
supported. The calculation of expressions	1
supported. For example, use AVX	1
anonymous object. The compiler can	1
anonymous namespace. 3. The Gnu	1
pure. This allows common subexpression	1
pure. Virtual functions and function	1
SSE4.2 string search instructions AVX	1
SSE4.2 nmmintrin.h (MS) smmintrin.h (Gnu)	1
clock; } // Or #include	1
clock; __cpuid(dummy, 0); DontSkip =	1
12.4a where current compilers don't	1
12.4a so that we can	1
matrices, clock cycles per element.	2
inconsistent and sometimes unacceptably long.	1
inconsistent results if the operands	1
bc); // Store the result	1
bc); // OR the results	1
join all source files into	1
join them into one thread.	1
range. The next line provokes	1
range. This may typically look	1
c:2; }; char abc; };	1
c:2; }; Bitfield x; int	1
Value of a will be	1
Value of b will be	1
CGrandParent { public: void Hello()	1
CGrandParent { public: void NotPolymorphic();	1
two); // Multiply b and	2
-- - - - -	1
-- - xx x x-	1
bypassed by any of these	1
bypassed when the virtual function	1
drivers, interrupt service routines, system	1
drivers, configuration files and system	1
-0 } It is not	1
-0 (zero with sign bit	1
accelerator card for other purposes	1
accelerator card. Some systems also	1
3.10 Graphics A graphical user	1
3.10 Graphics ................................................................................................................. 21 3.11	1
3.11 Other system resources ..........................................................................................	1
3.11 Other system resources Writes	1
increases the size of the	1
increases the amount of memory	1
3.13 Memory access Accessing data	1
3.13 Memory access....................................................................................................... 22 3.14	1
3.14 Context switches A context	1
3.14 Context switches..................................................................................................... 22 3.15	1
3.15 Dependency chains Modern microprocessors	1
3.15 Dependency chains ................................................................................................ 22	1
3.16 Execution unit throughput There	1
3.16 Execution unit throughput .......................................................................................	1
Sum1 has an implicit 'this'	1
Sum1 slightly more efficient than	1
a*x*x*x + b*x*x + c*x	2
0x20; If the length of	1
0x20; 46 A common situation	1
TILESIZE // Loop r1 and	1
TILESIZE = 8; // SIZE	1
expression, or first in an	1
expression, but none of the	1
consumers ................................................................................ 16 3.1 How	1
consumers 3.1 How much is	1
CPU, an insufficient amount of	1
CPU, which counts at the	1
&Object1; p1->Hello(); CChild2 * p2;	1
&Object1; p->NotPolymorphic(); p->Hello(); p =	1
............................................................................. 158 18 Overview of	1
............................................................................. 84 9 Optimizing memory	1
exp(x) for small x //	2
programming. The CPU dispatcher should	1
programming. 13.3 Difficult cases In	1
time1; // This is the	1
time1; long long timediff[NumberOfTests]; for	1
events, for example every time	1
events, such as the number	1
achieved more efficiently by better	1
achieved when none of the	1
<emmintrin.h> // Define SSE2 intrinsic	1
<emmintrin.h> static inline int lrintf	1
2.8 Overcoming the drawbacks of	2
answers to your programming questions	1
answers in the relevant books	1
starting a new software project,	1
starting and stopping threads. Don't	1
disadvantages: The unrolled loop takes	1
disadvantages: It is difficult for	1
2.3 Choice of operating system	1
2.3 Choice of operating system.........................................................................................	1
ahead of time and resolve	1
ahead of time so that	1
inserted in the final program,	1
inserted UnusedFiller in the structure	1
2.2 Choice of microprocessor The	1
2.2 Choice of microprocessor ...........................................................................................	1
/arch:SSE -msse SSE2 instruction set	1
/arch:SSE -msse /arch:SSE -msse SSE2	1
2.1 Choice of hardware platform	2
2.0 This method is useful	1
2.0 / 3.0; The compiler	1
40320, 362880, 3628800, 39916800, 479001600};	2
Func(int); const int size =	2
invalidate the cache. The operating	1
invalidate each other's caches and	1
opposite of register is volatile.	1
opposite order of the two	1
itself, and the cost of	1
itself, during installation of the	1
2.7 Choice of user interface	2
a[1000]; float b[1000]; }; if	1
a[1000]; F1(a); } else {	1
2.6 Choice of function libraries	1
2.6 Choice of function libraries........................................................................................	1
S. Goedecker and A. Hoisie,	1
S. Warren, Jr.: "Hacker's Delight".	1
environment block. Thread-local storage should	1
environment (IDE) supports multiple programming	1
F2(b); } } Using a	1
F2(b); } } Here it	1
handles this code. For example,	1
handles eight elements at a	1
2.4 Choice of programming language	2
note that this method works	1
note that my optimization manuals	1
others are not. Supports 32-bit	1
others have done the job	1
needs. The search for updates	1
needs. 9.8 Strings Text strings	1
sar add mov add cmp	1
sar ebx,1 adds this to	1
("internal"))) __attribute__ ((visibility ("internal"))) Vectorize	1
("internal"))) Vectorize #pragma vector always	1
8.15a were float instead of	1
8.15a struct S1 {double a;	1
footprint is unreasonably large. 156	1
footprint than the alternative version.	1
14.13b int list[300]; int i;	1
14.13b works only if the	1
namespaces. Therefore, you should avoid	1
namespaces. 65 8 Optimizations in	1
preventing program errors in case	1
preventing illegitimate copying. The benefits	1
Lowest version int CriticalFunction_386(int parm1,	2
Saturday = 0x40 }; Weekdays	1
Saturday }; Weekdays Day; if	1
a*b+a*c=a*(b+c) a*x*x*x + b*x*x +	2
resolutions, different system color settings	1
resolutions, etc. Accessibility guidelines should	1
So the address of array	1
So please don't send your	1
9.6a const int SIZE =	1
9.6a Time per element Example	1
a*(b+c) - n.a. x*x*x*x*x*x*x*x =	1
a*(b+c) - -(-a) = a	1
events that are not reproducible.	1
events as task switches and	1
__fastcall. The implicit 'this' pointer	1
__fastcall. Function parameters are transferred	1
a+0 = a - n.a.	1
a+0 = a - a*0	1
Delays in program execution may	1
Delays or glitches in the	1
Report on C++ Performance for	1
Report on C++ Performance". www.open-	1
(bb[i] * cc[i]); } 109	1
(bb[i] > 0) ? (cc[i]	1
specified. The code will read	1
specified. Insert an explicit CPU	1
prototype to tell the compiler	1
prototype CriticalFunctionType CriticalFunction_Dispatch; // Function	1
39 shows how you can	1
39 matrix[i][j] += x; This	1
let's look at the example	1
let's say that you want	1
(Day & (Tuesday | Wednesday	1
(Day == Tuesday || Day	1
visible in the scope of	1
visible at all to the	1
Kbytes to 2 Mbytes. There	1
Kbytes and a level-2 cache	1
proxy is smaller and closer	1
proxy for the main memory	1
Microprocessors with the SSE and	1
Microprocessors with out-of-order capabilities are	1
105. Floating point addition takes	1
105. 8.7 Checking what the	1
recently than to access it	1
recently 4 ?Func2@@YAXQAHAAH@Z ENDP ecx,	1
creating and deleting the object	1
creating and deleting containers. If	1
order(i); matrix[j][0] = i; }	1
order(i); list[j].a = list[j].b +	1
refers to the situation where	1
refers to. For example: //	1
floppy disk. A big file	1
floppy disks and USB sticks	1
underflow. The range of floating	1
underflow. The fact that the	1
37 A compiler has to	1
37 7.8 Member pointers.......................................................................................................37 7.9	1
36 C++ as 'this'. We	1
36 7.7 Function pointers ......................................................................................................	1
3) << 4) | ((C	1
3) <<6 ); 7.26 Overloaded	1
contrived example, but the point	1
contrived examples exist. Therefore the	1
Manual on using the optimization	1
Manual 3: "The microarchitecture of	1
Excessive use of templates makes	1
Excessive loop unrolling is not	1
FuncA and FuncB, then FuncC.	1
FuncA (int * p) {	1
web application integration, mixed language	1
web browsing that previously required	1
occur, but the calculation time	1
occur, but unfortunately this is	1
reorder instructions for the sake	1
reorder instructions without help of	1
microseconds to execute then measurements	1
microseconds as a time measure.	1
Standard C++ imple- mentations have	1
Standard Template Library (STL) which	1
const_cast operator is used for	1
const_cast operator here is to	1
though. In some cases the	1
though. Some instructions are one	1
compiler: unsigned __int64 64-bit Linux:	1
compiler: __int64 64 -263 263-1	1
y) { if (y) {	1
y) { union { 89	1
/MT -msse3 /arch:SSE3 -mssse3 /arch:SSSE2	1
/MT 160 /Qparallel -parallel -openmp	1
overwritten, and even worse, it	1
overwritten, possibly in a different	1
[esp+8] DWORD PTR [edx] DWORD	1
[esp+8] eax, eax edx, DWORD	1
annoyingly long and irregular response	1
annoyingly high for programs that	1
list[size]; int i, j; ...	1
list[size]; ... if (i <	1
license Table 12.4. Vector class	1
license included in compiler price	1
y1 = a1 * b2	1
y1 = a1 / b1;	1
y2 = a2 * b1	1
y2 = a2 / b2;	1
swapd(x,y) {temp=x; x=y; y=temp;} //	1
swapd(x,y) {temp=x; x=y; y=temp;} int	1
int)i < 10) { ...	1
int)i >= (unsigned int)size) {	1
CriticalFunction_SSE2(int parm1, int parm2) {...}	2
GHz then the length of	1
GHz CPU. Should we try	1
false. The value of cc[i]+2	1
false. Likewise, you cannot replace	1
Multithreading The clock frequency of	1
Multithreading works more efficiently with	1
New versions are produced regularly.	2
CriticalFunctionDispatch(void) { // Returns a	1
CriticalFunctionDispatch(void) __asm__ ("CriticalFunction"); typeof(CriticalFunction) *	1
methods. The most common pitfalls	1
methods. If you are using	1
became available because the interpreted	1
became available. It should be	1
if, a level-2 cache miss	1
if, and only if, a	1
computers. At this time, any	1
computers. Today, the choice of	1
x.abc = A | (B	1
x.abc = (A & 0x0F)	1
Worst-case testing Most performance tests	1
Worst-case testing ................................................................................................ 157 17	1
Operations that are only available	1
Operations that are missing in	1
named YMM in the AVX	1
named MKL, VML and SVML.	1
a*0=0 a*1=a (-a)*(-b)=a*b a/a=1 ----x---x	1
a*0=0 --xxxx-xx a*1=a x-xxxxx-x (-a)*(-b)=a*b	1
p2 = &Object2; p2->Hello(); //	1
p2 having different types. A	1
p1 and p2 having different	1
p1 = &Object1; p1->Hello(); CChild2	1
major platforms. However, C++ is	1
major platforms. Pascal has many	1
internet or intranet for automatic	1
internet forums and newsgroups contain	1
p; int i; p =	1
p; p = &Object1; p->NotPolymorphic();	1
lrintf and lrint. Unfortunately, these	1
lrintf (float const x) {	1
resulting code will be very	1
resulting machine code becomes the	1
a[c][r]); // swap elements }	1
a[c][r]); void test () {	1
math. Memory copying. There are	1
math. Libraries for high precision	1
2048 bytes = 4 rows.	1
2048 230.7 513 513 2056	1
3.5; c = d +	1
3.5; Here, the constant 3.5	1
DLLs are relocated by the	1
DLLs use relocation. The DLLs	1
Unix systems allow up to	1
Unix applications and the Gnu,	1
Lookup tables are particular advantageous	1
Lookup tables can be useful	1
differ a lot in performance.	1
differ then you will get	1
InstructionSet(); // Set pointer to	2
F1() { C1 x; ...	1
F1() throw(); This allows the	1
safety is to store all	1
safety problem can be overcome	1
predefined vector classes are currently	1
predefined vector classes Fortunately, it	1
variable-size array with alloca: //	1
variable-size arrays with alloca. This	1
obj1; C0 * p =	1
obj1; p->f(); // Virtual call	1
Codes", by S. Goedecker and	1
Codes", SIAM 2001. Advanced book	1
summarized in table 8.1. The	1
summarized below. Intrinsic function Size	1
small. The number of branches	1
small. Are objects numbered consecutively?	1
................................................................................ 16 3.1 How much	1
................................................................................ 61 7.31 Other cases	1
buffer. It should never respond	1
buffer. Contentions in the branch	1
list[size], sum = 0; int	1
list[size], sum1 = 0, sum2	1
"asmlib.h" // Define function type	1
"asmlib.h" // Lowest version int	1
ArraySize = 1000; int List[ArraySize];	1
ArraySize by the value 1000.	1
Live range analysis The live	1
Live range analysis Join identical	1
mask); // Store the result	1
mask); 110 // AND each	1
suffixes are listed in table	1
suffixes such as e.g. .R.	1
programmer. There is a higher	1
programmer. 79 Floating point induction	1
x-xxxxxx- a*0=0 --xxxx-xx a*1=a x-xxxxx-x	1
x-xxxxxx- x-xxxx-x- x-xxxxxxx xxxxxxxxx xxxxxxx-x	1
name. In the Windows operating	1
name. #define directives when used	1
third-party graphics framework between the	1
third-party profilers such as AQtime,	1
(a+b)+c=a+(b+c) --xx----- (a&&b) || (a&&c)	1
(a+b)+c=a+(b+c) a+b+c=c+b+a a+b+c+d = (a+b)+(c+d)	1
audio and video processing, signal	1
audio or video should also	1
arguments are sure to produce	1
arguments while pointers and non-constant	1
infinite loop if powN is	1
infinite loop. The effect of	1
flow. However, this did not	1
flow. Failure to do so	1
worse, it can overwrite the	1
worse, many software products fail	1
miss can be expected. The	1
miss on a store operation	1
unsafe code is limited to	1
unsafe because serious errors can	1
away. It is common to	1
away. Note that volatile doesn't	1
movements of objects in a	1
movements of objects in computer	1
((x2) 2) 2 - n.a.	1
((x2) 2) 2 a+a+a+a=a*4 -(-a)=a	1
windows, mutexes, database connections, etc.	1
windows, graphic brushes, etc. Locked	1
pressing a key or moving	1
pressing a button or moving	1
Factors that make vectorization less	1
Factors that make vectorization favorable:	1
price, and in most libraries	1
price, compatibility, second source, and	1
Jumps can be avoided by	1
Jumps between CPU cores. A	1
maintaining a new branch of	1
maintaining such code is so	1
Nevertheless, the bitwise operators are	1
Nevertheless, it is possible to	1
sound processing Memory and string	1
sound processing, and mathematical operations	1
servers that run many processes	1
servers should be tested on	1
utility. The conclusion is that	1
utility. It supports 32-bit and	1
executable. SSE2 is the minimum	1
executable. Most compilers offer the	1
controlled. The network access may	1
controlled. Small hand-held devices are	1
literature for more complicated mathematical	1
literature on algorithms and data	1
512; // number of rows	2
precautions to account for unaligned	1
precautions for speeding up 64-bit	1
smarter ways of doing things	1
smarter ways of organizing the	1
2001. 9.11 Explicit cache control	1
2001. Advanced book on optimization	1
Current compilers are not very	1
Current CPUs have only one	1
concentrated on CPU efficiency then	1
concentrated on arranging data in	1
aa[i] = (bb[i] > 0)	1
aa[i] = bb[i] + 2;	1
null reference to provoke error	1
null reference. This will provoke	1
capable of register renaming and	1
capable of making two threads	1
FuncC(i); } This loop repeats	1
FuncC(i); FuncB(i+1); FuncC(i+1); } This	1
updating. The change of a	1
updating. The update process should	1
MOVNTDQ require that the operating	1
MOVNTDQ _mm_stream_si128 SSE2 Table 9.2.	1
renaming and doing multiple calculations	1
renaming mechanism works only on	1
considering is the D language.	1
considering whether a particular integer	1
worthwhile to unroll the loop	1
worthwhile to invest more efforts	1
a-(-b)=a+b a-a = 0 a+0=a	1
a-(-b)=a+b ---xxx-x- a+0=a x-xxxxxx- a*0=0	1
f(); }; class C1 :	1
f(); }; void g() {	1
separately. The fallacy of measuring	1
separately. The allocation, deallocation and	1
patterns with fixed strides. Uncached	1
patterns containing multiple streams with	1
93. Avoid the function scanf.	1
93. 7.10 Arrays An array	1
lowest of the compiled versions	1
lowest instruction set not supported	1
EXCEPTION_FLT_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)	1
EXCEPTION_FLT_OVERFLOW 0xC0000091L void MathLoop() {	1
constructor, if any, is usually	1
constructor, an overloaded assignment operator,	1
syntax: __asm fld qword ptr	1
syntax: __asm ("fldl %1 \n	1
1.2; // everything is double	1
1.2; // Mixing float and	1
26. The heap space becomes	1
26. Avoid global and static	1
parentheses can be calculated independently.	1
parentheses manually. The effect of	1
check. It does not produce	1
check. There are a number	1
experiments in order to determine	1
experiments on seven different brands	1
................................................................................................. 103 12 Using vector	1
................................................................................................. 132 14.2 Bounds checking	1
tables". There are certain restrictions	1
tables". Tips about how to	1
jl $B1$2 is the loop	1
jl $B1$3: pop ret ALIGN	1
computation time is determined by	1
computation time. 4 Performance and	1
thread-local storage of static and	1
thread-local storage p. 28) The	1
date. A more realistic goal	1
date. Mac The libraries included	1
physics processor for calculating the	1
physics processing unit intended for	1
first, then all the G	1
first, then d+e, then c	1
below) then it may be	1
below) 16.1 Using performance monitor	1
eliminated. Loop unrolling also has	1
eliminated. Code caching will be	1
c.load(cc+i); a = select(b >	1
c.load(cc+i); // result = b	1
x-xxxxxxx xxxxxxxxx xxxxxxx-x xxxxxxxxx x-xxx----	1
x-xxxxxxx ---x----- x--xx---- (a&&b)||(a&&!b)=a x--xx----	1
Unrolling the loop by two	1
Unrolling a loop becomes a	1
hyperthreading. If so, then you	1
hyperthreading. On the contrary, each	1
bytes, so we can calculate	1
bytes, 4 ways, with a	1
(*.lib, *.a) or dynamic link	2
irrelevant software installed, a lot	1
irrelevant within a year or	1
careful when swapping the order	1
careful optimization. A mixed implementation	1
compression and cryptography (www.intel.com). If	1
compression Most compilers include standard	1
intervals are short. In Windows,	1
intervals which may interfere with	1
(c2 = r1; c2 <	1
(c2 = c1; c2 <	1
immediate response to pressing a	1
immediate responses to simple actions	1
Object1; CChild2 Object2; CChild1 *	1
Object1; C2 Object2; CHello *	1
etc.) have little-endian storage, but	1
etc.) inside the loop. If	1
64-bit. Supports OpenMP and automatic	1
64-bit. They have not been	1
indirect function feature is used	1
indirect function" has been introduced	1
(-a==-b)=(a==b) ---xx---- (a+c==b+c)=(a==b) ----x---- !(a<b)=(a>=b)	1
(-a==-b)=(a==b) ---xx---- (-a>-b)=(a<b) ---xx---x Divide	1
hyperthreading, then try to run	1
hyperthreading, but the performance is	1
exponent, and the most significant	1
exponent, and fffff is the	1
FuncA(i); } else { FuncB(i);	1
FuncA(i); FuncC(i); FuncB(i+1); FuncC(i+1); }	1
cross-platform compatibility is not always	1
cross-platform portability. Unfortunately, the cross-platform	1
{temp=x; x=y; y=temp;} // Check	1
{temp=x; x=y; y=temp;} int r,	1
decomposition. It is important to	1
decomposition. Functional decomposition here means	1
parameter: // Example 7.42 int	1
parameter: template <typename MyChild> class	1
determines the program flow and	1
determines whether the second operand	1
(properties) The data members of	1
(properties) ............................................................................ 51 7.19 Class	1
ABC = 123; are equally	1
ABC 123 and static const	1
comments about how the development	1
comments generated by the compiler	1
..................................................................................................................... 38 7.11 Type conversions....................................................................................................	1
..................................................................................................................... 163 20 Copyright notice	1
profitable to use vectorized code	1
profitable (see page 70). The	1
behind the program or because	1
behind the C++ syntax in	1
Technical Report on C++ Performance	1
Technical University of Denmark. Copyright	1
Neither is it unusual that	1
Neither can you assume that	1
calculation. In most cases, double	1
calculation. However, the out-of-order mechanism	1
const)) Assume function does not	1
const)) __attribute(( const)) Assume function	1
test, but is less reliable.	1
test, maintain and verify than	1
-ffunction- sections SSE instruction set	1
-ffunction- sections /Gy -ffunction- sections	1
-msse SSE2 instruction set (128	1
-msse /arch:SSE -msse SSE2 instruction	1
Initialize to zero // Return	1
Initialize loop counter outside both	1
indices or by keys within	1
indices when you want to	1
s0 = 0, s1 =	1
s0 += a[i]; s1 +=	1
/FA -S - masm=intel /FA	1
/FA -S Generate map file	1
marketing of 64-bit software, but	1
marketing reasons. This may cause	1
parm2); // Function prototype CriticalFunctionType	1
parm2); } int main() {	1
--xx----- (a&&b) || (a&&c) =	1
--xx----- x-xxx---x x-xxx---x x -	1
20, columns = 32; float	1
20, columns = 50; float	1
conflicting with the requirements of	1
conflicting considerations of efficiency, platform	1
20; i += 2) {	1
20; i++) { if (i	1
61 function calls to check	1
61 7.31 Other cases of	1
looking at a link map	1
looking name ?Func@@YAXQAHAAH@Z is the	1
coarse-grained parallelism and fine-grained parallelism	1
coarse-grained parallelism than with fine-grained	1
matrix[c][r] at its mirror position	1
matrix[c][r] above the diagonal are	1
-mssse3 -msse4.1 -mAVX -axSSE3, etc.	1
-mssse3 /arch:SSSE2 -msse4.1 /arch:SSE4.1 -mAVX	1
isolate the most critical part	1
isolate the hot spot and	1
Let me explain the above	1
Let me explain this with	1
question. You may choose the	1
question. For example, a heavy	1
x^n // sum, initialize to	1
x^n } return add_elements(s); //	1
treats different brands of CPUs	1
treats non-Intel CPUs in a	1
topics ......................................................................................... 132 14.1 Use	1
topics 14.1 Use lookup tables	1
(3) look up the address	1
(3) trap integer overflow with	1
table: // Example 14.3b int	1
table: // Example 14.1b int	1
unstable or if the new	1
unstable due to interrupts and	1
60 The cost of synchronizing	1
60 7.30 Exceptions and error	1
iterations. The advantage of this	1
iterations. Here the iteration is	1
Join identical branches The code	1
Join identical branches Eliminate jumps	1
bb[i] + 2; } }	1
bb[i] > 0 is true,	1
sampling requires a CPU- specific	1
sampling generates too little data	1
(memory address) / (line size)	1
(memory pooling) than to allocate	1
verifying the functionality of an	1
verifying and maintaining a new	1
3.6 Dynamic linking and position-independent	2
3.4 Automatic updates Many software	1
3.4 Automatic updates .................................................................................................... 19	1
log(b[i]) + log(c[i]); // Increment	1
log(b[i]) + log(c[i]);. This would	1
Now, the factor to multiply	1
Now, according to the rules	1
a+a+a+a=a*4 -(-a)=a - - x	1
a+a+a+a=a*4 -(-a)=a --xxxxxx- a-(-b)=a+b ---xxx-x-	1
doubt how big a structure	1
doubt obtained with a fully	1
78). A matrix or multidimensional	1
78). Adding the compiler option	1
v.f are both positive. It	1
v.f if both positive }	1
manner? If objects are accessed	2
generating overflow. Likewise, it is	1
generating denormal numbers in case	1
Especially the use of intrinsic	1
Especially the memory allocation is	1
.................................................................................................... 10 2.6 Choice of	1
.................................................................................................... 19 3.5 Program loading	1
3.2 Use a profiler to	2
F1(a); } else { float	1
F1(a); } else { F2(b);	1
Switch between different parts of	1
Switch statements are most efficient	1
_mm_set1_epi16(0); // Make a vector	2
everywhere in the source files.	1
everywhere by default. Position-independent code	1
a&&(b||c) !a && !b =	1
a&&(b||c) (a&&!b) || (!a&&b) =	1
(a&b) | (~a&c) | (b&c)	1
(a&b) | (~a&c) a&b&c&d =	1
3.3 Program installation The time	1
3.3 Program installation .................................................................................................. 18	1
3.1 How much is a	2
randomly one way or the	1
randomly around in the memory.	1
Useful for vector operations, see	1
Useful when no reasonable upper	1
3.8 System database It can	1
3.8 System database ...................................................................................................... 20	1
3.9 Other databases Many software	1
3.9 Other databases ....................................................................................................... 21	1
............................................................................................ 66 8.2 Comparison of	1
............................................................................................ 36 7.7 Function pointers	1
mainframe computer. Big supercomputers with	1
mainframe computers. Today, the choice	1
(time before) } printf("\nResults:"); for	1
(time after) - (time before)	1
Everything that is said here	2
required. The Intel compiler has	1
required. See page 73 and	1
theoretical possibility that such contrived	1
theoretical background is further explained	1
12.1a. Automatic vectorization const int	1
12.1a. Enable the AVX or	1
file, is acceptable. 3.6 Dynamic	1
file, especially if the user	1
working with sets rather than	1
working software users. In some	1
pragmas in the code to	1
pragmas must be placed immediately	1
use. The installation of downloaded	1
use. I am not going	1
use, as explained in the	1
use, incompatible or error prone.	1
favorable: Small data types: char,	1
favorable: Larger data types: long	1
color settings and different user	1
color difference. Newest instruction set	1
8192 / 4 = 2048	1
8192 bytes, 4 ways, with	1
_mm_cmpgt_epi16(b, zero); // Use mask	1
_mm_cmpgt_epi16(b, zero); // AND each	1
lost. This dilemma can be	1
lost. It is not unusual	1
Exceptions and error handling Exception	1
Exceptions and error handling ................................................................................	1
question when efficiency is important.	1
question without generating overflow. Likewise,	1
afterwards a BSF (bit scan	1
afterwards reads or writes to	1
Every time a function is	1
Every fourth of these cache	1
denormals-are-zero mode if SSE2 is	1
denormals-are-zero mode (SSE2): #include <xmmintrin.h>	1
declaration. The type of storage	1
declaration. This is the simplest	1
exceptions: while (i < arraysize)	1
exceptions: __except (GetExceptionCode() == EXCEPTION_FLT_OVERFLOW	1
read. It is often easier	1
read. If a template has	1
Non-static member functions have a	1
Non-static members of the same	1
re- allocating when a memory	1
re- usable library if possible.	1
requiring the same address. There	1
requiring many files to be	1
{int a; int b; int	1
{int a; int b;}; Sab	1
branching is done every time	1
branching takes time. Dispatch on	1
changed. This will allow the	1
changed. 7.8 Member pointers In	1
belongs to the area of	1
belongs to class C1 or	1
(a&&c) = a&&(b||c) !a &&	1
(a&&c) || (a&&b&&c) = a&&(b||c)	1
NumberOfTests = 10; int i;	1
NumberOfTests times // Time before	1
obviously takes time to copy	1
obviously influenced by the requirements	1
undetected. The principle of table	1
undetected. Converting class objects Conversions	1
alone in the core. It	1
alone compiler when called from	1
caller to the called function.	1
caller through a hidden pointer.	1
understanding of the whole structure	1
understanding of how compilers work.	1
influence the performance of the	1
influence on the efficiency of	1
x-xx----- x--x----- ---x----- x---x---x x-xxx----	1
x-xx----- 75 (a&&b) || (!a&&c)	1
Lazy binding can be useful	1
Lazy binding should therefore be	1
Volatile to prevent optimizing //	1
Volatile The volatile keyword specifies	1
lock a thread to a	1
lock a container for exclusive	1
allowed. The code examples in	1
allowed. Non-public distribution to a	1
today will be mainstream next	1
today where cache size is	1
(double)(signed int)u; // Faster, but	1
(double)(signed int)u; 14.9 Using integer	1
programmable logic device is a	1
programmable logic device than in	1
checks. But it is the	1
checks. These conversions are not	1
mechanisms often disturb the users	1
mechanisms explained above. A shared	1
8.1. The table shows whether	1
8.1. Comparison of optimizations in	1
G values in the next	1
G values, and last all	1
Align by 16 __declspec( align(16))	1
Align arrays and big structures	1
c) The creation of a	1
c) 139 can sometimes be	1
&CriticalFunction_386; } // Now call	1
&CriticalFunction_386; } int main() {	1
(three on CodeGear compiler) integer	1
(three parameters on CodeGear compiler).	1
goto CFALSE; } } 34	1
goto DTRUE; } } else	1
testing. Here, you should be	1
testing. Trying to read the	1
feature. This includes static variables,	1
feature. All accesses to functions	1
interposition is intended to mimic	1
interposition feature that allows overriding	1
loads the library through the	1
loads the appropriate version of	1
*.a) or dynamic link libraries,	2
dispatchers are designed to handle	1
dispatchers up to date. A	1
Registers are a scarce resource	1
Registers are a scarce resource,	1
Event-based sampling: The profiler tells	1
Event-based sampling requires a CPU-	1
associated with dynamic memory allocation.	1
associated with profiling, but it	1
time-consumer in the program. Reading	1
time-consumer even for programs implemented	1
mechanism. The CPU dispatch mechanism	1
mechanism. See page 43 for	1
Optimizations in the compiler ..........................................................................................	1
Optimizations in the compiler 8.1	1
machines with embedded microcontrollers. I	1
machines use just-in-time compilation of	1
problem: 1. Relocation. All pointers	1
problem: (1) check for overflow	1
constructors, and any other constructors.	1
constructors, copy constructors, and any	1
References are useful for copy	1
References are safer to use	1
mutually incompatible. A function library	1
mutually incompatible. You may make	1
_mm_empty() as shown in example	1
_mm_empty() after the 64-bit vector	1
report that memset is deprecated.	1
report /Qopt-report -opt-report Table 18.2.	1
disturbing influences in order to	1
disturbing influences are removed, all	1
develop- ment in order to	1
develop- ment time when performance	1
negative. The method described above	1
negative. The last line is	1
facilities, binary trees, hash maps	1
facilities, easy GUI development, database	1
creation of a temporary object	1
creation of temporary objects for	1
warning for such optimizations with	1
warning from the compiler if	1
min = 100, max =	1
min && i <= max)	1
14.2 Bounds checking In C++,	1
14.2 Bounds checking .................................................................................................. 134	1
14.3 Use bitwise operators for	2
14.1 Use lookup tables Reading	1
14.1 Use lookup tables .................................................................................................	1
vectorclass manual for details. //	1
vectorclass www.agner.org/optimize/#vectorclass. The Intel vector	1
14.7 Don't mix float and	2
debugging. A debugger can execute	1
debugging. A command-line version of	1
Func(int a[], int & r)	2
(columns * sizeof(float)). Now, the	1
(columns * sizeof(float)) = 8	1
14.5 Integer division Integer division	1
14.5 Integer division...................................................................................................... 137 14.6	1
defined. The cost of dynamic	1
defined. This can cause all	1
-msse4.1 -mAVX -axSSE3, etc. (Intel	1
-msse4.1 /arch:SSE4.1 -mAVX /arch:AVX /QaxSSE3,	1
x^10 // loop for //	1
x^10 // return x^10 //	1
branches): if (level >= 11)	2
DoThisThreeTimesAWeek(); } 135 The if	1
DoThisThreeTimesAWeek(); } By giving each	1
-msse2 SSE3 instruction set Suppl.	1
-msse2 /arch:SSE2 -msse2 SSE3 instruction	1
logarithms, exponential functions, trigonometric functions,	2
default. This is less efficient	1
default. Position-independent code is inefficient,	1
WTL application is generally faster	1
WTL applications can be expected	1
_controlfp(0, _EM_OVERFLOW); // if above	2
load. The clock frequency is	1
load. A light-weight alternative is	1
select(b > 0, c +	2
framework. The optimized part of	1
framework. Obviously, the directly compiled	1
8.6 Optimization directives Some compilers	1
8.6 Optimization directives .............................................................................................. 82	1
synchronization between the different cores	1
synchronization between threads, such as	1
Without static, the logarithm would	1
Without optimization, the compiler needs	1
millisecond resolution and the critical	1
millisecond resolution. A much higher	1
sizeof(S1) = 16 is actually	1
sizeof(S1) would be 8 and	1
high-priority threads are areas where	1
high-priority thread can possibly block	1
development. This unit-testing is necessary	1
development. For example, the first	1
push and pop ebx. 9	1
push mov xor mov $B1$2:	1
Numerically Intensive Codes", by S.	1
Numerically Intensive Codes", SIAM 2001.	1
verify that all code branches	1
verify than a program where	1
us to compare two positive	1
us to manipulate the different	1
searching, and mathematical calculations. In	1
searching, or the specific literature	1
known. This information is contained	1
known. Example: // Example 8.5a	1
14.13 System programming .......................................................................................... 150	1
14.13 System programming Device drivers,	1
14.12 Position-independent code Shared objects	1
14.12 Position-independent code.................................................................................. 148 14.13	1
area. The nontemporal write instructions	1
area. Join identical branches The	1
14.19 static inline int lrint	1
14.19 below. The function rounds	1
rounding. This is unfortunate because	1
rounding. Pointer type conversion A	1
column; for (row = 0;	1
column; Do not swap the	1
dramatically for very large data	1
dramatically by unrolling the loop	1
148 It is possible to	1
148 14.13 System programming ..........................................................................................	1
8.5 Compiler optimization options All	1
8.5 Compiler optimization options ...................................................................................	1
Polynomial coefficients // Table //	1
Polynomial coefficients double Table[100]; int	1
temporarily. This is intended for	1
temporarily. Using the methods in	1
obscure examples where the reduction	1
obscure possibility of overflow. Table	1
14.1c is copied from static	1
14.1c void CriticalInnerFunction () {	1
142 unsigned int one :	1
142 14.10 Mathematical functions .......................................................................................	1
"assume no pointer aliasing" if	1
"assume no pointer aliasing" (if	1
properly and the memory released	1
properly aligned or not. The	1
issue. See my blog for	1
issue. But it is certainly	1
restarted anyway. Software distributors are	1
restarted anyway. Updates to the	1
Func2() { int a =	1
Func2() { int list[100]; Func1(list,	1
x--x----- ---x----- x---x---x x-xxx---- a*b*c=a*(b*c)	1
x--x----- --xx----- x-xxx---x x-xxx---x x	1
PCs. The clock frequency may	1
PCs. Therefore, it is even	1
8.2 Comparison of different compilers	1
8.2 Comparison of different compilers.............................................................................	1
Possible solutions to this problem	1
Possible solutions are: Avoid the	1
IDE's for D are not	1
IDE's (Integrated Development Environments) have	1
8.3 Obstacles to optimization by	2
obtained. If a loop contains	1
obtained. In the latter case,	1
C++: An optimization guide for	1
C++: Preprocessor directives. For example	1
sin(x); } 68 else {	1
sin(x); z = y +	1
delay. See page 43 about	1
delay. But if the loop	1
1.f; for (int n =	1
1.f; float nfac = 1.f;	1
Divisions can sometimes be eliminated	1
Divisions take longer time. It	1
7.32 Preprocessing directives ......................................................................................... 65	1
7.32 Preprocessing directives Preprocessing directives	1
largest_index = 0; for (i	1
largest_index = i; } }	1
wide, should be avoided because	1
wide, while an int is	1
list[i].a and list[i].b. It can	1
list[i].a = 1.0; list[i].b =	1
model. You may ignore the	1
model. Instead, I will make	1
7.33 Namespaces........................................................................................................... 65 8 Optimizations	1
7.33 Namespaces There is no	1
manipulating floating point variables Floating	1
manipulating floating point variables .........................	1
Dependency chains Modern microprocessors can	1
Dependency chains ................................................................................................ 22 3.16	1
additions. When used simply to	1
additions. Divisions take longer time.	1
MOVNTPD and MOVNTDQ require that	1
MOVNTPD _mm_stream_pd SSE2 Store 16	1
158 Integer variables can be	1
158 18 Overview of compiler	1
A; double Y = C;	1
A; x.b = B; x.c	1
cycle? In this manual, I	1
cycle? ...................................................................................... 16 3.2 Use	1
server. Use large data files	1
server. These problems should be	1
156 16.3 Worst-case testing Most	1
156 16.3 Worst-case testing ................................................................................................	1
fine-tuned for a particular set	1
fine-tuned for specific CPU brands	1
157 17 Optimization in embedded	2
draw the attention of software	1
draw each pixel or line	1
examples. The table can give	1
examples. You cannot expect a	1
class: // Example 7.38a. Multiple	1
class: class CGrandParent { public:	1
sharing the same cache is	1
sharing the same queue, list,	1
155 16.2 The pitfalls of	1
155 test. You can use	1
7.30 Exceptions and error handling	2
ways, with a line size	1
ways, as explained in chapter	1
predicted. The target address is	1
predicted. This is no problem	1
i<n; i++) is the same	1
i<n; ++i). But when the	1
dividing by 2 (See page	1
dividing repeatedly with the same	1
complications that make member pointers	1
complications with member pointers and	1
AVX, as explained on page	1
AVX, AVX2 Mathematical vector function	1
7.31 Other cases of stack	2
redo the calculations in a	1
redo the calculation in a	1
parallelization of code into multiple	1
parallelization in the code and	1
Matrix size Time per element	1
Matrix size Total kilobytes Time	1
.................................................................................. 16 3.3 Program installation	1
.................................................................................. 55 7.24 Unions ....................................................................................................................	1
a.store(aa+i); } } The Microsoft	1
a.store(aa+i); } } #if INSTRSET	1
0x7FFFFFFF) { // test bits	1
0x7FFFFFFF) { // check if	1
add, etc. SSSE3 a few	1
add, remove or modify objects	1
fed into the pipeline then	1
fed directly to the next	1
array, or approximately so. It	1
array, which it has calculated	1
AVX. These suffixes are listed	1
AVX. 5. The loop count	1
Alignd(X) X __attribute__((aligned(16))) #endif const	1
Alignd(X) __declspec(align(16)) X #else //	1
_mm_add_epi16(c, two); // Multiply b	2
waits for user input. The	1
waits until the first time	1
loops, then the transformation of	1
loops, etc. Optimizing database queries	1
Tuesday, Wednesday or Friday is	1
Tuesday, Wednesday, Thursday, Friday, Saturday	1
loops. 13.1 CPU dispatch strategies	1
loops. Consider the following example,	1
Increment and decrement operators The	1
Increment loop counter and go	1
cached as good as possible.	1
cached more efficiently than static	1
propagation, and loop-invariant code motion	1
propagation, etc. Whether you choose	1
exceeds an acceptable limit, then	1
exceeds 64 kbytes. This is	1
Wikipedia under CPU cache (en.wikipedia.org/wiki/L2_cache).	1
Wikipedia article on compiler optimization.	1
................................................................................................ 22 3.16 Execution unit	1
................................................................................................ 157 17 Optimization in	1
mask. The expression that is	1
mask. Poor reproducibility. Delays in	1
conclude that most variables in	1
conclude this section by summing	1
shared. You can't have public	1
shared. Any writable data section	1
relocated by the linker to	1
relocated (rebased) once more by	1
else. This normally belongs to	1
else. System code has to	1
FIFO queue should be implemented	1
FIFO manner? If objects are	1
Library" and "Integrated Performance Primitives".	1
Library" contains many functions for	1
dealing with in a particular	1
dealing with this problem: 1.	1
Hello() { cout << "Hello	2
Various development tools for supporting	1
Various graphics function libraries and	1
software, it is not unusual	1
software, but it is quite	1
Overflow may occur in multiplication	1
Overflow behaves differently on signed	1
multiplications and divisions are given	1
multiplications only. The following algorithm	1
differences were observed between the	1
differences due to the design	1
2.2, C = 3.3; //	1
2.2, C = 3.3; double	1
machine. The best Java machines	1
machine. The virtual processor may	1
containers. If the program logic	1
containers. See page 90. 15	1
tree. On older processors, a	1
tree. Is searching needed after	1
approach to CPU dispatching. Underestimating	1
approach to error handling. You	1
dynamically. The advantages of dynamic	1
dynamically. Arrays that are too	1
__asm__ (".type CriticalFunction, @gnu_indirect_function"); //	1
__asm__ ("CriticalFunction"); typeof(CriticalFunction) * CriticalFunctionDispatch(void)	1
difficulties making floating point register	2
deleting the object then you	1
deleting containers. If the program	1
discussion. Integer to float conversion	1
discussion. 7.33 Namespaces There is	1
...................................................................................................................... 96 9.9 Access data	1
...................................................................................................................... 33 7.5 Booleans................................................................................................................... 33	1
int) are only slightly less	1
int) instead of bool in	1
(y) { int a[1000]; F1(a);	1
(y) { F1(a); } else	1
purpose, or you may use	1
purpose, you must consider if	1
algorithms, are not suited for	1
algorithms, cannot easily be implemented	1
&CriticalFunction_SSE2; } // Default version	1
&CriticalFunction_SSE2; } else { //	1
Disp(); class C1 : public	1
Disp(); void Hello() { cout	1
consistent for the function call.	1
consistent modularity and reusable classes.	1
1.23456. The conclusion to this	1
1.23456. But we will not	1
v; if (u.i * 2	1
v; if (u.i > v.i)	1
(b, c); // Compare each	2
reveal a zigzag course that	1
reveal things that can be	1
created. There is no 51	1
created. Far Systems with segmented	1
denormal numbers in case of	1
denormal numbers. You may, in	1
optional and off by default	1
optional commercial license Table 12.4.	1
op. Intel Core 2 0.63	1
op. AMD Opteron K8 0.38	1
experiment are given below. The	1
experiment where 10 elements were	1
Induction++; } } The compiler	1
Induction++; ; point to a[i+2]	1
precisions when the code is	1
precisions take no extra time.	1
Difficult cases In most cases,	1
Difficult cases........................................................................................................ 124 2 13.4	1
interpreter for Basic. A compiler	1
interpreter which interprets the intermediate	1
(PLT). The memory space becomes	1
(PLT). And whenever a public	1
order(int x); const int size	1
order(int x); 136 ... for	1
digital operation can often be	1
digital building blocks such as	1
i++){ list[i] = i %	1
i++){ list[i] += i /	1
0.40 n.a. 1.00 0.35 0.29	1
0.40 0.30 4.5 0.82 0.59	1
z; a = x >	1
z; bool b; if (b)	1
139 can sometimes be replaced	1
139 14.7 Don't mix float	1
0.44 0.12 memcpy 16kB aligned	1
0.44 0.40 n.a. 1.00 0.35	1
cc); } // Entry to	1
cc); } #endif // INSTRSET	1
__GNUC__ and not not _WIN32	1
__GNUC__ #define pure_function __attribute__((const)) #else	1
covered the address range from	1
covered in manual 3: "The	1
fashioned C style with character	1
fashioned C style as character	1
alloca. This is a function	1
alloca. 9.7 Container classes Whenever	1
Efficient caching is therefore becoming	1
Efficient conversion from float or	1
spaces for different arrays even	1
spaces that are no longer	1
$B1$1: mov mov mov lea	1
$B1$1: push mov xor mov	1
362880, 3628800, 39916800, 479001600}; if	1
362880, 3628800, 39916800, 479001600}; ...	1
(line size) = (total cache	1
(line size) % (number of	1
column. The access is faster	1
column. Number 17 will evict	1
complex, that there is more	1
complex, but not the compiled	1
3.7 File access Reading or	1
3.7 File access................................................................................................................ 20 3.8	1
cheap if they are predicted	1
cheap compiler for 32-bit Windows,	1
purity. In many cases it	1
purity. For example, compilers cannot	1
0.f, 0.f, 1.f); // initialize	1
0.f, 1.f); // initialize sum	1
14.23b and 14.30 will therefore	1
14.23b union { double d;	1
below). The 256-bit YMM vectors	1
below). A variable cannot be	1
division, which is slow unless	1
division, square root and mathematical	1
received by an interrupt should	1
received data in a static	1
degradation of performance on AMD	1
degradation in code caching for	1
"override" feature. This includes static	1
"override" feature. All accesses to	1
11.2b const int size =	1
11.2b was an odd number	1
matrix[j][0] is calculated internally as	1
matrix[j][0] = i; } Here,	1
x--xx---- (a&&b) || (!a&&c) =	1
x--xx---- (a&&b)||(a&&!b)=a x--xx---- (a&&b) ||	1
Sometimes, the best way to	1
Sometimes, functions are kept in	1
distribute function libraries in this	1
distribute all the dynamic libraries	1
"worst case" and "best case"	1
"worst case" counts. In any	1
overdetermined in the sense that	1
overdetermined Boolean variables are stored	1
ms. This delay is just	1
ms. If the response time	1
thing. Example: // Example 7.12	1
thing. An expression with multiple	1
squares: for (r1 = 0;	1
squares: const int TILESIZE =	1
MemberPointer is declared. Therefore, it	1
MemberPointer is declared. Avoid multiple	1
www.intel.com. (See also page 119).	1
www.intel.com. Manual on using the	1
TILESIZE) { for (c1 =	1
TILESIZE) { // Loop r2	1
sources. The above code can	1
sources. For example, the Boost	1
first-in-last-out fashion. It is used	1
first-in-last-out nature of the stack.	1
3628800, 39916800, 479001600}; if ((unsigned	1
3628800, 39916800, 479001600}; ... int	1
uncommon for software teachers to	1
uncommon for virus scanners to	1
coprocessor or graphics accelerator card.	1
coprocessor might also be used	1
23; // add n to	1
23; // fractional part unsigned	1
82 8.7 Checking what the	1
82 Keywords that work on	1
relates to security. There are	1
relates to security. Standard C++	1
7.9 Smart pointers A smart	1
7.9 Smart pointers .......................................................................................................... 38	1
alignment. See www.agner.org/optimize/cppexamples.zip for examples	1
alignment. __declspec(align(16)) or __attribute__((aligned(16))). Specifies	1
7.5 Booleans The order of	1
7.5 Booleans................................................................................................................... 33 7.6 Pointers	1
deal of programming experience before	1
deal of research on CPU	1
binutils version 2.20 or later	1
binutils version 2.20, glibc version	1
7.6 Pointers and references Pointers	1
7.6 Pointers and references ............................................................................................	1
Specific optimization topics ......................................................................................... 132	1
Specific optimization topics 14.1 Use	1
__attribute__((const)) #else #define pure_function #endif	1
__attribute__((const)) (Linux only). Specifies a	1
unnecessary for the user and	1
unnecessary functions Some programming textbooks	1
b[1000]; }; if (y) {	1
b[1000]; F2(b); } } Here	1
7.3 Floating point variables and	2
performing an illegal operation that	1
performing software product is one	1
once, rather than each time	1
once, while the runtime address	1
s1 = 0, s2 =	1
s1 += a[i+1]; s2 +=	1
(called static if), but no	1
(called x86) of the standard	1
84 for (i = 0;	1
84 9 Optimizing memory access	1
"C" int CriticalFunction (); __asm__	1
"C" declaration and the object	1
respects and highly compatible with	1
respects relevant to software optimization.	1
License license included in compiler	1
License shall automatically come into	1
ISO/IEC TR 18015, "Technical Report	1
ISO/IEC TR18015 Technical Report on	1
command-line version of the C++	1
command-line versions without an IDE.	1
i++ are as fast as	1
i++ ;checkifi<100 ; repeat loop	1
137). The second thing we	1
137). This also applies to	1
template. The powN template is	1
template. 57 Templates are efficient	1
General case, N is not	1
General Public License, optional commercial	1
container, then a linear array	1
container, preferably with contiguous memory.	1
integrated in the CPU chip.	1
integrated development environment (IDE) supports	1
started. The length of a	1
started. It takes longer time	1
transposes a matrix and stores	1
transposes a quadratic matrix, i.e.	1
container. STL deque (doubly ended	1
container. Can the container be	1
(*SelectAddMul_pointer)(aa, bb, cc); } //	1
(*SelectAddMul_pointer)(aa, bb, cc); } #endif	1
crash the program. 16.2 The	1
crash on old operating systems	1
1.1, B = 2.2, C	2
reserve the amount of memory	1
reserve resources for other virtual	1
Older operating systems lack the	1
Older CPUs with execution units	1
deleted. Smart pointers are used	1
deleted. User work that needs	1
Asmlib Gnu 64 bit -fno-builtin	1
Asmlib My own function library	1
Both the executable file and	1
Both code cache use and	1
&Object2; p->Hello(); } // Non-polymorphic	1
&Object2; p2->Hello(); // Writes "Hello	1
a:4; int b:2; int c:2;	2
(-a)*(-b)=a*b a/a=1 ----x---x a/1=a xxxxxxxxx	1
(-a)*(-b)=a*b ---xxx--- a/a=1 --------x a/1=a	1
left for transferring additional parameters.	1
left out if exceptions can	1
c2++) { swapd(a[r2][c2],a[c2][r2]); } }	2
Nested loops are predicted well	2
ipow faster than pow The	1
ipow (double x, unsigned int	1
comparison, which is fast. Calculating	1
comparison, bit operations and shift	1
produced regularly. Intel: "Intel C++	1
produced regularly. AMD: "Software Optimization	1
NotPolymorphic(); virtual void Disp(); void	1
NotPolymorphic(); }; // Any function	1
a*b+a*c = a*(b+c) - n.a.	1
a*b+a*c = a*(b+c) - -(-a)	1
11.1a to 11.1b automatically, although	1
11.1a float a, b, c,	1
support, and the program will	1
support, then call _mm256_zeroupper() before	1
forget to make the local	1
forget to delete the object.	1
inverted bit-mask: bc = _mm_andnot_si128(mask,	1
inverted mask. The expression that	1
11.1b float a, b, c,	1
11.1b automatically, although it appears	1
80. The keyword static, when	1
80. The difference lies in	1
i. The size of an	1
i. This index must be	1
worked well in tests on	1
worked sufficiently fast on a	1
needed: // Example 7.40c x.abc	1
needed: // Example 7.44 class	1
Introduction This manual is for	1
Introduction ....................................................................................................................... 3 1.1 The	1
i+=3){ list[i] = 0; list[i+1]	1
i+=3){ list[i] =0; list[i+1] =	1
PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROCNEAR ;	1
PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROC NEAR	1
-(-a)=a - - x -	1
-(-a)=a --xxxxxx- a-(-b)=a+b ---xxx-x- a+0=a	1
"IA-32 Intel Architecture Software Developers	2
loaded, the loader calls the	1
loaded, but waits until the	1
(a&&b&&c) = a&&(b||c) (a&&!b) ||	1
(a&&b&&c) = a&&b (a&&b) ||	1
a+0=a a*0=0 a*1=a (-a)*(-b)=a*b a/a=1	1
a+0=a x-xxxxxx- a*0=0 --xxxx-xx a*1=a	1
7.15b below shows. It is	1
7.15b SafeArray <float, 100> list;	1
grows by only 50% or	1
grows during program execution then	1
0. The constant N1 could	1
0. The division is inexact	1
r2++) { for (c2 =	2
index, just as a normal	1
index, i. This index must	1
time-consumers are discussed in the	1
time-consumers mentioned in the above	1
enough. A hash table increases	1
enough. For example, some programmers	1
720, 5040, 40320, 362880, 3628800,	2
tedious and the code becomes	1
tedious indeed. It is possible	1
correctly. The speed test should	1
correctly. A code branch for	1
flexible, but quite inefficient in	1
flexible, well tested, and very	1
ARRAYSIZE = 100; float list[ARRAYSIZE];	1
ARRAYSIZE && list[i] > 1.0)	1
annotation in the assembly output	1
annotation option if you want	1
respectively. (In 64-bit mode, the	1
respectively. Increment and decrement operators	1
1.1 The costs of optimizing	2
43). The Boolean operations can	1
43). There is no need	1
^= 0x80000000; // flip sign	1
^= 0x80000000; because this is	1
1's is unchanged, while the	1
1's when bb[i] > 0	1
hexadecimal numbers because all the	1
hexadecimal numbers, we have a	1
u, v; if (u.i *	1
u, v; if (u.i >	1
extending the sign-bit if the	1
extending with zero-bits if unsigned.	1
^, ~ are useful for	1
^, ~, <<, >> can	1
systematic and well thought-through approach	1
systematic manner to make sure	1
forces the compiler to store	1
forces the variable to be	1
rolled out by 4 float	1
rolled out by 2. (See	1
__attribute__ ((visibility ("internal"))) __attribute__ ((visibility	1
__attribute__ ((visibility ("internal"))) Vectorize #pragma	1
Java, use dynamic memory allocation	1
Java, C#, Visual Basic, etc.	1
ivdep Assume function is pure	1
ivdep __restrict #pragma ivdep Assume	1
Gnu. It is expected to	1
Gnu. There is a problem	1
recursion must always end with	1
recursion template<> class powN<true,1> {	1
^a = 0 a ^	1
^a = 0 - n.a.	1
algebra, it is possible to	1
algebra, we may write: y	1
management and garbage collection. A	1
management and garbage collection, as	1
lots of data. Use an	1
lots of things you can	1
163 20 Copyright notice ..........................................................................................................	1
163 Internet forums Several internet	1
projects, it is recommended to	1
projects, it is sufficient to	1
160 19 Literature ..................................................................................................................... 163	1
160 /Qparallel -parallel -openmp -static	1
(This is faster than the	1
(This eliminates the need for	1
Mac. The Gnu compiler is	1
Mac. Supports parallel processing, OpenMP	1
chip. Such units can be	1
chip. Such hybrid solutions are	1
wrapped into a class or	1
wrapped into a class with	1
perfectly on a Pentium 4.	1
perfectly varies between 9 and	1
zero); // Use mask to	1
zero); // AND each element	1
added? If search facilities are	2
Addison-Wesley, 1996. These two books	1
Addison-Wesley, 2003. Contains many bit	1
counter, which is calculated fast	1
counter, comparing the loop counter	1
modifier can make function calls	1
modifier will be stored in	1
-Ofast /O3 -O3 Interprocedural optimization	1
-Ofast -mveclibabi -fopenmp /Qopenmp -m32	1
test. You can use the	1
test. disable power-save options in	1
respond to a command or	1
respond quickly to keyboard or	1
Intensive Codes", by S. Goedecker	1
Intensive Codes", SIAM 2001. Advanced	1
planning phase in order to	1
planning stage that a detailed	1
C2 : public CHello {	1
C2 Object2; CHello * p;	1
R value in one vector,	1
R values first, then all	1
release version of object files	1
release version with all relevant	1
fraction. The sign is stored	1
fraction. For example, to test	1
Friday is set in the	1
Friday = 0x20, Saturday =	1
textbooks recommend that every function	1
textbooks recommend object oriented programming	1
slower. Many compilers have an	1
slower. Another disadvantage is that	1
9.7 Container classes Whenever dynamic	1
9.7 Container classes ..................................................................................................... 93	1
c1; int c1::*MemberPointer; Here, the	1
c1; c2 < c1+TILESIZE; c2++)	1
compilers, system database, and other	1
compilers, etc., as is commonly	1
subtracting 1 from -128 generates	1
subtracting n from the exponent	1
Returns a pointer to the	1
Returns time stamp counter //	1
insight can lead to a	1
insight you gain by testing	1
a*b=b*a x n.a. x x	1
a*b=b*a a+b+c=a+(b+c) (a+b)+c=a+(b+c) --xx----- (a&&b)	1
r1+TILESIZE; r2++) { for (c2	2
0/a = 0 - Divide	1
0/a = 0 because this	1
hope that such feature will	1
hope that future compilers will	1
Portability C++ is fully portable	1
Portability note: This example is	1
compilers). The best performance is	1
compilers). The representation of float,	1
Catch floating point overflow but	1
Catch exceptions in this block:	1
99% of the time is	2
"; // call polymorphic child	1
"; Disp(); class C1 :	1
Sab {int a; int b;};	1
Sab ab[size]; int i; ...	1
contribution to the total execution	1
contribution to the total calculation	1
distinction between the latency and	1
distinction between leaf functions and	1
Update induction variable Y //	1
Update induction variable Z }	1
Supported compilers Intel, Microsoft Intel,	1
Supported operating systems Windows, Linux,	1
ment in order to make	1
ment time when performance is	1
typeof(CriticalFunction) * CriticalFunctionDispatch(void) { //	1
typeof(CriticalFunction) * CriticalFunctionDispatch(void) __asm__ ("CriticalFunction");	1
ones that are available to	1
ones mentioned in table 9.2,	1
busy doing the spell checking.	1
busy concentrating on important work.	1
optimally on any brand of	1
optimally aligned. See page 120	1
Fast function calling. __fastcall or	1
Fast versions of common string	1
funny things with the sign	1
funny looking name ?Func@@YAXQAHAAH@Z is	1
queries is beyond the scope	1
queries can often be optimized	1
saying that it doesn't work	1
saying please install this important	1
normal. This happens when a	1
normal. 157 17 Optimization in	1
1" // Writes "Hello 2"	2
updated. It is tempting to	1
updated. Most copy protection schemes	1
clumsy and tedious. The code	1
clumsy AND-OR construction in example	1
int)u; // Faster, but risk	1
int)u; 14.9 Using integer operations	1
trivial programming work automatically. The	1
trivial tasks such as copying	1
a[SIZE][SIZE]) { // function to	1
a[SIZE][SIZE]) { // Define macro	1
x64 141 #include <emmintrin.h> static	1
x64 (Visual Studio 2005). Borland	1
systems). 28 Dynamic memory allocation	1
systems). 42 If you access	1
wasted on software that is	1
wasted on runtime dispatch to	1
Public distribution and mirroring is	1
Public License, optional commercial license	1
dummy elements at the end	1
dummy element to list and	1
symbolic link to the appropriate	1
symbolic link. Use different executables.	1
fetched and decoded in several	1
fetched from the cache in	1
0x40 bytes from address 0x2700	1
0x40 }; Weekdays Day; if	1
(a&b)|(a&c) = a&(b|c) - n.a.	1
(a&b)|(a&c) = a&(b|c) x-xxxx--x (a|b)&(a|c)	1
relocation, but only self- relative	1
relocation, especially in 32-bit mode.	1
(The Microsoft compiler supports this	1
(The PGI compiler supports intrinsic	1
Mixing float and double is	1
Mixing object files from different	1
decides which function to use	1
decides whether to repeat or	1
<xmmintrin.h> _mm_setcsr(_mm_getcsr() | 0x8040); See	1
<xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It is strongly	1
Func1(x) + 1.; } Here,	1
Func1(x) * Func1(x) + 1.;	1
5040, 40320, 362880, 3628800, 39916800,	2
ability to define function names	1
ability to override public symbols,	1
3, 5 and 9. Multiplications	1
3, 4, 6, 9 and	1
3.12 Network access Some application	1
3.12 Network access ...................................................................................................... 21	1
123 and static const int	1
123 correspond to any known	1
provoke an error message in	1
provoke error // Return reference	1
VectorC A commercial compiler for	1
VectorC v. 2.1.7, 2004. No	1
processes. The data section is	1
processes. The profiler measures not	1
((visibility ("internal"))) __attribute__ ((visibility ("internal")))	1
((visibility ("internal"))) Vectorize #pragma vector	1
stronger for level-2 cache contentions	1
stronger when they are long.	1
accessible from other modules. You	1
accessible from compilers that have	1
reusable and well- tested library	1
reusable classes. Security The most	1
procedures for installation and uninstallation	1
procedures are inefficient. If a	1
!(a < b) = (a	1
!(a || b) a &&	1
Overview of compiler options Table	1
Overview of compiler options....................................................................................... 160	1
ammintrin.h AMD XOP ammintrin.h (MS)	1
ammintrin.h (MS) xopintrin.h (Gnu) AMD	1
sequences of code. The second	1
sequences of operations. A complex	1
stop the program in case	1
stop the thread. The cost	1
expansions of the register size	1
expansions and Newton-Raphson iterations. Here	1
bit. The fact that the	1
bit. We can tell it	1
Conclusion There is a lot	1
Conclusion .......................................................................................................... 120 13 Making	1
linking. The file http://www.agner.org/optimize/asmlib.zip contains	1
linking. A dynamic library can	1
Free Documentation License shall automatically	1
Free trial versions are available	1
bottlenecks is to put measurement	1
bottlenecks can lead to a	1
interrupts and task switches; so	1
interrupts at certain events, for	1
legacy code, specific preferences for	1
legacy software. It may even	1
segment by using the keyword	1
segment then it is recommended	1
__unix__ __linux__ x86 platform _M_IX86	1
__unix__ __linux__ __unix__ __linux__ x86	1
attempts to set seconds to	1
attempts to translate these addresses	1
Code that is compiled for	1
Code caching will be better	1
Day; if (Day & (Tuesday	1
Day; if (Day == Tuesday	1
swapd(a[r2][c2],a[c2][r2]); } } } //	1
swapd(a[r2][c2],a[c2][r2]); } } } }	1
bb, cc); } // Entry	1
bb, cc); } #endif //	1
power. There are various ways	1
power. Connecting several standard PC's	1
consumer to many hard working	1
consumer if it involves allocation	1
parenthesis around the constant subexpression.	1
parenthesis around such a subexpression	1
Security The most serious problem	1
Security software that is part	1
limit, then you should test	1
limit, etc. In most cases,	1
~ for NOT. Instead, you	1
~ are useful for Boolean	1
swapd(a[r][c], a[c][r]); // swap elements	1
swapd(a[r][c], a[c][r]); void test ()	1
Single precision is good if	1
Single precision division, square root	1
0.28 strlen 128 bytes Intel	1
0.28 0.22 memcpy 16kB unaligned	1
Booleans The order of Boolean	1
Booleans as output can produce	1
0.24 n.a. 1.00 0.25 0.28	1
0.24 0.25 0.24 n.a. 1.00	1
Caching of code and data	2
interfere with any function or	1
interfere with real time applications.	1
-fomit- frame- pointer No runtime	1
-fomit- frame- pointer -fomit- frame-	1
0.25 0.28 0.22 memcpy 16kB	1
0.25 0.24 n.a. 1.00 0.25	1
_mm_mullo_epi16 (b, c); // Compare	2
FMA4 instruction set. This instruction	1
FMA4 fma4intrin.h (Gnu) all intrin.h	1
distribution to a limited audience	1
distribution and mirroring is not	1
>> can test or manipulate	1
>> n with a suitable	1
do, at least in some	1
do, however, often write expressions	1
appropriate. 8. Avoid branches at	1
appropriate. Compiler-specific keywords Fast function	1
Please skip the following explanation	1
Please note that my optimization	1
Network access Some application programs	1
Network access ...................................................................................................... 21 3.13	1
__int64 64-bit Linux: unsigned long	1
__int64 64 -263 263-1 int64_t	1
mispredictions, floating point exceptions, etc.	1
mispredictions, etc. These counters can	1
rows; i++) for (j =	1
rows; i++) { j =	1
together. The link order is	1
together. Data members of a	1
organize the code in a	1
organize data to optimize caching.	1
bitfield is less efficient than	1
bitfield by the use of	1
15.1b. Calculate integer power using	1
15.1b. Branches are implemented by	1
sees the constant 8 rather	1
sees a relative reference to	1
Interpreted code is very inefficient	1
Interpreted languages are out of	1
treat a variable or object	1
treat non-Intel CPUs in a	1
a[SIZE][SIZE], double b[SIZE][SIZE]) { int	2
(a<b && b<c && a<c)	1
(a<b && b<c) Multiply by	1
processor). Integer division by a	1
processor). Optimizing compilers will often	1
occurred. // Reset floating point	1
occurred. This makes it possible	1
corresponding instruction set. If you	1
corresponding bitwise operators &, |,	1
memset(a, 0, sizeof(a)); // copy	1
memset(a, 0, sizeof(a)); } int	1
m;} int a, b; a	1
m;} template <int m> int	1
recovering or for issuing an	1
recovering from error conditions in	1
Sunday, Monday, etc. are defined	1
Sunday, Monday, Tuesday, Wednesday, Thursday,	1
incompatible. A function library with	1
incompatible. You may make separate	1
2;} // add 2 to	1
2;} int a; Plus2 (&a);	1
fast, compact, and simple to	1
fast, -fp- model fast=2 Simple	1
University of Denmark. Copyright 	1
University courses in programming nowadays	1
log, and logarithms take a	1
log, exp, sin, etc. Overriding	1
begins with #) are costless	1
begins at the label $B1$2:.	1
14.26 does not check for	1
14.26 union { float f;	1
14.27 union { float f;	1
14.27 assumes that we know	1
somewhat more complicated because various	1
somewhat less efficiently when data	1
predictable. It may be useful	1
predictable. For example: // Example	1
subtraction, multiplication, etc. is still	1
subtraction, comparison, bit operations and	1
14.23 page 143. The trick	1
14.23 union { float f;	1
slight degradation in code caching	1
slight imprecision in some rare	1
unit. For example, it may	1
unit. Various graphics function libraries	1
direct access to hardware interfaces	1
direct hardware access. Available protocols	1
generic version that is compatible	1
generic branch, which is the	1
unit, but this unit is	1
unit, either on a graphics	1
invalid. The heap manager will	1
invalid. Boolean variables are overdetermined	1
heavily on table lookup or	1
heavily loaded. 21 3.13 Memory	1
self- relative addresses in 32-bit	1
self- relative addresses. Therefore, the	1
log2 a global const variable	1
log2 = log(2.0); ... }	1
counters. A performance monitor counter	1
counters. My test tool supports	1
speed, memory economy and small	1
speed, memory economy, cache efficiency	1
(!a&&c) = a ? b	1
(!a&&c) || (b&&c) = a	1
[] array index operator }	1
[] operator will detect an	1
122. The code becomes more	1
122. The Intel compiler can	1
messages to the user. Making	1
messages saying please install this	1
x[]); void F3(bool y) {	1
x[]); void F2(float x[]); void	1
only) -O3 or (requires no	1
only) (Intel CPU only) -O3	1
although it appears to be	1
although slightly less efficiently. This	1
primitive programming style that doesn't	1
primitive operations in the sense	1
Goedecker and Adolfy Hoisie: "Performance	1
Goedecker and A. Hoisie, SIAM	1
Model-specific dispatching There may be	1
Model-specific dispatching .................................................................................... 124 13.3	1
-fno-rtti Assume no pointer aliasing	1
-fno-rtti /GR- -fno-rtti Assume no	1
initialization, or if the type	1
initialization, condition, and increment. The	1
largest_abs = 0; int i,	1
largest_abs = absvalue; largest_index =	1
implementations. However, these languages have	1
implementations. 7.22 Inheritance An object	1
24, 120, 720, 5040, 40320,	2
studying the bottlenecks can lead	1
studying a piece of code	1
87). There is no need	1
87). Data caching is poor	1
contentions. See page 87 for	1
contentions. Use simple method. //	1
SafeArray { protected: T a[N];	1
SafeArray <float, 100> list; //	1
58 If it is known	1
58 shows an example of	1
increasingly important. A virtual processor	1
increasingly blurred as the standard	1
accurate and reproducible as possible.	1
accurate for the purpose of	1
efforts in optimizing library functions	1
efforts on the time consuming	1
starts. The user may not	1
starts. The disadvantage is that	1
i/2+r. The instructions mov ebx,eax	1
i/2+r. The next instruction mov	1
reader has a good knowledge	1
reader what is happening. It	1
usability, program compactness, and execution	1
usability, but I think that	1
template<> class powN<true,0> { public:	1
template<> class powN<true,1> { public:	1
low-level C language as a	1
low-level optimizations. Most C++ compilers	1
available: // Example 7.6. Set	1
available: // Example 12.4c. Same	1
_controlfp_s(&dummy, 0, _EM_OVERFLOW); // _controlfp(0,	2
mangled function name ; start	1
mangled function name ;startofFunc ;	1
Transforming serial code for vectorization	1
Transforming serial code for vectorization.............................................................	1
contend for the same cache	2
collector at inconvenient times. A	1
collector which is likely to	1
int)n < 4) { //	1
int)n < 13) { //	1
Far storage, far pointers, and	1
Far Systems with segmented memory,	1
factorials: static const int FactorialTable[13]	1
factorials: const int FactorialTable[13] =	1
........................................................................................ 53 7.21 Runtime type	1
........................................................................................ 109 12.5 Using vector	1
compares the array pointer eax	1
compares eax with 100 and	1
shows. The best way to	1
shows. It is accessed with	1
By giving each constant a	1
By Agner Fog. Technical University	1
certainty that the operands have	1
certainty which version of a	1
1-bit in binary representation of	1
1-bit removed. If N is	1
Or it might be possible	1
Or #include <ia32intrin.h> etc. //	1
Programs that produce streaming audio	1
Programs using such a framework	1
operation, which is very fast.	1
operation, which is much faster.	1
closed. The same method can	1
closed. The file will remain	1
source. It comes with most	1
source. Supports all x86 platforms.	1
:1;//signbit }; struct Sdouble {	1
:1;//signbit }; struct Slongdouble {	1
avoided, if possible, and replaced	1
avoided, there are various ways	1
book on optimization of C++	1
book "Performance Optimization of Numerically	1
avoided. The disadvantage is that	1
avoided. 37 A compiler has	1
EMMS } const int SIZE	1
EMMS instruction before any floating	1
immediately before the code to	1
immediately before the loop or	1
sizeof(a)); // copy a to	1
sizeof(a)); } int Size() {	1
105). If the AVX instruction	1
105). Using the SSE2 instruction	1
usage in kernel code" in	1
usage convention says that a	1
fix the thread to a	1
fix the problem and make	1
b[SIZE][SIZE]) { int r, c;	2
press or mouse move. It	1
press break while the program	1
sorting and searching, or the	1
sorting algorithms, are not suited	1
(*.dll, *.so). The mechanism of	1
(*.dll, *.so). There are several	1
1.00 0.25 0.28 0.22 memcpy	1
1.00 0.35 0.29 0.28 strlen	1
, longdoublevalue ( 1)sign 2exponent	1
, doublevalue ( 1)sign 2exponent	1
efficiently. This method is inefficient,	1
efficiently. It is therefore recommended	1
word static is removed from	1
word processor the user expects	1
B2 { public: int c;	1
B2 b2; int c; };	1
10.1 Hyperthreading Some versions of	1
10.1 Hyperthreading ..................................................................................................... 103 11	1
Converting an integer to a	1
Converting class objects Conversions involving	1
matrix. For example, a library	1
matrix. My experimental results in	1
B; for (x = 0;	1
B; x.c = C; Assuming	1
divisions. It is recommended to	1
divisions. Example: // Example 14.17a	1
chains, especially loop-carried dependency chains	1
chains, namely the two induction	1
coprocessors is beyond the scope	1
coprocessors to take care of	1
x.a = A; x.b =	1
x.a = y.a + 1.;	1
effect. GOT and PLT tables	1
effect. Which method you use	1
keyboard and mouse inputs when	1
keyboard or mouse input. It	1
39916800, 479001600}; if ((unsigned int)n	1
39916800, 479001600}; ... int i,	1
Approximate exp(x) for small x	2
Table[x] = A*x*x + B*x	1
Table[x] = Y; Y +=	1
restriction on x. It is	1
restriction from a pointer. It	1
x.c = C; Assuming that	1
x.c = y.c + 3.;	1
misleading results or fail completely	1
misleading reports of which functions	1
#ifdef _MSC_VER // If Microsoft	1
#ifdef __GNUC__ #define pure_function __attribute__((const))	1
.................................................................................................. 18 3.4 Automatic updates	1
.................................................................................................. 134 14.3 Use bitwise	1
Sum of a list float	1
Sum of a list, rolled	1
x.b = B; x.c =	1
x.b = y.b + 2.;	1
CPUs". A branch instruction takes	1
CPUs". 9.3 Functions that are	1
shr add sar add mov	1
shr ebx,31 copies the sign	1
each. The critical stride is	1
each. The type __m128 defines	1
0/a=0 ---x---xx (-a==-b)=(a==b) ---xx---- (a+c==b+c)=(a==b)	1
0/a=0 ---xx--xx (-a==-b)=(a==b) ---xx---- (-a>-b)=(a<b)	1
replacing a function call with	1
replacing an integer variable by	1
1.0f + b * 1.5f;	1
1.0f : 2.5f; If we	1
manual, but you should be	1
manual, I am using CPU	1
involve the loading of several	1
involve a high overhead cost	1
Optimize for speed /O2 or	1
Optimize function #pragma optimize(...) Fastcall	1
list[i]; This has a long	1
list[i]; sum2 += list[i+1];} sum1	1
initialize to x^0/0! // n	1
initialize sum for(inti=0;i<16;i+=4){ //Loopby4 s	1
117 A C++ implementation may	1
117 12.7 Mathematical functions for	1
previously in the code. Example:	1
previously required a PC. Similarly,	1
113 Number of simultaneous lookups	1
113 12.6 Transforming serial code	1
root and mathematical functions are	1
root and mathematical functions take	1
statistics, and the "Intel Performance	1
statistics, signal processing and image	1
times, one for the SSE2	1
times, even for simple tasks.	1
obstacle of possible pointer aliasing	1
obstacle to vectorization. The newest	1
Fog. Technical University of Denmark.	1
Fog. Public distribution and mirroring	1
12.8 Aligning dynamically allocated memory	1
12.8 Aligning dynamically allocated memory.................................................................	1
IDE with many of the	1
IDE on some systems. If	1
12.9 Aligning RGB video or	2
removing the call to CriticalFunction	1
removing superfluous code, but there	1
setup may look like this:	1
setup but slow or completely	1
_LP64 Windows platform _WIN32 _WIN32	1
_LP64 _WIN64 _LP64 Windows platform	1
type, a pointer, a reference,	1
type, but you cannot always	1
b.load(bb+i); // Load eight consecutive	1
b.load(bb+i); c.load(cc+i); a = select(b	1
factorials so that we don't	1
factorials don't depend on x	1
subroutine for the critical innermost	1
subroutine if it is only	1
later. The AVX instruction set	1
later. Example: // Example 14.18a	1
12.4 Using intrinsic functions It	1
12.4 Using intrinsic functions ........................................................................................	1
12.5 Using vector classes .............................................................................................	1
12.5 Using vector classes Programming	1
manipulations of floating point expressions	1
manipulations on integer expressions (except	1
leaks and other common programming	1
leaks if you forget to	1
says that the behavior of	1
says that a function is	1
12.6 Transforming serial code for	2
140). The SSE2 instruction set	1
140). Mathematical functions must use	1
12.7 Mathematical functions for vectors	1
12.7 Mathematical functions for vectors........................................................................	1
52 or class is 128	1
52 , longdoublevalue ( 1)sign	1
obey any specific calling conventions	1
obey certain rules about register	1
72. It is therefore possible	1
72. You have to set	1
b*a - n.a. (a+b)+c =	1
b*a (a+b)+c=a+(b+c) a+b+c=c+b+a a+b+c+d =	1
95 and 120 for discussion	1
95 not needed. You may	1
12.1 AVX instruction set and	2
time-critical code. 7.32 Preprocessing directives	1
time-critical part of the code	1
12.3 Automatic vectorization ......................................................................................... 107	1
12.3 Automatic vectorization Good compilers	1
universal solution is best for	1
universal algorithm (e.g. QuineMcCluskey or	1
Suppl. SSE3 instr. set SSE4.1	1
Suppl. SSE3 tmmintrin.h SSE4.1 smmintrin.h	1
crash. See page 122 for	1
crash. Furthermore, it is not	1
a+b+c+d = (a+b)+(c+d) a*b+a*c=a*(b+c) a*x*x*x	2
99 read from the same	1
99 10 Multithreading.............................................................................................................. 101 10.1	1
Remove branch that is always	1
Remove right-most 1-bit in binary	1
interpreters, just-in-time compilers, system database,	1
interpreters, just-in-time compilers, etc., as	1
9. Avoid table lookup at	1
9. Multiplications are done implicitly	1
any, is usually called in	1
any, must be called before	1
thread-safe function should never use	1
thread-safe functions. A thread-safe function	1
F3(bool y) { if (y)	1
F3(bool y) { union {	1
exclusive access by each thread.	1
exclusive mode, and an error	1
9.2. All these instructions require	1
9.2. Cache control instructions. There	1
NumberOfTests; i++) { // Loop	1
NumberOfTests; i++) { time1 =	1
stay in the same processor	1
stay on until you turn	1
extension of vector register sizes	1
extension to the x86 instruction	1
"best case" counts that you	1
"best case" values. Which of	1
functions) has no negative effect	1
functions) /Gy -ffunction- sections /Gy	1
repeated until the residual error	1
repeated 1024/4 = 256 times	1
FactorialTable[13] = {1, 1, 2,	2
Friday) in example 14.7b is	1
Friday) { DoThisThreeTimesAWeek(); } 135	1
function: // Example 14.20 double	1
function: (static_cast<MyChild*>(this))->Disp(); } }; //	1
8.21 is indeed a very	1
8.21 void Func1 (int a[],	1
&CriticalFunction_AVX; } if (level >=	1
&CriticalFunction_AVX; } else if (level	1
105 The vector operations use	1
105 12.1 AVX instruction set	1
interpret the bits of the	1
interpret that string as code.	1
Writing a = OneOrTwo5[b!=0]; will	1
Writing past the end of	1
bug is a minor error	1
bug causes floating point division	1
Compare each element in b	2
x=y; y=temp;} // Check if	1
x=y; y=temp;} int r, c;	1
better, you may make multiple	1
better, make your own error	1
flip the sign bit in	1
flip sign bit of u.f	1
float's when the SSE2 instruction	1
float's fits into a 128-bit	1
minutes to write the file	1
minutes to start up, which	1
109 } It is possible	1
109 12.5 Using vector classes	1
(a+1) * (a+1); c =	1
(a+1) / 4; The compiler	1
reasons, the preferred language will	1
reasons, but part of the	1
better: store the reciprocal factorials	1
better: -Ofast -mveclibabi -fopenmp /Qopenmp	1
method, it is clear that	1
method, but it doesn't work	1
whose address is in edx,	1
whose distance in memory is	1
delete, and often excessively so.	1
delete, or malloc and free.	1
accessed, and this error is	1
accessed, it is necessary to	1
a&(b|c) - n.a. - -	1
a&(b|c) x-xxxx--x (a|b)&(a|c) = a|(b&c)	1
assigning a new physical register	1
assigning different priorities to different	1
10% of the time. The	1
10% of the time. This	1
Mostly obsolete. Microprocessor documentation Intel:	1
Mostly obsolete. Rick Booth: "Inner	1
4: "Instruction tables". There are	1
4: "Instruction tables". Tips about	1
4; The compiler may replace	1
4; Register variables The most	1
have. The developers may therefore	1
have. In some cases it	1
relieving the const restriction from	1
relieving a syntax restriction, but	1
10, columns = 8; float	1
10, 12 or 16 8	1
ENDP + esp ebx ecx,	1
ENDP ecx, 1 eax, 8	1
incremented to 5 by another	1
incremented every second by another	1
48 Use macros instead of	1
48 7.15 Function parameters ...............................................................................................	1
Tuesday = 4, Wednesday =	1
Tuesday || Day == Wednesday	1
internally as a member function	1
internally as (int)&matrix[0][0] + j	1
fourth of these cache lines	1
fourth value to make the	1
tips on advanced C++ programming,	1
tips on improving performance. Stefan	1
shared_ptr than for auto_ptr. Smart	1
shared_ptr allows multiple pointers to	1
BSD. The Windows version is	1
BSD. If a function in	1
effort. 7.21 Runtime type identification	1
effort. Square blocking and similar	1
today. You may choose a	1
today. But this language gained	1
Put the function or class	1
Put in an unused fourth	1
CriticalFunction_AVX(int parm1, int parm2) {...}	2
(r2 = r1; r2 <	1
(r2 = r1+1; r2 <	1
writing: 103 // Example 11.1b	1
writing: __declspec(align(64)) int BigArray[1024]; //	1
B2; class D : public	1
B2; 54 class D :	1
overall performance of a program.	1
overall computation time is determined	1
Structures and classes Nowadays, programming	1
Structures and classes............................................................................................ 51 7.18	1
executables. This method can be	1
executables. Make sure to distinguish	1
inherently parallel because it defines	1
inherently serial, such as most	1
me. You will not get	1
me. My vector class library	1
non-virtual member function, provided that	1
non-virtual functions. Avoid virtual functions	1
safer. It may catch programming	1
safer. Type casting of pointers	1
b+c = 100000001.23456. The float	1
b+c will be rounded to	1
__linux__ x86 platform _M_IX86 _M_IX86	1
__linux__ __unix__ __linux__ x86 platform	1
-32768 32767 int16_t int in	1
b+a a*b = b*a (a+b)+c=a+(b+c)	1
factorials, but this is not	1
convenience - there is no	1
231. This extra cost is	1
pow(x,10); } The pow function	1
companies often fail to keep	1
dominate in the future. 6	1
preferences for the IDE, for	1
optimize("a",on). Specifies that pointer aliasing	1
optimize(...) Fastcall function __fastcall __attribute((	1
x---x---x x-xxx---- a*b*c=a*(b*c) a+b+c+d =	1
16383 one fraction 2 63	1
extensions. If a profiling (see	1
today, then it may take	1
14.5b if ((unsigned int)(i -	1
14.5a const int min =	1
otherwise. In difficult cases like	1
//Loopby4 s += xxn *	1
b2); y1 = a1 *	1
1./3628800., 1./39916800., 1./4.790016E8, 1./6.22702E9, 1./8.71782E10,	1
niche in scientific computing, but	1
10) { ... Conversions between	1
fistp dword ptr n; #endif	1
SetThreadAffinityMask, in Linux, sched_setaffinity). The	1
common, and there is no	1
(low numbers mean good performance).	1
common. Even some of the	1
segments (32-bit or 64-bit systems).	1
Darwin8 g++ v 4.0.1. Gnu:	1
108 You may look at	1
compact, and simple to develop.	1
102 also useful to put	1
namespace. 3. The Gnu compiler	1
update, or update automatically when	1
similarity between the operating systems	1
106 CPUs if the data	1
function) should be hidden by	1
"move constructor" to transfer ownership	1
function" has been introduced in	1
Friday, Saturday }; Weekdays Day;	1
bits), unless the SSE4.1 instruction	1
Correction for the FDIV bug	1
vulnerability of software with network	1
reinstallation work to take a	1
ignoring the higher bits. There	1
sums } This loop calculates	1
N-1)==0 if N is a	1
1./6., 1./24., 1./120., 1./720., 1./5040.,	1
{x = a; y =	1
Rather than comparing i with	1
code-based methods or require runtime	1
N+1 supports at least the	1
512-bit ZMM registers by 64,	1
7.6. Set flush-to-zero and denormals-are-zero	1
circumvent operating system standards. Such	1
---x---xx (-a==-b)=(a==b) ---xx---- (a+c==b+c)=(a==b) ----x----	1
blog. Here, you can also	1
OpenMP. www.openmp.org. Documentation of the	1
Includes many functions for statistics,	1
$B2$2 ; Induction++; ; point	1
effects. This effect can be	1
Delight". Addison-Wesley, 2003. Contains many	1
AND-operations in just one clock	1
precompiled code. The history of	1
typo in a hand- written	1
51). The order in which	1
Included with Intel C++ compiler,	1
Updates to the operating system	1
'@' and '$' are allowed	1
(methods) Each time a new	1
count. The method of bounds	1
masm=intel /FA -S Generate map	1
warn against overkill. Don't use	1
warm up the CPU by	1
noticed that i can never	1
constructs........................................................................ 26 7.1 Different kinds	1
a<<b<<c = a<<(b+c) - n.a.	1
leak. An even worse kind	1
utility for modifying the name	1
clumsy, as you will see	1
16-byte instructions MOVNTPS, MOVNTPD and	1
zeroes. Example: // Example 7.33a	1
caveats. We can change the	1
$B1$2:. This is just an	1
repagination are running in other	1
a[i+2] ; compare with end	1
recognizes it as a subexpression.	1
recognized in 64-bit mode. Make	1
cleans up the stack. This	1
(bitwise and) will cut off	1
portability. Unfortunately, the cross-platform compatibility	1
independently. The CPU will start	1
9.5b void transpose(double a[SIZE][SIZE]) {	1
answer questions from everybody. So	1
(Standard Template Library) and other	1
13.2. CPU dispatching in Gnu	1
adds, not edx but the	1
objconv or a similar utility	1
purpose: Contain one or multiple	1
limitations to what the preprocessor	1
x8*x2; return x10; } //	1
limitation). 14.11 Static versus dynamic	1
speculatively executing instructions during this	1
disassembly window of a debugger.	1
(en.wikipedia.org/wiki/L2_cache). The details of cache	1
attempt is made to recover	1
0+1.23456 = 1.23456. But we	1
before) } printf("\nResults:"); for (i	1
blocks. A method with multiple	1
timingtest.h from www.agner.org/optimize/testp.zip or get	1
C1::Disp() or C2::Disp() is done	1
predictor. On other processors, only	1
128. These lines are organized	1
accurate, however, and it may	1
Misaligned data. Extra data conversion,	1
FAQ for the newsgroup comp.lang.asm.x86	1
before. This is faster than	1
Xnu project. Some of the	1
initialized. The dispatcher function will	1
so). A template parameter can	1
Remember, therefore, always to specify	1
/fp:fast=2 -fp-model fast, -fp- model	1
/MT). In Linux and Mac	1
MKL). Works with all x86	1
B1 { public: B2 b2;	1
CParent::Hello() has multiple instances that	1
user-defined function is pure. Virtual	1
spots, but for studying a	1
B. In order to take	1
exploiting fine-grained parallelism. The way	1
sets). Here, / means integer	1
lost at the time we	1
i+1; The compiler may reduce	1
terminated. The purpose is to	1
burden is the calculation of	1
(a&&!b) || (!a&&b) = a	1
SafeArray: // Example 7.15b SafeArray	1
Is8vec16 Vec16c 8 16 unsigned	1
weakness or bottleneck, it is	1
imple- mentations have no checking	1
Yeppp. Open source library. Supports	1
nested function calls in the	1
source) { _mm_stream_pi((__m64*)dest, *(__m64*)&source); //	1
1994. Mostly obsolete. Rick Booth:	1
side effects or if the	1
ample resources. For example, a	1
(MMX), 128 bits (XMM), 256	1
1/50 of the time it	1
/openmp /MT -msse3 /arch:SSE3 -mssse3	1
forgot to tell the compiler	1
clauses are separated by semicolons,	1
reproducibility. Delays in program execution	1
-abs(x);. There are a number	1
x-xxx - xx(-)x- - x-xxxx--x	1
timediff[i] = ReadTSC() - time1;	1
Be sure not to mix	1
for(inti=0;i<16;i+=4){ //Loopby4 s += xxn	1
message. It is recommended to	1
coordination with other subtasks is	1
distant future. 12.3 Automatic vectorization	1
Sunday = 1, Monday =	1
restore ebx from stack ;	1
47 Most compilers will automatically	1
1996. These two books contain	1
www.agner.org/optimize. Copyright conditions are listed	1
row++) for (column = 0;	1
resume after exceptions: while (i	1
x-xxxxx-- (a&b)|(a&c) = a&(b|c) x-xxxx--x	1
areas. Data that are read-only	1
qword ptr x; __asm fistp	1
Repeat NumberOfTests times // Time	1
/EHs- No stack frame /Oy	1
union: // Example 9.2b void	1
(12.4e) with automatic CPU dispatching.	1
steals resources from a higher-priority	1
(add with carry) instructions where	1
moved, which may happen quite	1
moved. A binary tree or	1
areas, and there will be	1
longdoublevalue ( 1)sign 2exponent 16383	1
unconventional manner by returning a	1
*const_cast<int*>(&x) += 2;} // add	1
(option -fno-pic). 64 bit systems	1
x-xxxxx-x (-a)*(-b)=a*b ---xxx--- a/a=1 --------x	1
Handles to windows, graphic brushes,	1
strange and unexpected behaviors. Arrays	1
invalid, and by avoiding pointer	1
_mm_stream_si128 SSE2 Table 9.2. Cache	1
/Gy, Linux: -ffunction-sections) which allows	1
(there is one set of	1
sqrt and pow at compile-	1
b.y + c.y + d.y;	1
SSE. Several function libraries published	1
bits: // Example 14.29 union	1
264-1 uint64_t Table 7.1. Sizes	1
generality. The most important remedy	1
sin(0.8); The sin function is	1
esp+12 and loaded into ecx	1
bounds-checking to an array and	1
owns the allocated object, and	1
i--, x++) factorial *= x;	1
versa. But most of the	1
body. A function is usually	1
CString uses new and delete	1
58.7 168.3 Table 9.3. Time	1
Prevent optimizing away cpuid //	1
"express" edition is available for	1
(en.wikipedia.org/wiki/Standard_Template_Library). The objects stored in	1
zero: // Example 14.24 union	1
*(int*)&x |= 0x80000000; // Set	1
-fno-pic). 64 bit systems have	1
tread can take care of	1
rows. Let's look at what	1
saturated. This can be ameliorated	1
rows, not the columns. Every	1
uncaught overflow condition will generate	1
macro, but the method used	1
virtualization. The time when the	1
seek information elsewhere and get	1
macro. If you want the	1
constructed. All non-static variables and	1
data, including local data that	1
FuncB (int & r) {	1
limits the CPU brand. Critical	1
xx4(x4); // x^4 F32vec4 s(0.f,	1
precious resource for many computer	1
15h Processors". www.amd.com. Advices on	1
installed, a lot of background	1
installed. The installation process should	1
point: // Example 14.22b unsigned	1
IA-32/Intel64, 2009. Gnu C++ v.	1
_mm_perm_epi8 32 1 byte =	1
min) <= (unsigned int)(max -	1
LLVM is a new compiler	1
7.40a struct Bitfield { int	1
7.40b union Bitfield { struct	1
7.40c x.abc = (A &	1
(FuncRow(i)*columns + FuncCol(i)) * sizeof(float)	1
(Darwin) are part of the	1
see, it is possible to	1
importance of structured and object-oriented	1
comparable to a clock cycle	1
interpretation. The program code is	1
xxn-1, and each value of	1
rarely. The above code will	1
optimize("a", on) __restrict __restrict __declspec(	1
neither faster nor slower than	1
correctly whether vectorization will be	1
sets) (line size) = (total	1
libraries........................................................................................ 12 2.7 Choice of	1
mind. In some cases you	1
sets, cache size, etc. There	1
dot in the function name	1
a2*b1) / (b1*b2); The trick	1
mispredicted. A branch that always	1
Day. Note the difference between	1
mispredicted, which causes a long	1
Good compilers such as the	1
after) - (time before) }	1
OneOrTwo5[2] = {1.0f, 2.5f}; a	1
intermediates, loop counters, function parameters,	1
incremented. See page 31 for	1
incremented, while in the former	1
here's an explanation. Please skip	1
insufficient. The user expects immediate	1
she is busy concentrating on	1
not-too-big upper limit can be	1
evictions and other resource conflicts.	1
bit, the exponent, and the	1
Prefetch PREFETCH _mm_prefetch SSE Store	1
core). The counters will stay	1
noalias) __restrict #pragma ivdep __restrict	1
transposition of different size matrices,	1
other's caches and cause large	1
below, on page 15. C++	1
illegitimate copying. The benefits of	1
legitimate backup copying without effectively	1
121 13 Making critical code	1
architecture of the software. You	1
renamed instances of the same	1
unacceptable to the user if	1
hardware-related details depend on the	1
12, last byte at 13	1
12) are more useful methods	1
"More Effective C++". Addison-Wesley, 1996.	1
"Effective C++". Addison-Wesley. Third Edition,	1
Dispatcher void SelectAddMul_dispatch(short int aa[],	1
Boost collection contains well-tested libraries	1
ebx,31 copies the sign bit	1
matters. Problems with invalid pointers	1
<ia32intrin.h> etc. // Returns time	1
finish. 3.8 System database It	1
inappropriate CPU dispatch methods. The	1
0: printf("Alpha"); break; case 1:	1
IA-32 Architectures Optimization Reference Manual".	1
x87 style floating point code.	1
a+b+c=a+(b+c) (a+b)+c=a+(b+c) --xx----- (a&&b) ||	1
6.0f; Constant folding and constant	1
brackets. However, most compilers do	1
NULL. There should of course	1
b*(2.0/3.0) unless you put a	1
.a), but not dynamic libraries	1
tolerance may be so high	1
Processor memcpy 16kB aligned operands	1
Files on remote or removable	1
compactness, and execution time. No	1
(partial) template specialization. This is	1
Abrash: "Zen of code optimization",	1
T+1 to T+6, and the	1
0] in this case so	1
Edition, 2005; and "More Effective	1
14.7b is converted by the	1
Otherwise the program will be	1
suggested improvements). // Example 8.26b	1
14.3a int n; switch (n)	1
14.3b int n; static char	1
(DLL) which is called by	1
SelectAddMul_SSE41 #elif INSTRSET == 8	1
thenaandbcannot use the same register	1
Hat). PathScale C++ v. 3.1,	1
int32_t long long or int64_t	1
issuing an error message. It	1
unchanged across a call to	1
Deallocation has no cost because	1
initiative whenever it is possible.	1
bloat and complexity (en.wikipedia.org/wiki/Standard_Template_Library). The	1
Division, square root and mathematical	1
Gives a more clear program	1
C- style type-casting with a	1
boolb=0; static const float lookup[2]	1
C# and avoids many of	1
(0); and the second operand	1
acceptable limit, then you should	1
FuncB, then FuncC. Unrolling the	1
removed. If N is a	1
trigger the error condition. Replacing	1
basic understanding of how compilers	1
j++) 39 matrix[i][j] += x;	1
once................................... 135 14.4 Integer multiplication	1
statements, as explained on page	1
compiling. This prevents it from	1
frustration and waste of time	1
2-3 clock cycles if it	1
prone to even allocate more	1
switches..................................................................................................... 22 3.15 Dependency chains	1
deeper into the technical details	1
b)) even though the latter	1
less. Fortunately, all compilers are	1
"function". Multiple calls to a	1
Max. number of elements in	1
operator[] (unsigned int if (i	1
enabled: // Example 14.21. //	1
owns. A destructor is as	1
wrapper classes with destructors to	1
161 32 bit platform not	1
162 19 Literature Other manuals	1
be, for example, to go	1
algebra) require other access patterns.	1
be. The distinctions between RISC	1
Re-do the calculation in a	1
algebra. For example, a compiler	1
slices. This will make applications	1
transformation of example 15.1b to	1
x^8 // x^10 // return	1
2.11 ifunc branch). This feature	1
power-save options in the BIOS	1
situations: The stack unwinding mechanism	1
balance between these considerations. It	1
0.35 0.29 0.28 strlen 128	1
over. Virtualization is becoming increasingly	1
over- loaded type casting operator	1
a<c) = (a<b && b<c)	1
a1/b1 + a2/b2; Here we	1
"memory" ); #else // 32-bit	1
2009. Gnu C++ v. 4.1.0,	1
situations, and which reductions they	1
vendor string. In the future	1
list; // Make array of	1
Non-polymorphic functions go here //	1
investment. A redesign can not	1
MOVNTPS, MOVNTPD and MOVNTDQ require	1
(80 bits). The advantages of	1
matrix[NUMROWS][NUMCOLUMNS]; int row, column; for	1
149 All code that is	1
x);} void SelectAddMul(short int aa[],	1
cc[i]+2 is AND'ed with this	1
Iu32vec2 64 1 int64_t 64	1
Iu32vec4 Vec4ui 64 2 int64_t	1
time1 = ReadTSC(); CriticalFunction(); timediff[i]	1
plug-ins that add functionality to	1
Vec32c unsigned char short int	1
interval, for example i =	1
time? If the number of	1
&SelectAddMul_AVX2; (iset >= 5) SelectAddMul_pointer	1
i7 processor with four cores	1
kit (SDK or PSDK). Supports	1
i) { // Safe []	1
(Vec4f const & x) {	1
transitions between the two kinds	1
Usually it takes only a	1
a[size]; unsigned int absvalue, largest_abs	1
................................................................................................... 87 9.3 Functions that	1
x?" or "how many elements	1
separating the flags register into	1
(the instruction set has nothing	1
g() { C1 obj1; C0	1
technology, and microprocessor microarchitecture. A	1
800 bytes smaller. Structure and	1
tolerated. PGI C++ compiler for	1
Gbytes. This large memory model	1
p1; p1 = &Object1; p1->Hello();	1
CriticalFunctionType(int parm1, int parm2); //	1
deleted, copied or transferred from	1
a/1 = a - 0/a	1
Yet, D is compiled to	1
-263 263-1 int64_t 29 64-bit	1
assigned previously in the code.	1
functional decomposition and data decomposition.	1
2eee 1.fffff, where is the	1
human readable and not easily	1
plug-in to Microsoft Visual Studio	1
_mm_setcsr(_mm_getcsr() | 0x8040); See page	1
2-20, but this is sufficiently	1
yet as well developed as	1
Newton-Raphson iterations. Here the iteration	1
regarded as a valuable source	1
pixel or line separately through	1
affinity mask. Poor reproducibility. Delays	1
PROCNEAR ; parameter 1: 8	1
119). The AMD math core	1
stack). ecx now contains the	1
ago, the recommendation was the	1
reuse the same array for	1
Beginners are advised to seek	1
Error: lowest instruction set not	1
pool, as explained above. Examples	1
reordered, inlined, or optimized away.	1
doublevalue ( 1)sign 2exponent 1023	1
(IPP). Works with all x86	1
hand. Low-level languages are good	1
hand- written table may go	1
|) instead of the Boolean	1
standardization of programming languages, operating	1
Patches should be easily available	1
object-oriented programming, modularity, reusability and	1
WriteFile if the handle is	1
link. Use different executables. This	1
strategies........................................................................................ 122 13.2 Model-specific dispatching	1
monitoring options. CPU vendors are	1
printf("Beta"); break; case 2: printf("Gamma");	1
re-use a container than to	1
dead code if no other	1
Core2 processor performs better on	1
meaning. 2. Put the function	1
meaning, then you can set	1
2014-08-07. Contents 1 Introduction .......................................................................................................................	1
(int)&matrix[0][0] + j * (columns	1
Safe [] array index operator	1
i*12, because the size of	1
__thread or __declspec(thread). Such variables	1
(BTB). Contentions in the BTB	1
meanings depending on the context.	1
capabilities. Here is a list	1
paragraph. The target of branches	1
Sum2(S3 * p) {return p->a	1
18015, "Technical Report on C++	1
alignments and different sizes of	1
status: _fpreset(); _controlfp_s(&dummy, 0, _EM_OVERFLOW);	1
Including the appropriate header file	1
millisecond. The profiler counts how	1
list[100], *temp; for (temp =	1
benchmark performance of competing brands	1
ifbit=1 bitofn // return y	1
f(x) or g(x) is calculated	1
floatvalue ( 1)sign 2exponent 127	1
Inlining a function is advantageous	1
remains zero in the while	1
worst- case conditions. For example,	1
titles. Literature on code optimization	1
11.2a const int size =	1
/GR -fno-rtti /GR- -fno-rtti Assume	1
~C1(); }; void F1() {	1
(vector const & a) {	1
initial value of i must	1
optimize/#vectorclass Include file dvec.h vectorclass.h	1
powN<true,N/2>::p(x); } }; // Full	1
accumulators. Current CPUs have only	1
22. Avoid long dependency chains,	1
addressed relative to the stack	1
F0() { try { F1();	1
OS, etc.) have little-endian storage,	1
vmlsExp4 vmldExp2 Intel SVML v.10.3	1
-mcmodel=large, but this will use	1
+127. An integer overflow will	1
precision: // Example 14.18b float	1
223 to a floating point	1
x[1] = b; c =	1
Adolfy Hoisie: "Performance Optimization of	1
64; // number of rows/columns	1
products fail to recognize VIA	1
dvec.h vectorclass.h Supported compilers Intel,	1
(.dll or .so). There is	1
stages before they are executed.	1
InstructionSet().The following example shows how	1
64. Each cache line can	1
sticks may not be cached.	1
Parallelization by OpenMP directives 32	1
covers 64 consecutive bytes of	1
153. A profiler is most	1
65535 uint16_t unsigned int in	1
/Qopt-report -opt-report Table 18.2. Compiler	1
low-priority thread steals resources from	1
Vectorization with alignment problem void	1
Profile-guided optimization Whole program optimization	1
destructors. The copy constructors and	1
Locked mutexes. Open database connections.	1
independence, and easy development. For	1
libraries............................................................................ 146 14.12 Position-independent code..................................................................................	1
fine-tuning, testing, verifying and maintaining	1
exits. For example, if a	1
exits, when in fact it	1
mangling are explained in manual	1
utilities in 2010. This feature	1
cases........................................................................................................ 124 2 13.4 Test	1
alleviated in the 64-bit extension	1
decimals, for example, you should	1
cell for different matrix sizes	1
transfers ownership of the memory	1
list[j].b + list[j].c; } Here,	1
list[j].a = list[j].b + list[j].c;	1
12.4a. Loop with branch //	1
12.4a, depending on how predictable	1
example,a * 16is calculated asa	1
obeyed. Copy protection. Some copy	1
sufficient, and the caching conditions	1
product. It is good to	1
restores the value of ebx	1
2011). Instead, the following work-around	1
serial, such as most sorting	1
restored before the function returns.	1
managed C++, and other languages	1
Disadvantages are: Long double precision	1
real-time speed. Delays or glitches	1
1./40320., 1./362880., 1./3628800., 1./39916800., 1./4.790016E8,	1
exceeding that of yesterday's big	1
(a+c==b+c)=(a==b) ----x---- !(a<b)=(a>=b) (a<b &&	1
18.2. Compiler directives and keywords	1
click becomes inconsistent and sometimes	1
1.23456, y; y = a	1
download updates through the Internet	1
/Qopenmp -m32 -m64 -static /MT	1
technique is illustrated in example	1
de-allocation of memory with new	1
x<<3, which is faster. In	1
optimizer. Borland/CodeGear/Embarcadero C++ builder Has	1
division). The object pointed to	1
monotonically increasing function of the	1
top-of-stack index. Are objects identified	1
configurations with the same source	1
off. It is important to	1
Vec8ui Vec4q Vec4uq Vec4f Vec2d	1
2.20 or later // Header	1
2.23 0.95 0.6 1.19 13	1
std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP. www.openmp.org. Documentation of	1
relocate, but these address calculations	1
advised to seek information elsewhere	1
button or moving the mouse.	1
positions in the vectors. This	1
did not improve the execution	1
Vec8us 32 4 int 128	1
<excpt.h> #include <float.h> #include <math.h>	1
minimal difference between the efficiency	1
Library, available from www.intel.com. (See	1
Systems with segmented memory, such	1
more. Many software applications need	1
telling the user to restart	1
unexpected behaviors. Arrays are often	1
feasible. Interference from other processes.	1
x2*x2; double x8 = x4*x4;	1
Mathcad (v. 15.0) is using	1
-mveclibabi=acml. Agner's vector class library.	1
friendly compiler with many features,	1
running, and a slow and	1
targets is small. The number	1
exit. Calling exit may not	1
switching. This cost is minimized	1
alternatives: Make the function a	1
operations............................................................................................... 105 12.1 AVX instruction	1
27). The maximum number of	1
................................................................................... 81 8.6 Optimization directives	1
log(c[i]); // Increment loop counter	1
assignment, as a function parameter,	1
assignment. shared_ptr allows multiple pointers	1
diagnose. It is the responsibility	1
8.9b int SomeFunction (int a,	1
15.1c). 16 Testing speed Testing	1
vector(float a, float b) {x	1
c;}; abc * p; int	1
8.9a int SomeFunction (int a,	1
sets........................... 122 13.1 CPU dispatch	1
Integrates into the Microsoft Visual	1
AddTwo(int * __restrict aa, int	1
Violation of array bounds is	1
evenly between the different execution	1
identified, then it may be	1
simultaneous lookups Max. number of	1
incrementing a loop counter, comparing	1
imprecise or simply zero. Execution	1
Technology Journal Vol. 11, Iss.	1
-100, b = 100, c	1
p->f() goes to C0::f or	1
DontSkip = dummy[0]; clock =	1
1./2., 1./6., 1./24., 1./120., 1./720.,	1
blend instruction if the SSE4.1	1
e + f; The compiler	1
flexibility of the STL containers	1
SelectAddMul_SSE2, SelectAddMul_SSE41, SelectAddMul_AVX2, SelectAddMul_dispatch; //	1
Greek[4] = { "Alpha", "Beta",	1
Windows: __rdtsc()). The time stamp	1
wealth of advanced features rarely	1
correlated with preceding branches and	1
independently of other tasks that	1
Output array element } An	1
T, unsigned int N> class	1
T> static inline T max(T	1
SelectAddMul, SelectAddMul_SSE2, SelectAddMul_SSE41, SelectAddMul_AVX2, SelectAddMul_dispatch;	1
throw()specification is useful for library	1
asa << 4, anda *	1
themselves. But implementing a matrix	1
ARRAYSIZE. Another example: // Example	1
electrical connections rather than sequences	1
A2 = A + A;	1
"=m"(n) : "m"(x) : "memory"	1
A. Hoisie, SIAM 2001. 9.11	1
(IDE) supports multiple programming languages,	1
TR 18015, "Technical Report on	1
Numbers in the table are	1
amounts of memory will benefit	1
fld qword ptr x; __asm	1
Calculating the difference between two	1
(v. 15.0) is using a	1
polygon or bitmap than to	1
~(~a)=a x-xxxxx-- (a&b)|(a&c) = a&(b|c)	1
/vms Fastcall functions /Gr Function	1
sample more data than it	1
everybody. So please don't send	1
unwise to use it. Complicated	1
systems"). An application with many	1
looses ownership of the memory	1
p2->Hello(); // Writes "Hello 1"	1
8.23b. Calculate polynomial with induction	1
d); Now the two parentheses	1
144 The above examples all	1
circuits consisting of digital building	1
14.1b int factorial (int n)	1
143 if (u.i & 0x7FFFFFFF)	1
14.1a int factorial (int n)	1
ecx+eax*4. The result ebx is	1
Reinterpret cast The reinterpret_cast operator	1
max = 110; int i;	1
77) shows which reductions the	1
theory. Advice on how to	1
constructor" to transfer ownership of	1
14, with some changes for	1
Number) if an overflow or	1
grow in the future. To	1
Pointers, references, and stack entries	1
Unpredictable branches that select between	1
QueryPerformanceCounter functions for millisecond resolution.	1
workload between multiple CPU cores:	1
u[0]. 14.10 Mathematical functions The	1
class). If the same function	1
seeing an increasing number of	1
distributors are often abusing the	1
2B, and 3A and 3B.	1
(Red Hat). PathScale C++ v.	1
optimally. The speed for certain	1
optimally, or from knowing that	1
view. This instruction set is	1
competition. Processors with multiple cores	1
8.42n, 2004. Open Watcom C/C++	1
group books 1994. Mostly obsolete.	1
thank the many people who	1
www.openmp.org. Documentation of the OpenMP	1
interesting because it makes floating	1
~a&~b=~(a|b) --xxxx--- a & a=	1
;eax=addressofa ;edx=addressinr ; ecx =	1
"static" or "__attribute__((visibility ("hidden")))". A	1
0x800 apart. I will call	1
subtract this value from the	1
works, here's an explanation. Please	1
@gnu_indirect_function"); // Make the dispatcher	1
optimizations, as explained below. The	1
matrixes. Algorithms that are inherently	1
speeds. If I write that	1
tmmintrin.h SSE4.1 smmintrin.h SSE4.2 nmmintrin.h	1
{}; void xplus2() { The	1
forgets that the system code	1
7. If the arrays or	1
integer: // Example 15.1b. Calculate	1
module2.cpp. The simplest way to	1
last: // Example 7.35b struct	1
14.0 80.8 65 65 13.6	1
SelectAddMul_AVX2, SelectAddMul_dispatch; // Define function	1
Choose the strongest optimization option	1
list[j].c; } Here, we have	1
r.a + r.b;} The three	1
places). Some compilers have an	1
Linux) 4. Align arrays and	1
decrementing a pointer does not	1
Accessibility guidelines should be obeyed.	1
constructors. A class doesn't need	1
x10 = x8*x2; return x10;	1
Generic version CriticalFunction = &CriticalFunction_386;	1
F64vec4 Table 12.5. Vector classes	1
system-independent, in another module. The	1
DynamicArray[i] = WhateverFunction(i); // ...	1
cross-module optimizations when interprocedural optimization	1
therefore, always to specify the	1
FuncCol(i)) * sizeof(float) in order	1
requesting a map file from	1
locally. Access to remote databases	1
8.3a float parabola (float x)	1
12.4c. Same example, vectorized with	1
a+b=0, and then 0+1.23456 =	1
"Software Optimization Guide for AMD	1
listing. Use the "generate map	1
eax. The loop initialisation i=0;	1
game or animation. It is	1
polynomial(x) = 2.5*x^2 - 8*x	1
cc[i]); } 109 } It	1
Time-based sampling: The profiler tells	1
uninstallation of programs should be	1
a+b=b+a a*b=b*a a+b+c=a+(b+c) (a+b)+c=a+(b+c) --xx-----	1
remaining bits represent a monotonically	1
u.d is negative or -0	1
branch). This feature uses an	1
conversions.................................................................................................... 40 7.12 Branches and	1
forbids the user to turn	1
107. A disadvantage of using	1
Walking through a linked list	1
(1985). This standard is used	1
de-allocated. This is the best	1
.................................................................................................................. 60 7.30 Exceptions and	1
/O3 -O3 Interprocedural optimization /Og	1
dispatching: 1. How much you	1
dispatching, then it is advisable	1
C++0x support. Make a member	1
(b1*b2); The trick of using	1
1./1.30767E12, 1./2.09227E13}; float x2 =	1
*temp; for (temp = &list[0];	1
segmented memory, such as DOS	1
integral number of vectors. 12.10	1
compiler). Fastcall functions are not	1
Weighing the above advantages of	1
workaround methods depend on the	1
Users should get a reply	1
Problems with invalid pointers can	1
-m32 -m64 -static /MT 160	1
bool, enum as well as	1
branch, which is the one	1
/arch:SSE4.1 -mAVX /arch:AVX /QaxSSE3, etc.	1
performance: The first time you	1
editions). Do not turn on	1
[ecx+eax*4]. This is all done	1
Borland/CodeGear/Embarcadero C++ builder Has an	1
easier. I have done a	1
1000. The loop in example	1
ready made containers is that	1
studied do not make induction	1
0.666666666666666666667; This is actually quite	1
A2; // Table // Loop	1
commpage. These functions are highly	1
uses. There are also third-party	1
powN<true,0> { public: static double	1
0x3700, 0x3F00 and 0x4700. These	1
matrix[row][column] = row + column;	1
performance). Aligned operands means that	1
describes how this works and	1
{2.6f, 1.5f}; a = lookup[b];	1
non-sequentially because it may cause	1
1% goes to actually doing	1
errors; make sure allocated resources	1
1) y *= x; x	1
(typically 64) can improve performance	1
hackers often have exploited. A	1
errors, and some tips on	1
formula: (set) = (memory address)	1
Certainly not! 250 s is	1
occupies a space in the	1
multi-threading, e.g. Intel Math Kernel	1
"xmmintrin.h" // header for intrinsic	1
occupied throughout the whole program	1
experimental results in table 9.1	1
condition: // Example 7.32b double	1
runtime). The following techniques can	1
c1, c2; double temp; //	1
Dr Dobbs Journal, 2002). In	1
switching to protected mode and	1
formulas in this example so	1
trace with a debugger. You	1
Single-Instruction-Multiple-Data (SIMD) operations. The total	1
condition, and increment. The three	1
protected: T a[N]; public: SafeArray()	1
zigzag course that reflects the	1
topic, see my free E-book	1
complaints should be regarded as	1
(XMM), 256 bits (YMM), and	1
local: 1. Add the keyword	1
20. The fact that the	1
D, Pascal, Fortran and several	1
throw(A,B,C) to tell explicitly what	1
fills up the loop buffer	1
local. This makes it easier	1
precise floating point calculations. Even	1
Predefined macros Compiler identification 16	1
local, and use the local	1
column-wise. Assume now that we	1
__intel_cpu_features_init_x() does the same without	1
stall because the CPU has	1
=0; list[i+1] = 1; list[i+2]	1
accelerators The choice of platform	1
Addison-Wesley. Third Edition, 2005; and	1
absvalue = a[i].u[1] * 2;	1
eax,0. The loop body begins	1
dword ptr n; #endif return	1
ger or double) /arch:SSE2 -msse2	1
recommendations are based on the	1
decomposition, we should preferably have	1
targets. A switch statement with	1
undesired. Example: // Example 7.41a	1
bytes). This has a significant	1
Turn on the option for	1
12.6. Function with vector parameters	1
7.32b. A for-loop has three	1
VTune, for AMD CPUs use	1
[1.0, 2.0) by setting the	1
if), but no compile- time	1
referencing it twice. You can	1
VTune; AMD's profiler is called	1
stupid things. Looking at the	1
worrying too much about the	1
storing. The standard solution to	1
...................................................................... 32 7.4 Enums ......................................................................................................................	1
7.29b floata; boolb=0; static const	1
"Hacker's Delight". Addison-Wesley, 2003. Contains	1
Storage on the stack Variables	1
Unsigned is faster than signed	1
blurred as the standard PC	1
7.29a float a; bool b;	1
dummy; double a[arraysize], b[arraysize], c[arraysize];	1
eliminating the if-branch in example	1
FatalAppExitA(0,"Array index out of range");	1
emulating the so-called Java virtual	1
satisfies the user's needs. The	1
(int)n - 2, x =	1
with, e.g. the option /QaxAVX	1
appropriately. Users should get a	1
168.5 513 513 58.7 168.3	1
x10; } // x^2 //	1
168.3 Table 9.3. Time for	1
streaming audio or video should	1
(2.5f * x - 8.0f)	1
commas and semicolons in a	1
reciprocal_divisor = 1. / (b1	1
usual object file format. The	1
?Func2@@YAXQAHAAH@Z ENDP ecx, 1 eax,	1
<float.h> #include <math.h> #define EXCEPTION_FLT_OVERFLOW	1
temp++ actually adds 16 to	1
doing. See the end of	1
unreasonably large. 156 16.3 Worst-case	1
popularity when a genuine compiler	1
(rebased) once more by the	1
ja $B2$3: ret ALIGN ;	1
(YMM), and soon also 512	1
2.0) by setting the fraction	1
dates back to around 1980	1
Called directly // Writes "Hello	1
(-a)*(-b) = a*b - n.a.	1
row, column; for (row =	1
position above the diagonal. The	1
constructor. A default constructor is	1
2B. There are hundreds of	1
number). Different compilers behave differently	1
(0, 2, 4, etc.). Older	1
78. Assume no pointer aliasing.	1
decimals of the fraction. The	1
executables for 32-bit and 64-bit	1
among the most frequent causes	1
Installing a second application that	1
largest_abs) { largest_abs = absvalue;	1
8.15b. The integer representation of	1
towards zero, rather than rounding.	1
b[i]*c[i], though this only happens	1
Compiler-specific keywords Fast function calling.	1
maintained for the sake of	1
efficient: // Example 7.18 int	1
LoadVectorA(void const * p) {	1
c[arraysize]; // Enable exception for	1
performance, it is also likely	1
sensible balance between these considerations.	1
Interprocedural optimization /Og Whole program	1
Assembly name Intrinsic function name	1
powN<true,N> { public: static double	1
a+b+c = a+(b+c) - a*b+a*c	1
compelling security reason for updating.	1
profile. It may be necessary	1
cumbersome to use for many	1
403 int ReadB() {return b;}	1
pmmintrin.h Suppl. SSE3 tmmintrin.h SSE4.1	1
experience. Occasionally, the clock counts	1
executable: a debug version with	1
vector). The first generation of	1
Environments) have facilities for making	1
machines? Possible solutions to this	1
those who want to go	1
a[i].u[1] * 2; // Find	1
scheme should be weighed against	1
IDE, for debugging facilities, easy	1
(N-1)) return powN<(N1&(N1-1))==0,N1>::p(x) * powN<true,N-N1>::p(x);	1
investigating performance problems. The performance	1
novector to tell the compiler	1
110; int i; ... if	1
spaces. This is called garbage	1
signaling the availability of an	1
passed as parameters to a	1
<pmmintrin.h> // SSE3 required //	1
sub-vector. A long dependency chain	1
IEEE standard 754 (1985). This	1
(|) works even if a	1
expensive, while the type conversion	1
N-1 is inferior. A model	1
dominating and there are no	1
fastcall)) __fastcall Noncached write #pragma	1
interrupted. Now it is the	1
17.4 129 129 130 14.4	1
script languages, it is often	1
lookup[b]; If a bool is	1
const*)p);} // Function to store	1
Vec16uc 16 8 short int	1
xxn(x4, x2*x, x2, x); //	1
i/2; } } The Intel	1
According to the standards for	1
microarchitecture. A higher level of	1
team projects, it is recommended	1
abs(v.f) } The multiplication by	1
(".type CriticalFunction, @gnu_indirect_function"); // Make	1
one-man projects, it is sufficient	1
vectorization............................................................. 117 12.7 Mathematical functions	1
None of the compilers I	1
MAX(a,b) (a > b ?	1
buffer, branch pattern history, etc.	1
roughly estimate that the loop	1
pow(x,n) As we can see,	1
<<6 ); 7.26 Overloaded functions	1
arrays: // Example 12.4a. Loop	1
Processors". www.amd.com. Advices on optimization	1
Instrumentation: The compiler inserts extra	1
i&15 is guaranteed to be	1
("hidden")))". A more complicated solution	1
buffers for storing text or	1
_mm256_i64gather_pd unlimited 8 bytes =	1
twice. You can avoid this	1
(2013) both 32-bit and 64-bit	1
capability to reduce various algebraic	1
_endthread() cleans up the stack.	1
2.5*x^2 - 8*x + 2	1
__debugbreak();. If you run the	1
system- specific parts of the	1
calls, if there are many	1
fine- tune the code to	1
asmlib, which is available in	1
aiming at explaining the relative	1
found, then it is important	1
subtask before coordination with other	1
lrint. Unfortunately, these functions are	1
c[i]); } } // Catch	1
231-1 int32_t long long or	1
serves as entry point. //	1
latencies are listed in manual	1
audience for educational purposes is	1
ced functions) /Gy -ffunction- sections	1
full. This may require that	1
if. This is a very	1
bloat. It is common for	1
radical solution of making the	1
Putting simple variables into a	1
absence of such checks makes	1
FuncB(i); } FuncC(i); } This	1
solving the problem is to	1
programmers' time, but also inconvenient	1
Four typical uses of dynamic	1
(a+b). This can save several	1
objects? It may not be	1
y. The purpose of this	1
violations, invalid pointers, etc. And	1
processor) when the XMM registers	1
sourcebook for fast 32-bit software	1
horizontal add, etc. SSSE3 a	1
comparison. On big endian systems	1
broken up. The two summation	1
*)alloca(n * sizeof(float)); // (Some	1
spell-checking and repagination are running	1
int)size) { cout << "Error:	1
7.34a. Use macro as inline	1
SSE). The YMM registers are	1
CPU-type is already known at	1
communicating between threads. The overhead	1
even-numbered logical processors (0, 2,	1
meaning for member functions. You	1
a<<(b+c) - n.a. - -	1
mixes float and double (see	1
encryption algorithms, cannot easily be	1
tried to make the matrix	1
coef[16] = { // table	1
fallacy of measuring performance by	1
referenced from any other module	1
0xC0000091L void MathLoop() { const	1
formalism. The splitting of software	1
underflow: // Example 7.5. Set	1
mark end of procedure 4	1
sub-vectors that fit the size	1
polymorphism. It is sometimes possible	1
__assume_aligned directive to tell the	1
polymorphism, which is more efficient	1
polymorphism: // Example 7.43a. Runtime	1
menus of a graphical user	1
(Microsoft, Intel) know that standard	1
f, x, y; x =	1
date): Microsoft Visual studio 2008,	1
Examples: // Example 14.10 int	1
MOVNTPS _mm_stream_ps SSE Store 16	1
lacks the self-explaining menus of	1
arranged in regular patterns with	1
(c+d) before it has finished	1
pushed on the stack before	1
USB sticks may not be	1
brand, family and model number.	1
(b+c) can be avoided by	1
"frame pointer". The standard stack	1
Sdouble { unsigned int fraction	1
tested, and very useful for	1
Sum3(S3 & r) {return r.a	1
duration. The best way to	1
lifetime of your software. A	1
temp++) { temp->a = 1.0;	1
14.13c int list[301]; int i;	1
consecutively? If objects are identified	1
14.13a int list[300]; int i;	1
fill up the queue of	1
8.15b struct S1 {double a;	1
_mm_i64gather_pd unlimited 8 bytes =	1
finally (4) access the data	1
hybrid solutions are now used	1
Func1(list, &list[8]); } Here, it	1
workday or more. Many software	1
instantiated at compile time. A	1
flaws in the CPU detection	1
pointers). An optimizing compiler might	1
file" option for the linker.	1
IntegerPower<10>(x); } 152 If you	1
tested: Microsoft C++ Compiler v.	1
analyzing program performance and studying	1
S2 { public: int a[100];	1
S3 { public: int a;	1
(a+b)+c = a+(b+c) - n.a.	1
{1.1, 0.3, -2.0, 4.4, 2.5};	1
elements, as follows: Type of	1
(static_cast<MyChild*>(this))->Disp(); } }; // The	1
cross- compiled on a PC	1
GetLogicalProcessorInformation in Windows) to determine	1
it). This can be useful	1
substantial. This gain in performance	1
A*x*x + B*x + C;	1
AES, PCLMUL wmmintrin.h AVX immintrin.h	1
u < 231 then convert	1
driver. A call to a	1
combined. For example: // Example	1
disadvantages. The original method of	1
loose the ability to override	1
Processors with multiple cores are	1
investing in a big mainframe	1
arguments. This closely follows the	1
www.agner.org/optimize/asmlib.zip contains various functions for	1
Round to nearest integer int	1
reductions. Algebraic reduction is a	1
kludgy. The few clock cycles	1
sched_setaffinity). The program should be	1
answer. Beginners are advised to	1
out-of- order calculation capabilities. Here	1
r1, r2, c1, c2; double	1
GUI development, database integration, web	1
fence instructions, but these are	1
eee is the exponent, and	1
(Scalar means not a vector).	1
Omitting the standard stack frame	1
nine, even though it is	1
$B2$2: mov mov 2:8+esp eax,	1
7.10b char a = 0,	1
d.y; Fortunately, most compilers will	1
7.10a bool a, b; b	1
randomness in order to get	1
thread, and only if the	1
development", Addison- Wesley 1997. Mostly	1
selected. Compiler has insufficient information	1
BigArray[1024] __attribute__((aligned(64))); // Linux syntax	1
shortly. The following examples explain	1
latencies, throughputs and micro-operation breakdowns	1
perspective of usability. This is	1
latencies. 8.5 Compiler optimization options	1
<<, >> can test or	1
FuncRow(int); int FuncCol(int); const int	1
versions: class CChild1 : public	1
1.0E8, c = 1.23456, y;	1
12.4c is quite tedious indeed.	1
"Intel C++ Compiler Documentation". Included	1
illogical that the compiler uses	1
Programmers Manual", Volume 1 -	1
AND-OR construction in example 12.4b	1
(short int)i; This conversion takes	1
!b) rather than the equivalent	1
versions, each carefully optimized and	1
microcontrollers. I am not making	1
-b to a < b	1
-a > -b to a	1
_mm_prefetch SSE Store 4 bytes	1
12.4. Vector class libraries 113	1
MyChild> class CParent : public	1
bb[size] ); Alignd ( short	1
building blocks such as gates,	1
universal, flexible, well tested, and	1
pool all the objects together	1
&list[100] is (int)(&list[100]) = (int)(&list[0])	1
Entry to dispatched function call	1
add_elements(__m128 const & x) {	1
Returning objects of a composite	1
++i). But when the result	1
NUMROWS = 100, NUMCOLUMNS =	1
(s0+s1)+(s2+s3); Now s0, s1, s2	1
Primitives (IPP). Works with all	1
narrow range then a simple	1
12.4e. Same example, using Agner	1
DLL's (dynamically linked libraries or	1
"Moving blocks of data", where	1
sqaure: for (r2 = r1;	1
&SelectAddMul_dispatch; // Dispatcher void SelectAddMul_dispatch(short	1
mutexes. Open database connections. Open	1
move. It is unacceptable to	1
nfac; xn *= x; nfac	1
detecting errors that seldom occur	1
move, depending on the specified	1
"Inner Loops: A sourcebook for	1
distinct tasks. A critical innermost	1
(a&b)&(c&d) a ^0 = a	1
License, optional commercial license Table	1
core, but it requires that	1
string, wstring or CString uses	1
0.82 0.59 0.27 strlen 128	1
heading You can subtract this	1
60. In the case of	1
Prefetching data The prefetch instruction	1
vectorization, such as Gnu, Clang,	1
position. Windows DLLs use relocation.	1
0.89 0.40 0.30 4.5 0.82	1
ahead. It is less efficient	1
15] += 1.0f; This needs	1
scanner that scans all files	1
logic. Some guidelines are provided	1
ifunc branch). This feature uses	1
/Gr Function level linking (remove	1
n(n-1)!. If we want to	1
Transposing a matrix is the	1
controlling the order in which	1
shared_ptr. auto_ptr has the feature	1
databases. The operating system may	1
trying the techniques in the	1
multitasking environment, between different threads	1
(27 - 80 clock cycles	1
(20 - 45 clock cycles).	1
(total cache size) / (number	1
8.5b a += 2; Common	1
/GL --combine -fwhole- program /Qipo	1
8.5a void Plus2 (int *	1
it) load into memory even	1
strategies It is quite expensive	1
requested. See page 45. This	1
delayed for several seconds because	1
List[i]++; Here, the compiler can	1
you. Optimized function libraries for	1
assumes that we know that	1
variable: // Example 7.26b float	1
2003. Contains many bit manipulation	1
assumed that the reader has	1
builder. Not optimized for SSE2	1
! and the corresponding bitwise	1
nowadays stress the importance of	1
Templates...............................................................................................................57 7.29 Threads .................................................................................................................. 60	1
OneOrTwo5[b!=0] as OneOrTwo5[(b!=0) ? 1	1
maps etc. It is common	1
9.10, then the nontemporal write	1
steps. All source files are	1
Updating mechanisms often disturb the	1
-axAVX. This will make multiple	1
inverting the sign bit: //	1
(int)(&list[100]) = (int)(&list[0]) + 100*16,	1
_mm_or_si128(c2, bc); // Store the	1
ebx,eax / shr ebx,31 copies	1
specialization. This is how the	1
specialization, not with a branch	1
improved. 3.2 Use a profiler	1
Fortran. These directives are supported	1
Meyers: "Effective C++". Addison-Wesley. Third	1
(a1*b2 + a2*b1) / (b1*b2);	1
evaluated, because the result is	1
OneOrTwo5[b!=0]; will also work, 133	1
x(0) {}; void xplus2() {	1
vmldExp2 Intel SVML v.10.3 &	1
rounded to 100000000. When we	1
Truncation is slow. Value of	1
1.2345; Change this to: //	1
duration compared with the time	1
pointers: The trick violates the	1
_mm. These functions are listed	1
Wikibooks. The following list points	1
switches; so that it is	1
interleave the two formulas in	1
27 The number of registers	1
0.57 0.44 0.12 memcpy 16kB	1
0); DontSkip = dummy[0]; clock	1
Eclipse when compiling for Linux.	1
real time applications. Remember that	1
B*x + C; } polynomial	1
2002). In some cases, it	1
"generate map file" option for	1
true/false Loopunrolling x-xxxx--x Profile-guided optimization	1
detected until 10 - 20	1
supercomputers with massively parallel vector	1
initializing pointers to zero, by	1
mirrored in the level-1 data	1
matrix[FuncRow(i)][FuncCol(i)] += x; Here, the	1
Implicit type conversion // C-style	1
underestimate this time lag. Thinking	1
rule. Splitting up a function	1
Installation problems. The procedures for	1
undocumented. 2.7 Choice of user	1
bitmap than to draw each	1
0x7FFFFF) | 0x3F800000; // Now	1
2A and 2B. There are	1
valuable source of information about	1
type-casting. It is used, for	1
bases, but there is no	1
redirects it to the exception	1
(SSE2): #include <xmmintrin.h> _mm_setcsr(_mm_getcsr() |	1
severe delays if the distance	1
member. This pointer is 4	1
vectors) /arch:SSE -msse /arch:SSE -msse	1
mentally flawed approach to CPU	1
connect them. The hardware definition	1
bility of the programmer to	1
n+1; // Approximate exp(x) for	1
Sutter: A Pragmatic Look at	1
primitive, but efficient, way of	1
transposing and copying different size	1
computer, including the profiler itself.	1
closest to the truth depends	1
print out results printf("\n%2i %10I64i",	1
evaluation of the operands has	1
foreground jobs and 10 ms	1
only). Specifies a function to	1
obtain, such as eliminating the	1
investigated by the methods described	1
power, loop unrolled double xpow10(double	1
(handle != INVALID_HANDLE_VALUE && WriteFile(handle,	1
11.1 for IA-32/Intel64, 2009. Gnu	1
Constructor // Initialize to zero	1
11.6 64 64 32 16.4	1
media such as floppy disks	1
benefits of a copy protection	1
11.8 127 127 126 12.2	1
powN<(N & N-1)==0,N>::p(x); } //	1
bias of the Intel compiler	1
utilized appropriately. Users should get	1
MKL relies on the CPU	1
263-1 int64_t 29 64-bit Linux:	1
F64vec2 F32vec8 F64vec4 Table 12.5.	1
language", section 17.9: "Moving blocks	1
X. 14.13 System programming Device	1
(remove unreferen- ced functions) /Gy	1
X" is simply not appropriate	1
developing so fast that what	1
aligned, and make sure that	1
2.0/3.0 than to calculate the	1
7.31b char string[100], *p =	1
7.31a char string[100], *p =	1
powN<true,N-N1>::p(x); #undef N1 } };	1
Language Runtime, CLR, to produce	1
noticeable. The following example transposes	1
gigabytes of data. The similarity	1
>>= 1; } return y;	1
103) will be able to	1
learning process where the main	1
7.43b. Compile-time polymorphism with templates	1
links. 20 Copyright notice This	1
UnusedFiller; }; int order(int x);	1
50-50 chance of going either	1
know). The code can now	1
overview of the problem cannot	1
supposed to call the destructor	1
14.4b if ((unsigned int)i >=	1
15.1a. Calculate x to the	1
Mbytes. There may also be	1
interactive programs because the response	1
version). This wasteful behavior can	1
bitofn // return y =	1
happens. This is the reason	1
error-prone. The program has to	1
article on compiler optimization. en.wikipedia.org/wiki/Compiler_optimization.	1
entries. This may improve the	1
risky. The returned pointer or	1
built with another compiler. 2.6	1
Members of parent and child	1
majority of end user's computers.	1
build code for the .NET	1
(multithreaded) /arch:AVX /openmp /MT -msse3	1
int)(i - min) <= (unsigned	1
justifies the relatively small gain	1
8.13a int i, a[100], b;	1
8.13b int i, a[100], b,	1
~, <<, >> can test	1
wheel. The containers in the	1
come. Even big software companies	1
(gcc v. 4.5.2, July 2011).	1
self-explaining menus of a graphical	1
actively invalidate the cache. The	1
2.5}; return list[x]; } The	1
a.x, y + a.y);} vector	1
weigh the advantages over the	1
resource-hungry applications to perform poorly	1
zero-bits if unsigned. This typically	1
reorganized in such a way	1
(a&~b)|(~a&b)=a^b --------- ~a ^ ~b	1
__try { // Main loop	1
minimizing memory fragmentation. Bounds checking	1
relation to execution time. 4	1
b[r][c]; } } } This	1
enum, const, or #define makes	1
8.21, you could calculate *p+2	1
14.15b if (a * c	1
fine then it is not	1
Usability for Nerds at Wikibooks.	1
CPU-dispatching (see page 122) for	1
double) /arch:SSE2 -msse2 /arch:SSE2 -msse2	1
main, but also when called	1
truly represent a known CPU	1
allocation, deallocation and garbage collection	1
seen, is certainly a very	1
(MFC). A competing product is	1
sprintf, etc. But beware that	1
double: // Example 14.23b union	1
CriticalFunction, @gnu_indirect_function"); // Make the	1
reorganize: // Example 15.1c. Calculate	1
convoluted template metaprogramming is. //	1
b[i]; c[i] = temp *	1
.R. for AVX. These suffixes	1
restrictions. A GNU Free Documentation	1
copyrighted by Agner Fog. Public	1
network. Various development tools for	1
arraysize; i++) { // Overflow	1
express any algorithm with template	1
cheaper and more efficient than	1
re-allocation is needed. Objects inside	1
de-referenced in order to access	1
Web systems should be tested	1
restart the computer while he	1
(dynamically linked libraries or shared	1
(j = 0; j <	1
clearing arrays It may not	1
auto_ptr. Smart pointers can be	1
Non-strict floating point -ffast-math /fp:fast	1
List[ArraySize]; ... for (int i	1
experiments. Contentions in the level-2	1
acceptable. 3.6 Dynamic linking and	1
*(++p) because in the latter	1
Vec4uq Vec4f Vec2d Vec8f Vec4d	1
Modulo by a constant is	1
improvements). // Example 8.26b void	1
vectorize, or #pragma novector to	1
doubles by comparing bits 32-62.	1
so, then you can avoid	1
Compile-time polymorphism with templates //	1
weekdays. The maximum number of	1
price GNU General Public License,	1
PSDK). Supports the OpenMP directives	1
Noncached write #pragma vector nontemporal	1
printf(Greek[n]); } The declaration of	1
Unlike a pointer or a	1
interface, another thread can take	1
(MKL v. 7.2). This library	1
response. It is the responsibility	1
MFC application. The development time	1
supported"); return; } // continue	1
misprediction, or long dependency chains	1
loader. 2. Position-independent code. All	1
(1./1.2345) at compile time and	1
array[++i] because in the latter	1
Func1(int x) { return x*x	1
responses to simple actions like	1
offering profiling tools that fit	1
Programming in the way of	1
First-In-Last- Out (FILO) basis then	1
Inserting your own profiling instruments	1
(10000 / 64) % 32	1
cpuid // Read time You	1
16.2. The measured time is	1
Advice on how to test	1
a+a+a+a = a*4 - n.a.	1
PTR[ecx+eax*4],ebx eax, 1 eax, 100	1
mode): ; Example 8.26a compiled	1
{1.0f, 2.5f}; a = OneOrTwo5[b	1
kludgy that it may not	1
clauses: initialization, condition, and increment.	1
throughout the whole program execution,	1
x8 = x4*x4; double x10	1
eliminates the need for the	1
straightforward. The MASM assembly language	1
create a new one. I	1
non-const reference, a const reference	1
dropping the graphical user interface	1
Studio. This tool can make	1
SSE4A ammintrin.h AMD XOP ammintrin.h	1
friend function or operator that	1
inlining, common subexpression elimination, constant	1
linking, as explained in the	1
12.2, the optimized code will	1
unnecessarily wasteful in the STL.	1
caught by the operating system	1
structure), the microprocessor doesn't know	1
checked before storing. The standard	1
a[i+1]; s2 += a[i+2]; s3	1
(true) { a = b;	1
107), OpenMP and automatic parallelization	1
122) for the latest instruction	1
62. If the critical innermost	1
source, and the availability of	1
96. 14.5 Integer division Integer	1
coded. If the software contains	1
further. The first thing we	1
Branch/loop function vectorized: void SelectAddMul(short	1
key? If the key values	1
sizeof(float)); // (Some compilers use	1
x-xxx-x-- 0/a=0 ---xx--xx (-a==-b)=(a==b) ---xx----	1
xx x x- x -----	1
key. Do objects have mixed	1
Menus, buttons, dialog boxes, etc.	1
conform to the standard calling	1
sizeof(float)). Now, the factor to	1
password. The log on process	1
Linked lists and other data	1
classes): // Example 12.9b. Taylor	1
compilers............................................................................. 74 8.3 Obstacles to	1
transition from AVX code to	1
(3 - 10 clock cycles,	1
Copy protection. Some copy protection	1
10.1.020. Functions _intel_fast_memcpy and __intel_new_strlen	1
TR18015 Technical Report on C++	1
happening. It is possible to	1
keys within a limited range	1
assignment operator, or an over-	1
Namespaces........................................................................................................... 65 8 Optimizations in	1
alternatingly several times in order	1
e, f, x, y; x	1
2005. Codeplay VectorC v. 2.1.7,	1
_mm_malloc and _mm_free. A more	1
exit(), abort(), _endthread(), etc. then	1
sizeof(list)); A multidimensional array should	1
hand-held devices are becoming more	1
a;} float parabola (float x)	1
5.82 (Embarcadero/CodeGear/Borland C++ Builder 5,	1
year or two. Often, it	1
ex xn n 0 n!	1
1./720., 1./5040., 1./40320., 1./362880., 1./3628800.,	1
throughputs and micro-operation breakdowns for	1
for(i=i_div_3=0; i<300; i+=3,i_div_3++){ list[i] +=	1
meta- programming is so complicated	1
CFALSE; } } 34 else	1
CFALSE: c = 0; }	1
Except for the simplest cases,	1
Include file dvec.h vectorclass.h Supported	1
entirely inside one function, if	1
(&ArraySize) is taken. A const	1
form. A disadvantage of binary	1
cut off the binary value	1
developed. A CPU dispatch mechanism	1
frequency, as explained on page	1
lineage of software that dates	1
nor slower than truncation when	1
x*x + 1; } module2.cpp	1
error-handling function that simply prints	1
correspondence between function names and	1
areas where speed is particularly	1
occasionally predict that the loop	1
forms a long dependency chain.	1
reusability and systematization of the	1
141. Applications that generate floating	1
First-In-First-Out or First-In-Last-Out access, sort	1
old-fashioned. Development in C++ is	1
n;} This code will work	1
u[1] by u[0]. 14.10 Mathematical	1
indication of which optimizations you	1
x*8 is replaced by x<<3,	1
complicated. If the total number	1
block, but this memory block	1
ended queue) allocates one memory	1
-msse2, -mavx, etc. for Linux)	1
strongest optimization option available. Some	1
remember that your code is	1
Keep often used functions separate	1
Memory-hungry applications force the operating	1
sizeof operator. The code for	1
server in full use rather	1
affects other parts of the	1
decision at different times: Dispatch	1
0.75 0.18 0.11 1.21 0.57	1
0.77 0.89 0.40 0.30 4.5	1
Nothing in the calculation of	1
<bool IsPowerOf2, int N> class	1
staircase function of the loop	1
?: operator here is a	1
economy and small code size	1
1./8.71782E10, 1./1.30767E12, 1./2.09227E13}; float x2	1
ipow(x,10); // used for multiplication	1
packing, unpacking needed. Predictable branches	1
Contains many bit manipulation tricks	1
attribute which can be applied	1
E-book Usability for Nerds at	1
(int)d; // Truncation is slow.	1
7.2. Alignment of data members.	1
s1, s2 and s3 can	1
_intel_fast_memcpy and __intel_new_strlen in library	1
graphic brushes, etc. Locked mutexes.	1
vectors........................................................................ 119 12.8 Aligning dynamically	1
9.1a int Func(int); const int	1
9.1b int Func(int); const int	1
absvalue, largest_abs = 0; int	1
mathimf.h that come with the	1
GetTickCount or QueryPerformanceCounter functions for	1
registers; see page 122. The	1
(.lib or .a), but not	1
2'nd order polynomial: // Example	1
verifying, debugging and maintaining such	1
lesson we can learn from	1
forward access to a file	1
original, poorly designed program. 6	1
translate these addresses to function	1
Occasionally, the clock counts that	1
improvements. Making too many branches.	1
absvalue; largest_index = i; }	1
position-independent, makes a PLT for	1
conditional move, depending on the	1
9.1. Time for transposition of	1
frame, saving and restoring registers,	1
frame" or "frame pointer". The	1
int8_t short int in 16-bit	1
104). The table of coefficients	1
Vec8f Vec4d 16 16 32	1
Vec8i Vec8ui Vec4q Vec4uq Vec4f	1
x^3, x^4 F32vec4 xx4(x4); //	1
.................................................................................... 124 13.3 Difficult cases........................................................................................................	1
1.5f : 2.6f; The ?:	1
--combine -fwhole- program /Qipo -ipo	1
_mm256_i32gather_epi32 unlimited 4 bytes =	1
__declspec(noalias) or __restrict or #pragma	1
unequally can become a serious	1
(b&c) = (a&b) | (~a&c)	1
.exe file, is acceptable. 3.6	1
printf("Gamma"); break; case 3: printf("Delta");	1
polynomial: // Example 8.23a. Loop	1
commas. There should be only	1
popped from the stack before	1
engineering principles to use. I	1
polynomial. Scheduling A compiler may	1
burdensome position-independent code and table	1
trial versions are available for	1
contiguous. The code becomes smaller	1
................................................................. 107 12.2 AVX-512 instruction	1
thinks "what works best on	1
_mm_load_ps(coef+i); // s += x^n/n!	1
maintenance. However, this is not	1
downloaded program updates should be	1
(*CriticalFunction)(parm1, parm2); } int main()	1
b1; y2 = a2 /	1
explaining the relative efficiency of	1
(ArraySize) is constant and known	1
prepared for several iterations of	1
iterators that are used in	1
implies more than it says.	1
200. Next, we are adding	1
safety, you may store all	1
(a|b)&(a|c) = a|(b&c) x-xxxx--x ~a&~b=~(a|b)	1
2006 (Red Hat). PathScale C++	1
2007 (www.intel.com/technology/itj/). 10.1 Hyperthreading Some	1
2004 - 2014. Last updated	1
53). No general statement can	1
ready-made profiler. This does not	1
Detect supported instruction set int	1
GetPrivateProfileString and WritePrivateProfileString to read	1
vector::reserve with a prediction or	1
CParent<CChild2> { public: void Disp()	1
storage............................................................................. 26 7.2 Integers variables	1
query certain operating system functions	1
7.33b const int size =	1
delete). 88 Object oriented programming	1
compose a bitfield by the	1
prototype: void F1() throw(); This	1
fragmentation. Bounds checking is included	1
OK, however, to pass a	1
sorting, searching, and mathematical calculations.	1
y2; y1 = a1 /	1
fatal errors if they are	1
scarcity of registers. This problem	1
Rick Booth: "Inner Loops: A	1
MOVNTI _mm_stream_si32 SSE2 Store 8	1
-100+100+100 = 100. Now, according	1
classes............................................................................................ 51 7.18 Class data	1
initializer lists, switch statement jump	1
(www.intel.com). If you are using	1
1./362880., 1./3628800., 1./39916800., 1./4.790016E8, 1./6.22702E9,	1
non-zero, and therefore count as	1
initializes x to 0 //	1
g(x) is calculated twice because	1
discover that there are smarter	1
-2.0 55 In this example,	1
93). All common implementations of	1
(release version) in the debugger	1
publicly available information. They have	1
optimized, using assembly language and	1
discrete icon signaling the availability	1
-opt-report Table 18.2. Compiler directives	1
unsatisfied with the performance of	1
safe, of course. It is	1
entries use 64 bits rather	1
other, then put the most	1
seemingly simultaneously. If the computer	1
imported pointer, but this feature	1
standardized. It is not even	1
compensate for the difference between	1
maintain and verify than a	1
sin. Pointer elimination A pointer	1
sin, etc. Overriding the Intel	1
rightmost 1-bit removed. If N	1
............................................................................... 8 2.5 Choice of	1
insertion of a new element	1
object: (1) get its own	1
instead. The Gnu libraries support	1
saved. Any other allocated resource.	1
_mm_andnot_si128(mask, bc); // OR the	1
8.11b int SomeFunction (int a,	1
8.11a int SomeFunction (int a,	1
(Integrated Development Environments) have facilities	1
opposite). 9.10 Cache contentions in	1
"AMD64 Architecture Programmers Manual", Volume	1
0x20, Saturday = 0x40 };	1
DTRUE: d = 1; }	1
DTRUE; } } else {	1
exchange data or pointers to	1
supposedly is system-independent, in another	1
digits. The exponent is always	1
44. The dispatching mechanism can	1
digits, so the value of	1
www.agner.org/optimize/#vectorclass All these libraries have	1
(absvalue > largest_abs) { largest_abs	1
8.23b has two loop-carried dependency	1
defined(__GNUC__) // 32-bit Linux, Gnu/AT&T	1
excuse that "we don't support	1
SelectAddMul_SSE2 #elif INSTRSET == 5	1
system-specific. In order to facilitate	1
Predictable branches that can skip	1
Later models had the full	1
www.agner.org/ optimize/#vectorclass Include file dvec.h	1
factors. The way to increase	1
operators). The same argument does	1
(b&&c) = a ? b	1
35 This is optimal in	1
34 else { CFALSE: c	1
'?', '@' and '$' are	1
-2.0, 4.4, 2.5}; return list[x];	1
int)a / 10; // Convert	1
holding the pointer. These conversions	1
module, and to put the	1
Running multiple threads on a	1
hint, but it can be	1
system-specific graphical interface calls. The	1
instrset_detect(); 116 // Set function	1
remotely. If frequent updates are	1
distributions of Linux, BSD and	1
Loops: A sourcebook for fast	1
"we don't support processor X"	1
little-known alternative to using new	1
Hoisie: "Performance Optimization of Numerically	1
InstructionSet(): // Example 13.1 //	1
decryption, data compression Most compilers	1
crystal ball reveals that similar	1
resolution. A much higher resolution	1
absent in a use situation	1
Similarly, we are seeing an	1
name, regardless of scope or	1
(approximately): if (absvalue > largest_abs)	1
reset or goes into sleep	1
disassembly, probably without information about	1
ordering? If you need to	1
arranging data in order to	1
hints as pragmas in the	1
functionality. This will be very	1
decoded in several stages before	1
a<<b<<c=a<<(b+c) x-xxx--xx a | 0	1
__intel_cpu_feature_indicator where each bit indicates	1
Vol. 11, Iss. 4, 2007	1
unchanged. The problem with this	1
unchanged, while the expression that	1
tag on a program saying	1
Or, if protection against overflow	1
Combining the Borland compiler with	1
fetch the variable from RAM	1
(c1 = 0; c1 <	1
reserved for dynamic allocation. The	1
balanced mix of additions and	1
convenient. It is easier to	1
(when vector operations are not	1
effectively preventing illegitimate copying. The	1
specification. The empty throw()specification is	1
high. It may be more	1
native floating point execution units.	1
rendering graphics on the screen.	1
First-In-First- Out (FIFO) basis then	1
line: static inline void StoreNTD(double	1
dilemma can be solved by	1
(b*c)/d, it can happen that	1
propagate through the calculations so	1
varies between 9 and 64,	1
line, because the threads will	1
framework........................................................................... 14 2.8 Overcoming the	1
floats: float * DynamicArray =	1
timediff[NumberOfTests]; for (i = 0;	1
floats. The same applies to	1
22). 159 18 Overview of	1
Place non-polymorphic functions in the	1
abc; }; Bitfield x; int	1
ambiguous and may produce undesired	1
models. However, we must consider	1
correspond to any known hardware	1
_mm_permutevar_ps 4 4 bytes =	1
7.38b. Alternative to multiple inheritance	1
Y; Y += Z; Z	1
BigArray[1024]; // Windows syntax or	1
3B. developer.intel.com. AMD: "AMD64 Architecture	1
steps to access a public	1
looping through a linear array.	1
Func1(2); ... } If Func1	1
flawed approach to CPU dispatching.	1
about. Function inlining The compiler	1
pop-up messages saying please install	1
signifying one of the weekdays.	1
renaming. The CPU can hold	1
manually, but if we want	1
<malloc.h> void SomeFunction (int n)	1
spell checking. Any task that	1
sequential, and you cannot make	1
&list[0]; temp < &list[100]; temp++)	1
(Not A Number) if an	1
day be implemented in PC	1
complications. A double is represented	1
least, it can be said	1
VTune and AMD CodeAnalyst. There	1
__vrs4_expf __vrd2_exp AMD LIBM Library	1
x-xx----x x-xxxxxx- x-xxxx-x- x-xxxxxxx xxxxxxxxx	1
identifies any hot spots in	1
--------x a/1=a x-xxx-x-- 0/a=0 ---xx--xx	1
a|(b&c) x-xxxx--x ~a&~b=~(a|b) --xxxx--- a	1
double's of 8 bytes each.	1
lists. A linked list is	1
lists, switch statement jump tables,	1
programmed in a hardware definition	1
most. The opposite of register	1
Print heading You can subtract	1
designers have gone to great	1
Try to allocate more RAM	1
contiguously in the memory. This	1
8.1b float parabola (float x)	1
x,y coordinates // default constructor	1
8.1a float square (float a)	1
-fno-strict-overflow. You may deviate from	1
usable library if possible. This	1
Reset floating point status: _fpreset();	1
likelihood that certain parts of	1
fixed-size array is made very	1
dependent. The stack unwinding mechanism	1
right-most 1-bit in binary representation	1
--------- ~a ^ ~b =	1
143. The trick will fail	1
||). The bitwise operators are	1
facilitate porting between platforms, it	1
2007. PGI C++ v. 7.1-4,	1
12.9b. Taylor series, vectorized #include	1
esp+8 and esp+12 and loaded	1
...................................... 88 9.5 Alignment of	1
economy, cache efficiency and code	1
lately. Vector class library Intel	1
structures: // Example 9.1a int	1
row-wise, then the mirror elements	1
lookup-table static. Example: // Example	1
reached with a 32-bit (signed)	1
8.16 float a, b, c,	1
__rdtsc()). The time stamp counter	1
(GOT). These table lookups are	1
8.17 char a = -100,	1
8.18 float a = -1.0E8,	1
Sequential forward access to a	1
may, in addition, set the	1
multithreading. 7.30 Exceptions and error	1
7.43 on page 58 shows	1
7.42 int Multiply (int x,	1
renewed. Context switches are more	1
7.45 // Portability note: This	1
7.44 class C1 { public:	1
7.4. Signed and unsigned integers	1
two(2,2,2,2,2,2,2,2); // Roll out loop	1
while-loop is also a kind	1
Compiled languages include C, C++,	1
1/n! 1., 1./2., 1./6., 1./24.,	1
378.7 168.5 513 513 58.7	1
counting clock cycles at the	1
"\nError: Instruction set SSE2 not	1
neutralize each other. This is	1
x.i |= 0x80000000; // set	1
38.1 97 Table 9.1. Time	1
38.7 512 512 2048 230.7	1
"__attribute__((visibility("hidden")))". Use whole program optimization	1
animations is of course also	1
Manual". developer.intel.com. Many advices on	1
demonstration purposes. Available from www.agner.org/optimize/asmlib.zip.	1
cards, etc. Use an antivirus	1
1./6.22702E9, 1./8.71782E10, 1./1.30767E12, 1./2.09227E13}; float	1
hand and insert the values	1
caller, and so on. 7.31	1
32, 64, ...). We can	1
provokes an error. // You	1
operand. Likewise, if the first	1
memory-hungry software in two versions.	1
provoked here in a rather	1
32; float matrix[rows][columns]; int i;	1
WhateverFunction(i); // ... } }	1
unavoidable. It may be useful	1
apparently has no effect. GOT	1
DLL. Another alternative worth considering	1
_mm_stream_ps SSE Store 16 bytes	1
perform poorly for the end	1
mark_end; This solution is clearly	1
96). Virtual functions in C++	1
x^1, x^2, x^3, x^4 F32vec4	1
-ftrapv, but this is extremely	1
libircmt.lib. Function names are undocumented.	1
1.2345); The compiler will calculate	1
repetitive. The simplest case is	1
(n) { case 0: printf("Alpha");	1
consumers. Choose the strongest optimization	1
request for inlining a function	1
N: #define N1 (N &	1
"Alpha", "Beta", "Gamma", "Delta" };	1
(be aware of possible overflow	1
artificially changed to the old	1
animation. It is possible in	1
cons of using classes. 7.2	1
tolerance. The time it takes	1
0x3F00 and 0x4700. These addresses	1
17is calculated as(a << 4)	1
reputation. The compactness of the	1
Iu8vec8 16 4 short int	1
(/Oa). The easiest way to	1
saturated addition, fast approximate reciprocal,	1
offsets). Example: // Example 7.36	1
$B1$2: mov shr add sar	1
knowledge of the C++ programming	1
list[i].b = 2.0; } In	1
stub. If different versions of	1
Espresso) that can reduce any	1
Guide for AMD Family 15h	1
"Integrated Performance Primitives". These function	1
T+6, and the whole loop	1
examples: strlen function. The string	1
bear in mind, that many	1
log(2.0) is only calculated the	1
andnot(a,a) = 0 - n.a.	1
12.8a. Sum of a list	1
0x7FFFFFFF; // set sign bit	1
-mavx, etc. for Linux) 4.	1
"__attribute__((visibility ("hidden")))". A more complicated	1
2:8+esp eax, edx, ecx, edx,	1
c2, mask); // Store the	1
anything, you have to identify	1
pulses since the CPU was	1
disappears when running in 64-bit	1
requests for elements in a	1
reliable. Event-based sampling: The profiler	1
Typically it should save one	1
constructing the object on its	1
Non-public distribution to a limited	1
GB, but not in a	1
writable data section needs one	1
c2; double temp; // Define	1
inttypes.h is available then it	1
attempting to write the variable	1
Debugging. The profiler inserts temporary	1
indexes, working with sets rather	1
--xxxxxx- a-(-b)=a+b ---xxx-x- a+0=a x-xxxxxx-	1
preprocessor can do because it	1
enters the market for many	1
July 2011). Instead, the following	1
lookup[2] = {2.6f, 1.5f}; a	1
Surprisingly, we end up with	1
because, in most cases, an	1
jeopardizing safety, you may store	1
draws a whole polygon or	1
UNIX shell script. Interpreted code	1
_mm256_permutevar_ps 4 4 bytes =	1
'$' are allowed in assembly	1
exist. Therefore the compiler is	1
9.3. Time for transposing and	1
freely without any cost in	1
taking cache effects into account.	1
values: // Example 14.28 union	1
zation by multiple threads Parallelization	1
(4096). This will make all	1
process...................................................................................................... 25 7 The efficiency	1
values, and last all the	1
maximum, saturated addition, fast approximate	1
discussions about code optimization. See	1
#define, const or typedef instead	1
_fpreset(); _controlfp_s(&dummy, 0, _EM_OVERFLOW); //	1
observed between the optimization capabilities	1
15.1d to 15.1c as intended,	1
package, including all runtime libraries	1
piecewise or re- allocating when	1
division: Integer division by a	1
unused. This removed the contentions	1
ab[size]; int i; ... for	1
steal the user's time. The	1
array[i++] is more efficient than	1
FPGAs. The difference between a	1
x^n/n! xxn *= xx4; //	1
access................................................................................................................ 20 3.8 System database	1
OMF format. Alternatively, make a	1
nicely into the vector registers.	1
finishes in a short time	1
keyword: // Example 14.1c void	1
keyword, for floating 26 point	1
2GHz A clock cycle on	1
cryptography (www.intel.com). If you are	1
Professional and Enterprise editions). Do	1
keyword. The CodeGear compiler cannot	1
strcpy, strcat, strlen, sprintf, etc.	1
7.35b struct S1 { double	1
7.35a struct S1 { short	1
plain old data file in	1
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It is strongly recommended	1
_mm_stream_si32 SSE2 Store 8 bytes	1
GB. When considering whether a	1
advisable to make it in	1
mentations have no checking for	1
_mm_i32gather_ps unlimited 4 bytes =	1
100000001.23456. The float type holds	1
9.6b 64 64 14.0 80.8	1
processors). It has excellent support	1
weighed against the costs in	1
/arch:SSE2. The compiler will produce	1
2009). Intel C++ Compiler v.	1
UnusedFiller in the structure to	1
flaws: The best possible version	1
Booleans................................................................................................................... 33 7.6 Pointers and	1
notion of a "function". Multiple	1
Atom). The following example shows	1
kbytes. This is quite inefficient.	1
Intel) know that standard library	1
comparison: // Example 14.4b if	1
Intel. See Intel Technology Journal	1
FreeBSD and Open BSD are	1
somewhat. The AVX2 instruction set	1
set: // Example 12.4b. Vectorized	1
SelectAddMul_dispatch(short int aa[], short int	1
<intrin.h> long long ReadTSC() {	1
reduced. This may be because	1
Avoiding the cost of exception	1
reporting here: return *(T*)0; }	1
profiling, but it often gives	1
profiling. When a hot spot	1
numbered consecutively? If objects are	1
phase in order to predict	1
(b1 * b2); y1 =	1
builder Has an IDE with	1
Uncached memory store An uncached	1
responsi- bility of the programmer	1
thought about the possibility of	1
(SVML). This is supplied with	1
xx(-)x- - x-xxxx--x x-xxxx--x x-xx-----	1
8.23a. Loop to make table	1
indexed in a non-sequential order	1
event-counters do. This results in	1
often. This is necessary if	1
Microcontrollers used in small embedded	1
genuine compiler became available. It	1
calculate. If there is a	1
modularity, reusability and systematization of	1
modularity. For example, it may	1
localize the first byte of	1
optimize, and reading the performance	1
Instead of returning a composite	1
Repeating the break a few	1
Fine-grained parallelism is the situation	1
script. Interpreted code is very	1
28) The threads have each	1
work, 133 although slightly less	1
28, the cache will evict	1
calculated. Therefore, it is recommended	1
"FDIV bug". The FDIV bug	1
3.1, 2007. PGI C++ v.	1
slower, especially when the code	1
reciprocal: // Example 14.14a double	1
__attribute__((fastcall)). The fastcall modifier can	1
cc[size] ); // Function to	1
fistpl %0 " : "=m"(n)	1
VML and SVML. The IPP	1
Bridge) because it is important	1
mmintrin.h SSE xmmintrin.h SSE2 emmintrin.h	1
long, double. Misaligned data. Extra	1
wastes several clock cycles whenever	1
inexact if b and c	1
odd-sized vector data. The data	1
1./4.790016E8, 1./6.22702E9, 1./8.71782E10, 1./1.30767E12, 1./2.09227E13};	1
thread-like scheduling in an application	1
T+5, then it can do	1
Itanium systems. The Intel compiler	1
Relocation. All pointers and addresses	1
brands, and one that doesnt.	1
2056 38.1 97 Table 9.1.	1
NUMROWS; row++) for (column =	1
Lists of instruction latencies, throughputs	1
module2.cpp int Func2() { int	1
12.8b. Sum of a list,	1
0.29 0.28 strlen 128 bytes	1
14.18c double a, b; //	1
xmmintrin.h SSE2 emmintrin.h SSE3 pmmintrin.h	1
blocking: int r1, r2, c1,	1
0.27 strlen 128 bytes AMD	1
0.22 memcpy 16kB unaligned op.	1
((C & 3) <<6 );	1
((B & 3) << 4)	1
Func(a[i]); } The data in	1
creates or modifies many strings.	1
work-around can be used: //	1
results, which may be undesired.	1
log) inside the critical innermost	1
a*b*c=a*(b*c) a+b+c+d = (a+b)+(c+d) a*b+a*c=a*(b+c)	1
non-vector library. 119 The function	1
recycled? There is a large	1
carry) instructions where the carry	1
OS. See page 128 below.	1
FactorialTable in example 14.1c is	1
timediff[i]); } The code in	1
can. It is therefore necessary	1
JNZ). This solution can incur	1
chain, especially on the Pentium	1
to) the time stamp counter.	1
!(a<b)=(a>=b) (a<b && b<c &&	1
134. The table should be	1
shows, the method of storing	1
feeds a branch into the	1
1.0) { ... Here, you	1
improvements in microprocessor hardware design.	1
introduced in Linux and supported	1
Hence, it is hardly worth	1
x86) of the standard PC	1
8.2a double a, b; a	1
8.2b a = b +	1
alternately FuncA and FuncB, then	1
routines and device drivers are	1
billions of times before the	1
1.09 1.25 1.61 n.a. 2.23	1
x4xn-4. There is no easy	1
103), but the compiler can	1
1980 where RAM memory and	1
14.7b, we are in fact	1
14.7b. Testing multiple conditions using	1
Ignoring virtualization. The time when	1
affected by __fastcall. The implicit	1
x.d = y.d + 4.;	1
x.f = 2.0f; x.i |=	1
7.9b char a = 0,	1
7.9a bool a, b, c,	1
identical. For example, for (i=0;	1
somewhere in F1? Then we	1
!b = !(a || b)	1
bus is saturated. This can	1
(FIFO) basis then use a	1
practice, of course, because you	1
8.24 can be implemented in	1
8.25 void Func () {	1
disassembler. Note that the Intel	1
&&, ||, ! and the	1
8.20 module1.cpp int Func1(int x)	1
(critical stride) = (number of	1
8.22 #ifdef __GNUC__ #define pure_function	1
smart. They can detect that	1
12.9a. Taylor series float Exp(float	1
SSE2, preferably 32 for AVX.	1
r.b;} The three functions Sum1,	1
Multiplying by a power of	1
post-increment operator i++ are as	1
bugs, compatibility problems, usability problems	1
C1::f. But an optimizing compiler	1
F32vec8 F64vec4 Table 12.5. Vector	1
Will be called only first	1
overkill. Don't use an advanced	1
8.3b a = 5.0f; b	1
ordinary procedure linkage table (PLT)	1
paying the performance costs. The	1
Journal Vol. 11, Iss. 4,	1
-1.0E8, b = 1.0E8, c	1
imprecision in some rare cases	1
provide the best optimization it	1
in-between the floating point operations	1
__intel_cpu_feature_indicator_x. You can bypass the	1
recovery information for function F1.	1
(WTL). A WTL application is	1
2.8. Asmlib: v. 2.00. Intel	1
indicates a specific CPU feature	1
46 A common situation where	1
(WTL): // Example 7.43b. Compile-time	1
44 In some cases it	1
decision. 13.4 Test and maintenance	1
42 If you access part	1
indicated by the caller through	1
workstations and scientific vector processors.	1
41 Float to integer conversion	1
230.7 513 513 2056 38.1	1
faster, except perhaps for a	1
(cc[i] + 2) : (bb[i]	1
85 ; eax = i	1
/Qipo -ipo No exception handling	1
indeed. It is possible to	1
a[1] = 2; Unfortunately, some	1
6); Or, if protection against	1
hackers. It is necessary to	1
exact. Multiple divisions can be	1
(row = 0; row <	1
friendly. It is free and	1
predictable, then it is advantageous	1
(OnIdle in Windows MFC). This	1
abusing the update mechanism to	1
Leaf functions are more efficient	1
"Delta" }; if ((unsigned int)n	1
0x10, Friday = 0x20, Saturday	1
................................................................................................................ 48 7.15 Function parameters	1
C2::Disp() is done at runtime	1
sleep mode. See the manual	1
(SIMD) operations. The total size	1
if-else structure), the microprocessor doesn't	1
(); __asm__ (".type CriticalFunction, @gnu_indirect_function");	1
feeding an array of thousand	1
----x---x a/1=a xxxxxxxxx 0/a=0 ---x---xx	1
violate or circumvent operating system	1
34. In some cases the	1
1.19 13 Asmlib Gnu 64	1
(a&&b)||(a&&!b)=a x--xx---- (a&&b) || (!a&&c)	1
mathe- matical applications. But we	1
VHDL or Verilog. Common devices	1
postponed until the program is	1
rise to some extra complications.	1
u[2]} a[size]; unsigned int absvalue,	1
browsing that previously required a	1
counter: // Example 7.31b char	1
0.3, -2.0, 4.4, 2.5}; return	1
Henry S. Warren, Jr.: "Hacker's	1
encounter another problem. The compiler	1
Bit-fields of sizes other than	1
unacceptable. Each of the following	1
live-ranges do not overlap or	1
0.30 4.5 0.82 0.59 0.27	1
Serialize // Prevent optimizing away	1
Reference Manual". developer.intel.com. Many advices	1
consuming, especially if there is	1
problems, usability problems and desired	1
(GOT) in order to implement	1
0.38 0.44 0.40 n.a. 1.00	1
----x---- !(a<b)=(a>=b) (a<b && b<c	1
created, deleted, copied or transferred	1
transpose(matrix); } } } }	1
contention. You may skip this	1
powN<(N1&(N1-1))==0,N1>::p(x) * powN<true,N-N1>::p(x); #undef N1	1
(r1 = 0; r1 <	1
wrapping the vectors into C++	1
omitted, of course, if the	1
p->a + p->b;} int Sum3(S3	1
newer. The CPU family and	1
consisting of digital building blocks	1
estimated calculation time of 250	1
Underestimating the cost of keeping	1
edx. Furthermore, this solution is	1
Z. Each dependency chain has	1
Architectures Optimization Reference Manual". developer.intel.com.	1
hide them for the sake	1
specification to F1 only if	1
decoding and perhaps }; //	1
abort(), _endthread(), etc. then there	1
others. While some of the	1
Z; Z += A2; //	1
memory................................................................. 120 12.9 Aligning RGB	1
considered. A realistic performance test	1
general. Assume that a loop	1
7.38a. Multiple inheritance class B1;	1
hundreds of different intrinsic functions	1
Func2(double x) { return Func1(x)	1
studio 2008, v. 9.0 CodeGear	1
reinvent the wheel. The containers	1
yesterday's big mainframe computers. Today,	1
4.5.2, July 2011). Instead, the	1
NEAR ; parameter 1: 4	1
CodeGear, Codeplay and Watcom compilers	1
http://www.agner.org/optimize/asmlib.zip contains complete code examples	1
compiler) integer parameters are transferred	1
2040 38.7 512 512 2048	1
7.43a. Runtime polymorphism with virtual	1
recursive templates. The powN template	1
Trying to read the performance	1
29. Each cache line has	1
returning. F1 is prevented from	1
sizeof(b)); 47 Most compilers will	1
scheduler. This can be accomplished	1
summarizes the different integer types	1
(b*c) overflows, even if a,	1
prints an appropriate error message	1
optimization", Coriolis group books 1994.	1
(2.0f); b = a +	1
list[i & 15] += 1.0f;	1
pow(x,N) where N is a	1
[eax+400] DWORD PTR [eax], ecx	1
-156. Surprisingly, we end up	1
speeded up significantly just by	1
y.d + 4.; }; //	1
used: // Example 13.2. CPU	1
m. The advantage of using	1
m) { return x *	1
y.a + 1.; x.b =	1
y.b + 2.; x.c =	1
y.c + 3.; x.d =	1
Coriolis group books 1994. Mostly	1
...). We can make sure	1
m> int MultiplyBy (int x)	1
...)) { ... Here you	1
oldest Pentium CPUs which may	1
correspondingly two different types of	1
excellent support for inline assembly	1
(float)i; f = float(i); f	1
grandparent class: class CGrandParent {	1
Vec4q Vec4uq Vec4f Vec2d Vec8f	1
ebx,1 adds this to i	1
(u.i[1] < 0) { //	1
simplicity. But a sorted list	1
Actually, only the code section	1
geometry and other odd-sized vector	1
Vec4i 32 4 unsigned int	1
saves time for the user.	1
aliased #pragma optimize("a", on) __restrict	1
Vec4d 16 16 32 8	1
(MS Visual Studio 2008 version).	1
scheduling in an application program	1
PowerPC). We can make an	1
guarantee that all destructors are	1
Virtualization is becoming increasingly important.	1
algorithm. The choice of algorithm	1
compete for the same resources,	1
searches of the kind: "what	1
both, while the expression a	1
writes. If the cache contentions	1
p->member is equally fast whether	1
confirmed this by measuring the	1
hence higher speed. In the	1
EXCEPTION_CONTINUE_SEARCH) { // Floating point	1
14.21. // Only for SSE2	1
versatile. Fortran is also quite	1
systematization of the software development	1
footprint. If, for example, you	1
memcpy: // Example 7.33b const	1
summing up the factors that	1
ports, etc. of only half	1
Assume, for example, that a	1
ultimate solution would be to	1
organized. Floating point comparisons are	1
parsing are provided in the	1
 2004 - 2014. Last	1
official C standard says that	1
fragmentation of the code makes	1
construction in example 12.4b can	1
modified, if necessary, to fit	1
40% more time to transpose	1
9.0 CodeGear Borland bcc, v.	1
suppress. GOT and PLT tables	1
reflected, first and foremost, in	1
137, respectively. Increment and decrement	1
terminates the program before the	1
26). Variables stored on the	1
perfectly. As explained above, the	1
16.4 65 65 33 11.8	1
-fwhole- program /Qipo -ipo No	1
terminated and the user will	1
. The value is zero	1
backwards. Copying or clearing arrays	1
"Gamma", "Delta" }; if ((unsigned	1
often, but such expressions may	1
history, etc. may have to	1
c1() : x(0) {}; void	1
integer-to-float conversion takes more time	1
arraysize = 1000; unsigned int	1
Vec16us Vec8i Vec8ui Vec4q Vec4uq	1
---xxx-x- a+0=a x-xxxxxx- a*0=0 --xxxx-xx	1
subexpressions, and induction variables (see	1
unreferenced functions. It is recommended	1
non-recursing template specialization, not with	1
puts the programmer in a	1
15.0) is using a six	1
identifier names. We can only	1
gained remarkably in popularity when	1
stage that a detailed overview	1
i++,i2+=2.0f)a[i]=i2; 41 Float to integer	1
(byte code). The source code	1
asmlib.. // or from example	1
combining multiple .cpp files into	1
scope. A macro will interfere	1
selecting optimize performance for background	1
............................................................. 96 9.11 Explicit cache	1
connections, etc. The C++ exception	1
(temp = &list[0]; temp <	1
added. This method is described	1
Namespaces There is no cost	1
merge the multiple data structures	1
142). 30 Overflow behaves differently	1
flush and fence instructions, but	1
ASP and UNIX shell script.	1
documented. The examples in this	1
standards. Such schemes are frequent	1
pointers.......................................................................................................37 7.9 Smart pointers ..........................................................................................................	1
correctness must be found elsewhere.	1
(rather than pointers to objects)	1
(zero with sign bit set).	1
CriticalFunction_Dispatch(int parm1, int parm2) {	1
BTB can cause branch mispredictions	1
profile-guided optimization. This works in	1
PROC NEAR ; parameter 1:	1
0x3FF unsigned int sign :1;//signbit	1
7.32a double x, n, factorial	1
(*p != 0) *(p++) |=	1
issues, and I believe that	1
coding rules apply as to	1
F2(float x[]); void F3(bool y)	1
options....................................................................................... 160 19 Literature .....................................................................................................................	1
0x3FFF unsigned int sign :	1
$B1$3: pop ret ALIGN ?Func@@YAXQAHAAH@Z	1
0.0; // copy a to	1
rewritten with the use of	1
mutexes and message systems. All	1
_mm256_i64gather_epi32 unlimited 8 bytes =	1
attack for hackers. It is	1
clock. This gives a measure	1
exp, sin, etc. Overriding the	1
rights. Software should use standard	1
fluctuating and it may be	1
combine the multiple .cpp modules	1
b<c && a<c) = (a<b	1
incur a large delay due	1
included. Combining the Borland compiler	1
compiler-specific. You cannot expect a	1
security, but may be removed	1
reinterpret_cast operator is used for	1
CPU-dispatcher that checks whether the	1
1.5f; is efficient when b	1
Sum1, Sum2 and Sum3 are	1
(*.ini files). 20 3.9 Other	1
returned. There is no check	1
1.25 1.61 n.a. 2.23 0.95	1
1.21 0.57 0.44 0.12 memcpy	1
(also called properties) are always	1
mechanisms. Modern microprocessors are able	1
Warren, Jr.: "Hacker's Delight". Addison-Wesley,	1
matrix[i][j] += x; This makes	1
pass a pointer or reference	1
mechanisms, and some of these	1
Constantfolding xxxxxxxxx Codeplay Watcom Digital	1
&CriticalFunction_Dispatch; // Lowest version int	1
traditionally considered a software optimization	1
Database queries can often be	1
upon the double. Another problem	1
isolated into a separate function	1
thorough analysis of the data	1
EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { //	1
isolates the least significant n	1
ball reveals that similar solutions	1
intrin.h (MS) x86intrin.h (Gnu) Table	1
Convert to unsigned for fast	1
pow, log, exp, sin, etc.	1
denominator can even be used	1
int)(max - min)) { ...	1
pattern, while Pentium 4 and	1
of. Big runtime frameworks. The	1
Float to integer conversion Conversion	1
Sort the array after all	1
excessively so. These containers should	1
inlined, or optimized away. It	1
1024/4 = 256 times and	1
max) { ... can be	1
/QaxAVX or -axAVX. This will	1
delaying process is used when	1
/Ox -O3 or -Ofast /O3	1
/Oy -fomit- frame- pointer -fomit-	1
reorganize the code so that	1
intranet for automatic updates, remote	1
v.i * 2) { //	1
(2,2,2,2), and store the four	1
directly: Library exp function of	1
INVALID_HANDLE_VALUE && WriteFile(handle, ...)) {	1
(Embarcadero/CodeGear/Borland C++ Builder 5, 2009).	1
/Oa -fno-alias Non-strict floating point	1
/Og Whole program optimization /GL	1
54. It is recommended to	1
micro-operation breakdowns for Intel, AMD	1
||, ! and the corresponding	1
Bit vector algebra reductions: x--	1
inputs. Let's take the integer	1
infinity, and this value will	1
infinity. A typical implementation of	1
utilizing its out-of- order calculation	1
solution, but it increases the	1
Larger data types: long long,	1
criticized for code bloat and	1
PathScale. 2. Use the latest	1
reduction. For example, a programmer	1
label. It uses ebx as	1
despite the extra function calls	1
/O2 or /Ox -O3 or	1
reinstall a software package several	1
framework, during start of the	1
SSE3. // (This is faster	1
situation, but the programmer can.	1
modulo. For example, if we	1
5.0f; b = 6.0f; Constant	1
a[0] = 1; a[1] =	1
hard-to-find errors, and some tips	1
new. The purpose of using	1
/fp:fast /fp:fast=2 -fp-model fast, -fp-	1
adjusted if you change pre-increment	1
dominating. At least, it can	1
discriminating between CPU brands and	1
36. There may be cases	1
Contents 1 Introduction ....................................................................................................................... 3	1
Asmlib: v. 2.00. Intel C++	1
zero-terminated ASCII string to lower	1
pipelined, as explained above, so	1
polymorphous class? This chapter is	1
_mm_free. A more general method	1
discovers that it has chosen	1
_mm_stream_pd SSE2 Store 16 bytes	1
streams with different strides. Therefore,	1
_mm_stream_pi SSE Store 16 bytes	1
2.20, glibc version 2.11 ifunc	1
intervals. Some programs search for	1
81). 77 Pointer aliasing When	1
cycles). Floating point division by	1
16is calculated asa << 4,	1
non-constant references require a variable.	1
taken. A const pointer or	1
irregular response times. It is	1
extracts the functions that are	1
taken, i.e. if there is	1
games and animations is of	1
lrint(d); // Rounding is fast.	1
Is32vec4 Vec4i 32 4 unsigned	1
Is32vec2 32 64 Iu32vec2 64	1
microcontrollers: Smaller microcontrollers have no	1
(other than log) inside the	1
-ipo No exception handling /EHs-	1
x[]) { int b, c;	1
a[arraysize], b[arraysize], c[arraysize]; // Enable	1
printf("Delta"); break; } This can	1
1.2 in this example is	1
ends the recursion template<> class	1
quickly to keyboard or mouse	1
restriction, but it doesn't generate	1
email and web browsing that	1
(Windows, Linux, BSD, Intel-based Mac	1
i*sizeof(S1). This is a linear	1
end. The reason for this	1
147 14.12 Position-independent code Shared	1
packed into a vector register.	1
0x2F00, 0x3700, 0x3F00 and 0x4700.	1
(Windows: /Gy, Linux: -ffunction-sections) which	1
(!a&&b) = a XOR b	1
temp2. Modern CPUs are capable	1
edition is available for free.	1
stride, as explained on page	1
stride. Variables whose distance in	1
stride) = (number of sets)	1
temporarily lock a container for	1
teachers to recommend that no	1
stopping threads. Don't put a	1
0x2C so that the if	1
(CGrandParent) contains any non-polymorphic member	1
caches. Typically, there is a	1
positive. It will fail if	1
Booth: "Inner Loops: A sourcebook	1
Libraries for high precision math	1
Because the C++ template feature	1
Find numerically largest element (approximately):	1
2016. The same coding rules	1
!(!a)=a x-xxxxxxx ---x----- x--xx---- (a&&b)||(a&&!b)=a	1
NAN. Avoiding the cost of	1
Interrupt service routines and device	1
platform-independent and compact. The biggest	1
strcat, strlen, sprintf, etc. But	1
(bit scan forward) instruction to	1
required, but in example 12.1b,	1
numerical data is more compact	1
characters '?', '@' and '$'	1
made) then it is preferred	1
matrices. An efficient solution in	1
Thursday, Friday, Saturday }; Weekdays	1
counterparts. In general, you can	1
90. 15 Metaprogramming Metaprogramming means	1
double..................................................................................... 140 14.8 Conversions between	1
(Of course there is no	1
language...................................................... 14 3 Finding the	1
64). You may save RAM	1
STL. Some STL templates, such	1
matters: Division by a constant:	1
0= 0 - n.a. -	1
advance, because a fixed address	1
operators............................................................................... 29 7.3 Floating point	1
84). The compiler can also	1
(Visual Studio 2005). Borland C++	1
13.1. Instruction sets A more	1
new/delete or malloc/free should be	1
14.22b unsigned int u; double	1
14.22a unsigned int u; double	1
technological point of view. This	1
matters, which few programs do.	1
interprets the intermediate code by	1
Run multiple processes or threads	1
vectorizing mathematical code. There are	1
400, last byte at 403	1
www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP. www.openmp.org. Documentation	1
15.1d. Integer power using template	1
Taking the logarithm of each	1
reloaded eight times because it	1
features: The code section contains	1
Nerds at Wikibooks. The following	1
user-written code with automatic CPU	1
59 third generations classes contain	1
amd_vrd2_exp Agner's vector class library	1
5; to int x =	1
clearly better. The loop body	1
-fno-alias Non-strict floating point -ffast-math	1
ingenious things to make the	1
57 Templates are efficient because	1
denominator: // Example 14.16b double	1
Func1(double) pure_function ; double Func2(double	1
later) instruction set is enabled.	1
Denmark. Copyright  2004 -	1
StoreNTD(double * dest, double const	1
(Both use 32 bits in	1
5, 2009). Intel C++ Compiler	1
two: // Example 11.2b const	1
14.18a float a, b; a	1
14.18b float a, b; a	1
53. 7.24 Unions A union	1
two, b * c); //	1
Slongdouble { unsigned int fraction	1
9.2b void F3(bool y) {	1
9.2a void F1(int x[]); void	1
Much of the advice given	1
evicted. Don't mix nontemporal writes	1
advertise new versions of their	1
(-a>-b)=(a<b) ---xx---x Divide by constant	1
short. In Windows, you can	1
45. This may be advantageous	1
1./39916800., 1./4.790016E8, 1./6.22702E9, 1./8.71782E10, 1./1.30767E12,	1
occurrences of ArraySize by the	1
Connecting several standard PC's in	1
134) return FactorialTable[n]; // Table	1
12.1a, the compiler can align	1
memset, or mathematical functions such	1
destroyed. In 50 simple cases,	1
have: // Example 12.8b. Sum	1
memset: // Example 7.16 float	1
etc.). Older operating systems lack	1
9.2, such as flush and	1
things. Looking at the compiler	1
limitation and other flaws in	1
8.24. Integer constant const int	1
attacks and other abuse is	1
7.32b double x, n, factorial	1
undocumented Intel library function __intel_cpu_features_init()	1
surely rely on is the	1
-1. The bitwise AND operation	1
met: the object is so	1
shut down and restarted anyway.	1
sections. 3.3 Program installation The	1
behaviors. Arrays are often used	1
Very poor performance for vector	1
assembly-like intrinsic functions, inline assembly	1
Addison- Wesley 1997. Mostly obsolete.	1
following: 130 Compile for a	1
difference, let's say that you	1
bottleneck. Organize the data into	1
sequence. If you know that	1
__declspec(__align(64)) double matrix[SIZE][SIZE]; transpose(matrix); }	1
rounds a floating point number	1
expansions. Programmers do, however, often	1
temp1 and temp2. Modern CPUs	1
0x40) % 0x20 = 0x1C.	1
temp. The compiler doesn't need	1
printf("\nResults:"); for (i = 0;	1
Low-level languages are good for	1
0x0F) | ((B & 3)	1
........................................................................... 54 7.22 Inheritance ..............................................................................................................	1
powN<true,N/2>::p(x) * powN<true,N/2>::p(x); } };	1
version) in the debugger then	1
memcpy(b, a, sizeof(b)); 47 Most	1
b[arraysize], c[arraysize]; // Enable exception	1
truth depends on whether CriticalFunction	1
ADX instructions for high precision	1
ADC (add with carry) instructions	1
realize that such devices typically	1
Contain one or multiple elements?	1
objects, respectively (MS Visual Studio	1
I64vec2 Vec2q 64 2 uint64_t	1
mitigated by making critical functions	1
-axSSE3, etc. (Intel CPU only)	1
objects) are possible only if	1
2015 or 2016. The same	1
r+i/2 could be calculated by	1
lag. Thinking in terms of	1
tedious. The code becomes more	1
design. The ultimate solution would	1
design, it is possible to	1
scratch. This would not only	1
0.63 0.75 0.18 0.11 1.21	1
---xxx--- a/a=1 --------x a/1=a x-xxx-x--	1
Programmable logic devices A programmable	1
producer will try to fix	1
says. A code that is	1
-ffunction-sections) which allows the linker	1
re-allocated every time it is	1
nn ifbit=1 bitofn // return	1
DEC, JNZ). This solution can	1
whereas 64-bit Linux, BSD and	1
Faster, but risk of overflow	1
(Linux only). Specifies a function	1
ns = 250 s on	1
Effective C++". Addison-Wesley, 1996. These	1
XOP ammintrin.h (MS) xopintrin.h (Gnu)	1
XOR b Bit vector algebra	1
stand alone compiler when called	1
-fp-model fast, -fp- model fast=2	1
class? This chapter is aiming	1
free) causes the memory to	1
1./2.09227E13}; float x2 = x	1
135). This extra check on	1
caching, but it took several	1
fprintf // define function type	1
Sum3. Whether you want to	1
block: 62 __try { //	1
clients that depend on network	1
1.4, 2005. Codeplay VectorC v.	1
column++) matrix[row][column] = row +	1
occurred anywhere in the calculations.	1
tool. 7 The efficiency of	1
iterator in some cases, but	1
illegal operation that crashes the	1
8.6a int a, b, c;	1
8.6b int a, b, c,	1
zip file of every version.	1
7.15a. Array with bounds checking	1
33% when the CPUID is	1
signed. Be sure not to	1
signed, or by extending with	1
7.5. Set flush-to-zero mode (SSE):	1
s0, s1, s2 and s3	1
remarkably in popularity when a	1
Today (2013) both 32-bit and	1
great lengths to reduce this	1
files). 20 3.9 Other databases	1
/QaxSSE3, etc. -msse3 -mssse3 -msse4.1	1
(www.agner.org/optimize/testp.zip). A particularly useful performance	1
everything, which is quite inefficient,	1
Security. The vulnerability of software	1
standard. An implementation of the	1
methods: Instrumentation: The compiler inserts	1
respectively (MS Visual Studio 2008	1
v.10.3 & later __svml_expf4 __svml_exp2	1
v.10.2 & earlier vmlsExp4 vmldExp2	1
tiling. This technique is illustrated	1
doubles: union {double d; unsigned	1
Next, we are adding -100	1
alternative. The theoretical background is	1
Library) and other container class	1
lea $B2$2: mov mov 2:8+esp	1
StoreVectorA(void * d, __m128i const	1
emphasized that the compilers may	1
*.so) that belong to each	1
en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC TR 18015, "Technical	1
wmmintrin.h AVX immintrin.h AMD SSE4A	1
flip-flops, multiplexers, arithmetic units, etc.	1
Microsoft's .NET framework are based	1
(/FAs or -fsource-asm). This option	1
standards for the C++ language,	1
140. Avoid conversions between integers	1
for(i=0,i2=0; i<100; i++,i2+=2.0f)a[i]=i2; 41 Float	1
(Division is slow, you know).	1
i<301; i+=3){ list[i] = 0;	1
valid) can possibly improve the	1
CPUs. Another function __intel_cpu_features_init_x() does	1
ab[i].b = Func(ab[i].a); } There	1
forwards, not backwards. Copying or	1
elimination. The method in example	1
unreliable. They sometimes give misleading	1
port to different platforms because	1
Currently includes optimized versions of	1
cheap, in relation to execution	1
Library. The multiple CPU cores	1
(www.intel.com/technology/itj/). 10.1 Hyperthreading Some versions	1
timing, assembly language programming, compiler	1
520 and leave the last	1
properties) are always stored together	1
result, true (1) or false	1
reply about investigation of the	1
14.17b double a1, a2, b1,	1
52; // fractional part unsigned	1
costless in terms of program	1
penalty. Branches are relatively cheap	1
fetching, decoding and perhaps };	1
afterwards. The clock counts are	1
123; are equally efficient because,	1
groups of four (or eight)	1
_mm_load_si128((__m128i const*)p); } // Function	1
sent me corrections and suggestions	1
(less than 65 bytes of	1
_mm_exp_ps _mm_exp_pd AMD Core Math	1
noticeable but not long enough	1
_mm_exp_pd AMD Core Math Library	1
Step (1) is not needed	1
__declspec(cpu_dispatch(...)). See the Intel C++	1
c[size]; float register temp; for	1
bb[i]*cc[i] is AND'ed with the	1
memset(list, 0, sizeof(list)); A multidimensional	1
broader perspective of usability. This	1
NUMCOLUMNS; column++) matrix[row][column] = row	1
semicolons in a loop with	1
toggle multiple bits with the	1
14.7a. Testing multiple conditions enum	1
Today's microprocessors have vector instructions	1
holes of unused bytes in	1
12.1. Vector classes defined in	1
Therefore the compiler is prevented	1
output, which is useful for	1
i=0; has been translated to	1
session. But lazy binding definitely	1
algorithm, then you need to	1
2014. Last updated 2014-08-07. Contents	1
a[i+2]; s3 += a[i+3]; }	1
anda * 17is calculated as(a	1
deviate from the above security	1
Background services. Many services that	1
"instrset_detect.cpp" // instrset_detect function //	1
12.1b to 12.1a. Enable the	1
_mm_add_epi16(a,b). Two libraries of predefined	1
EXCLUSIVE OR operator (^) may	1
8.26b: ; Example 8.26b compiled	1
list[16]; int i; ... list[i	1
formalism that requires several layers	1
full-size execution units. The problem	1
graceful way. You may think	1
changes. A branch that follows	1
(ATL) and Windows Template Library	1
-parallel -openmp -static Generate assembly	1
n++) { sum += xn	1
(Examples can be found in	1
Friday)) { DoThisThreeTimesAWeek(); } By	1
relaxed floating point precision. The	1
and) will cut off the	1
Family 15h Processors". www.amd.com. Advices	1
fprintf(stderr, "\nError: Instruction set SSE2	1
16.1. This code works only	1
handle. Waiting for user input.	1
Uses debug version of the	1
modifies many strings. In most	1
specifically for the CPU it	1
controversies over the C99 standard.	1
F1(int x[]); void F2(float x[]);	1
representation, except in the long	1
Thus, we will calculate xn	1
http://www.agner.org/optimize/ - vectorclass www.agner.org/optimize/#vectorclass. The	1
80.9 512 512 378.7 168.5	1
80.8 65 65 13.6 80.9	1
intelligible way by wrapping the	1
computational power of the graphics	1
__attribute__((aligned(16))). Specifies alignment of arrays	1
measurement. If time is measured	1
obscured in optimized programs. The	1
considerations. It is discussed how	1
dictates that an object must	1
crashes the program. The CPU	1
83 called faster than a	1
Look at Exception Specifications, Dr	1
17.9: "Moving blocks of data",	1
multiplexers, arithmetic units, etc. and	1
next. The carry bit can	1
representations in two different registers.	1
deallocate the space explicitly when	1
_mm_store_si128((__m128i *)d, x); } 112	1
completely. For example: // Example	1
different. 64-bit Windows allows only	1
succeeded in applying the various	1
little-endian storage, but other systems	1
chapter. Using the out-of-order capabilities	1
Vec16c 8 16 unsigned char	1
125 for this function, though	1
14.16a double y, a1, a2,	1
if-branch in example 7.30b. The	1
mainly on my study of	1
132. Unfortunately, table lookup is	1
size_t is 32 bits in	1
FILO manner? If objects are	1
Higher inputs give overflow and	1
86 add add cmp ja	1
coordinates // default constructor //	1
b2 * reciprocal_divisor; y2 =	1
b1 * reciprocal_divisor; 14.7 Don't	1
"Macro loops" chapter in manual	1
b. But in more complex	1
VIA. The next section (page	1
happened to be possible. Template	1
Polymorphism is one of the	1
32-62. This can be useful	1
motion. See page 78. Assume	1
(www.boost.org). The "Intel Math Kernel	1
(seconds < 5) { //	1
continue in dispatched version return	1
Intel/x86-compatible microprocessors. The function is	1
7.26b float a[100]; int i;	1
Journal, 2002). In some cases,	1
(parallel composer) This compiler does	1
7.26a float a[100]; int i;	1
possibilities for optimization. For example,	1
subtasks is necessary. 101 Multithreading	1
bottleneck, it is likely that	1
analysis. If the program takes	1
speed.............................................................................................................. 153 16.1 Using performance	1
difference. Newest instruction set available,	1
nmmintrin.h (MS) smmintrin.h (Gnu) AES,	1
const, or #define makes no	1
SVML. The IPP library does	1
non-object oriented programs. If you	1
catching hardware exceptions. The mechanism	1
F1(); } catch (...) {	1
used). You may use double	1
2.6.30 and later. The AVX	1
contentions, as explained on page	1
causing return addresses to be	1
StoreNTD(&a[c][r], b[r][c]); } } }	1
F1. However, if F1 calls	1
("fldl %1 \n fistpl %0	1
8.19. Devirtualization class C0 {	1
micro- processors have to be	1
15.1b, and in this case	1
module1.cpp int Func1(int x) {	1
memory-intensive functions such as memcpy,	1
F1? Then we are breaking	1
account. You can calculate how	1
project. Some of the most	1
project, it is important to	1
recoverable and non-recoverable errors; make	1
3.x. These systems use segmentation	1
checking, as illustrated in this	1
checking. Any task that takes	1
8.10b a = b; A	1
8.10a if (true) { a	1
yet. Supports both AMD and	1
0.59 0.27 strlen 128 bytes	1
DontSkip; long long clock; __cpuid(dummy,	1
(&a); The compiler may replace	1
During the history of CPU	1
---xx---x Divide by constant =	1
view the software development work	1
discontinued Object Windows Library (OWL).	1
Address calculation is more complicated	1
virtually no cost to using	1
satisfactory. The following considerations should	1
87. This will happen if	1
-fp- model fast=2 Simple member	1
.................................................................... 155 16.2 The pitfalls	1
fetching a cache line that	1
i2; for(i=0,i2=0; i<100; i++,i2+=2.0f)a[i]=i2; 41	1
zero(0,0,0,0,0,0,0,0); // Make a vector	1
card. Some systems also have	1
Func1, while other compilers will	1
convention says that a function	1
(OWL). Several graphical interface frameworks	1
<, <=, > and >=	1
<. The result of comparing	1
PHP, ASP and UNIX shell	1
non-reduced expression better explains the	1
level. My recommendation for good	1
released when the object is	1
address: // Example 7.27 float	1
Enterprise editions). Do not turn	1
Vec2uq 8 32 char 256	1
statements............................................................................. 43 7.13 Loops...................................................................................................................... 45	1
Mac, BSD Instruction set control	1
www.agner.org/optimize/testp.zip. This tool is not	1
CString. This is safe and	1
receive new relevant information. 1.1	1
Mac: Darwin8 g++ v 4.0.1.	1
expanded like a macro so	1
solutions. Patches should be easily	1
solutions, depending on what fits	1
(a+1); c = (a+1) /	1
7.30b int i; 45 for	1
7.30a int i; for (i	1
return; } // continue in	1
published by Intel have similar	1
GetProcessAffinityMask in Windows). There are	1
reinstalled and user settings are	1
emulated processors and FPGA soft	1
map. Do objects have a	1
/Qparallel -parallel -openmp -static Generate	1
fffff is the binary decimals	1
Basic, etc. But program loading	1
OneOrTwo5[b & 1]; Here, I	1
Basic. A compiler for Basic	1
fastest. The typical way to	1
square(x) + 1.0f;} The compiler	1
fastest: // Example 7.17 const	1
max(T const & a, T	1
late. You should therefore not	1
<float, 100> list; // Make	1
closer to the CPU than	1
static_cast operator does the same	1
performance/price ratio. The CISC instruction	1
improvement in performance if the	1
runtime, if only you make	1
x^2, x^3, x^4 F32vec4 xx4(x4);	1
set). We can shift out	1
corresponds to 16 lines in	1
icon signaling the availability of	1
3"); or __debugbreak();. If you	1
1.61 n.a. 2.23 0.95 0.6	1
38). Is the size known	1
__attribute__((aligned(16))) #endif const int size	1
Documentation". Included with Intel C++	1
connection with reading the value	1
satisfactorily on a non-Intel CPU.	1
(SDK or PSDK). Supports the	1
alloca: // Example 9.3 #include	1
Linear arrays are faster than	1
list[301]; int i; for(i=0; i<301;	1
code.................................................................................. 148 14.13 System programming	1
Server 2008 R2 as well	1
Comments All of these compilers	1
synchronizing and communicating between threads.	1
redesigning a program may in	1
alloca, because it is deallocated	1
brushes, etc. Locked mutexes. Open	1
_mm_cvtss_si32(_mm_load_ss(&x));} static inline int lrint	1
mind, that many users will	1
addressing. In 32-bit Linux and	1
Optimized function libraries for many	1
multi-threaded software are available from	1
7.3. Explain volatile volatile int	1
Fog The present manual is	1
;edx=addressinr ; ecx = Induction	1
//=DeltaY // Store result //	1
Similar operations on all data	1
Alignment? Some applications require that	1
startup code and main() are	1
1.5f}; a = lookup[b]; If	1
doesnt. The undocumented Intel library	1
7.39 union { float f;	1
12.8a to 12.8b automatically and	1
12.8b automatically and vectorize the	1
"how many elements are there	1
7.35 page 52. You may	1
7.37 class S3 { public:	1
#) are costless in terms	1
connections rather than sequences of	1
7.36 class S2 { public:	1
MAX(f(x), g(x)); In this example,	1
add_horizontal) static inline float add_elements(__m128	1
violates the strict aliasing rule	1
8*x + 2 return (2.5f	1
www.agner.org/optimize and the FAQ for	1
write: y = c +	1
exploited. A good way to	1
closely follows the mathematical notion	1
foremost, in the choice of	1
remedy is memory pooling. It	1
dependent and therefore not recommended	1
c1::*MemberPointer; Here, the compiler has	1
i--) *(p++) |= 0x20; 46	1
list[i].b. It can also eliminate	1
removable media such as floppy	1
ignore, then the solution is	1
atomic. It doesn't prevent two	1
5). As soon as you	1
87) is likely to cause	1
distributed. The intermediate code cannot	1
degrades performance for the functions	1
Explain volatile volatile int seconds;	1
(VML, MKL). Works with all	1
IsPowerOf2, int N> class powN	1
Func(ab[i].a); } There will be	1
(NetBurst) CPU is designed for	1
understands only the simplest expressions	1
6! The speed on non-Intel	1
ArraySize; i++) List[i]++; Here, the	1
poorly. It is not a	1
habit, it is true that	1
log(2.0); ... } Here, log(2.0)	1
M processor may be able	1
period and by the number	1
flexibility, while execution speed, memory	1
fashion. It is used for	1
3A and 3B. developer.intel.com. AMD:	1
CPU-time in library functions, or	1
62 __try { // Main	1
CLR, to produce binary code).	1
0.95 0.6 1.19 13 Asmlib	1
exponent: // Example 14.26 union	1
operands: minimum, maximum, saturated addition,	1
67 The maximum number of	1
68 else { y =	1
69 } else { return	1
details). The Intel compiler is	1
4.0.1. Gnu: Glibc v. 2.7,	1
DLLs, configuration files, resource files,	1
Incrementing or decrementing a pointer	1
conversion. The constructor or overloaded	1
browsers, different platforms, different screen	1
50; float matrix[rows][columns]; int i,	1
unrealistic that you can do	1
identification. Such schemes cause problems	1
500 clock cycles. You can	1
between. It is difficult to	1
consult the general literature on	1
iteration. This allows it to	1
event, the clock counts should	1
helpful for later maintenance. However,	1
costs. The time it takes	1
protocols and standardized file formats	1
instead: // Example 12.6. Function	1
(char, short int) are only	1
moderately well. Supports three different	1
aa, int * __restrict bb)	1
overflows, even if a, b,	1
12.3. Intrinsic functions for vectorized	1
brutally interrupted. Now it is	1
sign(i) ; shift right =	1
occur: if (SIZE > 256	1
bcc, v. 5.5 Mac: Darwin8	1
#undef N1 } }; //	1
1.fffff, where is the sign,	1
"Technical Report on C++ Performance".	1
converts a zero-terminated ASCII string	1
sizeof(float)) = 8 * 4	1
Sfloat { unsigned int fraction	1
erroneously called with IsPowerOf2 =	1
Subtractions use the same unit	1
Builder 5, 2009). Intel C++	1
as(a << 4) + a.	1
shifts one place to the	1
intrinsics and automatic vectorization (see	1
$B2$3: ret ALIGN ; mark_end;	1
Vec2d Vec8f Vec4d 16 16	1
breakdown. Many copy protection schemes	1
subtasks, but it is impossible	1
y?" then you may use	1
driver involves the overhead of	1
producers keep adding new instructions	1
Vec2q 64 2 uint64_t 128	1
parts: one for constants that	1
Is8vec8 8 8 unsigned char	1
prototypes for each version FuncType	1
manuals: 1. Optimizing software in	1
(int)(&list[0]) + 100*16, and temp++	1
If, for example, you want	1
breakdowns for Intel, AMD and	1
minimize the amount of cache	1
uint16_t unsigned int in 16-bit	1
32767 int16_t int in 16-bit	1
parts, for example if you	1
IPP library does not need	1
courses in programming nowadays stress	1
fma4intrin.h (Gnu) all intrin.h (MS)	1
all, it will often take	1
bodies above, it is clear	1
eax,1 is the loop increment	1
Loading data into a vector	1
(SIZE > 256 && SIZE	1
Michael Abrash: "Zen of code	1
actions like a key press	1
risking to insert an instruction	1
sign, eee is the exponent,	1
MathLoop() { const int arraysize	1
heuristic guidelines. Most caches are	1
(n!) as an example. The	1
root, RGB color difference. Newest	1
GOT, and finally (4) access	1
7.2). This library has a	1
130. It is often easier	1
ameliorated by using nontemporal writes.	1
installed can take several minutes	1
Gauss elimination. The method in	1
blog for details. The behavior	1
Dobbs Journal, 2002). In some	1
fundamental laws of algebra. For	1
[eax+4], ecx 86 add add	1
dest, double const & source)	1
("CriticalFunction"); typeof(CriticalFunction) * CriticalFunctionDispatch(void) {	1
Change this to: // Example	1
scheduled in a separate thread	1
-fwrapv or -fno-strict-overflow. You may	1
conversions. It does the same	1
educational purposes is allowed. The	1
state. This penalty should be	1
i/2 in ebx ; shift	1
__vrd2_exp AMD LIBM Library amd_vrs4_expf	1
traffic and a server in	1
address) / (line size) %	1
Compatibility problems. All software should	1
conversions: // Example 7.19 int	1
confined to a narrow range	1
glitches in the output are	1
funda- mentally flawed approach to	1
matrix[SIZE][SIZE]; transpose(matrix); } } }	1
FUNCNAME(short int aa[], short int	1
matrix[c][r]. // Example 9.5a const	1
__declspec(align(64)) int BigArray[1024]; // Windows	1
\n fistpl %0 " :	1
MultiplyBy<8>(10); a and b will	1
accept expressions as arguments while	1
suggestions for my optimization manuals.	1
Since most development methods are	1
impacts on program performance. The	1
(with new or malloc) is	1
Your measurement code should have	1
learn from this is that	1
compatibility, second source, and the	1
c1+TILESIZE; c2++) { swapd(a[r2][c2],a[c2][r2]); }	1
slice are quite costly because	1
division...................................................................................................... 137 14.6 Floating point	1
_mm_shuffle_epi8 16 1 byte =	1
__svml_expf4 __svml_exp2 Intel SVML +	1
Complicated code is a risk	1
temp->b = 2.0; } The	1
list[x]; } The advantage of	1
temp->a = 1.0; temp->b =	1
subexpressions that contain pure function	1
(addition, multiplication, etc.) inside the	1
guess, that compiler makers assume	1
12.1b. Vectorization with alignment problem	1
12.1b, the compiler cannot know	1
&SelectAddMul_SSE2; // Error: lowest instruction	1
imprecisions should be allowed and	1
(Intel) #include <pmmintrin.h> // SSE3	1
__svml_exp2 Intel SVML + ia32intrin.h	1
hardware. Porting such an application	1
followed by an EMMS instruction	1
SelectAddMul_dispatch; // Define function name	1
branches: one for the latest	1
prior to SSE4.1 and integer	1
a+1;. The compiler can eliminate	1
(but not in some very	1
__intel_cpu_features_init() sets the variable __intel_cpu_feature_indicator	1
low-power CPUs (Intel Atom). The	1
list[i+1];} sum1 += sum2; If	1
IsProcessorFeaturePresent in Windows). Alternatively, you	1
names, one global and one	1
satisfied. The conditions that make	1
distinctions between RISC and CISC	1
i+=3,i_div_3++){ list[i] += i_div_3; list[i+1]	1
relocation at load time. Shared	1
hours to install automatic updates	1
b+a, a*b = b*a -	1
satisfied: 1. Use a compiler	1
neverthe- less be possible to	1
list[] = {1.1, 0.3, -2.0,	1
clause. Comparing an integer to	1
expandable, but it is very	1
754 (1985). This standard is	1
x2*x, x2, x); // x^1,	1
Should we try to optimize	1
deprecated. This is because it	1
porting between platforms, it is	1
amd_vrs4_expf amd_vrd2_exp Agner's vector class	1
hour. Neither is it unusual	1
discriminates between CPU brands, and	1
applying the various optimization methods	1
has. Assuming that processor model	1
1023 1 fraction 2 52	1
Waiting for user input. Many	1
classes: // Example 12.4d. Same	1
p1->Hello(); CChild2 * p2; p2	1
_mm_blendv_epi8(bc, c2, mask); // Store	1
8.12a int i, a[2]; for	1
8.12b int a[2]; a[0] =	1
CriticalFunction_Dispatch; // Function pointer serves	1
(Compile without the Common Language	1
Frequent context switches can reduce	1
isolating a single function. Switch	1
strongly recommended to set the	1
manageable and easier to test,	1
include: Memory allocated with new	1
totaling up to fourteen register	1
(5) make the overflow behavior	1
(MOVNT) are designed to solve	1
.NET, which is implemented with	1
column-wise manner where the critical	1
exception-safe code Assume that a	1
spends most of its time	1
4.5 0.82 0.59 0.27 strlen	1
Size() { return N; }	1
Sizes of different integer types	1
4.; }; // Make all	1
website. 5 Choosing the optimal	1
buttons, dialog boxes, etc. should	1
9.5a: 98 int r, c;	1
call, and the time it	1
....................................................................... 77 8.4 Obstacles to	1
1./5040., 1./40320., 1./362880., 1./3628800., 1./39916800.,	1
ReadB() {return b;} }; The	1
printf("\n%2i %10I64i", i, timediff[i]); }	1
7.1. Sizes of different integer	1
elements? If the container is	1
(if valid) can possibly improve	1
caused by random events that	1
x.f; // will give -2.0	1
---xx--xx (-a==-b)=(a==b) ---xx---- (-a>-b)=(a<b) ---xx---x	1
XOP, AMD only _mm_permutevar_ps 4	1
First-In-Last-Out access, sort and search	1
sizeof(float) in order to find	1
Hardware updating. The change of	1
tricks Michael Abrash: "Zen of	1
a= a a & ~a	1
a: // Example 9.6b. #include	1
directory as the .exe file,	1
"Beta", "Gamma", "Delta" }; if	1
(b*2.0)/3.0 rather than as b*(2.0/3.0)	1
(doubly ended queue) allocates one	1
CriticalFunction(b, c); ... return 0;	1
unreferen- ced functions) /Gy -ffunction-	1
scalar (Scalar means not a	1
57). It is possible to	1
63; // fractional part 142	1
Scott Meyers: "Effective C++". Addison-Wesley.	1
delays. The easiest way to	1
Read time You can use	1
paralleli- zation by multiple threads	1
uint8_t unsigned short int in	1
opportunities for parallelization in the	1
Thursday = 0x10, Friday =	1
_mm_i32gather_epi32 unlimited 4 bytes =	1
gone to great lengths to	1
aliasing, but the compiler is	1
add_elements(s); // add the four	1
Dispatcher. Will be called only	1
void. Returning objects of a	1
worse kind of error is	1
((a+b)+c)+d. This is a dependency	1
Classes (MFC). A competing product	1
strlen, sprintf, etc. But beware	1
Constructor-style type casting // C++	1
correctness. It is therefore recommended	1
miss. But if the program	1
higher-priority thread running in the	1
services. Many services that run	1
library). The D language allows	1
[esp+4] DWORD PTR [esp+8] DWORD	1
N; } T & operator[]	1
DynamicArray = (float *)alloca(n *	1
_mm_hadd_ps(x, x); s = _mm_hadd_ps(s,	1
N) { // Array with	1
design of small microcontrollers: Smaller	1
(depending on the processor) when	1
obvious. See the compiler documentation	1
obvious, then it may be	1
FuncType(short int aa[], short int	1
(1. / 1.2345); The compiler	1
freely. The loop counter i	1
x-xx--xx- x--x----- --xx----- x-xxx---x x-xxx---x	1
b[r][c]); } } } The	1
option) better: -Ofast -mveclibabi -fopenmp	1
replacements for switch statements because	1
Performance". www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP. www.openmp.org.	1
handler, even if no exception	1
increment. The three clauses are	1
segmentation of the memory if	1
integers: // Example 14.27 union	1
-openmp -static Generate assembly listing	1
behaviour is implementation dependent. The	1
XOR'ing it with 1: //	1
RTTI then turn it off	1
divisor. In this case you	1
a.y);} vector a, b, c,	1
r1+1; r2 < r1+TILESIZE; r2++)	1
increments seconds. A safer implementation	1
handlers for cleaning up and	1
references: If the Intel compiler	1
composer) This compiler does not	1
2-dimensional vector 56 public: float	1
-128, and subtracting 1 from	1
//=A*x*x+B*x+C //=DeltaY // Store result	1
applications: The cost of starting	1
/Fa for assembly output. The	1
unrecoverable error without using exceptions	1
Things that may need to	1
/Fm Generate optimization report /Qopt-report	1
texts they point to are	1
redesign. Some software development models	1
0x3F800000; // Now 1.0 <=	1
-fpic. This will generate relative	1
research on CPU dispatching and	1
servicing. A command received by	1
__cpuid(dummy, 0); DontSkip = dummy[0];	1
rows/columns in matrix 96 void	1
p->NotPolymorphic(); p->Hello(); p = &Object2;	1
Hoisie, SIAM 2001. 9.11 Explicit	1
e.g.: // Example 12.1b. Vectorization	1
destroys any memory block that	1
deque (doubly ended queue) allocates	1
knows that it can multiply	1
2010. This feature is intended	1
80x86 / x64 (Visual Studio	1
restoring registers, and possibly save	1
a2/b2; Here we can eliminate	1
_mm_cvtss_f32(s); } // Approximate exp(x)	1
-read_only_relocs suppress. GOT and PLT	1
newsgroups contain useful discussions about	1
12.4b, rewritten with the use	1
12.4b. Vectorized with SSE2 #include	1
(rarely 64). You may save	1
10000, then we have (set)	1
b[0], a[1], b[1], ... then	1
72). The compiler cannot rule	1
dimensions of the array is	1
v 4.0.1. Gnu: Glibc v.	1
y2, reciprocal_divisor; reciprocal_divisor = 1.	1
lightweight processors with low power	1
;alignby4 ; mangled function name	1
Coarse time measurement. If time	1
vectorized: void SelectAddMul(short int aa[],	1
influenced by the requirements of	1
5.5 Mac: Darwin8 g++ v	1
swapping. Software developers typically have	1
breaking out of F1 without	1
Cannot optimize across modules The	1
libmmt.lib and the header file	1
speeding up 64-bit shared objects	1
;a ;r ; unused label	1
_finite()) and redo the calculations	1
Functional decomposition here means that	1
ratio. The CISC instruction set	1
unattended. Uninstallation should also proceed	1
reflect this or for the	1
;r ; unused label ;eax=addressofa	1
2.5f}; a = OneOrTwo5[b &	1
61. It is recommended to	1
-m64 -static /MT 160 /Qparallel	1
concentrating on important work. The	1
(& and |) instead of	1
preference is for C++ for	1
&list[8]); } Here, it is	1
(6 integer and 8 floating	1
(0 < 5) {} which	1
(YMM) if the AVX instruction	1
12.4d. Same example, using Intel	1
process, and the destructor is	1
best-case conditions. All disturbing influences	1
d.x; a.y = b.y +	1
a+b=b+a, a*b=b*a x n.a. x	1
(8 float or double plus	1
(A & 0x0F) | ((B	1
(C << 6); Or, if	1
developer may choose to make	1
(B << 4) | (C	1
PREFETCH _mm_prefetch SSE Store 4	1
mangling. The characters '?', '@'	1
susceptible to problems of overflow	1
Stefan Goedecker and Adolfy Hoisie:	1
(SSE): #include <xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It	1
inte- ger or double) /arch:SSE2	1
/arch:SSE3 -mssse3 /arch:SSSE2 -msse4.1 /arch:SSE4.1	1
sum. The trick is to	1
ReadB needs to code the	1
Verilog. Common devices are CPLDs	1
inferior. A model with a	1
dimension may preferably be a	1
party security software. Background services.	1
Advices on optimization of C++	1
reporting. For example, in Windows,	1
wired for a specific purpose.	1
14.12a int list[300]; int i;	1
refresh the screen. There is	1
inequality sign must be reversed	1
Ready made container class templates	1
types. A disadvantage is that	1
!a; can be optimized to:	1
defined(__unix__) || defined(__GNUC__) // 32-bit	1
destructor, if any, must be	1
destructor. A function that reads	1
wires that connect them. The	1
_mm_clflush intrinsic function. Provoke branch	1
sizes? It is possible to	1
SelectAddMul example (12.4e) with automatic	1
--xxxx-xx a*1=a x-xxxxx-x (-a)*(-b)=a*b ---xxx---	1
Loops...................................................................................................................... 45 7.14 Functions ................................................................................................................	1
iset = instrset_detect(); 116 //	1
beginning. ret returns from the	1
adhere to certain programming principles	1
__rdtsc(); return clock; } //	1
3.0; The compiler will replace	1
Calculations in a loop where	1
loop- carried dependency chain would	1
i++)a[i]=2*i; The conversion of i	1
non-recoverable errors; make sure allocated	1
side-effects and its return value	1
Looking at the compiler output	1
loop? Certainly not! 250 s	1
Glibc v. 2.7, 2.8. Asmlib:	1
C1, so it can call	1
written. This worked sufficiently fast	1
Partial template specialization for N	1
a[] which will change during	1
modularity and reusable classes. Security	1
properly. Many CPU dispatchers are	1
fast=2 Simple member pointers /vms	1
aa[size] ); // Make three	1
throws an exception. Therefore, you	1
feed into the pipeline. If	1
former case x can be	1
bug". The FDIV bug is	1
considerably. Another serious burden is	1
feel that a particular programming	1
relate to CPU-intensive code. But	1
b++; will make the values	1
well-known languages. My preference is	1
6. If arrays are accessed	1
antivirus program that scans all	1
sizes, and they can be	1
pipeline. If the wrong branch	1
" : "=m"(n) : "m"(x)	1
gates, flip-flops, multiplexers, arithmetic units,	1
games. Such a coprocessor might	1
FactorialTable[n]; // Table lookup }	1
Newer processors are sometimes able	1
IntegerPower (double x) { //	1
158. This manual is based	1
'>') are not permissible for	1
18.1. Command line options relevant	1
obsolete within the lifetime of	1
15.1c, but none of the	1
prediction). 149 All code that	1
-231 231-1 int32_t long long	1
information, such as supported instruction	1
a*b*c*2. It is quite difficult	1
nagging pop-up messages saying please	1
threads? Container classes are generally	1
7.22. // Example 7.22 short	1
www.yeppp.info And here is a	1
&list[100]; temp++) { temp->a =	1
Intel/MASM syntax: __asm fld qword	1
Keywords that work on all	1
requires, of course, that you	1
workplace and the system forbids	1
risky because it involves the	1
"standard stack frame" or "frame	1
cached, but several hundred clock	1
p->f(); // Virtual call to	1
checking). An error message is	1
search: // Example 14.30 const	1
instrset_detect function // Function pointer	1
measure. This is because computers	1
concentrate the optimization effort on	1
double's. It is almost always	1
Inlined functions have a non-inlined	1
a*4 - n.a. -(-a) =	1
this). Use rounding instead of	1
x2; // x^4 // Define	1
Runtime, CLR, to produce binary	1
multiplications, which can take quite	1
That being said, I must	1
reach element number 16 in	1
x2, x); // x^1, x^2,	1
76 Boolean XMM (vector) reductions:	1
75 (a&&b) || (!a&&c) ||	1
832 256 16 16 256	1
job, but it may be	1
job. You have to check	1
71 The compilers I have	1
70 Induction variables An expression	1
www.openmp.org and the compiler manual	1
down. Remember to insert a	1
79 Floating point induction variables	1
CPLDs and FPGAs. The difference	1
coincides with the beginning of	1
8.14b int i, a[100], temp;	1
press. 19 Avoid an excessive	1
8.14a int i, a[100]; for	1
bit-mask which is all 1's	1
worried about this condition. In	1
"m"(x) : "memory" ); #else	1
sign-bit if the integer is	1
7.33a const int size =	1
stupid. Some common compilers are	1
pooling. It is more efficient	1
pooling) than to allocate a	1
shares the resources of the	1
modular. The so-called objects are	1
forward) instruction to localize the	1
advantages: The i<20 loop control	1
WritePrivateProfileString to read and write	1
2005). Borland C++ 5.82 (Embarcadero/CodeGear/Borland	1
try, catch, and throw. It	1
multiply-and-add Table 13.1. Instruction sets	1
only, then the effect of	1
triangle is handled separately: for	1
x-xxxx-x- x-xxxxxxx xxxxxxxxx xxxxxxx-x xxxxxxxxx	1
Rounding is fast. Value of	1
QuineMcCluskey or Espresso) that can	1
n-1 multiplications, which can take	1
laws of algebra. For example,	1
x^0/0! // n factorial }	1
semicolons, while multiple statements within	1
(/arch:SSE2, /arch:AVX etc. for Windows,	1
float(i); f = static_cast<float>(i); //	1
decimals. It is recommended to	1
not! 250 s is less	1
together...................................... 88 9.4 Variables that	1
(live ranges) do not overlap.	1
-ffast-math /fp:fast /fp:fast=2 -fp-model fast,	1
managing a memory heap. The	1
Sum1() {return a + b;}	1
rare. Testing for the overflow	1
responded to at a lower	1
-100 to -56 which will	1
2.; x.c = y.c +	1
pre-calculated table. Even better: store	1
a+b+c=c+b+a a+b+c+d = (a+b)+(c+d) a*b+a*c=a*(b+c)	1
devirtualization (see page 73) automatically	1
invoked with automatic vectorization. The	1
128- bit vector registers when	1
9.5b. // Example 9.5b void	1
printer or other device should	1
Uninstallation should also proceed in	1
Half size execution units. The	1
Important features 80386 32 bit	1
Func2 were in the same	1
say that you want to	1
12.3a, for example, you can	1
......................... 142 14.10 Mathematical functions	1
reads. The same can be	1
1./120., 1./720., 1./5040., 1./40320., 1./362880.,	1
unions rather than type casting	1
Pascal, Fortran and several other	1
namely the two induction variables	1
structure, data flow and algorithms	1
Multidimensional arrays should be accessed	1
'this'. We can therefore conclude	1
AVX2, or two 128- bit	1
<asmlib.h> void CriticalFunction(); ... //	1
16-bit, 32-bit and 64-bit mode.	1
u.i[1] ^= 0x80000000; because this	1
much. Excessive loop unrolling is	1
(eax) which contains the address	1
on) __restrict __restrict __declspec( noalias)	1
attention of software programmers to	1
level- 1 cache. This has	1
maintainability of C++ projects can	1
f=i; f = (float)i; f	1
0x7F unsigned int sign :1;//signbit	1
relying on the microprocessor hardware	1
setup. on Intel CPUs: use	1
Monday = 2, Tuesday =	1
n'th degree polynomial of the	1
"Register usage in kernel code"	1
a&b&c&d = (a&b)&(c&d) a ^0	1
clause are separated by commas.	1
ignored if the goal of	1
union, as in example 14.23	1
i<20 loop control branch is	1
<=, > and >= operators).	1
relational operators (e.g. '>') are	1
*x; double x4 = x2*x2;	1
Primitives" library contains many functions	1
finds the numerically largest element	1
false: // Example 8.10a if	1
square: // Example 8.1b float	1
protection. Some copy protection schemes	1
iterative in nature, it is	1
objects), resource files, configuration files,	1
tricky. I have used the	1
opposite: Don't put something in	1
for-loop: i++; } } }	1
complication that the same function	1
++b; the compiler will recognize	1
square. // This triangle is	1
SelectAddMul_SSE41, SelectAddMul_AVX2, SelectAddMul_dispatch; // Define	1
strategy for saving a backup	1
AND'ing it with 2n -1.	1
xplus2() { The effect of	1
X?" rather than "what works	1
Specifications, Dr Dobbs Journal, 2002).	1
million times less than in	1
(new and delete). 88 Object	1
reason. A program with many	1
reason, you can use only	1
-fopenmp /Qopenmp -m32 -m64 -static	1
squares and handle one square	1
Best-case testing is useful because	1
investigation of the problems and	1
disguise. Enums are exactly as	1
route. This mechanism is also	1
small, then it is necessary	1
compactness of the code makes	1
overhead. Example: // Example 8.12a	1
//=2*A //=A*x*x+B*x+C //=DeltaY // Store	1
2.6f; The ?: operator here	1
%10I64i", i, timediff[i]); } The	1
point-to-integer conversions in the critical	1
set?". A list of which	1
loop-branch is usually predicted well	1
vector(x + a.x, y +	1
8.8b double x, y; bool	1
Encryption, decryption, data compression Most	1
8.8a double x, y, z;	1
~b = a ^ b	1
Firewalls, virus scanners and other	1
x-xxx--xx a | 0 =	1
100*16, and temp++ actually adds	1
Newest instruction set available, e.g.	1
normalized, if possible, so that	1
MFC). This method may be	1
.............................................................................. 65 7.32 Preprocessing directives	1
widely different priority in the	1
re-calculated every time Func is	1
advise of using powers of	1
Multithreaded programs must use thread-safe	1
year. Ignoring virtualization. The time	1
Insert an explicit CPU dispatching	1
Reducible expressions also occur quite	1
vector() {} vector(float a, float	1
decades ago, the recommendation was	1
decreased when the work load	1
CPU.............................................................................81 8.5 Compiler optimization options	1
(*CriticalFunction)(b, c); ... return 0;	1
12.7. Vector class code with	1
patterns. This can cause severe	1
publish a function library with	1
definitions when used for defining	1
Multiply(10,8); b = MultiplyBy<8>(10); a	1
"undefined". This allows the compiler	1
separately: for (r2 = r1+1;	1
[ecx+eax*4],ebx stores this result in	1
std::unexpected() function in case F2	1
b.x + c.x + d.x;	1
people. I simply don't have	1
(GetExceptionCode() == EXCEPTION_FLT_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER	1
-mveclibabi=svml. This library has reduced	1
a[c][r] = b[r][c]; } }	1
uninitialized, if pointer arithmetic calculations	1
jumps, calls and branches in	1
places. Constant folding and constant	1
computing, but for most purposes	1
stress the importance of structured	1
Iu8vec16 Vec16uc 16 8 short	1
b[1], ... then you may	1
strictness is required. See page	1
2.1. Comparing performance of different	1
alignment, bytes bool 1 1	1
2.00. Intel C++ compiler, v.	1
around. Adding 1 to 127	1
Why is template metaprogramming so	1
access....................................................................................................... 22 3.14 Context switches.....................................................................................................	1
arraysize) { // Catch exceptions	1
casting. Linked lists and other	1
casting, but also safer. It	1
violations and invalid pointers. This	1
-mveclibabi -fopenmp /Qopenmp -m32 -m64	1
malloc. Handles to windows, graphic	1
Last updated 2014-08-07. Contents 1	1
malloc) is necessarily accessed through	1
*(__m64*)&source); // MOVNTQ _mm_empty(); //	1
231 then convert it to	1
interval. A hash map can	1
removed, all resources are sufficient,	1
Func() { S1 x, y;	1
interval: // Example 14.5a const	1
question: Put in an unused	1
r2; c2++) { swapd(a[r2][c2],a[c2][r2]); }	1
violation, integer overflow, and invalid	1
incremental or iterative in nature,	1
admittedly very kludgy. The few	1
application- specific instructions that are	1
collect the functions that are	1
PC's, workstations and scientific vector	1
"position-independent code" actually implies more	1
application, while dynamic linking makes	1
spots. The test should be	1
list.Size(); i++) { // Loop	1
essential task of the program.	1
r2, c1, c2; double temp;	1
xx-xx--x- reciprocal Boolean algebra reductions:	1
mirroring is not allowed. Non-public	1
"function level linking" if available.	1
identified. My test tool can	1
g(x)); In this example, f(x)	1
Time- consuming library functions often	1
originally designed by Intel but	1
8*1024/64 = 128. These lines	1
--xxxx--- a & a= a	1
(using Intel vector classes): //	1
series: ex xn n 0	1
3.; x.d = y.d +	1
v.i) { // u.f >	1
select_gt(b, zero, c + two,	1
Prototype for the common entry	1
String constants and floating point	1
IsPowerOf2 = false where it	1
glibc version 2.11 ifunc branch).	1
pros and cons of using	1
matical applications. But we do	1
............................................................................ 51 7.19 Class member	1
stored? If the total number	1
tends to make the code	1
leftmost column to the diagonal.	1
Gnu). Other compilers need assembly	1
series, vectorized #include <dvec.h> //	1
series. The exponential function can	1
(ZMM). Vector operations are useful	1
Command line options relevant to	1
2.1.7, 2004. No differences were	1
Square blocking and similar methods	1
DelayFiveSeconds function will wait until	1
tortuous and convoluted template metaprogramming	1
.......................................................... 107 12.3 Automatic vectorization	1
boxes, etc. should be as	1
s); return _mm_cvtss_f32(s); } //	1
yes License license included in	1
dialog boxes, etc. should be	1
integer). All intermediate results should	1
~. The Boolean operators produce	1
~(~a) = a - n.a.	1
matrix, i.e. each element matrix[r][c]	1
xxxxxxx-x xxxxxxxxx x-xxx---- a-(-b)=a+b a-a	1
Those who are satisfied with	1
file) should be made local.	1
predictions in the different microprocessors.	1
value, n. But not if	1
x[0] = a; b =	1
_mm_stream_pi((__m64*)dest, *(__m64*)&source); // MOVNTQ _mm_empty();	1
OneOrTwo5[(b!=0) ? 1 : 0]	1
fake an Intel Pentium 4.	1
(XMM) if the SSE2 instruction	1
logically distinct tasks. A critical	1
vendors are offering profiling tools	1
constant, unless the address of	1
i[2]; } u; if (u.i[1]	1
analyze all pointers and references	1
accomplished by doing the heavy	1
catch, and throw. It is	1
2005; and "More Effective C++".	1
PCLMUL wmmintrin.h AVX immintrin.h AMD	1
wherever appropriate to give the	1
criteria or lists of specific	1
.............................................................................................................. 54 7.23 Constructors and	1
++i and the post-increment operator	1
repeatedly with the same divisor.	1
sqrt, pow and log are	1
__restrict__, if supported by the	1
raising an exception in case	1
vectorclass.h Supported compilers Intel, Microsoft	1
section. 12.5 Using vector classes	1
section, but it will not	1
unfavorable, unless the value is	1
114 #include <dvec.h> // Define	1
................................................................................................................... 56 7.26 Overloaded functions	1
hasn't thought about the possibility	1
1.f); // initialize sum for(inti=0;i<16;i+=4){	1
emmintrin.h SSE3 pmmintrin.h Suppl. SSE3	1
optimal, though. In some cases	1
occurrence is rare. Testing for	1
testing, verifying and maintaining a	1
row. The same advice applies	1
(methods)......................................................................... 53 7.20 Virtual member	1
self-styled hacks and direct hardware	1
ia32intrin.h _mm_exp_ps _mm_exp_pd AMD Core	1
N-1)==0,N>::p(x); } // Use template	1
minute if the network or	1
develop. It is easy to	1
Declare the function inline. This	1
exact time consumption as the	1
RAM, a lot of irrelevant	1
circumstances around the hot spot.	1
powN<true,1> { public: static double	1
NOT. Instead, you can make	1
(0x2710 / 0x40) % 0x20	1
_mm_i64gather_epi32 unlimited 8 bytes =	1
Embarcadero Comes with the Borland	1
lower; and the amount of	1
table-based methods with little or	1
(a*b*c)+(c*b*a) to a*b*c*2. It is	1
97 Table 9.1. Time for	1
pow(x,10) with only four multiplications.	1
AMD's profiler is called CodeAnalyst.	1
data", where it is also	1
92 DynamicArray[i] = WhateverFunction(i); //	1
allowing two data members that	1
Tips about how to speed	1
vice versa. But most of	1
generators. In general, it is	1
x4*x4; double x10 = x8*x2;	1
tested. The reason is that	1
c.x + d.x; a.y =	1
c.y + d.y; Fortunately, most	1
activates critical application- specific instructions	1
back, where n is the	1
activated by the user. Feature	1
Scheduling A compiler may reorder	1
7.34b. Replace macro by template	1
Vectorize #pragma vector always #pragma	1
comments, in green. It takes	1
variables: // Example 8.23b. Calculate	1
80386 32 bit mode SSE	1
14.16b double y, a1, a2,	1
note: This example is specific	1
Requires binutils version 2.20 or	1
Pentium-II or later instruction set	1
Borland's now discontinued Object Windows	1
xx4; // next four x^n	1
__except (GetExceptionCode() == EXCEPTION_FLT_OVERFLOW ?	1
rounding, but neither faster nor	1
issue, as you can read	1
superfluous code, but there are	1
b*2.0/3.0 will be calculated as	1
mainstream next year. Ignoring virtualization.	1
_mm_hadd_ps(s, s); return _mm_cvtss_f32(s); }	1
Perl. Several modern programming languages	1
14.17a double a1, a2, b1,	1
15.1c? We took advantage of	1
discussions. Turn on the option	1
unwinding. All functions have to	1
("int 3"); or __debugbreak();. If	1
relax floating point precision (see	1
higher) is enabled. Volatile The	1
;checkifi<100 ; repeat loop if	1
dealt with in assembly language.	1
((x2)2)2 a+a+a+a=a*4 -(-a)=a - -	1
language: An optimization guide for	1
dummy[4]; volatile int DontSkip; long	1
model, which quite likely is	1
exist for all major platforms.	1
14.15a if (a > b	1
(without member functions) has no	1
Loopunrolling x-xxxx--x Profile-guided optimization Whole	1
wrong, but it is still	1
makers assume that floating point	1
textbook on test theory. Advice	1
15; // exponent + 0x3FFF	1
leaks. It is the responsibility	1
large. 156 16.3 Worst-case testing	1
Poor reproducibility. Delays in program	1
159 18 Overview of compiler	1
154 // Print heading You	1
/GR- -fno-rtti Assume no pointer	1
152 If you want to	1
entry. You can avoid this	1
inlining. Reducible expressions also occur	1
Object1.Hello(), though future compilers may	1
151 15.1c automatically, and only	1
thought-through approach to error handling.	1
vectorize. The pragmas must be	1
suggests methods for avoiding the	1
normally. There are various alternatives	1
_mm256_i32gather_ps unlimited 4 bytes =	1
Multithreading.............................................................................................................. 101 10.1 Hyperthreading .....................................................................................................	1
_endthread(), etc. then there is	1
ranges) do not overlap. 27	1
analogous to example 15.1b and	1
summation variables sum1 and sum2	1
system......................................................................................... 6 2.4 Choice of	1
statement: // Example 8.9b int	1
happy to receive new relevant	1
systems" for details on when	1
Gnu/AT&T syntax: __asm ("fldl %1	1
Device drivers, interrupt service routines,	1
mainframes, and between simple processors	1
device. Any language that requires	1
loops" chapter in manual 2:	1
www.agner.org/optimize/#vectorclass. The Intel vector class	1
%1 \n fistpl %0 "	1
sort and search facilities, binary	1
floata; boolb=0; static const float	1
updates. Automatic updating of software	1
updates, remote help files, data	1
(b[i] * c[i]); } }	1
level-3 cache. If the combined	1
14.00 for 80x86 / x64	1
Few compilers are able to	1
detects an error can return	1
_alloca) for (int i =	1
anywhere in the calculations. The	1
B1, public B2 { public:	1
importantly, it requires an extra	1
................................................................................................................. 21 3.11 Other system	1
a[1], b[1], ... then you	1
0.5 ns = 250 s	1
Feature bloat. It is common	1
0.6 1.19 13 Asmlib Gnu	1
mask, and bb[i]*cc[i] is AND'ed	1
list[ARRAYSIZE]; if (i < ARRAYSIZE	1
Is16vec4 16 4 unsigned short	1
Details about instruction latencies are	1
JavaScript, PHP, ASP and UNIX	1
NUMCOLUMNS = 100; int matrix[NUMROWS][NUMCOLUMNS];	1
eight) points with the four	1
First you compile the program	1
losing precision. The compilers will	1
ReadTSC(); CriticalFunction(); timediff[i] = ReadTSC()	1
cores: Define multiple threads and	1
makers. 4. Instruction tables: Lists	1
panic if you don't understand	1
sin function is defined in	1
rebooted. To prevent this kind	1
WritePrivateProfileString, which opens and closes	1
(...) { ... } }	1
abuse is extremely costly to	1
place. This can be avoided	1
FuncCol(int); const int rows =	1
%. Conversion to floating point	1
Const cast The const_cast operator	1
abs(u.f) > abs(v.f) } The	1
tables: Lists of instruction latencies,	1
13) { // Bounds checking	1
Interference from other processes. The	1
times: Dispatch on every call.	1
min)) { ... There is	1
conflicts. But if a large	1
133 although slightly less efficiently.	1
complicated? Because the C++ template	1
131 Note that these methods	1
<math.h> #define EXCEPTION_FLT_OVERFLOW 0xC0000091L void	1
Application programmers rarely program their	1
people who have sent me	1
disks and USB sticks may	1
Further details are given in	1
single-thread speed. In this case	1
collection, as mentioned above. The	1
138 A similar method can	1
tables. The static data area	1
%0 " : "=m"(n) :	1
tables, and virtual function tables.	1
superior performance/price ratio. The CISC	1
powerful. The high priority of	1
newsgroup comp.lang.asm.x86 for some links.	1
activate a particular part of	1
C2, then we can avoid	1
massively parallel vector processing capabilities	1
unique key. Do objects have	1
multithreading that we have to	1
unlikely that the end user	1
pending instructions in the CPU	1
a[0], b[0], a[1], b[1], ...	1
kb. This corresponds to 16	1
kb, 8 ways. The critical	1
practice to test each function	1
(RTTI). See page 54. It	1
(RTTI), which affects other parts	1
www.agner.org/optimize/testp.zip or get ReadTSC as	1
.................................................................................................................... 55 7.25 Bitfields ...................................................................................................................	1
ease of development are more	1
resized in the event that	1
Pro instruction set makes floating	1
unpredictably at inconvenient times. This	1
................................... 141 14.9 Using integer	1
Internal references to data within	1
comparisons. The solution a =	1
trap integer overflow with the	1
overridden in Linux and BSD.	1
Vec4ui 64 2 int64_t 128	1
sub-expressions. Why is template metaprogramming	1
addresses, or if pointers are	1
opinions on which imprecisions should	1
microprocessors, different alignments and different	1
individually. Example: // Example 7.40a	1
p->b;} int Sum3(S3 & r)	1
initialisation i=0; has been translated	1
matters rather than the parts	1
tune the code to a	1
18.3. Predefined macros Compiler identification	1
doubled for this task when	1
categories: File input/output Graphics and	1
routines, system core and high-priority	1
usability. This is not a	1
0x8040); See page 145 and	1
couple of things that the	1
Parameter transfer is more efficient	1
huge). Far storage, far pointers,	1
13.1, Requires binutils version 2.20	1
Of course, this works only	1
131) shows a way to	1
recompile it. I am using	1
Main loop for calculations: for	1
MKL, VML and SVML. The	1
log(c[i]);. This would double the	1
said, I must warn against	1
ways). If a program contains	1
tests, the Intel compiler reduced	1
trees, hash maps etc. It	1
template: // Example 7.34b. Replace	1
bits). The advantages of using	1
FactorialTable[b]; ... } } The	1
Thin clients that depend on	1
_mm_cvtsd_si32(_mm_load_sd(&x));} The code in example	1
int)i; This conversion takes no	1
tried. The Microsoft, Intel and	1
Windows) to determine if the	1
needed? A matrix or multidimensional	1
2A, 2B, and 3A and	1
follows. The first generation class	1
static_cast<float>(i); // Implicit type conversion	1
respect. 7.15 Function parameters Function	1
bulky and difficult to read.	1
light-weight alternative is the Windows	1
kilobyte is 1024 bytes, so	1
correction for the "FDIV bug".	1
supports. An inferior version of	1
supports, rather than its brand,	1
104 } Microprocessors with out-of-order	1
5-10% for some CPU-intensive applications	1
0.5ns. 2GHz A clock cycle	1
profitable. On the other hand,	1
255 uint8_t unsigned short int	1
MASM assembly language has full	1
150. Using templates for polymorphism	1
directly, or use the CPU	1
directly. The reason for this	1
argue that it is safer	1
planned solutions. Patches should be	1
capability: // Example 11.1a float	1
destination, but don't count on	1
shell script. Interpreted code is	1
.so). There is no easy	1
range"); or better, make your	1
reversed if c < 0.	1
4.4, 2.5}; return list[x]; }	1
reflecting it at the diagonal.	1
scanf. Violation of array bounds	1
isolation have been unsatisfied with	1
limiting factors for the performance	1
(signed) address. The linker will	1
exceptions, etc. Event-based sampling requires	1
measurements: warm up the CPU	1
1.0 <= u.f < 2.0	1
YMM) which can be used	1
Covers PC's, workstations and scientific	1
Wednesday, Thursday, Friday, Saturday };	1
(XMM or YMM) which can	1
Iu16vec4 32 2 2 int	1
patch. 131 Note that these	1
1., 1./2., 1./6., 1./24., 1./120.,	1
met then it is usually	1
xopintrin.h (Gnu) AMD FMA4 fma4intrin.h	1
FuncC(i+1); } This has three	1
^0 = a a ^	1
C99 standard. An implementation of	1
Iu16vec8 Vec8us 32 4 int	1
x86intrin.h (Gnu) Table 12.2. Header	1
unpacking needed. Predictable branches that	1
-fsource-asm). This option makes the	1
seriously. User complaints should be	1
__attribute__((aligned(64))); // Linux syntax 90	1
clash with another dynamic library	1
nature of the stack. Deallocation	1
if(!(a || b)) even though	1
requirement. Useful when no reasonable	1
Advanced book on optimization of	1
propagated through a series of	1
C0::f or C1::f. But an	1
I64vec1 8 16 char 128	1
(CParent<>) contains any member functions	1
dilemma. You may prefer to	1
High precision math. Libraries for	1
Gnu: Glibc v. 2.7, 2.8.	1
API's. Memory swapping. Software developers	1
workaround. Supports all x86 and	1
4.1.0, 2006 (Red Hat). PathScale	1
_mm_empty(); // EMMS } const	1
parallel: Using multiple CPUs or	1
our estimate is correct or	1
8.0f) * x + 2.0f;	1
considerable. If two threads are	1
pointer". The standard stack frame	1
"Zen of code optimization", Coriolis	1
parameters). The this pointer in	1
debate about which software development	1
Pragmatic Look at Exception Specifications,	1
Multiplications are done implicitly when	1
(1,2,3,4), and store the result	1
146). In the cases where	1
green. It takes some experience	1
candidates for register variables are	1
Preprocessor directives. For example use	1
Out-of-order execution (chapter 11) and	1
he or she is busy	1
thousands of people. I simply	1
menu click becomes inconsistent and	1
chapter, I have described some	1
shuffling can sometimes take more	1
a&&b (a&&b) || (a&&c) ||	1
arithmetics and pointer type casting.	1
Vec32uc Vec16s Vec16us Vec8i Vec8ui	1
Move the conversions out of	1
if(!a && !b) rather than	1
(column = 0; column <	1
gives: // Example 7.30b int	1
100000000. When we add a	1
formats. Comments All of these	1
Iss. 4, 2007 (www.intel.com/technology/itj/). 10.1	1
incomplete information about the class	1
printf("Alpha"); break; case 1: printf("Beta");	1
generations classes contain the different	1
costless. It is simply a	1
guidelines. Most caches are organized	1
knowing that the objects are	1
7.43b is admittedly very kludgy.	1
18, then the & operator	1
Thinking in terms of specific	1
Relocation is done by the	1
Typical candidates for register variables	1
int16_t int in 16-bit systems:	1
shall automatically come into force	1
p2; p2 = &Object2; p2->Hello();	1
SafeArray() { memset(a, 0, sizeof(a));	1
closes the file for each	1
uint32_t unsigned long long or	1
2.5f; If we assume that	1
breakpoints at every function or	1
favor of Intel CPUs cannot	1
g++ v 4.0.1. Gnu: Glibc	1
....................................................................................................................... 3 1.1 The costs	1
frustrated by unacceptably long response	1
2.7, 2.8. Asmlib: v. 2.00.	1
a[i+3]; } sum = (s0+s1)+(s2+s3);	1
columns. Every fourth of these	1
a[N]; public: SafeArray() { memset(a,	1
Overriding the Intel CPU detection	1
columns; j++) 39 matrix[i][j] +=	1
a.x = b.x + c.x	1
a.y = b.y + c.y	1
conversion, shuffling, packing, unpacking needed.	1
responsible for creating and deleting	1
i++; } } } Assume	1
throw(); This allows the compiler	1
i++. cmp eax, 100 /	1
tools, rather than by the	1
precedence, not only when called	1
__intel_cpu_features_init_x(). In other cases, it	1
(Some compilers use the name	1
well- tested library modules and	1
a=a*2; to return a+1;. The	1
interrupt, e.g. every millisecond. The	1
7.1-4, 2008. Digital Mars Compiler	1
truncation, and % means modulo.	1
old. The CPU market is	1
232-1 uint32_t unsigned long long	1
API. In some cases, there	1
__m128d defines a 128 bit	1
Wesley 1997. Mostly obsolete. Microprocessor	1
73) automatically then it is	1
73. Runtime polymorphism is needed	1
s(0.f, 0.f, 0.f, 1.f); //	1
Active Template Library (ATL) and	1
subset, giving access to low-level	1
remedies against this problem: (1)	1
resultant code will be efficient	1
sequence, where r is the	1
safely assume that the value	1
1]; Here, I have AND'ed	1
kind: "what is the nearest	1
environment, between different threads in	1
point). There are also other	1
(everything that begins with #)	1
2008, v. 9.0 CodeGear Borland	1
bb) { for (int i	1
2008. Digital Mars Compiler v.	1
intrinsics, automatic vectorization (see page	1
intrinsics. Digital Mars This is	1
layer of a third-party graphics	1
(FILO) basis then use a	1
linking" if available. See page	1
14.2a float a; int b;	1
14.2b float a; int b;	1
FuncC. Unrolling the loop by	1
similarly sets the variable __intel_cpu_feature_indicator_x.	1
R2 as well as in	1
apart. I will call this	1
FMA3 floating point multiply-and-add Table	1
clarity of the program as	1
these, it is important to	1
these. The CodeGear, Codeplay and	1
Porting such an application to	1
wasted. The consequence is that	1
memmove, memset, or mathematical functions	1
[esp+12] ; edx = r	1
reserving memory in advance. The	1
tempting to fine- tune the	1
levels of cache for the	1
DelayFiveSeconds() { seconds = 0;	1
mimic the behavior of static	1
Third Edition, 2005; and "More	1
identifying hot spots in the	1
disagree with this rule. Splitting	1
AQtime, Intel VTune and AMD	1
14.29 union { float f;	1
14.24 union { float f;	1
14.25 union { float f;	1
Vectors of 256-bit size are	1
reciprocal, fast approximate reciprocal square	1
14.20 double d = 1.6;	1
14.21 is faster than other	1
adapt to the new context.	1
unrelated to each other (not	1
unit- test because the total	1
SelectAddMul_AVX2 #endif // SSE2 //	1
1.6; int a, b; a	1
fighting with the problems of	1
__intel_new_strlen in library libircmt.lib. Function	1
ARM platforms and various programming	1
a[i]. Note how efficient the	1
at, rather than the external	1
overwrite the return address of	1
seconds. A safer implementation would	1
399 int b; // 4	1
immintrin.h AMD SSE4A ammintrin.h AMD	1
BSF (bit scan forward) instruction	1
seconds; // incremented every second	1
1.2f; // Example 14.18c double	1
intended, while the Borland and	1
makefile. You can check the	1
strings. In most cases, the	1
supply such a framework in	1
queue. It is more efficient	1
queue, list, database, or other	1
from), function parameters, local variables,	1
distinguishing between the number of	1
queue) allocates one memory block	1
comp.lang.asm.x86 for some links. 20	1
9.1b. On the contrary, the	1
cc[]); // function prototypes for	1
Coarse-grained parallelism refers to the	1
term for running multiple threads	1
wstring or CString uses new	1
symbols, but this feature is	1
consequences. I once made a	1
activating the very time-consuming garbage	1
sum2; If the microprocessor is	1
minimized. For example, if multiple	1
inserted, one by one, into	1
*(T*)0; } // No error	1
7.30b. The loop control condition	1
vary dynamically and that measurements	1
14.4a const int size =	1
exceed 2 Gbytes. This large	1
WriteFile(handle, ...)) { ... Here	1
&SelectAddMul_SSE41; (iset >= 2) SelectAddMul_pointer	1
11, Iss. 4, 2007 (www.intel.com/technology/itj/).	1
allocated. If the final size	1
11. Using the vector operations	1
minimized if the number of	1
alias, if appropriate. 8. Avoid	1
115 from bb into vector	1
Atom processors, but is less	1
100> list; // Make array	1
116 // Set function pointer	1
111 } You have to	1
110 // AND each element	1
around, (3) trap integer overflow	1
112 Vectorized table lookup Lookup	1
-Wstrict-overflow=2, or (5) make the	1
FuncB(i+1); FuncC(i+1); } This has	1
minimum, maximum, saturated addition, fast	1
118 12.7 Mathematical functions for	1
11; // exponent + 0x3FF	1
constant: Unsigned is faster than	1
Jr.: "Hacker's Delight". Addison-Wesley, 2003.	1
70). The programmer does not	1
(&) and the EXCLUSIVE OR	1
list[300] = 0; 14.6 Floating	1
(&& and ||). The bitwise	1
Default version return &CriticalFunction_386; }	1
locked after the program is	1
1./24., 1./120., 1./720., 1./5040., 1./40320.,	1
executed, cache misses, branch mispredictions,	1
annoying. We may decide to	1
94 Are objects accessed in	1
91 step by step. In	1
9; } Induction variables are	1
98 int r, c; double	1
platform, but also supports Linux	1
exiting the {} brackets in	1
rare cases of floating point	1
occupying a cache line. 132	1
_mm_and_si128(c2, mask); 110 // AND	1
getting them into the right	1
Linux). Threads are useful for	1
7.41a class vector { //	1
7.41b a.x = b.x +	1
Zero can be represented with	1
endl; // Output array element	1
0x20 = 0x1C. Reading or	1
[eax], ecx DWORD PTR [eax+4],	1
Alternative to multiple inheritance class	1
NOT on a variable which	1
reports of which functions take	1
registration database in the Windows	1
error; and make appropriate error	1
calling. __fastcall or __attribute__((fastcall)). The	1
(arrays can also be huge).	1
__declspec(thread). Such variables have one	1
2.5; // Use signed when	1
granularity is too fine then	1
&= 0x7FFFFFFF; // set sign	1
accessed. Pointer arithmetic A pointer	1
BIOS setup. on Intel CPUs:	1
quadratic matrix, i.e. each element	1
d+e, then c is added	1
re-loaded from memory a hundred	1
2.5, which is double. Here	1
writeable data. Therefore, the data	1
malloc/free should be avoided because	1
(single precision requires only SSE).	1
"Gnu indirect function" has been	1
eax,eax. This is a common	1
nature, it is important to	1
/arch:SSSE2 -msse4.1 /arch:SSE4.1 -mAVX /arch:AVX	1
27. An array can be	1
1997. Mostly obsolete. Microprocessor documentation	1
Nowadays, programming textbooks recommend object	1
Sandy Bridge) because it is	1
Primitives". These function libraries are	1
;startofFunc ; a ; r	1
meaningless event counts for threads	1
--- - ----- x---- x----	1
disturb the users with nagging	1
task-specific part of the code,	1
Temporary files that need to	1
'1' is not included in	1
dummy[0]; clock = __rdtsc(); return	1
replaces the PLT entry with	1
a+1; b = temp *	1
reproducible. Such events as task	1
incredibly stupid things. Looking at	1
Efficiency Accessing a variable or	1
Re-interpreting the type of an	1
inheritance. There may be a	1
inheritance, virtual functions, and other	1
Future processors will support the	1
sub-vector before it has finished	1
(^) may give inconsistent results	1
incurred on all non-static member	1
b<c) Multiply by constant =	1
Foundation Classes (MFC). A competing	1
volumes in this series of	1
12.2. Header files for intrinsic	1
