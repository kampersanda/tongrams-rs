61516
the // parent	1
the function is	22
the function a	4
the function to	1
the function and	1
the function in	5
the function for	1
the function that	1
the function can	1
the function or	3
the function has	1
the function pointer	5
the function library	2
the function where	1
the function we	1
the function return	1
the function cannot	1
the function address	1
the function call	1
the function they	1
the function type	1
the function must	1
the function through	1
the function was	1
the function name	1
the function calling	2
the function go	1
the function names	1
the function directly	1
the function modify	1
the function returns.	9
the function stores	1
the function could	1
the function body	1
the function call.	2
the function returns	1
the function definition.	1
the function longjmp	1
the function ReadTSC	1
the function argument	1
the function inline.	2
the function construct	1
the function declaration.	1
the function body.	1
the function prototype:	1
the function billions	1
the function add_horizontal)	1
the function bodies	1
the function scanf.	1
the if branch	1
the if statement	1
the if condition	1
the code is	19
the code of	1
the code to	6
the code and	3
the code in	8
the code that	8
the code are	2
the code can	8
the code if	1
the code with	1
the code you	1
the code have	1
the code more	4
the code will	3
the code then	1
the code from	1
the code has	2
the code cache	5
the code size	1
the code where	1
the code takes	1
the code so	1
the code faster	1
the code makes	2
the code less	1
the code rather	1
the code 16	1
the code up	1
the code must	1
the code inside	1
the code contains	2
the code memory.	1
the code automatically	2
the code cache.	2
the code difficult	1
the code becomes	4
the code together	1
the code smaller	1
the code section	5
the code still	1
the code prevent	1
the code further	1
the code execute	1
the code to:	1
the code could	1
the code involves	1
the code itself	1
the code automatically.	1
the code generated	2
the code relies	1
the code itself.	1
the code incompatible	1
the code only.	1
the code explicitly.	1
the code carefully	1
the code mixes	1
the code section,	1
the compiler is	6
the compiler to	21
the compiler and	1
the compiler in	1
the compiler that	5
the compiler can	9
the compiler if	1
the compiler not	1
the compiler may	7
the compiler you	2
the compiler have	1
the compiler will	3
the compiler from	8
the compiler at	1
the compiler has	4
the compiler takes	2
the compiler cannot	3
the compiler does	4
the compiler must	2
the compiler (see	1
the compiler doesn't	6
the compiler option	2
the compiler manual	2
the compiler uses	2
the compiler would	1
the compiler optimize	1
the compiler needs	2
the compiler optimizations	1
the compiler output	1
the compiler e.g.	1
the compiler explicitly	1
the compiler itself	1
the compiler generates	1
the compiler ..........................................................................................	1
the compiler additional	1
the compiler 8.1	1
the compiler documentation	2
the compiler optimizes	1
the compiler bypassing	1
the compiler sees	1
the compiler treat	1
the compiler interpret	1
the compiler recognizes	1
the compiler knows	1
the time the	3
the time is	2
the time of	3
the time to	1
the time and	2
the time it	16
the time on	1
the time you	1
the time used	1
the time we	1
the time before	2
the time goes	1
the time delay	1
the time stamp	4
the time consuming	1
the time spent	2
the time consumption	2
the time slices	3
the time MemberPointer	1
the use of	12
the more important	1
the more complicated	1
the memory is	1
the memory to	2
the memory if	1
the memory when	1
the memory used	1
the memory page	1
the memory allocation	1
the memory space	1
the memory model	1
the memory block	2
the memory block.	1
the memory footprint	1
the memory bus	1
the memory released	1
the data to	1
the data and	1
the data in	1
the data are	6
the data with	1
the data as	1
the data more	1
the data cache	1
the data set	1
the data into	2
the data object	2
the data elements	1
the data caching	1
the data cache.	6
the data block	1
the data section	1
the data fit	2
the data members.	2
the data optimally,	1
the data structure,	1
the program is	19
the program of	1
the program to	3
the program in	2
the program that	4
the program are	2
the program or	1
the program if	1
the program by	1
the program with	1
the program code	2
the program as	2
the program -	1
the program than	1
the program may	2
the program have	1
the program more	1
the program will	2
the program then	1
the program has	1
the program do	1
the program takes	1
the program before	1
the program less	1
the program must	1
the program uses	2
the program contains	1
the program under	3
the program happen	1
the program logic	2
the program had	1
the program itself	1
the program itself.	1
the program appear	1
the program runs	1
the program starts	2
the program 153	1
the program flow	2
the program flow.	1
the program afterwards	1
the program slower.	1
the program starts.	2
the program logic.	1
the vector class	2
the vector size	3
the vector register	1
the vector registers	3
the vector operations	2
the vector element	2
the vector size.	1
the vector registers.	1
the different functions	1
the different integer	1
the different compilers	1
the different instructions	1
the different versions	3
the different execution	1
the different parts	1
the different tasks	1
the different cores	1
the different microprocessors.	1
the same in	2
the same for	1
the same or	1
the same function	4
the same code	4
the same as	10
the same compiler	1
the same time	5
the same memory	8
the same data	1
the same instruction	1
the same cache	6
the same set	1
the same class	2
the same object	1
the same array	1
the same version	1
the same member	1
the same way	4
the same address	1
the same critical	1
the same register	4
the same time.	5
the same without	1
the same dynamic	2
the same part	3
the same bits	2
the same type	1
the same result	1
the same processor	4
the same thread	1
the same precision	2
the same few	1
the same structure	1
the same inline	1
the same shared	1
the same space	1
the same cache.	1
the same name	3
the same source	3
the same induction	1
the same reason	1
the same after	1
the same piece	2
the same function,	1
the same compiler.	1
the same range	1
the same core	1
the same errors	1
the same variables.	1
the same operation	2
the same level-1	1
the same resources.	1
the same class.	1
the same object.	1
the same time,	1
the same priority	2
the same thing	4
the same logical	1
the same subexpression	1
the same resource	1
the same generation	1
the same address.	1
the same module	2
the same features	1
the same value.	1
the same unit	1
the same register.	1
the same DLL	1
the same object,	1
the same core.	1
the same constant.	1
the same principle	1
the same regardless	1
the same result.	1
the same resources,	1
the same cache,	1
the same brand.	1
the same way,	1
the same chip	1
the same name.	1
the same arguments	1
the same executable.	1
the same machine.	1
the same thing.	2
the same template.	1
the same chip.	1
the same effect.	1
the same class).	1
the same computer,	1
the same name,	1
the same algorithm,	1
the same directory	1
the same divisor.	1
the same queue,	1
the functions that	8
the functions are	2
the functions memset	1
the functions malloc	1
the functions lrintf	1
the only one	1
the only way	1
the only situation	1
the only reasonable	1
the CPU is	1
the CPU to	4
the CPU and	5
the CPU can	1
the CPU it	1
the CPU by	1
the CPU than	1
the CPU may	1
the CPU time	1
the CPU from	3
the CPU has	3
the CPU which	1
the CPU used	1
the CPU clock	3
the CPU doesn't	1
the CPU doing	1
the CPU was	1
the CPU dispatching	2
the CPU dispatcher	2
the CPU dispatch	1
the CPU core	1
the CPU supports	2
the CPU (See	2
the CPU cores	1
the CPU dispatching.	1
the CPU brand	1
the CPU detection	7
the CPU family	1
the CPU brand.	1
the CPU chip.	1
the CPU supports,	1
the other is	1
the other with	1
the other then	1
the other way	3
the other thread	1
the other thread.	1
the other way.	1
the other hand,	5
the other way,	1
the other compilers).	1
the other volumes	1
the instruction set	4
the instruction code.	1
the instruction sets	1
the instruction set.	1
the instruction xor	1
the point is	1
the point where	1
the loop is	4
the loop and	3
the loop in	3
the loop are	1
the loop can	2
the loop or	2
the loop if	3
the loop by	5
the loop will	1
the loop branch	1
the loop without	1
the loop does	1
the loop counter	5
the loop count	5
the loop control	9
the loop further	1
the loop unroll	2
the loop condition	1
the loop buffer	1
the loop body	1
the loop is.	1
the loop counter.	2
the loop increment	1
the loop index.	1
the loop counter,	1
the loop exits,	1
the loop overhead.	1
the one that	4
the one it	1
the cache to	1
the cache in	2
the cache will	2
the cache then	1
the cache so	1
the cache between	1
the cache always	1
the cache line	5
the cache contentions	1
the cache size.	2
the cache lines	2
the cache miss	1
the integer is	1
the integer in	2
the integer has	1
the integer size	1
the integer value	1
the integer registers	1
the integer operations	1
the integer expression	1
the integer calculations.	1
the integer factorial	1
the set can	1
the class is	1
the class of	1
the class that	1
the class or	3
the class has	1
the class c1	1
the class Vec16s	1
the class definition.	1
the class declaration.	1
the floating point	13
the example of	1
the example below	1
the compilers that	1
the compilers are	1
the compilers may	1
the compilers will	1
the compilers cannot	1
the compilers I	5
the compilers reduced	1
the most used	2
the most efficient	8
the most critical	10
the most often	3
the most simple	1
the most important	2
the most common	5
the most complicated	1
the most advanced	1
the most significant	1
the most time-consuming	2
the most frequent	1
the most reliable	1
the most predictable	1
the double precision	1
the size is	1
the size of	20
the size and	1
the size doesn't	1
the size known	2
the size parameter	2
the size (in	1
the Intel and	1
the Intel function	1
the Intel compiler	11
the Intel CPU	2
the Intel C++	2
the Intel libraries	1
the Intel mechanism	1
the Intel compiler.	1
the Intel math	1
the Intel libraries.	1
the Intel Core	1
the pointer is	3
the pointer or	1
the pointer it	1
the pointer has	2
the pointer does	1
the pointer p	1
the library is	3
the library that	2
the library function	2
the library has	1
the library functions	1
the library into	1
the library file	1
the library function.	1
the library through	1
the library functions.	1
the library function,	1
the library www.agner.org/optimize/asmlib.zip.	1
the library libmmt.lib	1
the multiple data	1
the multiple processor	1
the multiple .cpp	1
the two clock	1
the two operating	1
the two functions.	1
the two branches	1
the two induction	1
the two types	1
the two modules	1
the two constants	1
the two kinds	1
the two loops	2
the two AND	1
the two parentheses	1
the two formulas	1
the object is	7
the object of	1
the object in	1
the object can	1
the object or	1
the object it	1
the object on	1
the object x	1
the object then	1
the object has	2
the object file	2
the object does	1
the object doesn't	1
the object files	1
the object instead	1
the object file.	1
the object pointed	1
the object belongs	1
the object owns.	1
the number of	37
the number and	2
the static version	1
the static keyword	2
the static modifier	1
the static keyword:	1
the static keyword,	1
the 64-bit vector	1
the 64-bit instruction	1
the 64-bit systems	1
the 64-bit systems.	1
the 64-bit vectors	1
the 64-bit versions.	1
the 64-bit extension	1
the C++ compiler	1
the C++ template	1
the C++ programming	1
the C++ language	3
the C++ syntax	1
the C++ language,	1
the C++ language......................................................	1
the array is	3
the array a	1
the array to	1
the array or	1
the array size	1
the array pointer	1
the array elements	1
the array address	1
the array must	1
the array element	2
the array after	1
the array index	1
the array i)	1
the array 800	1
the many rules	1
the many people	1
the possible alternatives	1
the clock cycles	1
the clock count	1
the clock frequency	4
the clock counts	2
the clock frequency.	2
the clock frequency,	1
the clock period	1
the version in	1
the version that	1
the version changes	1
the value is	3
the value of	22
the value and	1
the value in	2
the value that	4
the value it	1
the value from	2
the value has	1
the value each	1
the value before	1
the value 0	1
the value 10	1
the value pointed	2
the value wrap	1
the value 1000.	1
the value -100+100+100	1
the value infinity,	1
the value 0x2C	1
the objects in	1
the objects are	2
the objects should	1
the objects stored	1
the objects they	1
the objects together	1
the objects (memory	1
the variable is	5
the variable to	1
the variable in	2
the variable that	1
the variable as	1
the variable from	1
the variable at	1
the variable two	1
the variable always	1
the variable pointed	2
the variable whose	1
the variable Day.	1
the variable __intel_cpu_feature_indicator	1
the variable __intel_cpu_feature_indicator_x.	1
the variable 85	1
the variable m.	1
the variables that	1
the variables might	1
the return address	1
the return statement:	1
the table is	3
the table to	2
the table in	2
the table that	1
the table are	1
the table from	1
the table at	1
the table has	1
the table takes	1
the table inside	1
the table values	1
the table lookup.	1
the table static.	1
the performance is	2
the performance of	5
the performance if	1
the performance by	2
the performance then	1
the performance because	2
the performance even	1
the performance counters	1
the performance during	1
the performance monitor	3
the performance under	1
the performance significantly	1
the performance dramatically	1
the performance somewhat.	1
the performance costs.	1
the very time-consuming	1
the software to	1
the software for	1
the software programming	1
the software contains	2
the software was	2
the software implementation	2
the software development	2
the software package	1
the order of	7
the order in	6
the order a[0],	1
the long double	1
the 32-bit version.	1
the 32-bit integer.	1
the 32-bit case.	1
the branch is	1
the branch by	1
the branch inside	2
the branch target	3
the branch prediction	1
the branch misprediction	1
the member function	1
the member functions	2
the member pointer	1
the member function.	1
the member pointer.	1
the member relative	1
the way the	2
the way a	1
the way of	2
the way member	1
the way microprocessors	1
the way m	1
the elements of	1
the elements in	1
the elements are	4
the elements from	1
the elements consecutively	1
the elements matrix[r][c]	1
the const int	1
the const keyword	1
the const restriction	2
the called function.	2
the address of	21
the address can	1
the address calculation	2
the address range	2
the 4 lines	1
the critical function	5
the critical code	3
the critical functions	2
the critical code.	1
the critical part	7
the critical function.	3
the critical parts	1
the critical innermost	5
the critical stride	7
the critical stride,	1
the critical stride.	1
the call to	3
the call and	1
the call stack	1
the call p->f()	1
the 8 most	1
the bit scan	2
the operating systems	1
the operating system	16
the operating system.	4
the operating system,	2
the unsigned integer	1
the first in	1
the first time	4
the first data	1
the first two	2
the first object	1
the first way	1
the first call	1
the first time.	1
the first processors	1
the first result	1
the first element	3
the first 128	2
the first four	1
the first program.	1
the first application	1
the first byte	2
the first algorithm	1
the first operand	3
the first six	1
the first PC's	1
the first sum,	1
the first sub-vector.	1
the first dimension	1
the register size	1
the register stack	2
the register usage	1
the register keyword.	1
the optimization of	1
the optimization unless	1
the optimization features	1
the optimization capabilities	1
the optimization effort	1
the optimization efforts	1
the optimization job.	1
the libraries named	1
the code. The	1
the code. //	1
the code. This	2
the code. It	1
the code. See	1
the code. For	1
the code. Example:	2
the code. Some	1
the code. Many	1
the code. Let's	1
the code. Sometimes	1
the code. C#,	1
the code. Inserting	1
the time. The	1
the time. This	1
the time. A	1
the template function	2
the template parameters	4
the template parameter	1
the template function,	1
the template parameter.	2
the registers eax,	1
the need to	3
the need for	1
the pointers and	1
the test and	1
the test program	2
the test loop.	1
the new version	2
the new value	1
the new function.	1
the new bigger	1
the new block.	1
the new features.	1
the new context.	1
the user is	1
the user to	2
the user and	2
the user can	1
the user if	1
the user will	1
the user has	2
the user but	1
the user must	1
the user never	1
the user actually	1
the user interface	3
the user might	1
the user interface.	2
the user expects	1
the user interface,	1
the even integer	1
the method of	1
the method that	1
the method used	1
the access to	1
the access non-sequential	1
the SSE2 or	4
the SSE2 instruction	17
the SSE2 version	1
the SSE2 (or	1
the following example,	1
the following assembly	2
the following methods	1
the following example:	1
the following conditions	2
the following way.	3
the following explanation	1
the following table.	1
the following disadvantages	1
the following reasons:	3
the following way:	3
the following cases:	1
the following alternatives:	1
the following steps	1
the following work-around	1
the following features:	1
the following sections.	1
the following solutions,	1
the system code	2
the system may	1
the system database	1
the system forbids	1
the 32 sets	1
the file is	2
the file to	1
the file for	1
the file has	1
the file until	1
the programming language	1
the programming manuals	1
the dynamic libraries	2
the dynamic linker.	1
the part of	1
the bits of	2
the bits for	1
the type of	5
the type and	1
the type that	1
the type conversion	2
the type T	1
the case a	1
the case of	4
the case in	1
the case that	1
the case if	1
the case with	1
the case then	1
the case we	1
the case labels	1
the cases where	1
the cases described	1
the short vector	1
the & operator	2
the & operation	1
the & operator;	1
the simple function	1
the simple function,	2
the instructions listed	1
the processors that	1
the processors on	1
the available vector	1
the available instruction	2
the available options	1
the constant is	1
the constant vector	1
the constant 8	1
the constant single	1
the constant 5.	1
the constant 3.5	1
the constant subexpression.	1
the constant 2.5,	1
the error is	1
the error code	1
the error code.	1
the error doesn't	1
the error condition.	1
the stack is	1
the stack and	2
the stack in	2
the stack for	1
the stack can	1
the stack when	1
the stack at	1
the stack before	2
the stack rather	1
the stack always	1
the stack (see	1
the stack pointer.	1
the stack Variables	1
the stack unwinding	1
the stack (three	1
the Gnu compiler	9
the Gnu manual	1
the Gnu mechanism	1
the Gnu directives	1
the Gnu compiler.	1
the Gnu C	2
the Gnu compiler,	1
the Gnu utilities	1
the function. The	4
the function. This	4
the function. In	1
the function. Copying	1
the function. Compile	1
the extra function	1
the extra operations	1
the extra work	1
the extra overhead	1
the extra bits.	1
the assembly output	4
the large graphics	1
the large overhead	1
the while loop	3
the while loop,	1
the arrays are	7
the arrays or	1
the arrays as	1
the arrays very	1
the work it	1
the work into	2
the work load	2
the work load.	1
the work evenly	1
the Windows operating	1
the Windows system.	1
the Windows Template	1
the calls to	2
the calculations of	1
the calculations in	1
the calculations are	1
the calculations on	1
the calculations so	1
the calculations inside	1
the execution of	2
the execution to	1
the execution time	2
the execution speed	1
the execution units	1
the execution considerably.	1
the result is	3
the result of	7
the result in	3
the result can	1
the result will	1
the result vector	4
the result 100	1
the result back	1
the result -56	1
the processor is	3
the processor and	2
the processor can	1
the processor has	1
the compiled code	2
the compiled code.	1
the compiled versions	1
the big registration	1
the threads are	1
the threads use	1
the threads will	1
the threads write	1
the threads share	1
the best and	1
the best compiler	1
the best possible	3
the best way	3
the best optimization	1
the best optimized	2
the best optimizing	1
the best implementation	1
the best cases.	1
the best algorithm	1
the best Java	1
the best job	1
the best optimizer.	1
the best algorithm.	1
the necessary functions	1
the necessary instruction	1
the necessary library	1
the necessary calculations	1
the necessary information	1
the necessary cleanup	1
the necessary initialization.	1
the speed of	5
the speed or	1
the speed by	1
the speed will	1
the speed here	1
the specific instruction	1
the specific purpose	1
the specific event	1
the specific literature	1
the virtual function	3
the virtual table	1
the virtual function.	1
the virtual functions.	1
the virtual table.	1
the virtual 53	1
the common language	1
the common entry	1
the thread to	1
the thread in	1
the thread function	1
the thread have	1
the thread priority	1
the exception handling	2
the exception handler	3
the exception handler,	1
the allocated memory	1
the allocated array	1
the allocated object,	1
the overflow and	1
the overflow condition	1
the overflow behavior	1
the integers from	1
the option for	2
the option that	1
the option -fpic	1
the option -fno-pic	1
the option -fpie	1
the option -mveclibabi=acml.	1
the option -ftrapv,	1
the option /QaxAVX	1
the option -read_only_relocs	1
the option -mveclibabi=svml.	1
the power of	3
the power function	1
the matrix is	2
the matrix when	1
the matrix into	1
the matrix line	1
the matrix longer	1
the matrix 512	1
the matrix element.	1
the AVX and	1
the AVX or	1
the AVX instruction	6
the AVX 32	1
the AVX instructions.	2
the AVX part.	2
the line that	1
the line number	1
the line containing	1
the optimized code	2
the optimized version	2
the manual for	2
the calculated value.	1
the calculated result.	1
the calculation of	14
the calculation in	2
the calculation time	2
the uses of	1
the four cache	2
the four results	1
the four B	1
the four G	1
the four R	1
the four sums	1
the parameters of	1
the parameters are	1
the parameters on	1
the parameters would	1
the check for	1
the check after	1
the problem is	3
the problem and	2
the problem that	1
the problem by	1
the problem cannot	1
the solution is	2
the solution to	1
the container is	1
the container be	1
the container may	1
the container rather	1
the container expandable,	1
the advantage of	1
the advantage that	2
the supported instruction	1
the operators new	1
the few cases	1
the list is	1
the list does	1
the list every	1
the list causes	1
the likely case	1
the structure to	1
the structure in	1
the structure or	1
the structure 8	1
the structure };	1
the structure y	1
the inline keyword	1
the standard libraries	1
the standard template	1
the standard stack	1
the standard calling	1
the standard header	1
the standard PC	4
the hardware is	1
the hardware can	1
the hardware implementation	2
the hardware platform	1
the hardware definition	1
the values of	5
the values in	2
the values because	1
the sign of	2
the sign bit	9
the sign bit:	2
the sign bit.	2
the sign bit,	1
the copy of	1
the copy constructor	1
the memory. The	1
the memory. This	1
the memory. It	1
the well optimized	1
the information is	1
the information in	1
the addresses of	4
the addresses are	2
the shared object	1
the shared variable	1
the shared resources	1
the shared object.	2
the shared object,	1
the program. The	4
the program. This	2
the program. In	1
the program. 3	1
the program. Reading	1
the program. 16.2	1
the program. Small	1
the program. Application	1
the intermediate code	1
the intermediate code.	1
the intermediate result	2
the intermediate expression	1
the allocation process	1
the write causes	1
the above code	1
the above example	3
the above example,	4
the above template	1
the above methods	1
the above examples	1
the above advantages	1
the above sections	1
the above table.	1
the above security	1
the programs they	1
the problems of	1
the problems and	1
the problems that	1
the problems mentioned	1
the problems associated	1
the optimal code	1
the optimal version	1
the optimal branch	1
the optimal solution	1
the optimal platform	2
the optimal choice	1
the optimal algorithm	3
the optimal order.	1
the optimal decomposition	1
the space explicitly	1
the dispatching only	1
the dispatching should	1
the particular application.	1
the microprocessor is	2
the microprocessor and	1
the microprocessor can	3
the microprocessor it	1
the microprocessor has	4
the microprocessor doesn't	1
the microprocessor hardware	1
the microprocessor jump	1
the microprocessor handles	1
the microprocessor wastes	1
the next time	1
the next new	1
the next function.	1
the next processor	1
the next model	1
the next higher	1
the next instance	1
the next generation	2
the next block.	1
the next element.	1
the next vector,	1
the next step	1
the next step.	1
the next calculation.	1
the next paragraph.	1
the next section.	1
the branches are	1
the Mac platform,	1
the multiplication is	2
the multiplication of	1
the multiplication can	1
the multiplication by	1
the multiplication would	1
the multiplication b[i]*c[i],	1
the application can	1
the application has	1
the application software	1
the application code.	1
the application uses	1
the application program.	3
the application programmer	1
the application software.	1
the application itself	1
the application programmer.	1
the caching conditions	1
the expression is	1
the expression a	2
the expression that	1
the expression contains	1
the expression y	1
the expression list[i]	1
the expression -(-a)	1
the complicated address	1
the dependency chain	1
the members of	1
the members individually.	1
the Boolean operators	4
the Boolean operands	1
the cache. The	3
the cache. When	1
the intrinsic function	1
the intrinsic hardware	1
the methods in	1
the methods described	1
the development of	1
the development process	1
the mathematical notion	1
the block size	1
the name of	1
the name in	1
the name cannot	1
the name _alloca)	1
the systems. There	1
the needs of	1
the conversion is	2
the conversion to	1
the conversion takes	1
the various optimization	1
the disadvantage of	1
the disadvantage that	3
the high processing	1
the high level	2
the high complexity	1
the zero flag	1
the Microsoft directives	1
the Microsoft platform	1
the Microsoft compiler.	1
the Microsoft Visual	1
the parameter is	1
the parameter has	1
the division faster.	1
the source is	1
the source code	1
the source code.	1
the source code,	1
the source files.	1
the source annotation	1
the cost of	6
the resources of	1
the induction variable	3
the reason why	4
the dispatcher function	2
the dispatcher function.	3
the dispatcher 128	1
the dispatcher signal	1
the string is	1
the programmer to	10
the programmer in	1
the programmer that	1
the programmer can	1
the programmer has	1
the programmer choosing	1
the programmer forgets	1
the programmer can.	1
the programmer hasn't	1
the three functions.	1
the keyword static	2
the keyword __restrict	1
the keyword volatile	1
the keyword far	1
the keyword __thread	1
the end of	5
the end in	1
the end when	1
the end user	4
the end user.	5
the && expression	1
the | operator	1
the | operator;	1
the examples in	1
the examples have	1
the examples I	1
the difference is	1
the difference between	6
the data. The	1
the data. This	1
the data. A	1
the data. Use	1
the runtime address	1
the runtime framework	1
the runtime polymorphism	1
the runtime polymorphism:	1
the last cache	1
the last 8	1
the last element	1
the last index	2
the last vector.	1
the last member.	1
the parts of	2
the optimizations that	1
the graphics processing	1
the framework and	1
the framework itself,	1
the numbers in	2
the numbers are	1
the dispatch on	2
the dispatch branch	1
the dispatch branches	1
the dispatch mechanism	1
the dispatch decision	1
the calling function	1
the calling program	1
the XMM registers	5
the second result	1
the second operand	4
the second generation	1
the second step	1
the second step.	1
the second sum,	1
the second operand.	1
the second sub-vector	1
the higher bits.	1
the vectors of	1
the vectors into	1
the AVX2 instruction	1
the piece of	2
the x86 instruction	2
the x86 CPUs.	1
the x86 family	3
the binary value	1
the binary decimals	1
the binary digits.	1
the advantages of	2
the advantages and	1
the advantages over	1
the results of	1
the results are	1
the storage order	1
the storage methods	1
the old memory	1
the old operating	1
the old block	1
the old Pentium	2
the old version.	1
the old fashioned	2
the options for	1
the options -S	1
the feature that	1
the feature information,	1
the link pointers	1
the appropriate function	1
the appropriate instruction	1
the appropriate version	6
the appropriate type	1
the appropriate header	2
the constructor itself.	1
the function, and	1
the function, but	1
the operands and	1
the operands are	3
the operands if	1
the operands have	2
the operands has	1
the operands because	1
the innermost loop	7
the innermost function,	1
the innermost loop.	3
the compiler. The	1
the compiler. You	1
the compiler. Some	1
the compiler. We	1
the compiler. Loop	1
the compiler. On	1
the compiler. Remember,	1
the advanced version	2
the advanced programming	1
the advanced principles	1
the range of	2
the start of	1
the start so	1
the modules of	1
the modules are	1
the modules appear	1
the smaller the	2
the core with	1
the core clock	1
the relevant optimization	1
the relevant books	1
the negative effects	1
the reductions that	1
the reductions manually.	1
the example: //	1
the contentions and	1
the main memory	2
the main program.	1
the main executable	3
the main reasons	1
the main feedback	1
the positive or	1
the loop. The	2
the loop. It	1
the loop. Example	2
the loop. If	1
the loop. In	1
the loop. Some	1
the loop. Most	1
the computer is	3
the computer for	1
the computer has	1
the computer while	1
the computer during	1
the computer starts	1
the overhead of	4
the pointer. These	1
the C style	1
the global offset	1
the conversions and	1
the conversions by	1
the conversions out	1
the statement was	1
the relative efficiency	1
the installation process	3
the syntax is	3
the syntax described	1
the cases. The	1
the choice of	4
the choice between	1
the STL is	2
the STL are	1
the STL has	1
the STL also	1
the STL containers	1
the STL (Standard	1
the profiler may	1
the profiler itself.	1
the index is	1
the index by	1
the inlining causes	1
the size. However,	1
the size. Integers	1
the network is	2
the network or	1
the slow GOT	1
the desired function	1
the desired program	1
the desired instruction	2
the desired version	2
the desired function.	1
the desired version.	1
the desired polymorphism	1
the desired functionality	1
the desired measurement	1
the desired interval	1
the #pragma vector	2
the whole program	2
the whole loop	1
the whole software	2
the whole structure	1
the whole program.	1
the inefficient virtual	1
the level-2 cache	7
the level-2 cache.	3
the response time	5
the response times	1
the hot spots	2
the hot spot	1
the hot spot.	1
the code, then	1
the code, which	1
the code, cache	1
the code, so	1
the code, including	1
the instance in	1
the fact that	1
the position-independent code	1
the position-independent code.	1
the out-of-order execution	2
the out-of-order mechanism	1
the out-of-order capabilities	1
the output of	1
the output are	1
the level-1 and	1
the level-1 data	3
the level-1 cache	4
the level-1 cache.	2
the resources. In	1
the task in	1
the local object	2
the local name	1
the costs of	3
the costs to	1
the costs in	1
the costs if	1
the inlined function	2
the inlined function.	1
the class. Data	1
the class. Calling	1
the class. Storing	1
the class. Which	1
the database anyway	1
the constants are	1
the constants Sunday,	1
the frame function	2
the special feature	1
the destructor is	1
the destructor of	1
the destructor to	1
the destructor for	1
the destructor by	1
the destructor causes	1
the preceding one	2
the preceding value	1
the preceding example,	1
the preceding addition	2
the preceding iteration	1
the preceding label	1
the preceding one.	2
the preceding paragraph	1
the preceding row.	1
the safe formula	1
the Pentium 4	1
the efficiency of	2
the repeat count	5
the unroll factor.	3
the algorithm in	2
the sum of	1
the strings including	2
the exponent is	3
the exponent if	1
the possibility of	3
the possibility for	3
the possibility that	3
the discussion of	1
the maximum loop	1
the maximum possible	1
the maximum repeat	1
the maximum value.	1
the alignment is	1
the alignment explicitly	1
the alignment requirements	1
the right in	1
the right function	1
the right data	1
the right vector	1
the right version	3
the right prediction.	1
the right format	1
the right formula	1
the right positions	1
the offset of	3
the offset can	1
the offset as	1
the offset has	1
the offset relative	1
the compatibility with	1
the macro is	1
the object. The	1
the object. If	1
the object. Make	1
the object. 7.17	1
the library. The	1
the library. This	1
the library. Add	1
the calculations. The	2
the operand that	2
the final program	1
the final size	2
the final array	1
the final version	1
the final value	1
the final result	2
the final program.	1
the final application	1
the final program,	1
the final product.	1
the sake of	13
the tasks into	1
the effect of	1
the amount of	6
the variable. This	1
the variable. For	1
the time, but	1
the copying process,	1
the performance. 14.4	1
the processing power.	1
the so-called time	1
the so-called intrinsic	1
the so-called Java	1
the so-called position-	1
the so-called partial	1
the so-called commpage.	1
the so-called CPU-dispatcher	1
the total number	3
the total time.	1
the total execution	2
the total calculation	1
the total amount	1
the total computation	1
the child class	2
the priority back	1
the disk cache.	1
the iteration is	1
the counters when	1
the stack. The	1
the stack. This	3
the stack. A	1
the stack. Each	1
the stack. Is	1
the stack. Deallocation	1
the stack. String	1
the full advantage	1
the full information	1
the full 128-bit	1
the full declaration	1
the full generality	1
the thread. The	1
the RAM size	1
the rows in	1
the rows are	3
the least significant	2
the least recently	1
the algebraic reductions	1
the logical register	1
the logical structure	1
the logical architecture	1
the bitwise operators	2
the bitwise OR	1
the handle is	1
the heap is	1
the heap to	1
the heap has	1
the heap space	2
the heap manager	1
the target if	1
the target address	2
the target pointed	1
the entire program	2
the entire floating	1
the entire library	1
the entire 64	1
the entire file	1
the entire list	1
the entire level-1	1
the entire object.	1
the entire contents	1
the executable to	1
the executable file	3
the executable file.	1
the subexpression c+b	1
the nontemporal write	2
the bounds of	1
the SSE and	2
the SSE or	2
the updates if	1
the loading of	2
the reading of	2
the directly compiled	1
the simplest possible	1
the simplest code.	1
the simplest cases,	2
the simplest expressions	1
the simplest cases.	1
the simplest method,	1
the situation where	3
the message loop	1
the condition is	1
the condition can	1
the condition clause.	1
the resource use	1
the PathScale and	1
the previous value	3
the previous link	1
the previous iteration	1
the previous chapter	1
the previous value.	2
the previous one.	1
the previous iteration.	1
the vector. The	1
the vector. This	1
the program, and	3
the program, for	1
the program, it	1
the program, one	1
the loops if	1
the SSE4.1 instruction	2
the chapter "Register	1
the risk of	3
the header file	2
the header files	1
the future we	1
the future due	1
the fraction is	1
the fraction bits:	1
the sequence of	2
the sequence to	1
the sequence in	1
the compiler, and	1
the compiler, you	1
the CPU. It	1
the CPU. If	1
the CPU. Algebraic	1
the CPU. Unrolling	1
the length of	6
the module with,	1
the beginning of	9
the beginning rather	1
the alternative version.	1
the current instruction	1
the current array	1
the current version	1
the current .cpp	1
the current position.	1
the 'this' pointer.	1
the problem. This	1
the row length	1
the declaration class	1
the declaration "static"	1
the series of	1
the features of	1
the user. Time	1
the user. Making	1
the user. With	1
the user. Compatibility	1
the user. Feature	1
the chosen compiler	1
the chosen version	1
the chosen expression.	1
the device itself	1
the subsequent times	1
the subsequent instructions.	1
the subsequent counts	1
the subsequent manuals.	1
the subsequent counts.	1
the low priority	1
the latter is	1
the latter function	1
the latter has	1
the latter case	1
the latter function,	1
the latter case,	2
the default integer	1
the default size	1
the time-consuming data	1
the diagonal is	1
the diagonal and	1
the diagonal are	2
the diagonal have	1
the diagonal there	1
the diagonal remain	1
the logic structure	1
the logic behind	1
the Microsoft, Intel,	2
the hard disk	1
the hard disk.	1
the typical repeat	1
the derived class	2
the derived class.	1
the derived class:	1
the overflow. Taking	1
the fully optimized	1
the factorial function	1
the OpenMP directives	2
the parent class	1
the value. The	1
the memcpy function	1
the memcpy function.	1
the procedure linkage	1
the parallelism is	2
the prediction turns	1
the polymorphic member	1
the polymorphic functions.	1
the graphical user	1
the lower 8	1
the lower 16	1
the label $B1$2:.	1
the iterations and	1
the misprediction before	1
the misprediction penalty	1
the background are	1
the background job	1
the chain of	1
the PLT and	1
the PLT entry	1
the heavy graphics	1
the heavy background	1
the additions are	1
the system. The	1
the inputs to	1
the inputs have	1
the interrupt 3	2
the fastest way	2
the fastest solution	1
the fastest first.	1
the DLL is	1
the DLL use	1
the factors that	1
the factors are	1
the Gnu, Clang	2
the Gnu, Clang,	3
the arrays. It	1
the arrays. An	1
the branch. It	1
the required amount	2
the GOT and	1
the GOT through	1
the array. This	1
the array. eax	1
the general case	1
the general case,	1
the general literature	1
the preferred programming	1
the preferred language	1
the software. You	1
the software. Smaller	1
the interpreted version	1
the vectors. This	1
the YMM register	1
the YMM registers.	1
the purpose of	1
the -fpic option.	1
the D language.	1
the sections below.	1
the carry and	1
the carry bit	2
the carry flag	3
the debugging options	1
the table. The	1
the table. Optimization	1
the object, and	1
the trick that	1
the disadvantages when	1
the disadvantages mentioned	1
the update mechanism	1
the update process.	1
the body of	2
the Java virtual	1
the memory, depending	1
the system, the	1
the system, as	1
the absolute value	3
the machine code	1
the CPUID is	1
the CPUID instruction	3
the CPUID information	1
the CPUID was	1
the saved variable	1
the changes of	1
the processor. This	1
the processor. Nested	2
the linker to	2
the linker and	1
the linker makes	1
the linker extracts	1
the measurements as	1
the representation of	1
the factor is	1
the factor to	1
the core. It	1
the rules of	2
the smallest data	1
the smallest integer	3
the smallest list	1
the smallest members	1
the smallest devices,	1
the responsibility of	7
the Borland and	1
the Borland compiler	1
the Borland C++	1
the sense that	6
the latest instruction	2
the latest compilers	1
the latest version	3
the reciprocal of	2
the reciprocal in	1
the reciprocal factorials	1
the log on	1
the thousand results	1
the break a	1
the break will	1
the Common Language	1
the scope of	5
the principle for	1
the throughput of	3
the throughput (see	1
the expected real-time	1
the application. The	1
the application. In	1
the application. You	1
the largest vector	1
the largest available	1
the largest vector.	1
the dispatched function	1
the normal return	1
the portability could	1
the availability of	5
the .NET framework	1
the .NET framework.	1
the newest CPU	2
the newest instruction	2
the newest processors.	1
the B values.	1
the debugger is	1
the debugger to	1
the debugger then	1
the ^ operator.	1
the base classes.	1
the result. You	1
the compilation is	1
the behavior of	3
the 7 program	1
the form of	3
the worst possible	2
the worst case	2
the job of	1
the job into	1
the job before	1
the job fast	1
the biggest time	2
the biggest vectors:	1
the biggest time-consumer	1
the users with	1
the structure. Incrementing	1
the requirements of	3
the profiler. The	1
the __fastcall keyword	1
the increment and	1
the method. A	1
the remote data	1
the future. If	1
the future. 6	1
the future. Typically,	1
the future. To	1
the swapping of	1
the AVX512 instruction	1
the memset line	1
the rest of	5
the Digital Mars	1
the third generation	1
the CISC instruction	1
the effort to	2
the reduction in	1
the reduction would	1
the strict aliasing	2
the event of	1
the event that	2
the select function,	1
the actual clock	1
the actual load	1
the actual calculations.	1
the actual processor.	1
the console or	1
the advice in	1
the advice given	2
the pow function	1
the recommendation was	1
the physical movements	1
the pitfalls here:	1
the equivalent if(!(a	1
the command line	1
the relatively small	1
the guidelines below.	1
the excessive memory	1
the latency of	2
the latency and	1
the latency or	1
the larger vector	1
the larger address	1
the project at	1
the project window	1
the 107 number	1
the upper 32	1
the key values	1
the combined size	2
the ever bigger	1
the division. Some	1
the present manual	1
the present manual.	1
the strlen function	2
the divisor is	2
the bit-mask: c2	1
the highest instruction	1
the highest level	1
the eight-element vectors:	4
the obstacles to	1
the asmlib function	1
the asmlib library	1
the modulo operator	1
the loader to	1
the loader will	1
the loader calls	1
the SVML and	1
the "Intel Math	1
the "Intel Performance	1
the drawbacks of	3
the commercial compilers.	1
the x86-64 instruction	1
the pipeline and	1
the pipeline then	1
the pipeline structure	1
the flush-to-zero mode	2
the dispatcher. //	1
the queue of	1
the {} brackets	1
the appendix at	1
the empty throw()	1
the C-style type-casting	1
the C-style type-casting.	1
the bottleneck is	2
the directive __declspec(cpu_dispatch(...)).	1
the lrint function	1
the lrint function:	1
the user's time.	2
the user's needs.	1
the area of	1
the consequence of	1
the assumption that	2
the double. Another	1
the image base	1
the worst-case maximum	1
the individual bits	1
the diagonal. The	3
the diagonal. Each	1
the original is	1
the original pointer	1
the original object	1
the mirror elements	1
the functionality of	1
the counts. It	1
the unit-test but	1
the unit-test does	1
the implicit pointer	1
the interval from	1
the interval 0	1
the interval [1.0,	1
the 33 result	1
the considerations that	1
the selected instruction	1
the selected version	1
the techniques of	1
the techniques in	1
the resolution of	1
the advices may	1
the 49 first	1
the wrong branch	1
the wrong branch.	1
the compiler-generated code	1
the combination of	1
the distance between	1
the C/C++ standard	1
the 124 necessary	1
the basis for	1
the contents of	2
the unfortunate consequence	1
the parameter, and	1
the time- consuming	1
the divisions (Division	1
the dividend is	2
the dividend to	1
the stack, which	2
the stack, except	1
the residual error	3
the operations: //	1
the operands. The	1
the nearest element	1
the nearest integer.	1
the 145 SSE2	1
the correct result	1
the correct child	1
the contrary, the	1
the contrary, you	1
the contrary, each	1
the Internet at	1
the Internet where	1
the easiest and	1
the track backwards	1
the ReadTSC function.	1
the same. The	1
the same. This	1
the same. If	1
the technical details	1
the specified instruction	1
the specified types	1
the history of	1
the microprocessor. Integer	1
the microprocessor. Multiplication	1
the micro-op cache.	1
the linker. The	1
the linker. Both	1
the terminating zero	2
the numerically largest	2
the AVX-512 instruction	1
the market for	1
the logarithm of	1
the logarithm would	1
the logarithm again,	1
the services only	1
the product makes	1
the $B1$2 label	1
the flags register	1
the past history	1
the object's class	1
the object's class.	1
the context. The	1
the goal of	1
the screen. There	1
the screen. However,	1
the market. But	1
the market. Such	1
the dangers of	1
the external clock.	1
the CPU-specific versions	1
the mouse. The	1
the mouse. This	1
the relocations in	1
the early planning	1
the heap. The	1
the FDIV bug	1
the decimal point	1
the hint about	1
the loop, for	1
the loop: //	1
the minimum supported	1
the destination array.	1
the CPU, which	1
the answers in	1
the Standard Template	1
the const_cast operator	1
the resulting machine	1
the programmer. 79	1
the unsafe code	1
the movements of	1
the executable. Most	1
the lowest of	1
the parentheses manually.	1
the exponent, and	2
the cross-platform compatibility	1
the comments generated	1
the conflicting considerations	1
the 61 function	1
the sampling generates	1
the theoretical possibility	1
the file, especially	1
the question when	1
the denormals-are-zero mode	1
the branching takes	1
the caller to	1
the caller through	1
the G values,	1
the creation of	1
the vectorclass manual	1
the delay. But	1
the server. These	1
the array, which	1
the "override" feature.	1
the "worst case"	2
the first-in-last-out nature	1
the alignment. See	1
the template. The	1
the container, then	1
the container. STL	1
the container. Can	1
the inverted bit-mask:	1
the inverted mask.	1
the index, i.	1
the time-consumers mentioned	1
the recursion template<>	1
the planning phase	1
the R values	1
the fraction. The	1
the fraction. For	1
the ones that	1
the ones mentioned	1
the trivial programming	1
the symbolic link.	1
the ability to	2
the bottlenecks can	1
the FMA4 instruction	1
the processor). Integer	1
the processor). Optimizing	1
the corresponding instruction	1
the corresponding bitwise	1
the generic branch,	1
the reader has	1
the reader what	1
the low-level C	1
the book "Performance	1
the word static	1
the obstacle of	1
the IDE on	1
the factorials don't	1
the subroutine for	1
the time-critical part	1
the "best case"	1
the effort. 7.21	1
the effort. Square	1
the overall performance	1
the overall computation	1
the factorials, but	1
the reinstallation work	1
the 512-bit ZMM	1
the disassembly window	1
the FAQ for	1
the Xnu project.	1
the rows, not	1
the LLVM is	1
the importance of	1
the Boost collection	1
the tolerance may	1
the transformation of	1
the transitions between	1
the stack). ecx	1
the worst- case	1
the initial value	1
the workload between	1
the remaining bits	1
the formula: (set)	1
the usual object	1
the performance, it	1
the profile. It	1
the IDE, for	1
the IEEE standard	1
the arrays: //	1
the capability to	1
the programmers' time,	1
the processor) when	1
the CPU-type is	1
the even-numbered logical	1
the __assume_aligned directive	1
the lifetime of	1
the "generate map	1
the evaluation of	1
the bias of	1
the MKL relies	1
the majority of	1
the wheel. The	1
the self-explaining menus	1
the resource-hungry applications	1
the weekdays. The	1
the loader. 2.	1
the strongest optimization	1
the sizeof operator.	1
the GetTickCount or	1
the original, poorly	1
the .exe file,	1
the burdensome position-independent	1
the scarcity of	1
the other, then	1
the rightmost 1-bit	1
the insertion of	1
the hint, but	1
the spell checking.	1
the likelihood that	1
the preprocessor can	1
the Professional and	1
the responsi- bility	1
the "FDIV bug".	1
the reciprocal: //	1
the post-increment operator	1
the oldest Pentium	1
the grandparent class:	1
the integer-to-float conversion	1
the BTB can	1
the label. It	1
the framework, during	1
the end. The	1
the STL. Some	1
the user-written code	1
the following: 130	1
the difference, let's	1
the truth depends	1
the ADX instructions	1
the producer will	1
the iterator in	1
the standards for	1
the broader perspective	1
the EXCLUSIVE OR	1
the representation, except	1
the computational power	1
the next. The	1
the if-branch in	1
the "Macro loops"	1
the possibilities for	1
the <, <=,	1
the non-reduced expression	1
the startup code	1
the exponent: //	1
the conversion. The	1
the sign, eee	1
the GOT, and	1
the fundamental laws	1
the design of	1
the texts they	1
the dimensions of	1
the best-case conditions.	1
the destructor, if	1
the wires that	1
the _mm_clflush intrinsic	1
the SelectAddMul example	1
the beginning. ret	1
the former case	1
the pipeline. If	1
the sign-bit if	1
the devirtualization (see	1
the attention of	1
the level- 1	1
the opposite: Don't	1
the for-loop: i++;	1
the complication that	1
the std::unexpected() function	1
the strictness is	1
the application, while	1
the essential task	1
the series: ex	1
the pros and	1
the leftmost column	1
the DelayFiveSeconds function	1
the occurrence is	1
the exact time	1
the circumstances around	1
the Pentium-II or	1
the device. Any	1
the single-thread speed.	1
the newsgroup comp.lang.asm.x86	1
the C99 standard.	1
the columns. Every	1
the Active Template	1
the resultant code	1
the sequence, where	1
the kind: "what	1
the unit- test	1
the granularity is	1
the BIOS setup.	1
the task-specific part	1
is the function	1
is the code	2
is the time	1
is the vector	1
is the same	7
is the only	2
is the loop	2
is the one	1
is the most	4
is the number	2
is the variable	1
is the first	1
is the case	2
is the Windows	1
is the best	1
is the calculation	1
is the name	1
is the reason	4
is the binary	1
is the old	1
is the feature	1
is the range	1
is the simplest	1
is the situation	1
is the D	1
is the responsibility	7
is the reciprocal	2
is the job	1
is the biggest	1
is the combination	1
is the nearest	1
is the same.	1
is the minimum	1
is the Standard	1
is the exponent,	1
is the "best	1
is the scarcity	1
is the responsi-	1
is the sign,	1
is a function	5
is a loop	1
is a cache	1
is a class	2
is a double	1
is a pointer	2
is a library	1
is a float	1
is a multiple	5
is a clock	2
is a performance	1
is a very	4
is a branch	1
is a way	2
is a register	1
is a template	1
is a new	1
is a useful	2
is a part	1
is a simple	3
is a constant	1
is a large	2
is a big	1
is a specific	1
is a single	1
is a common	5
is a small	1
is a good	4
is a power	16
is a problem	3
is a few	1
is a list	2
is a structure	1
is a standard	1
is a copy	1
is a counter	2
is a lot	2
is a complicated	1
is a dependency	1
is a model	1
is a disadvantage	1
is a high	2
is a reference	1
is a higher	1
is a switch	1
is a positive	2
is a hot	1
is a level-1	1
is a limited	1
is a sum	1
is a total	1
is a risk	2
is a significant	1
is a linear	2
is a penalty	1
is a matter	2
is a series	1
is a waste	2
is a pure	1
is a frequent	2
is a kind	1
is a try	1
is a branch.	1
is a fixed	1
is a convenient	1
is a portability	1
is a considerable	1
is a compromise	1
is a valid	1
is a loop-invariant	2
is a scarce	1
is a float,	1
is a pointer,	1
is a chip	1
is a minor	1
is a 90%	1
is a proxy	1
is a cheap	1
is a precious	1
is a compelling	1
is a staircase	1
is a bottleneck.	1
is of course	4
is to have	1
is to use	7
is to make	8
is to set	1
is to do	2
is to return	1
is to always	1
is to access	1
is to avoid	1
is to compile	2
is to run	1
is to store	1
is to replace	1
is to put	1
is to choose	1
is to turn	1
is to find	1
is to rely	1
is to save	1
is to divide	3
is to mix	1
is to insert	1
is to enable	1
is to keep	1
is to allocate	1
is to help	1
is to hold	1
is to remove	1
is to declare	1
is to detect	1
is to roll	1
is to wrap	1
is to join	1
is to resume	1
is to combine	1
is and interpreted	1
is in mathematical	1
is in fact	1
is in edx,	1
is for the	1
is for C++	1
is for advanced	1
is that the	26
is that a	1
is that it	11
is that if	2
is that x	1
is that you	1
is that all	1
is that we	1
is that access	1
is that branches	1
is that modern	1
is that communication	1
is that CParent::Hello()	1
is that r+i/2	1
is // erroneously	1
is it unusual	1
is by a	1
is on a	1
is on mathematical	1
is as efficient	3
is as fast	1
is as follows:	1
is not the	3
is not a	7
is not in	3
is not an	4
is not i	1
is not possible	5
is not less	1
is not even	1
is not always	6
is not out	1
is not part	1
is not accessed	2
is not necessary	5
is not good	1
is not advantageous	4
is not known	5
is not certain	1
is not shared	1
is not quite	1
is not recommended	3
is not optimal	4
is not efficient.	1
is not needed	5
is not divisible	2
is not predicted	1
is not intended	1
is not clear	1
is not needed.	2
is not copied	1
is not significant	1
is not standardized	1
is not included	1
is not resolved	1
is not allowed	2
is not evaluated	1
is not permissible	1
is not portable	1
is not necessarily	2
is not seen	1
is not necessary.	1
is not doubled.	1
is not optimal.	1
is not guaranteed	1
is not expensive.	1
is not cached.	1
is not optimized.	1
is not separated	1
is not unusual	2
is not modified.	1
is not vacant	1
is not supported.	1
is not visible	1
is not allowed.	1
is not uncommon	2
is not recognized	1
is not human	1
is not referenced	1
is not evaluated,	1
is not detected	1
is not standardized.	1
is not traditionally	1
is not satisfactory.	1
is not met	1
is an integer	2
is an Intel	1
is an object	1
is an array	1
is an even	1
is an important	2
is an extra	3
is an advantage	1
is an expression	2
is an advanced	1
is an integer,	2
is an arithmetic	1
is an n'th	1
is an integer).	1
is time consuming	1
is more than	1
is more efficient	18
is more important	1
is more common	1
is more advantageous	2
is more likely	1
is more complicated	2
is more efficient.	2
is more difficult	1
is more relevant	1
is more safe	1
is more expensive	1
is more predictable	1
is more compact	2
is more complex	2
is more focus	1
is more difficult.	1
is more complicated.	1
is more manageable	1
is then stored	1
is then de-referenced	1
is memory pooling.	1
is data decomposition.	1
is different for	1
is because the	3
is because it	1
is because we	1
is because modern	1
is because algebraic	1
is because computers	1
is only a	3
is only an	1
is only used	1
is only one	1
is only possible	2
is only called	1
is only calculated	2
is only safe	1
is only half	1
is only 10%	1
is other code	1
is other work	1
is all done	1
is all 1's	1
is used is	1
is used and	2
is used in	7
is used for	12
is used or	1
is used by	2
is used as	2
is used more	1
is used when	1
is used only	2
is used inside	1
is used during	1
is one of	3
is one that	1
is one set	1
is no more	1
is no loop	1
is no such	1
is no performance	2
is no way	3
is no operating	1
is no need	7
is no extra	1
is no big	1
is no exception	1
is no check	2
is no problem	1
is no advantage	1
is no cost	2
is no automatic	1
is no reason	5
is no difference	5
is no longer	1
is no graphics	1
is no checking	1
is no clear	1
is no risk	3
is no penalty	1
is no easy	2
is no try	1
is no heavy	1
is no loop-carried	1
is no 51	1
is no doubt	1
is no guarantee	1
is set in	1
is set by	1
is floating point.	1
is most efficient	1
is most often	1
is most useful	1
is most appropriate	1
is using a	1
is using one	1
is double There	1
is float 140	1
is two or	1
is number one	1
is also a	4
is also used	3
is also possible	2
is also called	2
is also useful	2
is also available	2
is also likely	1
is also quite	1
is also recommended	1
is also relevant	1
is also discussed	1
is also treated	1
is also deallocated.	1
is also de-allocated.	1
is efficient for	1
is efficient when	1
is many times	1
is possible to	29
is possible in	2
is clock cycles	1
is so long	1
is so important	1
is so large	1
is so big	1
is so much	1
is so small	1
is so complicated	1
is so high	2
is so kludgy	1
is 2 GHz	1
is very time	1
is very useful	1
is very important	3
is very large	1
is very small	1
is very likely	2
is very fast	1
is very inefficient	1
is very little	1
is very inefficient.	1
is very fast.	1
is very limited.	1
is very problematic	1
is very old-fashioned.	1
is long because	1
is long does	1
is branch prediction.	1
is member of	1
is faster the	1
is faster to	5
is faster //	2
is faster if	5
is faster with	1
is faster than	16
is faster when	1
is faster because	1
is stored in	6
is stored on	1
is stored as	4
is stored at	1
is stored (or	1
is called the	1
is called a	3
is called and	3
is called in	1
is called for	1
is called by	1
is called with	1
is called on	1
is called when	1
is called from	3
is called only	1
is called CPU	1
is called before	1
is called register	1
is called stack	1
is called through	1
is called name	1
is called core	1
is called square	1
is called garbage	1
is called once	1
is called CodeAnalyst.	1
is called VTune;	1
is 4 bytes	1
is critical when	1
is 8 kb	1
is less than	5
is less efficient	7
is less useful	1
is less important	1
is less advantageous	1
is less efficient.	1
is less reliable.	1
is unsigned Examples:	1
is often the	1
is often a	2
is often an	1
is often more	2
is often possible	2
is often faster	2
is often useful	1
is often necessary	2
is often implemented	1
is often easier	2
is often determined	1
is often preferable	1
is often reorganized	1
is often seen,	1
is how the	1
is template metaprogramming	1
is useful to	1
is useful in	1
is useful for	6
is useful if	1
is useful on	1
is useful when	1
is useful because	1
is useful whenever	1
is even more	1
is sure to	2
is always 0	1
is always position-independent	1
is always inlined	1
is always resolved	1
is always enabled	1
is always one,	1
is always true/false	1
is always normalized,	1
is 16 bits	1
is out of	3
is 32 bits	1
is 32 bits,	1
is file access	1
is part of	2
is 0 and	1
is 0 for	1
is short in	1
is available in	3
is available for	3
is available then	2
is available from	2
is constant and	1
is important to	16
is important for	1
is important that	3
is accessed in	1
is accessed by	1
is accessed with	1
is accessed from	1
is accessed most	1
is accessed much	1
is accessed through	1
is accessed quite	1
is accessed after	1
is large or	1
is large then	1
is large because	1
is compiled to	1
is compiled and	1
is compiled in	1
is compiled for	3
is compiled with	1
is compiled as	1
is compiled when	1
is compiled into	1
is compiled without	1
is big and	1
is big enough	3
is best for	1
is best when	1
is best suited	1
is necessary to	10
is necessary for	1
is necessary if	1
is necessary here	1
is specific to	1
is much more	2
is much faster.	2
is much slower	1
is much simpler	1
is much faster,	1
is common to	2
is common for	1
is common practice	1
is exception safe	1
is allocated is	1
is allocated and	1
is allocated dynamically	1
is allocated separately.	1
is small and	2
is small or	2
is small then	1
is small enough	1
is good to	1
is good for	2
is good if	1
is done in	1
is done by	3
is done with	2
is done at	2
is done only	1
is done every	1
is done simply	1
is therefore a	1
is therefore not	1
is therefore more	1
is therefore possible	1
is therefore important	1
is therefore necessary	3
is therefore certain	1
is therefore recommended	2
is therefore equal	1
is therefore becoming	1
is therefore safer	1
is optimized is	1
is optimized for	1
is optimized away.	1
is inside a	1
is inside another	1
is explained on	1
is explained below	1
is calculated the	1
is calculated in	1
is calculated as	1
is calculated from	4
is calculated at	1
is calculated fast	1
is calculated twice	1
is calculated first,	1
is calculated internally	1
is 128 bits	1
is 128 bytes	1
is four places	1
is another security	1
is advantageous to	7
is advantageous in	2
is advantageous if	2
is advantageous because	1
is advantageous if,	1
is implemented in	3
is implemented with	1
is implemented as	2
is implemented simply	1
is implemented internally	1
is known to	4
is known with	1
is known from	1
is known at	6
is known which	1
is known before	1
is supported in	3
is supported by	7
is supported on	1
is eight in	1
is likely to	19
is likely in	1
is likely that	2
is doing an	1
is doing multiple	1
is doing two	1
is 1 0.5ns.	1
is simply the	1
is simply a	5
is simply not	1
is simply an	1
is simply no	1
is simply optimized	1
is simply predicted	1
is simply identical.	1
is able to	3
is certain to	2
is certain that	1
is shared between	1
is quite efficient	1
is quite simple	1
is quite certain	1
is quite difficult	1
is quite inefficient.	1
is quite expensive	1
is quite inefficient,	1
is quite tedious	1
is used. The	3
is used. A	1
is used. It	2
is used. For	1
is used. An	1
is used. However,	1
is used. Dynamic	1
is recommended to	21
is fast and	1
is fast anyway	1
is fast enough.	1
is optimal to	2
is optimal in	1
is optimal for	1
is optimal on	1
is optimal only	1
is typically between	1
is typically 64	2
is typically implemented	1
is typically aligned	1
is typically loaded	1
is preferably implemented	1
is automatically deallocated	1
is implementation dependent.	1
is never stored	1
is never used.	2
is never called.	2
is never changed.	1
is high and	1
is high then	1
is zero if	1
is zero by	1
is zero }	1
is Microsoft Visual	1
is Microsoft Foundation	1
is running in	1
is running on	1
is running on,	1
is running on.	1
is running at,	1
is n places	1
is better than	2
is too important	1
is too big	1
is too big.	1
is too fine	1
is too high.	1
is too late.	1
is needed a	1
is needed in	1
is needed for	2
is needed only	1
is difficult to	4
is difficult for	3
is transferred to	1
is transferred as	1
is transferred from	1
is transferred at	1
is longer than	1
is aligned #pragma	1
is actually more	1
is actually quite	1
is actually used.	1
is actually needed	1
is actually hidden	1
is later ported	1
is calling itself	1
is declared or	1
is declared by	1
is higher for	1
is bigger than	3
is divisible by	6
is 512 kb	1
is 512 kb,	1
is usually the	1
is usually not	1
is usually faster	1
is usually called	2
is usually much	1
is usually done	1
is usually higher	1
is usually predicted	1
is usually inlined	1
is usually divided	1
is called. The	2
is called. This	2
is called. If	1
is called. You	1
is called. I	1
is called. Example:	1
is called. Lazy	1
is called. 118	1
is based on	2
is based mainly	1
is made to	2
is made very	1
is just a	1
is just an	1
is just long	1
is just easier	1
is smaller and	1
is smaller in	1
is smaller because	1
is relevant for	1
is relevant when	2
is replaced by	3
is negative or	1
is predicted if	1
is predicted well.	1
is predicted well,	1
is loaded or	1
is loaded into	1
is loaded cannot	1
is loaded rather	1
is compatible with	4
is 1. This	1
is intended to	2
is intended for	5
is intended as	1
is intended for.	2
is avoided for	1
is slow //	2
is slow unless	1
is inefficient to	2
is inefficient because	3
is described in	1
is described below.	1
is particularly critical.	1
is particularly interesting	1
is particularly risky	1
is particularly tricky.	1
is given in	1
is given as	1
is outside the	1
is outside this	1
is limited is	1
is limited to	1
is limited and	1
is limited by	2
is sometimes more	1
is sometimes possible	1
is inlined -	1
is still the	2
is still frustrated	1
is safe to	1
is safe and	1
is further explained	1
is clear that	2
is obtained if	1
is obtained by	3
is obtained with	2
is obtained when	1
is possibly more	1
is overloaded or	1
is possible. A	1
is OS independent	1
is needed. The	1
is needed. Example:	1
is needed. These	1
is needed. All	1
is needed. Objects	1
is changed to	1
is changed so	1
is true that	1
is true 50%	1
is true 10%	1
is initialized or	1
is initialized when	2
is initialized only	1
is discussed on	1
is discussed which	1
is discussed how	2
is discussed below.	1
is copied to	2
is copied by	1
is copied from	1
is defined in	2
is defined inside	1
is Visual Basic	1
is rarely possible	1
is rarely necessary	1
is rarely needed	1
is rarely needed.	1
is rarely enough	1
is rarely worth	1
is easier to	3
is identical to	2
is similar to	2
is significant if	1
is something that	1
is invalid when	1
is within a	1
is used, for	1
is used, it	1
is used, then	2
is used, but	1
is organized in	1
is organized if	1
is added to	5
is approximately three	1
is approximately 12	1
is approximately six	1
is easy to	3
is chosen for	1
is chosen as	1
is chosen only	1
is slightly more	2
is slightly less	1
is independent of	2
is low in	1
is enabled. The	2
is enabled. A	1
is enabled. There	1
is enabled. Conversion	1
is enabled. Conversions	1
is enabled. Typically,	1
is enabled. Volatile	1
is enabled. Few	1
is near the	1
is provided in	1
is provided as	2
is inefficient. Division,	1
is critical. The	2
is critical. Optimizing	1
is available. The	3
is brand new	1
is executed. The	1
is executed. This	1
is executed. An	1
is executed. Furthermore,	1
is executed. Optimizes	1
is executed. Without	1
is faster. In	1
is pure if	1
is pure __attribute((	1
is fully standardized	1
is fully portable	1
is mispredicted only	4
is standardized allows	1
is included in	2
is included for	1
is 12 bytes.	1
is now as	1
is lower than	1
is converted to	2
is converted by	1
is equally fast	1
is equally efficient.	1
is designed for	2
is fragmented and	1
is fast. Value	1
is fast. Calculating	1
is fastest on	1
is fastest because	1
is required for	2
is almost always	1
is almost certain	2
is almost independent	1
is preferred to	2
is preferred when	1
is interpreted in	1
is interpreted as	1
is interpreted again	1
is exactly as	1
is exactly identical	1
is determined by	2
is determined where	1
is resolved when	1
is resolved at	2
is poorly predictable	1
is poorly predictable.	1
is poorly predictable,	1
is important. This	2
is important. A	1
is important. Some	1
is important. An	1
is allowed only	1
is distributed and	1
is distributed as	1
is distributed between	1
is generally possible	1
is generally faster	1
is called, a	1
is called, it	3
is called, while	1
is free and	1
is far from	1
is hardly any	1
is hardly worth	1
is hardly ever	1
is waiting for	2
is available, 256	1
is measured in	1
is measured with	1
is measured simply	1
is Intel's term	1
is equal to	3
is compact and	1
is spent in	1
is spent on	1
is 15 on	1
is expected to	1
is convenient to	1
is costly if	1
is costly when	1
is efficient, but	1
is poor if	1
is evaluated only	1
is deallocated when	1
is permissible when	1
is 4. So	1
is obvious and	1
is swapped with	2
is portable in	1
is becoming increasingly	1
is executed only	1
is executed even	1
is executed 10	1
is finished. The	1
is finished. Example:	1
is finished. Obviously,	1
is finished. Register	1
is split between	1
is created or	2
is already in	1
is already known	2
is nothing to	2
is increased when	1
is nonzero }	1
is equivalent to	1
is relatively expensive,	1
is inefficient, of	1
is inefficient, especially	1
is inefficient, however,	1
is necessarily accessed	1
is safer to	2
is larger than	1
is unfortunately very	1
is divided into	1
is valid only	1
is seen in	1
is contiguous with	2
is necessary. 101	1
is increasing faster	1
is AND'ed with	4
is definitely the	1
is doubled. The	2
is doubled. This	1
is true, and	1
is true, then	1
is true, which	2
is __asm int	1
is currently not	1
is currently only	1
is better. Whenever	1
is preferable to	1
is preferable for	1
is enabled there	1
is enabled (single	1
is sufficiently accurate	1
is bad The	1
is said here	2
is declared. If	1
is declared. An	1
is declared. Therefore,	1
is declared. Avoid	1
is true. The	1
is running. The	1
is running. If	1
is serial in	1
is serial because	1
is guaranteed to	2
is commonly the	1
is extended to	1
is contained in	1
is going to	1
is cached. Usually	1
is unsigned. The	1
is treated as	2
is prevented from	2
is seldom used.	1
is double. Here	1
is 50% of	1
is illustrated in	2
is optimized. We	1
is coded as	2
is represented with	1
is kept in	1
is selected if	1
is multiplied by	1
is inferior to	1
is unable to	2
is finished using	1
is run. The	1
is run. Examples	1
is run. Both	1
is simpler than	1
is simpler when	1
is deleted when	1
is deleted properly	1
is slow, you	1
is slow, then	1
is slow, difficult	1
is performed on	2
is removed from	1
is unfortunate because	1
is loaded. This	1
is implemented. The	2
is annoying to	1
is elsewhere then	1
is filled up,	1
is supplied with	1
is translated to	1
is translated into	1
is correct or	1
is stored. This	1
is inlined. An	1
is probably the	1
is beyond the	3
is infinity or	1
is false, then	1
is negligible when	1
is negligible because	1
is best. These	1
is best. 3.11	1
is odd and	1
is handled at	1
is handled separately:	1
is implicitly converting	1
is valid. For	2
is valid. Re-interpreting	1
is slow. If	1
is slow. Value	1
is limited. Example:	1
is limited. Dynamic	1
is ported to	1
is big. The	1
is extremely complicated	1
is extremely costly	1
is extremely inefficient,	1
is certainly a	1
is certainly more	1
is certainly something	1
is indeed a	1
is indeed vectorized	1
is sufficient to	2
is evicted before	1
is impossible to	1
is mostly compatible	1
is type-casted to	1
is 1024 bytes,	1
is 400 here.	1
is freed when	1
is biased allows	1
is reused again	1
is compiled. This	1
is compiled. #if	1
is volatile. The	1
is supported. For	1
is pure. Virtual	1
is bypassed by	1
is -0 (zero	1
is achieved when	1
is inserted in	1
is specified. The	1
is overwritten, possibly	1
is false. Likewise,	1
is small. The	1
is unsafe because	1
is concentrated on	2
is capable of	1
is worthwhile to	1
is eliminated. Loop	1
is profitable to	1
is unstable or	1
is required. The	1
is required. See	1
is 8192 /	1
is lost. This	1
is obviously influenced	1
is allowed. The	1
is (columns *	1
is defined. This	1
is known. This	1
is known. Example:	1
is restarted anyway.	1
is dividing repeatedly	1
is fed into	1
is relocated (rebased)	1
is consistent for	1
is created. There	1
is started. It	1
is deleted. Smart	1
is needed: //	2
is loaded, the	1
is loaded, but	1
is 0. The	1
is rolled out	1
is busy doing	1
is busy concentrating	1
is updated. Most	1
is wasted on	2
is stronger when	1
is fast, compact,	1
is somewhat more	1
is invalid. Boolean	1
is heavily loaded.	1
is available: //	2
is closed. The	2
is avoided. The	1
is 95 not	1
is repeated until	1
is accessed, and	1
is accessed, it	1
is inherently parallel	1
is safer. Type	1
is 102 also	1
is terminated. The	1
is moved, which	1
is saturated. This	1
is incremented. See	1
is insufficient. The	1
is unacceptable to	1
is unchanged across	1
is compiling. This	1
is enabled: //	1
is over. Virtualization	1
is dead code	1
is InstructionSet().The following	1
is correlated with	1
is ecx+eax*4. The	1
is system-independent, in	1
is occupied throughout	1
is referencing it	1
is unreasonably large.	1
is maintained for	1
is aiming at	1
is pushed on	1
is requested. See	1
is delayed for	1
is assumed that	1
is (int)(&list[100]) =	1
is mirrored in	1
is closest to	1
is utilized appropriately.	1
is developing so	1
is supposed to	1
is copyrighted by	1
is acceptable. 3.6	1
is unnecessarily wasteful	1
is caught by	1
is checked before	1
is happening. It	1
is OK, however,	1
is opposite). 9.10	1
is reset or	1
is unchanged, while	1
is reserved for	1
is ambiguous and	1
is counting clock	1
is provoked here	1
is repetitive. The	1
is artificially changed	1
is advisable to	1
is inexact if	1
is exact. Multiple	1
is created, deleted,	1
is organized. Floating	1
is reflected, first	1
is terminated and	1
is returned. There	1
is pipelined, as	1
is taken. A	1
is taken, i.e.	1
is clearly better.	1
is destroyed. In	1
is shut down	1
is re-allocated every	1
is signed, or	1
is 83 called	1
is virtually no	1
is expanded like	1
is fastest. The	1
is distributed. The	1
is unrealistic that	1
is deprecated. This	1
is strongly recommended	1
is obvious. See	1
is obvious, then	1
is servicing. A	1
is inferior. A	1
is cached, but	1
is rare. Testing	1
is "undefined". This	1
is admittedly very	1
is 8*1024/64 =	1
is stored? If	1
is Borland's now	1
is Perl. Several	1
is wrong, but	1
is rebooted. To	1
is unlikely that	1
is profitable. On	1
is considerable. If	1
is costless. It	1
is responsible for	1
is tempting to	1
is minimized. For	1
is minimized if	1
is re-loaded from	1
is incurred on	1
a is true	1
a is true,	1
a is true.	1
a is false.	1
a a &	1
a a &&	1
a a |	1
a a ^	1
a to the	1
a to be	1
a to this	1
a to double	1
a to b	2
a to unsigned	1
a to zero	2
a and b	15
a and r	1
a and b,	1
a and edx	1
a and b.	1
a in a	1
a = a	10
a = x	1
a = b	18
a = a,	1
a = b;	2
a = c;	1
a = 0,	2
a = (unsigned	4
a = parabola	1
a = 0x2710	1
a = (b	1
a = select(b	2
a = 1.0f	1
a = sin(0.8);	1
a = -100,	1
a = lookup[b];	1
a = _mm_or_si128(c2,	1
a = OneOrTwo5[b!=0];	1
a = (int)d;	1
a = (b*c)/d,	1
a = Func1(2);	1
a = -1.0E8,	1
a = 5.0f;	1
a = OneOrTwo5[b	1
a = _mm_blendv_epi8(bc,	1
a = CriticalFunction(b,	1
a = 10000,	1
a = b++;	1
a = ++b;	1
a = (*CriticalFunction)(b,	1
a = Multiply(10,8);	1
a = select_gt(b,	1
a = FactorialTable[b];	1
a function is	9
a function of	1
a function to	1
a function in	8
a function for	3
a function that	8
a function are	2
a function can	1
a function or	1
a function if	2
a function with	1
a function which	2
a function but	1
a function should	3
a function pointer	5
a function into	1
a function library	2
a function return	1
a function call	3
a function template	1
a function through	1
a function uses	1
a function parameter	2
a function just	1
a function library.	1
a function call.	1
a function library,	1
a function opens	1
a function parameter,	1
a function prototype	1
a function local:	1
a code that	2
a code then	1
a code one	1
a code version	1
a - n.a.	6
a - 1;	2
a - a-a	1
a - a*0	1
a - 0/a	1
a - a/1	1
a compiler to	2
a compiler that	2
a compiler can	1
a compiler with	1
a compiler may	1
a compiler option	1
a compiler generates	1
a compiler warning	1
a x -	1
a time and	3
a time in	1
a time because	1
a time consumer	1
a time packed	1
a time measure.	1
a use situation	1
a more efficient	1
a more clear	2
a more well-structured	1
a more distant	1
a will be	1
a will never	1
a memory address	3
a memory block	2
a memory pointer.	1
a memory buffer	1
a memory address.	1
a memory pool.	1
a memory heap.	1
a memory pool,	1
a data member	4
a program is	3
a program and	1
a program for	1
a program that	1
a program than	1
a program may	1
a program you	1
a program then	1
a program has	6
a program where	1
a program uses	1
a program contains	3
a program reads	1
a program package	1
a program repeats	1
a program chooses	1
a program saying	1
a program executable:	1
a program creates	1
a program dictates	1
a vector of	9
a vector or	1
a vector register	1
a vector implementation	1
a vector goes	1
a vector just	1
a vector register.	1
a vector simultaneously.	1
a vector register,	1
a make utility.	2
a different function	1
a different code	1
a different compiler	1
a different way	1
a different operating	1
a different type	1
a different implementation	1
a different name	1
a different platform	1
a different compiler.	1
a different thread.	1
a different way.	1
a different address.	1
a different module	1
a different kind	1
a different array.	1
a different type.	1
a different meaning.	1
a different meaning	1
a only when	1
a CPU of	1
a CPU with	3
a CPU dispatcher	3
a loop is	1
a loop of	1
a loop and	1
a loop in	1
a loop for	1
a loop that	2
a loop or	1
a loop if	2
a loop with	2
a loop where	2
a loop contains	1
a loop counter	3
a loop count	1
a loop automatically	1
a loop needs	1
a loop becomes	1
a loop depends	1
a loop repeats	1
a loop manually	1
a loop counter,	1
a loop count.	1
a loop counter:	1
a one parameter.	1
a cache is	1
a cache of	1
a cache that	1
a cache line	2
a cache line.	3
a cache line:	1
a cache miss.	1
a set of	2
a class is	1
a class are	2
a class or	4
a class with	2
a class data	1
a class member	2
a class template	1
a class need	1
a class Variables	1
a class containing	1
a class definition.	1
a class (also	1
a floating point	13
a double by	1
a double which	1
a double takes	1
a double without	1
a double precision	1
a double uses	1
a pointer of	1
a pointer to	15
a pointer in	2
a pointer can	1
a pointer or	11
a pointer then	1
a pointer stored	1
a pointer does	1
a pointer well	1
a pointer points	1
a + b	5
a + 2	1
a + 1;	6
a + 1.0f;	1
a + b;}	1
a library of	1
a library function	2
a library other	1
a float or	2
a float uses	1
a float variable.	1
a multiple of	9
a number of	4
a number to	1
a static object	1
a static part	1
a static link	1
a static library.	1
a static buffer	1
a static library,	1
a 64-bit integer	1
a 64-bit double	2
a 64-bit version	1
a 64-bit shared	1
a 64-bit double,	1
a C++ program	1
a C++ program.	1
a C++ program,	1
a * 2;	4
a * 3;	4
a * (2n	1
a * a;}	1
a * 2.5;	1
a possible point	1
a possible minor	1
a clock cycle	4
a clock cycle?	2
a version control	1
a value is	1
a value that	2
a value from	1
a variable is	3
a variable in	3
a variable for	1
a variable that	1
a variable can	1
a variable or	2
a variable from	1
a variable because	1
a variable which	1
a variable number	1
a variable even	1
a variable through	1
a variable global	1
a variable until	1
a variable declaration	1
a 2 GHz	1
a table of	5
a table in	1
a table //	2
a table with	1
a table lookup	1
a table lookup.	1
a table lookup:	2
a performance test	1
a performance penalty	1
a very efficient	2
a very long	1
a very user	1
a very useful	1
a very large	4
a very big	1
a very good	1
a very high	1
a very inefficient	2
a very low	1
a very dramatic	1
a very contrived	1
a very obscure	1
a software optimization	1
a software programming	1
a software implementation	2
a software framework	1
a software module	1
a software package	3
a long time	4
a long vector	2
a long time.	1
a long list	1
a long dependency	2
a long time,	1
a long sequence	1
a long delay.	1
a 32-bit integer	1
a 32-bit number	1
a 32-bit number.	1
a 32-bit (signed)	1
a branch that	3
a branch by	1
a branch will	2
a branch into	1
a branch inside	1
a branch (e.g.	1
a branch misprediction	1
a branch tree.	1
a < b	1
a member of	5
a member function	6
a member function.	2
a way of	1
a way to	2
a way that	4
a faster vectorized	1
a const function	1
a const reference	2
a const reference.	1
a critical function	1
a critical part	1
a critical dependency	2
a critical piece	1
a call to	2
a register to	1
a register and	1
a register if	1
a register variable	2
a register rather	1
a register (see	1
a register variable.	2
a register stack.	1
a register except	1
a 64 64	1
a rather unconventional	1
a time. This	1
a time. A	1
a time. You	1
a time. Do	1
a template has	1
a template class	2
a template parameter	1
a template parameter.	4
a template parameter:	2
a test program	1
a test run	1
a test feature	1
a test tool	1
a new and	1
a new compiler	1
a new memory	2
a new vector	1
a new instruction	1
a new cache	1
a new floating	1
a new object	2
a new version	1
a new value	1
a new software	1
a new branch	2
a new register	2
a new processor	1
a new element	1
a new addition	1
a new bigger	2
a new instance	2
a new one.	2
a new physical	1
a user is	1
a user has	1
a useful way	1
a useful source	1
a system with	1
a system call	1
a file is	1
a file in	1
a file that	1
a file can	1
a file by	1
a file on	1
a programming language	1
a dynamic library	3
a dynamic link	1
a part of	2
a short time	1
a short vector	1
a & a	1
a & b	1
a & 0	1
a & b;	2
a & -1	2
a & ~a	2
a & 0=	1
a & a=	1
a simple function	1
a simple integer	1
a simple class	1
a simple pointer	1
a simple array	2
a simple test	1
a simple type	1
a simple algorithm	1
a simple variable.	2
a simple regular	1
a simple index.	1
a simple periodic	2
a simple type,	1
a simple solution,	1
a constant is	6
a constant to	2
a constant that	1
a constant can	1
a constant with	1
a constant should	1
a constant (see	1
a constant known	1
a constant reference	1
a constant plus	1
a constant divisor	1
a stack frame	1
a stack frame,	1
a function. Using	1
a function. Avoid	1
a large memory	1
a large part	1
a large cost	1
a large runtime	1
a large positive	1
a large overhead	1
a large delay	1
a large fraction	1
a large object,	1
a must be	1
a ; parameter	1
a ; r	1
a ; top	1
a Windows compiler	1
a Windows program	1
a result of	2
a result then	1
a processor will	1
a processor has	1
a big program	1
a big loop	1
a big floating	1
a big matrix	1
a big program.	1
a big waste	1
a big mainframe	1
a language that	1
a specific CPU	4
a specific instruction	1
a specific size	1
a specific pointer	1
a specific advantage	1
a specific graphics	1
a specific load	1
a specific size.	1
a specific purpose.	1
a specific purpose,	1
a specific purpose:	1
a specific interval.	1
a much more	1
a single function	3
a single object	2
a single branch	1
a single call	2
a single bit	1
a single register	1
a single &	1
a single constant	1
a single function.	1
a single operation	1
a single task	1
a single executable	1
a single element.	1
a single step	1
a single result.	1
a single operation.	1
a single instruction.	1
a single container,	1
a single comparison:	1
a single result,	1
a single session.	1
a virtual function	2
a virtual table	2
a virtual member	2
a common way	1
a common programming	2
a common error	1
a common cause	1
a common source	1
a common denominator	1
a common denominator:	1
a thread is	1
a thread to	1
a thread that	1
a thread jumps	1
a thread environment	1
a thread affinity	1
a small and	1
a small bit	1
a small test	1
a small part	1
a small block	1
a small piece	2
a small fraction	1
a += b;	1
a += 2;	1
a good compiler	1
a good performance	1
a good way	1
a good implementation	1
a good choice	3
a good idea	3
a good deal	2
a good investment.	1
a good knowledge	1
a power of	28
a matrix is	4
a matrix a	1
a matrix and	1
a matrix in	1
a matrix for	1
a matrix when	1
a matrix using	1
a matrix line	1
a matrix line.	1
a Linux compiler,	1
a precision of	1
a line size	2
a manual on	1
a / b	1
a 128 bit	3
a check before	1
a problem with	1
a problem when	1
a problem then	1
a problem since	1
a known CPU	1
a solution where	1
a container for	2
a container that	2
a container or	1
a container than	1
a container class	2
a container class.	1
a few more	1
a few functions	1
a few clock	6
a few cases	1
a few instructions	1
a few times	1
a few extra	1
a few arrays	1
a few cases,	1
a few unused	1
a few lines	1
a few machine	1
a few pitfalls	1
a few lines.	1
a few kilobytes	1
a few comments	1
a few places.	1
a list is	1
a list of	3
a list should	1
a list float	1
a structure or	5
a structure where	1
a standard for	1
a standard function	1
a hardware implementation	1
a hardware definition	5
a : b;	1
a : b)	1
a store operation	1
a store forwarding	2
a copy constructor	1
a copy protection	1
a well optimized	1
a certain modification	1
a certain tolerance.	1
a certain interval:	1
a counter that	1
a counter inside	1
a shared object	5
a shared object.	1
a shared object,	1
a program. The	2
a program. This	1
a program. Avoid	1
a program. Whole	1
a was zero	1
a space in	1
a lot of	22
a lot to	3
a lot in	1
a particular code	2
a particular compiler	1
a particular memory	2
a particular CPU	2
a particular instruction	2
a particular integer	1
a particular set	1
a particular programming	1
a particular part	1
a particular processor	1
a particular application	1
a particular piece	1
a particular brand	1
a particular application.	1
a particular reduction	1
a particular purpose.	1
a particular weakness	1
a particular meaning,	1
a particular subtask	1
a particular situation,	1
a microprocessor in	1
a microprocessor that	1
a microprocessor because	1
a multiplication and	1
a multiplication but	1
a complicated code	1
a complicated implementation	1
a complicated process	1
a dependency chain	1
a dependency chain.	1
a Boolean vector.	1
a Boolean NOT	1
a signed integer	2
a signed variable	1
a model that	1
a separate function	2
a separate version	1
a separate file	1
a separate dynamic	2
a separate function.	1
a separate thread	5
a separate C	1
a separate module	1
a separate subroutine	1
a separate module,	1
a block of	1
a needs to	1
a disadvantage for	1
a disadvantage if	2
a disadvantage when	1
a high power	2
a high overhead	1
a high repeat	1
a high level	1
a high priority.	1
a high degree	1
a high price,	1
a parameter is	1
a parameter of	1
a parameter to	1
a reference to	1
a reference or	2
a string is	2
a string of	1
a string and	1
a programmer may	1
a better version	1
a better result	1
a better solution	1
a better solution.	1
a better understanding	1
a lookup in	1
a lookup table	3
a lookup table:	2
a && a	1
a && b	2
a && b;	1
a && true	1
a && false	1
a && !a	1
a | a	1
a | b	1
a | 0	2
a | b;	1
a | -1	2
a difference in	1
a mechanism called	1
a runtime check	1
a runtime DLL	1
a means of	1
a || b	1
a || b;	1
a || true	1
a || false	1
a || !a	1
a > b	1
a longer size	1
a graphics function	2
a graphics library	1
a graphics processing	1
a graphics card	1
a graphics accelerator	1
a graphics coprocessor	1
a public data	1
a public variable	2
a framework in	1
a framework sometimes	1
a linked function	1
a linked list	4
a linked list.	3
a platform with	1
a dispatch is	1
a second application	1
a second induction	1
a second step	1
a higher instruction	2
a higher number	1
a higher clock	1
a higher address	1
a higher risk	1
a piece of	10
a binary representation	1
a binary tree	1
a binary search,	1
a binary tree.	1
a 512 512	2
a union is	2
a feature for	2
a feature called	1
a link map	1
a constructor for	1
a compiler. Some	1
a compiler. Many	1
a #define directive	1
a switch in	1
a switch between	1
a switch statement	2
a smaller memory	1
a smaller size	1
a negative list	3
a negative result.	1
a positive integer	1
a positive list	3
a positive integer:	1
a loop. Example:	1
a computer with	1
a computer game	1
a pointer. The	1
a pointer. A	1
a pointer. It	4
a change in	1
a global variable	3
a global const	1
a global object.	1
a relative reference	1
a relative difference	1
a syntax restriction,	1
a profiler to	2
a profiler that	1
a profiler which	1
a profiler works	1
a Windows, Linux,	1
a modern CPU.	1
a network with	1
a network may	1
a slow and	1
a slow bit	1
a slow CPU,	1
a whole polygon	1
a whole workday	1
a level-2 cache	2
a response is	1
a hot spot	2
a hot spot.	1
a given instruction	1
a given task	1
a level-1 data	1
a task is	1
a task into	1
a task switch	1
a limited number	1
a limited range	1
a limited resource.	1
a limited audience	1
a local const	1
a local variable.	1
a database for	1
a database by	1
a bool is	1
a frame function	1
a frame function,	1
a special loop	1
a special cache	1
a special trick	1
a shift operation	1
a shift operation.	2
a shift operation,	1
a destructor to	1
a destructor that	3
a destructor if	1
a safe way	1
a safe programming	1
a Pentium 4	3
a Pentium 4.	1
a further discussion	1
a sum of	1
a discussion of	2
a non-Intel CPU.	1
a maximum of	1
a macro to	1
a macro in	1
a macro so	1
a reduced number	1
a variable. Make	1
a variable. Efficiency	1
a time, then	1
a processing speed	1
a so-called soft	1
a total offset	1
a total waste	1
a 128-bit vector	2
a 128-bit XMM	2
a full size	1
a thread. You	1
a square brackets	1
a little more	2
a little faster	1
a little explanation.	1
a little odd	1
a logical sequence.	1
a smart pointer	2
a smart pointer.	3
a subexpression to	1
a bounds check	1
a message loop	1
a condition is	1
a parallel structure	1
a ? b	2
a previous branch.	1
a vector. If	1
a vector. 6.	1
a program, especially	1
a similar utility	1
a risk that	1
a risk factor	1
a garbage collector	1
a header file	1
a future version	1
a newer instruction	1
a newer version	1
a sequence of	2
a sequence where	1
a significant effect	1
a significant amount	1
a significant contribution	1
a linear function	2
a linear array	3
a linear list	1
a linear array.	1
a linear search,	1
a penalty for	1
a module by	1
a 'this' pointer	1
a 'this' pointer.	1
a problem. If	1
a row to	1
a matter of	8
a series of	6
a waste of	6
a map file	1
a 256-bit vector	1
a device driver.	1
a non-static member	2
a low instruction	1
a low positive	1
a low priority	1
a default constructor	1
a hard disk	4
a typical set	1
a typical software	1
a typical application	1
a typical degree	1
a usability problem	1
a pure function	1
a pure function.	1
a derived class	3
a derived class,	1
a fully compiled	1
a standardized manner.	1
a parent class	2
a false model	1
a false vendor	1
a temporary object	1
a temporary array	1
a temporary variable	1
a temporary register	1
a procedure linkage	3
a PC and	1
a PC platform.	1
a frequent cause	1
a frequent source	1
a prediction or	1
a polymorphic function	1
a polymorphic class	1
a polymorphic member	1
a polymorphic function.	1
a register. The	1
a register. If	1
a kind of	2
a graphical user	3
a lower instruction	1
a lower priority	1
a misprediction every	1
a misprediction penalty	1
a just-in-time compiler	1
a try block.	1
a background process	1
a PLT for	1
a heavy graphics	1
a hash table	1
a hash map	1
a hash map.	1
a profiling (see	1
a DLL can	1
a DLL with	1
a DLL goes	1
a branch. If	1
a GOT for	1
a GOT entry.	1
a fixed size	1
a fixed address	1
a fixed breakpoint	1
a non-sequential order	1
a non-sequential order.	3
a non-sequential manner	1
a non-sequential manner.	1
a jump from	1
a random manner.	1
a measure that	1
a poorly predictable	1
a vector, uses	1
a suitable set	1
a suitable choice	1
a suitable pivot	1
a suitable duration.	1
a serious legal	2
a far data	1
a collection of	1
a composite type	3
a composite object,	1
a highly optimized	1
a debug version	2
a factor of	1
a factor 4	1
a reliable source	1
a reliable decision.	1
a thousand cache	1
a thousand times	2
a thousand numbers.	1
a compile-time polymorphism,	1
a constant. The	1
a complex framework	1
a dispatched function	1
a normal array.	1
a convenient way	1
a portability issue	1
a reference, or	1
a self-relative address.	1
a Core i7	1
a debugger and	1
a ^ b	1
a ^ 1;	1
a ^ -1	1
a ^ ~a	1
a base class	1
a base address	1
a leaf function	2
a leaf function.	1
a six years	1
a structure. The	1
a structure. For	1
a profiler. A	1
a profiler. It	1
a loss of	1
a remote database,	1
a considerable amount	1
a considerable improvement	1
a considerable job,	1
a considerable debate	1
a third thread	1
a multidimensional array	1
a multidimensional structure	1
a strict formalism	1
a portable way	1
a computer. The	1
a computer. Security	1
a list, rolled	1
a realistic set	2
a realistic number	1
a console mode	2
a hundred or	1
a hundred clock	1
a hundred times	1
a hundred times.	1
a loop-carried dependency	1
a compromise between	2
a nonzero floating	1
a command or	1
a command line	2
a relatively primitive	1
a latency which	1
a larger memory	1
a project built	1
a valid address.	1
a valid 63	1
a loop-invariant code	1
a loop-invariant expression	1
a key or	1
a key press	1
a bit-mask: __m128i	2
a type. The	1
a place indicated	1
a bad dilemma.	1
a mouse move	1
a non-inlined copy	3
a round function	1
a pipeline where	1
a Taylor series.	1
a dispatcher. The	1
a class, structure	1
a queue as	1
a protected operating	2
a dramatic degradation	1
a contained object	1
a bottleneck than	1
a directive for	1
a scarce resource	1
a scarce resource.	1
a scarce resource,	1
a suboptimal way	1
a suboptimal way.	2
a float, but	1
a detailed overview	1
a dedicated test	1
a dedicated microprocessor	2
a dedicated physics	1
a breakpoint in	1
a unit-test without	1
a virus scanner	1
a pointer, a	1
a pointer, but	1
a soft processor	2
a hyperthreading processor	1
a reasonable upper	1
a reasonable estimate	1
a well-defined interface	2
a well-defined functionality	1
a wrong type.	1
a combination of	1
a hidden pointer.	1
a speed-critical program	1
a high-level language	1
a multithreaded program,	1
a parameter, so	1
a circular buffer	3
a register, not	1
a natural order	1
a natural ordering?	1
a sorted list	3
a negligible contribution	1
a well-structured C++	1
a micro-op cache	1
a CPU- specific	1
a backup copy	1
a nearby address	1
a pivot search:	1
a float. (Both	1
a built-in test	1
a complete redesign	1
a variable, for	1
a variable, pointer	1
a viable solution	1
a viable compromise	1
a debugger. You	1
a debugger. However,	1
a computationally intensive	1
a subexpression. For	1
a chip that	1
a biased binary	1
a minor error	1
a non-member function,	1
a decimal point	1
a PC. Nevertheless,	1
a PC. Similarly,	1
a hint and	1
a case: //	1
a GOT. Another	1
a string. The	1
a 90% chance	1
a proxy for	1
a floppy disk.	1
a variable-size array	1
a buffer. It	1
a name. #define	1
a third-party graphics	1
a null reference	1
a null reference.	1
a constructor, an	1
a physics processing	1
a re- usable	1
a programmable logic	1
a time-consumer even	1
a high-priority thread	1
a FIFO queue	1
a FIFO manner?	1
a discussion. 7.33	1
a cheap compiler	1
a division, which	1
a first-in-last-out fashion.	1
a coprocessor might	1
a systematic and	1
a systematic manner	1
a ^a =	2
a release version	2
a distinction between	1
a symbolic link	1
a parenthesis around	2
a bitfield is	1
a bitfield by	1
a slight degradation	1
a generic version	1
a word processor	1
a matrix. For	1
a universal algorithm	1
a non-virtual member	1
a niche in	1
a "move constructor"	1
a typo in	1
a user-defined function	1
a union: //	1
a macro, but	1
a macro. If	1
a precious resource	1
a not-too-big upper	1
a basic understanding	1
a "function". Multiple	1
a plug-in to	1
a hand- written	1
a low-priority thread	1
a monotonically increasing	1
a top-of-stack index.	1
a button or	1
a minimal difference	1
a blend instruction	1
a wealth of	1
a zigzag course	1
a constructor. A	1
a number). Different	1
a sensible balance	1
a compelling security	1
a vector). The	1
a formalism. The	1
a narrow range	1
a multitasking environment,	1
a valuable source	1
a learning process	1
a 50-50 chance	1
a double: //	1
a First-In-Last- Out	1
a non-const reference,	1
a key? If	1
a password. The	1
a year or	1
a lineage of	1
a server in	1
a staircase function	1
a 2'nd order	1
a conditional move,	1
a polynomial. Scheduling	1
a ready-made profiler.	1
a discrete icon	1
a disassembly, probably	1
a tag on	1
a balanced mix	1
a First-In-First- Out	1
a fixed-size array	1
a lookup-table static.	1
a DLL. Another	1
a request for	1
a #define, const	1
a plain old	1
a genuine compiler	1
a thread-like scheduling	1
a non-recursing template	1
a thorough analysis	1
a zero-terminated ASCII	1
a polymorphous class?	1
a technological point	1
a bottleneck. Organize	1
a temp1 and	1
a XOR b	1
a stand alone	1
a zip file	1
a reply about	1
a graceful way.	1
a FILO manner?	1
a driver involves	1
a Gauss elimination.	1
a funda- mentally	1
a column-wise manner	1
a website. 5	1
a scalar (Scalar	1
a higher-priority thread	1
a destructor. A	1
a bit-mask which	1
a pre-calculated table.	1
a printer or	1
a union, as	1
a square. //	1
a strategy for	1
a million times	1
a minute if	1
a textbook on	1
a level-3 cache.	1
a unique key.	1
a couple of	1
a template: //	1
a ^0 =	1
a menu click	1
a subset, giving	1
a BSF (bit	1
a queue. It	1
a constant: Unsigned	1
a quadratic matrix,	1
of the function	6
of the code	25
of the compiler	2
of the time	10
of the memory	5
of the data	6
of the program	20
of the vector	2
of the different	1
of the same	13
of the functions	2
of the CPU	5
of the instruction	2
of the loop	5
of the integer	2
of the class	3
of the floating	2
of the compilers	4
of the most	7
of the size	1
of the Intel	4
of the pointer	3
of the library	3
of the two	4
of the object	3
of the number	1
of the 64-bit	1
of the C++	4
of the array	7
of the clock	2
of the value	2
of the objects	1
of the variable	2
of the table	2
of the performance	1
of the software	2
of the 32-bit	1
of the member	3
of the way	1
of the elements	1
of the called	1
of the address	1
of the 4	1
of the critical	9
of the operating	4
of the first	3
of the register	1
of the optimization	1
of the code.	7
of the time.	3
of the template	2
of the new	2
of the user	1
of the following	3
of the 32	1
of the bits	1
of the type	1
of the &	1
of the simple	1
of the processors	1
of the Gnu	2
of the function.	5
of the extra	2
of the large	1
of the while	1
of the execution	1
of the compiled	1
of the best	3
of the virtual	4
of the exception	1
of the power	1
of the matrix	3
of the AVX	2
of the four	2
of the problem	1
of the few	1
of the structure	2
of the standard	1
of the memory.	1
of the shared	1
of the program.	7
of the above	1
of the problems	1
of the next	1
of the multiplication	1
of the application	2
of the expression	1
of the Boolean	3
of the needs	1
of the Microsoft	1
of the parameter	1
of the source	1
of the induction	1
of the string	1
of the programmer	6
of the keyword	1
of the end	1
of the examples	1
of the difference	1
of the data.	1
of the graphics	1
of the framework	1
of the second	1
of the x86	1
of the advantages	3
of the storage	1
of the old	1
of the function,	1
of the operands	3
of the innermost	1
of the compiler.	1
of the advanced	1
of the core	1
of the main	1
of the loop.	2
of the installation	1
of the cases.	1
of the STL	3
of the size.	1
of the desired	1
of the whole	2
of the code,	4
of the fact	1
of the position-independent	1
of the level-1	1
of the resources.	1
of the task	1
of the costs	1
of the inlined	1
of the class.	3
of the preceding	5
of the exponent	1
of the possibility	1
of the maximum	1
of the library.	3
of the final	3
of the variable.	1
of the time,	1
of the total	1
of the child	1
of the counters	1
of the stack.	1
of the previous	1
of the program,	3
of the header	1
of the sequence	1
of the beginning	2
of the current	1
of the problem.	1
of the features	1
of the latter	1
of the default	1
of the derived	2
of the factorial	1
of the OpenMP	1
of the parent	1
of the memcpy	1
of the polymorphic	1
of the heavy	1
of the arrays.	2
of the branch.	1
of the GOT	1
of the array.	1
of the software.	1
of the object,	1
of the memory,	1
of the absolute	1
of the largest	1
of the .NET	1
of the base	1
of the result.	1
of the increment	1
of the advice	2
of the pitfalls	1
of the present	1
of the strlen	1
of the divisor	2
of the drawbacks	1
of the lrint	1
of the user's	1
of the considerations	1
of the techniques	1
of the advices	1
of the residual	2
of the specified	1
of the micro-op	1
of the object's	2
of the const_cast	1
of the executable.	1
of the comments	1
of the question	1
of the array,	1
of the alignment.	1
of the time-consumers	1
of the fraction.	2
of the trivial	1
of the subroutine	1
of the factorials,	1
of the Xnu	1
of the usual	1
of the programmers'	1
of the weekdays.	1
of the original,	1
of the user-written	1
of the iterator	1
of the kind:	1
of a and	3
of a function	4
of a code	1
of a compiler	1
of a will	1
of a memory	1
of a data	1
of a program	10
of a vector	1
of a different	1
of a loop	6
of a cache	1
of a class	6
of a floating	3
of a double	1
of a pointer	1
of a 64-bit	2
of a clock	3
of a variable	4
of a very	2
of a long	1
of a 32-bit	1
of a critical	2
of a template	1
of a new	2
of a simple	1
of a function.	1
of a ;	1
of a big	2
of a specific	2
of a virtual	1
of a matrix	2
of a list	1
of a store	1
of a copy	1
of a shared	1
of a program.	4
of a particular	1
of a signed	2
of a parameter	1
of a linked	2
of a piece	1
of a change	1
of a program,	1
of a row	1
of a hard	1
of a derived	2
of a parent	2
of a temporary	1
of a polymorphic	2
of a graphical	2
of a vector,	1
of a suitable	1
of a composite	2
of a structure.	1
of a list,	1
of a relatively	1
of a Taylor	1
of a class,	1
of a dedicated	1
of a variable,	1
of a debugger.	1
of a string.	1
of a third-party	1
of a re-	1
of a bitfield	1
of a macro.	1
of a "function".	1
of a double:	1
of that branch	1
of it (&ArraySize)	1
of function libraries	2
of function pointers	2
of function calls	2
of function inlining	2
of function calls.	1
of function libraries........................................................................................	1
of code is	4
of code to	1
of code and	4
of code in	3
of code that	3
of code can	1
of code you	1
of code then	1
of code into	1
of code compiled	1
of code gives	1
of code size.	1
of code execute	1
of code once	1
of code optimization",	1
of an int	1
of an integer	2
of an object	1
of an array	4
of an unsigned	2
of an error	1
of an execution	1
of an exception	2
of an optimized	1
of an intermediate	1
of an inlined	1
of an overloaded	1
of an exception.	2
of an update,	1
of an error;	1
of compiler may	1
of compiler There	1
of compiler options	1
of compiler ....................................................................................................	1
of compiler options.......................................................................................	1
of x is	1
of x The	1
of x for	1
of x by	1
of x must	1
of this is	1
of this function	2
of this by	1
of this bit	1
of this method	1
of this solution	1
of this section	1
of this fact	1
of this alignment	1
of this problem.	1
of this polynomial	1
of this method.	1
of this manual.	2
of this option.	1
of this bookkeeping	1
of this manual,	1
of this capability:	1
of time and	1
of time in	1
of time for	1
of time so	1
of time both	1
of time cleaning	1
of when they	1
of when type-casting	1
of A is	3
of A and	1
of memory to	1
of memory and	1
of memory for	2
of memory that	1
of memory or	1
of memory with	1
of memory will	1
of memory takes	1
of memory called	1
of memory inside	1
of memory addresses	1
of memory used.	1
of memory space	1
of memory needed	1
of memory required	1
of memory blocks,	1
of memory leaks	1
of memory blocks.	1
of data in	1
of data that	1
of data A	1
of data structures	1
of data members.	1
of data files.	1
of data ......................................................................................................	1
of data cache,	1
of data manipulation	1
of data shuffling,	1
of data (low	1
of data decomposition,	1
of data elements,	1
of program or	1
of program code	1
of program performance	1
of program efficiency	1
of program flow.	1
of vector register	1
of vector registers	1
of vector operations	1
of vector math	1
of vector operations,	1
of different function	1
of different integer	1
of different compilers	1
of different size	1
of different C++	3
of different type	1
of different intrinsic	1
of different types	4
of different sizes	2
of different algorithms	1
of different lengths	1
of different targets	1
of different compilers.............................................................................	1
of functions in	1
of functions that	1
of functions with	1
of functions A	1
of only half	1
of CPU that	1
of CPU dispatching	1
of CPU time,	1
of CPU cores.	1
of CPU development,	1
of other optimizations	1
of other tasks	1
of instruction latencies,	1
of instruction timing,	1
of loop ;	3
of loop iterations	1
of which code	1
of which functions	1
of which one	1
of which method	1
of which processor	2
of which optimizations	1
of all the	1
of all data	1
of all but	1
of all variables.	1
of all cleanup	1
of one iteration	2
of cache for	1
of cache space	2
of cache lines	1
of cache space.	2
of cache misses	2
of cache organization	1
of cache space,	1
of cache evictions	1
of integer register	1
of integer operations.	1
of class C1,	1
of floating point	9
of each function	1
of each vector	2
of each integer	1
of each object	2
of each array	2
of each version	1
of each table	1
of each run	1
of each string	1
of each row	1
of each factor	1
of each step	1
of each element,	2
of each method,	1
of example container	1
of example 15.1b	1
of example 12.4b	1
of most library	1
of using the	4
of using a	4
of using an	1
of using static	2
of using pointers	2
of using dynamic	1
of using exception	1
of using references	1
of using classes.	1
of using bitwise	1
of using smart	1
of using powers	2
of using ready	1
of Intel vector	1
of Intel C++	1
of Intel CPUs	1
of Intel microprocessors	1
of b is	2
of b will	1
of b into	1
of library functions	1
of i to	2
of i in	1
of i will	1
of i which	2
of i into	1
of i must	1
of i ;	1
of float or	1
of two different	1
of two double	1
of two induction	1
of two double.	1
of object files	1
of object p	1
of object oriented	3
of object pointed	1
of static and	1
of static data	1
of static linking	1
of static libraries.	1
of 64-bit integer	1
of 64-bit Windows	1
of 64-bit integers.	1
of 64-bit software,	1
of C++ and	3
of C++ but	1
of C++ should	1
of C++ compilers	1
of C++ projects	1
of C++ relates	1
of such container	1
of such contentions	1
of such checks	1
of efficient container	1
of array elements	1
of array ;	1
of array element	1
of array bounds	1
of array elements.	1
of possible pointer	1
of possible overflow	1
of possible inputs	1
of possible inputs.	1
of possible remedies	1
of clock pulses	1
of objects is	4
of objects in	2
of objects can	1
of objects they	1
of variable size	1
of variable storage	2
of variable size.	1
of variable storage.............................................................................	1
of any function	1
of any size	1
of some of	1
of some long	1
of some help	1
of variables can	1
of return prediction).	1
of 2 is	1
of 2 and	1
of 2 in	2
of 2 can	1
of 2 //	2
of 2 or	1
of 2 if	6
of 2 by	1
of 2 when	1
of 2 then	3
of 2 double	1
of 2 return	1
of 2 template	1
of 2 does	2
of 2 Integer	1
of 2 (See	1
of 2 applies	1
of 2 (i.e.	1
of table lookup	1
of performance on	1
of performance has	1
of performance monitoring	1
of software that	1
of software can	1
of software with	1
of software into	1
of software programmers	1
of software specifies	1
of software development,	1
of software develop-	1
of order or	1
of order execution	2
of 32-bit integers	1
of branch that	1
of branch prediction.	2
of member pointers	1
of elements is	3
of elements to	1
of elements in	8
of elements per	3
of elements Total	2
of elements Size	1
of const double	1
of 4 floats	2
of call and	1
of 8 -	1
of 8 bits	1
of 8 bytes	1
of 8 kb	1
of operating system	1
of operating system.........................................................................................	1
of unsigned integers	1
of register is	1
of register stack	1
of register variables.	1
of register temp	1
of register renaming	1
of 64 bits	2
of 64 bytes.	1
of optimization is	2
of optimization can	1
of optimization by	1
of how to	6
of how compilers	2
of code. The	1
of code. Example:	1
of code. Each	1
of code. Furthermore,	1
of time. The	1
of time. A	1
of time. You	1
of template parameters.	1
of registers is	2
of registers has	1
of registers used.	1
of pointers to	3
of pointers may	1
of pointers because	1
of test data	2
of test data.	2
of user interface	3
of user input	1
of user interfaces	1
of these functions	1
of these instruction	2
of these cache	1
of these compilers	1
of these two	2
of these also	1
of these methods	2
of these directives	1
of these conditions	1
of these classes.	1
of these purposes.	1
of these manuals	1
of these guidelines	1
of these obstacles	1
of these categories:	1
of 16 bits	1
of 16 bytes.	1
of system code.	1
of system programming,	1
of 32 bits	1
of programming will	1
of programming language	4
of programming languages	1
of programming languages,	1
of programming style.	4
of programming experience	1
of dynamic memory	5
of dynamic allocation	1
of dynamic linking	1
of bits in	1
of operations in	1
of operations can	1
of type short	1
of type T	1
of type int.	1
of short vector	1
of simple types	1
of instructions for	1
of processors is	1
of processors that	2
of processors on	1
of available registers	1
of error is	1
of error known	1
of error reporting.	1
of making the	4
of making two	1
of making software	1
of making sure	2
of times to	1
of times each	1
of times before	1
of times CriticalFunction	1
of stack unwinding	2
of its time	3
of its members	1
of its binary	1
of its child	1
of its arguments.	1
of its simplicity.	1
of CPUs is	1
of CPUs such	1
of CPUs increased	1
of CPUs unequally	1
of extra instructions	1
of extra resources.	1
of assembly language	1
of large memory	1
of large arrays	1
of arrays and	1
of arrays in	1
of arrays that	1
of arrays with	1
of work into	1
of calls to	1
of calculations then	1
of calculations without	1
of calculations forms	1
of execution speed	2
of processor models	2
of bytes to	1
of big memory	1
of threads is	1
of threads with	1
of necessary communication	1
of element number	1
of specific CPU	1
of specific processor	1
of virtual function	1
of virtual functions.	1
of several drivers,	1
of common string	1
of exception handling	1
of allocated resources.	1
of small microcontrollers:	1
of overflow is	1
of overflow and	2
of overflow Integer	1
of integers to	1
of integers and	1
of integers with	1
of good development	1
of Linux and	1
of classes and	1
of precision for	1
of precision on	1
of four parameters	1
of four (or	1
of four floats	1
of four float.	1
of four float's	1
of parameters then	1
of known type,	1
of container classes	2
of eight 16-bit	2
of whether you	1
of whether they	1
of list plus	1
of structure and	1
of structure or	2
of doing the	1
of doing floating	2
of doing type	1
of doing things	1
of doing whole	1
of every intermediate	1
of every version.	1
of standard C,	2
of hardware platform	4
of optimizing the	1
of optimizing ...............................................................................................	1
of optimizing University	1
of memory. See	1
of memory. These	1
of memory. One	1
of information about	1
of intermediate code	1
of both parent	1
of programs should	1
of problems you	1
of space on	1
of microprocessor The	1
of microprocessor ...........................................................................................	1
of branches and	2
of branches that	1
of branches every	1
of typically 30	1
of complicated algorithms	1
of handling errors	1
of handling cleanup	1
of dependency chains	1
of their time	1
of their execution	1
of their 23	1
of their superior	1
of Boolean operands	1
of Boolean operands.	1
of Boolean algebra,	1
of 256 Kbytes	1
of intrinsic vectors	1
of signed integers	1
of development are	1
of mathematical functions	1
of mathematical purity.	2
of separate layers	1
of #include directives	1
of #include directives.	1
of various instruction	1
of zero within	1
of parameter transfer	3
of induction variables	1
of n being	1
of n floats:	1
of string classes	1
of end user's	1
of && is	1
of data. The	3
of data. This	2
of data. A	1
of data. Use	1
of runtime DLL's	1
of || is	1
of expressions and	1
of expressions where	1
of longer response	1
of optimizations is	1
of optimizations in	1
of graphics objects	1
of graphics cards,	1
of public functions	1
of Intel, AMD	9
of microprocessors are	1
of microprocessors from	1
of platform is	1
of your software.	1
of bigger vector	1
of << and	1
of binary data	1
of storage is	1
of storage space.	1
of 10 -	1
of 10 double	2
of CPUs. The	1
of CPUs. These	1
of a[i] and	1
of advanced development	1
of advanced mathematical	1
of advanced features	1
of points is	1
of range is	1
of range and	1
of range }	1
of range (see	1
of range printf(Greek[n]);	1
of modules or	1
of smaller sizes	1
of things that	1
of things you	1
of main memory.	1
of my experiment	1
of errors in	2
of unused bytes	2
of columns a	1
of columns in	3
of dynamically linked	1
of consecutive variables.	1
of modern microprocessors	2
of modern CPUs,	2
of modern software,	1
of 2. The	1
of 2. Example:	2
of 2. Using	1
of 2. Objects	1
of 2. Contentions	1
of variables. Move	1
of lines is	1
of position-independent code.	1
of out-of-order execution.	1
of out-of-order execution,	1
of resources. For	1
of resources. Consider	1
of task switching.	1
of costs to	1
of S1 in	1
of S1 aligned	1
of math functions	1
of temp before	1
of inlined functions	1
of constants is	1
of constants we	1
of bool in	1
of special vector	1
of algorithm is	1
of sum depends	1
of Linux, BSD	1
of registers. This	1
of registers. There	1
of alignment problems.	1
of compatibility with	3
of compatibility problems	2
of macro expansions.	1
of 100 floats	1
of 100 numbers:	1
of 100 doubles:	1
of reduced performance.	1
of operations. A	1
of time, it	1
of copying it	1
of copying blocks	1
of optimization. 14	1
of containers is	1
of disk caching,	1
of unknown brand	1
of counters in	1
of 2, so	1
of full optimization.	1
of N with	1
of N into	1
of N template	1
of RAM memory	1
of RAM memory.	2
of rows and	2
of compiling multiple	1
of compiling without	1
of precision. Let's	1
of algebraic reduction.	1
of structures and	1
of structures (without	1
of logical processors	1
of logical processors.	1
of heap management	1
of smart pointers	1
of nontemporal write	1
of bounds checking	1
of resource problems	1
of cores in	1
of cores or	1
of cores will	1
of parallel execution.	1
of calculating the	1
of ebx that	1
of e.g. four	1
of sizes other	1
of sizes 1,	1
of list[i] is	1
of statements that	1
of course a	1
of course be	2
of course make	1
of course also	1
of course inefficient.	1
of course far	1
of course system-specific.	1
of templates where	1
of templates makes	1
of CriticalFunction in	1
of seconds and	1
of CPU. These	1
of f is	1
of f cout	1
of F1 without	1
of setting a	1
of added information	1
of approximately seven	1
of order. See	1
of order. Long	1
of situations where	1
of 256-bit size	1
of finding a	1
of purposes such	1
of usability problems	1
of overflow. The	1
of overflow. Table	1
of storage. See	1
of addition, subtraction,	1
of everything else.	2
of (or in	1
of parent and	2
of parent class	1
of temporary objects	1
of procedure 4	1
of iterations is	1
of background processes	1
of CPUs, different	1
of additions and	2
of j as	1
of fastest possible	1
of devices and	1
of branch. After	1
of zero. A	1
of multiplying by	1
of software. For	1
of jump targets.	1
of vectors. 12.10	1
of lazy loading	1
of lazy binding	1
of 1, 2,	1
of vector, such	1
of vector, bits	2
of algebra in	1
of algebra are	1
of suitable containers	1
of Java and	1
of Java are	1
of optimizations. The	1
of exceptions a	1
of machine instructions	1
of changes in	1
of storing data	1
of storing strings	1
of 2: //	1
of 2: template	1
of composite type	1
of bits. The	1
of bits. This	1
of speed. Assume	1
of thousand numbers	1
of Intel's Math	1
of course, and	1
of course, that	1
of course, if	1
of course, because	1
of course, but	1
of scope or	1
of Func with	1
of Func ;a	1
of c1 before	1
of portability to	1
of comparing signed	1
of computers and	1
of B before	1
of five manuals	1
of five manuals.	1
of five manuals:	1
of poor CPU	1
of self-relative references	1
of truncation and	1
of powerful development	1
of C++, directly	1
of C++, Pascal	1
of mixed sizes.	1
of branches. Manual	1
of communication with	1
of inheritance is	1
of backwards compatible	1
of backwards compatibility	1
of memset and	1
of context switches	2
of reducing the	1
of development, testing	1
of abc is	2
of abc can	1
of 250 ms.	1
of computing resources.	1
of pointers, by	1
of physical processors	1
of nonzero floating	1
of unacceptably long	1
of n! is	1
of Basic is	1
of Basic was	1
of valid addresses,	1
of CPU-intensive software	1
of CPU-intensive programs	1
of manuals. 7.1	1
of 18 software	1
of two. In	1
of ebx. The	1
of ebx. Only	1
of m and	1
of bad CPU	1
of resources, and	1
of declaring an	1
of defining integer	1
of precision, as	1
of precision, especially	1
of u.f We	1
of overflow, such	1
of modifications to	1
of efficiency. The	1
of efficiency. Using	1
of transferring the	1
of structured and	1
of structured software	1
of going either	1
of float, double	1
of alloca over	1
of unit-testing It	1
of unit-testing ......................................................................................	1
of sequential instructions,	1
of error. The	1
of abstraction is	1
of abstraction in	1
of abstraction which	1
of code). If	1
of aligning dynamically	1
of numbers: //	1
of calculations: //	1
of calculations, where	1
of xxn rather	1
of int. A	1
of position- independent	1
of C++. Yet,	1
of A, B	1
of text strings	1
of Pascal used	1
of overflow: //	1
of coefficients is	1
of longjmp if	1
of competing brands	1
of efficiency, platform	1
of bookkeeping in	1
of technical problems.	1
of organizing the	1
of measuring performance	1
of (0,0,0,0,0,0,0,0) __m128i	2
of (0,0,0,0,0,0,0,0) Is16vec8	1
of microprocessor. These	1
of returning a	1
of security. b	1
of (2n /	1
of vectors, as	1
of truncation. This	1
of double, then	1
of mispredictions (see	1
of allocations is	1
of n. The	1
of interpreting the	2
of jumping around	1
of x. This	1
of (2,2,2,2,2,2,2,2) __m128i	2
of (2,2,2,2,2,2,2,2) Is16vec8	1
of accumulators for	1
of interpretation or	1
of expressions, but	1
of jobs. For	1
of c+b will	1
of CriticalFunction. You	1
of keeping a	1
of keeping data	1
of dangers to	1
of semaphores, mutexes,	1
of course. A	1
of course. It	1
of it, for	1
of range"; }	1
of range"; 134	1
of range. The	1
of range. This	1
of programming. The	1
of programming. 13.3	1
of starting and	1
of underflow. The	1
of predefined vector	1
of ArraySize by	1
of experiments on	1
of irrelevant software	1
of cross-platform portability.	1
of iterations. The	1
of Numerically Intensive	2
of sharing the	1
of digital building	1
of received data	1
of matrix[j][0] is	1
of squares: const	1
of sources. For	1
of algebra, we	1
of factorials: static	1
of factorials: const	1
of coprocessors is	1
of removing superfluous	1
of relieving a	1
of b+c will	1
of convenience -	1
of B. In	1
of sets). Here,	1
of strange and	1
of sets) (line	1
of frustration and	1
of algebra. For	1
of cc[i]+2 is	1
of titles. Literature	1
of 64. Each	1
of fine-tuning, testing,	1
of Mathcad (v.	1
of simultaneous lookups	1
of view. This	1
of 0x800 apart.	1
of switching to	1
of i&15 is	1
of if. This	1
of solving the	1
of (a+b). This	1
of underflow: //	1
of it). This	1
of randomness in	1
of &list[100] is	1
of it) load	1
of doubles by	1
of verifying, debugging	1
of downloaded program	1
of structures: //	1
of multithreading. 7.30	1
of 1/n! 1.,	1
of N: #define	1
of profiling. When	1
of modularity. For	1
of yesterday's big	1
of identifier names.	1
of attack for	1
of security, but	1
of matrices. An	1
of Denmark. Copyright	1
of temp. The	1
of ADC (add	1
of synchronizing and	1
of habit, it	1
of CPU-time in	1
of DLLs, configuration	1
of redesign. Some	1
of -fpic. This	1
of research on	1
of rows/columns in	1
of inte- ger	1
of sum. The	1
of managing a	1
of people. I	1
of jumps, calls	1
of RAM, a	1
of data", where	1
of rounding, but	1
of losing precision.	1
of pending instructions	1
of usability. This	1
of ways). If	1
of range"); or	1
of activating the	1
of occupying a	1
to the function	5
to the code	2
to the compiler	1
to the time	2
to the different	1
to the same	9
to the CPU	1
to the instruction	3
to the point	1
to the integer	1
to the class	1
to the most	2
to the Intel	1
to the library	1
to the object	1
to the number	1
to the value	1
to the called	1
to the address	3
to the critical	2
to the operating	2
to the first	1
to the new	2
to the user	3
to the constant	1
to the stack	3
to the Gnu	2
to the function.	2
to the calculations	1
to the best	1
to the thread	1
to the exception	1
to the power	3
to the AVX	1
to the standard	2
to the sign	1
to the copy	1
to the allocation	1
to the next	2
to the dispatcher	1
to the programmer	1
to the end	4
to the calling	1
to the second	1
to the x86	1
to the old	1
to the appropriate	5
to the desired	5
to the inlined	2
to the preceding	2
to the right	4
to the offset	1
to the object.	2
to the so-called	1
to the total	3
to the disk	1
to the situation	1
to the previous	1
to the vector.	1
to the length	1
to the beginning	4
to the current	1
to the user.	2
to the hard	1
to the required	1
to the general	1
to the table.	1
to the rules	1
to the availability	1
to the structure.	1
to the profiler.	1
to the rest	1
to the console	1
to the modulo	1
to the dispatcher.	1
to the area	1
to the diagonal.	1
to the selected	1
to the parameter,	1
to the nearest	1
to the $B1$2	1
to the CPU-specific	1
to the first-in-last-out	1
to the container.	1
to the reader	1
to the tolerance	1
to the IEEE	1
to the truth	1
to the standards	1
to the next.	1
to the exponent:	1
to the design	1
to the device.	1
to is a	1
to is identical	1
to is deleted	1
to is known.	1
to a =	1
to a function	5
to a more	1
to a different	3
to a class	2
to a floating	1
to a pointer	6
to a float	1
to a static	1
to a clock	1
to a variable	3
to a table	1
to a branch	1
to a <	1
to a const	1
to a new	1
to a file	1
to a function.	1
to a specific	4
to a virtual	1
to a signed	1
to a better	1
to a longer	1
to a graphics	3
to a public	1
to a smaller	1
to a pointer.	1
to a global	1
to a limited	1
to a local	2
to a macro	1
to a usability	1
to a pure	1
to a derived	1
to a base	1
to a structure.	1
to a command	1
to a valid	1
to a dispatcher.	1
to a dramatic	1
to a contained	1
to a wrong	1
to a complete	1
to a non-member	1
to a floppy	1
to a matrix.	1
to a narrow	1
to a driver	1
to a printer	1
to and you	1
to be the	2
to be a	2
to be in	2
to be as	1
to be an	3
to be very	1
to be faster	1
to be stored	2
to be less	2
to be 0	2
to be available	1
to be compiled	1
to be done	2
to be calculated	1
to be able	3
to be put	1
to be too	2
to be transferred	4
to be read	1
to be aligned	1
to be higher	1
to be divisible	1
to be called.	1
to be predicted	1
to be loaded	2
to be limited	1
to be inlined	1
to be possible.	1
to be changed	1
to be true	1
to be initialized	1
to be scattered	1
to be mispredicted	2
to be false	1
to be converted	1
to be designed	1
to be fragmented	1
to be distributed	2
to be slower	2
to be aware	2
to be available,	1
to be equal	1
to be updated	1
to be expressed	1
to be cleaned	2
to be obsolete.	1
to be spaced	2
to be filled	1
to be stored.	1
to be inlined.	1
to be evicted	1
to be pure.	1
to be overwritten,	1
to be irrelevant	1
to be profitable	1
to be cached	1
to be deleted.	1
to be slower.	1
to be moved.	1
to be installed.	1
to be mispredicted,	1
to be restored	1
to be saved.	1
to be renewed.	1
to be platform-independent	1
to be reloaded	1
to be signed.	1
to be noticeable	1
to be resized	1
to be annoying.	1
to are constant.	1
to can be	2
to function names.	1
to by r	1
to by p	1
to code the	1
to an integer	1
to an object	2
to an array	2
to an address	1
to an intermediate	1
to an output	1
to an inlined	1
to an integer,	2
to an existing	1
to int in	1
to int x	1
to x 43	1
to have the	2
to have a	2
to have no	1
to have two	1
to have many	1
to have separate	1
to have just	1
to have constructors	1
to this the	2
to this number	1
to this manual	3
to this problem	3
to this argument	1
to use the	21
to use a	14
to use and	1
to use in	1
to use for	3
to use that	1
to use it	1
to use an	1
to use than	2
to use this	1
to use vector	4
to use float	1
to use multiple	1
to use static	1
to use 64-bit	1
to use 32-bit	1
to use dynamic	2
to use assembly	2
to use exception	1
to use inline	1
to use intrinsic	1
to use induction	1
to use string	1
to use later	1
to use depends	1
to use vectorized	1
to use it.	1
to use algebraic	1
to use hyperthreading	1
to use denormal	1
to use SafeArray:	1
to use try,	1
to memory without	1
to memory management	1
to at a	1
to data in	1
to data through	1
to data within	1
to make the	21
to make a	25
to make and	1
to make it	2
to make code	1
to make this	1
to make more	1
to make different	1
to make one	1
to make floating	1
to make multiple	1
to make two	1
to make table	1
to make software	2
to make member	1
to make register	1
to make pointers	1
to make sure	18
to make overflow	2
to make container	1
to make support	1
to make shared	1
to make their	1
to make better	1
to make aligned	1
to make special	1
to make 16-bit	1
to make profiling	1
to make explicit	1
to make CPU-	1
to make thread-specific	1
to make log2	1
to make memory-hungry	1
to different dynamically	1
to different platforms	1
to different tasks.	1
to functions and	1
to CPU dispatching.	1
to other parts	1
to other platforms	2
to point to	1
to all of	1
to all class	1
to all allocated	1
to all local	1
to all instances	1
to all zeroes.	1
to one of	3
to one class	1
to one thread	1
to cache misses,	1
to integer can	1
to integer takes	1
to integer without	1
to integer conversion	1
to integer According	1
to set the	2
to set an	1
to set number	1
to set up	1
to set seconds	1
to class C1	1
to floating point	6
to floating point.	1
to floating point:	1
to each compiler	1
to each other	1
to each new	1
to each element	2
to each task	1
to do the	10
to do is	1
to do a	3
to do and	1
to do it	1
to do as	1
to do an	1
to do this	3
to do more	2
to do when	1
to do different	1
to do integer	1
to do multiple	1
to do two	2
to do such	1
to do any	1
to do some	1
to do so	4
to do operations	1
to do simple	1
to do calculations	1
to do optimizations	1
to do things	3
to do something	2
to do this:	1
to do this.	1
to do so.	3
to do manually.	1
to do interprocedural	1
to do experiments	1
to do immediately	1
to do so).	1
to do cross-module	1
to do searches	1
to example 15.1b	1
to using a	1
to using new	1
to using templates	1
to using templates.	2
to using namespaces.	1
to using hyperthreading.	1
to using hyperthreading,	1
to using inheritance.	1
to double In	1
to double before	1
to double precision	1
to b for	1
to b memcpy(b,	1
to i and	1
to float in	1
to float conversion	1
to float conversions	1
to multiple operating	1
to multiple inheritance	1
to static or	1
to 64-bit mode,	1
to such a	1
to such an	1
to efficient use	1
to array elements.	1
to many hard	1
to many users.	1
to any other	2
to any known	1
to some of	1
to some other	1
to some extra	1
to some positive	1
to return from	2
to return a+1;.	1
to 2 by	1
to 2 Mbytes.	1
to very big	1
to software optimization.	1
to 32-bit integers,	1
to const definitions	1
to 4 clock	1
to call the	7
to call a	5
to call or	1
to unsigned in	1
to unsigned for	1
to unsigned if	1
to unsigned int	1
to first look	1
to first convert	1
to 64 bits.	1
to take a	1
to take more	1
to take into	1
to take branch	1
to take extra	1
to take advantage	2
to take longer	1
to take special	1
to take maximum	1
to take care	2
to optimization are	1
to optimization by	4
to optimization MS	2
to optimization are.	1
to test the	3
to test a	1
to test in	1
to test for	1
to test //	2
to test on	1
to test this	1
to test when	1
to test all	1
to test each	1
to test 16	1
to test several	1
to systems with	2
to user input	1
to these problems	1
to even allocate	1
to always use	1
to always true	1
to always behave	1
to access the	2
to access a	4
to access it	1
to access an	2
to access x	1
to access these	1
to 16 bytes	1
to 16 lines	1
to 32 bit	1
to 0 and	2
to 0 //	1
to type in	1
to & unless	1
to simple things	1
to simple actions	1
to error handling.	1
to stack memory	2
to stack memory.	1
to its variables	1
to its own	1
to its functions,	1
to its child	1
to assembly language	1
to ; store	1
to arrays of	1
to arrays that	1
to work in	1
to work for	1
to work with	1
to work on	2
to work best	1
to work around	1
to (see page	1
to execution time.	1
to avoid the	5
to avoid that	2
to avoid this	2
to avoid multiple	1
to avoid long	2
to avoid these	1
to avoid dynamic	2
to avoid running	2
to avoid conversions	1
to avoid this.	2
to avoid them.	1
to avoid modulo	1
to avoid hard-to-find	1
to speed up	2
to c =	1
to single precision.	1
to virtual function	1
to virtual member	1
to compile a	1
to compile for	1
to compile with	2
to compile for.	1
to exception handling	1
to small devices,	1
to integers of	1
to integers use	1
to matrix a	1
to Linux in	1
to cause contentions	1
to cause seven	1
to cause overflow,	1
to four bits,	1
to another by	1
to another class.	1
to another platform.	1
to get a	2
to get as	1
to get an	1
to get x	1
to get more	1
to get used	1
to get library	1
to get access	1
to get reliable	1
to get reproducible	1
to get rid	1
to check the	1
to check for	4
to check that	1
to check if	3
to check whether	1
to support different	1
to list and	1
to run the	2
to run a	2
to run most	1
to run two	2
to calculate the	13
to calculate than	1
to calculate when	1
to calculate each	1
to calculate self-relative	1
to calculate (c+d)	1
to calculate pow(x,10)	1
to inline the	2
to inline a	1
to inline and	1
to inline this	1
to hardware interfaces	1
to add the	1
to add i	1
to add new	1
to add unused	1
to add statements	1
to store the	1
to store is	1
to store x	1
to store data	1
to store all	1
to store each	1
to store many	1
to store objects	1
to store intermediate	2
to store aligned	1
to store strings	1
to store unaligned	3
to store help	1
to store application-specific	1
to copy the	2
to copy that	1
to certain programming	1
to addresses divisible	2
to count how	1
to count certain	1
to program. Many	1
to write the	4
to write a	1
to write 2.0/3.0	1
to write _mm_add_epi16(a,b).	1
to write if(!a	1
to optimize the	2
to optimize a	1
to optimize for	1
to optimize code	1
to optimize this	2
to optimize register	1
to optimize away	2
to optimize across	1
to optimize anything	1
to optimize access,	1
to optimize caching.	1
to optimize anything,	1
to problems of	1
to replace the	4
to replace a	2
to replace arrays	1
to replace u[1]	1
to automatically prefetch	1
to see the	3
to see if	4
to see which	2
to see how	1
to see whether	2
to see this.	1
to their 32-bit	1
to signed integer	1
to signed before	1
to signed integers	1
to put the	2
to put a	3
to put file	2
to put time-consuming	1
to put measurement	1
to put time-	1
to zero is	1
to zero and	1
to zero for	1
to zero that	1
to zero //	1
to zero by	1
to zero than	1
to zero at	1
to zero We	1
to zero whenever	1
to zero memset(a,	1
to Microsoft compilers.	1
to Microsoft Visual	1
to what the	1
to end of	1
to read the	1
to read and	2
to read from	2
to give the	2
to give each	1
to give higher	1
to look up	2
to actually doing	1
to load the	3
to load a	2
to load more	1
to load several	1
to load aligned	1
to load unaligned	3
to control the	2
to assume the	1
to assume that	2
to assume no	1
to dispatch by	1
to your programming	1
to improve the	1
to improve cache	1
to improve speed	1
to improve performance.	1
to improve efficiency.	1
to binary code	1
to know how	4
to know whether	1
to know what	1
to know about.	1
to generate a	2
to generate an	2
to generate many	1
to generate interrupts	1
to reduce the	1
to reduce this	1
to reduce example	1
to reduce complicated	1
to reduce various	1
to reduce (a*b*c)+(c*b*a)	1
to 10 means	1
to choose the	1
to choose a	1
to choose between	1
to choose between.	1
to link with	1
to just one	1
to a[i] More	1
to require modifications	1
to switch to	1
to start the	1
to start a	1
to start and	1
to start at	1
to start calculations	1
to start up,	1
to around 1980	1
to 5 by	1
to 5 }	1
to 5 times	1
to go the	1
to go one	1
to go away	1
to go deeper	1
to change the	1
to p is	2
to become fragmented	1
to become fragmented.	1
to become invalid,	1
to become obsolete	1
to turn on	2
to turn off	6
to network resources,	1
to desired values	1
to code, you	1
to find the	6
to find and	1
to find out	2
to find hot	2
to find elsewhere.	1
to rely on	2
to produce the	1
to produce binary	1
to produce tables	1
to out-of-order execution	1
to platforms that	1
to temp even	1
to frame functions	1
to frame functions.	1
to prevent memory	1
to prevent cache	1
to prevent such	3
to prevent optimizing	1
to save time	1
to save some	1
to save time.	1
to save power.	1
to save recovery	1
to tell the	8
to tell a	1
to tell these	1
to tell explicitly	1
to repeat or	1
to unroll the	2
to unroll a	3
to exponent }	1
to it. This	1
to it. Therefore,	1
to optimization. Prefetching	1
to accessing an	1
to divide the	6
to divide i	2
to mix the	1
to mix different	1
to mix integer	1
to mix floating	1
to mix simple	1
to mix signed	1
to mix mathematical	1
to fit the	6
to fit specific	1
to predict the	1
to predict a	1
to predict with	1
to predict which	4
to predict whether	1
to predict correctly	1
to 128-bit XMM	1
to execute the	1
to execute then	2
to execute it.	1
to execute CriticalFunction	1
to execute slower	1
to execute _mm_empty()	1
to square by	1
to fail if	1
to convert b	1
to convert float	1
to convert unsigned	1
to handle the	2
to handle an	1
to handle only	1
to handle strings	1
to handle unknown	1
to insert the	1
to insert a	2
to insert an	1
to insert optimization	1
to consider which	1
to reading as	1
to enable the	3
to enable constant	1
to enable fast	1
to e.g. a	1
to keep the	2
to keep multiple	1
to keep pointers	1
to keep up	1
to keep their	1
to keep together	1
to keep track	1
to align its	1
to align large	1
to align dynamically	1
to align arrays.	1
to BSD systems.	1
to come from	1
to SSE4.1 and	1
to CriticalFunction in	1
to swap memory	1
to swap two	2
to modify the	1
to modify a	1
to F1 only	1
to gain in	1
to gain if	1
to gain by	2
to apply to.	1
to allocate the	1
to allocate a	3
to allocate more	1
to allocate one	1
to allocate variable-size	1
to metaprogramming would	1
to define function	1
to define 64-bit	1
to define your	1
to define application-specific	1
to implement the	2
to implement a	3
to implement in	1
to implement this	1
to 256-bit registers	1
to contain all	1
to integers. It	1
to integers. 7.25	1
to help the	2
to transfer a	1
to transfer ownership	1
to multiply j	1
to share the	1
to default constructors,	1
to vectorize the	3
to vectorize code	1
to include the	1
to include a	1
to fully utilize	1
to care about	1
to memcpy rather	1
to lower case:	1
to try different	1
to account for	1
to heavy competition.	1
to general improvements	1
to zero. The	1
to zero. You	1
to zero. 14.3	1
to measure the	1
to measure //	1
to measure how	1
to measure exactly	1
to delete the	1
to delete it	1
to disk. Memory	1
to disk. Software	1
to disk. Provoke	1
to update the	1
to integer. The	1
to hold the	2
to hold only	1
to 120 ms	1
to eliminate common	1
to eliminate everything	1
to 127 will	1
to debug and	1
to vectorization. The	1
to do. The	1
to do. This	1
to do. It	1
to remove the	2
to remove all	1
to remove unreferenced	1
to transpose the	1
to transpose a	2
to transpose and	2
to transpose matrix	1
to wait for	4
to break a	1
to break down	1
to increase the	2
to identify the	2
to identify a	1
to identify and	1
to identify performance	1
to identify individual	1
to call. I	1
to declare the	1
to declare it	1
to declare objects	1
to dispatched function	1
to dispatched version	1
to detect if	1
to normal afterwards.	1
to show how	1
to evaluate the	1
to evaluate a	1
to evaluate and	1
to evaluate b	1
to evaluate whether	1
to five or	1
to poor documentation	1
to prefetch data	1
to truncation and	1
to base a	1
to completely rule	1
to roll out	5
to anything it	1
to increment the	1
to increment an	1
to economize the	3
to economize resource	1
to seven times	1
to overcome the	2
to overcome this	1
to overcome these	1
to maintain. The	1
to maintain. If	1
to maintain. Any	1
to maintain. And	1
to fourteen register	1
to fourteen parameters	2
to 122 this	1
to remote databases	1
to memset and	1
to install a	2
to install automatic	1
to consume time	1
to consume more	1
to select all	1
to recover in	1
to recover from	4
to split the	1
to split up	1
to limit the	1
to follow the	1
to compromise on	1
to understand and	1
to understand when	1
to understand how	1
to specify the	1
to specify static	1
to compare the	1
to compare two	1
to compare absolute	1
to valid values	1
to CPU-intensive code.	1
to wrap the	2
to wrap around,	1
to sum1 from	1
to 15.1c as	1
to 15.1c would	1
to 15.1c was	1
to recommend that	1
to recommend any	1
to lead to	1
to place the	1
to overlap the	2
to obtain the	2
to ebx. The	1
to modulo calculations:	1
to round addresses	1
to protected mode	2
to distinguish between	2
to distinguish elements	1
to distinguish these	1
to clean up	2
to contained objects?	1
to unsigned. //	1
to sum2 from	1
to suboptimal code.	1
to uncached memory	1
to individual array	1
to begin calculating	1
to another. The	1
to another. These	1
to recognize VIA	1
to mirror the	1
to force the	1
to virus attacks	1
to alias upon	1
to well-tested functions,	1
to zero, by	1
to reload the	2
to reload *p	1
to 12. Higher	1
to optimization, it	1
to ignore overflow	1
to manipulate the	2
to study the	2
to 0x273F will	1
to 0x273F into	1
to 0x273F would	1
to int. Reinterpret	1
to nearest integer	1
to justify the	1
to justify such	1
to cover the	2
to focus the	1
to issue an	1
to solve this	2
to utilize the	2
to top of	1
to decide which	1
to security. There	1
to security. Standard	1
to decrement operators	1
to determine the	1
to determine if	1
to determine whether	1
to 3-dimensional geometry	1
to a. I	1
to post-increment. There	1
to invest in	1
to invest more	1
to 1024 bits	1
to override the	1
to override public	1
to CriticalFunction. If	1
to exit the	1
to emulate the	1
to C1::f }	1
to worry about	1
to worry much	1
to 15. If	1
to develop and	2
to non-AVX code	1
to non-AVX code.	1
to -56 which	1
to assembly: ALIGN	2
to construct obscure	1
to 15.1c. We	1
to join all	1
to join them	1
to note that	1
to creating and	1
to reorder instructions	1
to windows, graphic	1
to pressing a	1
to date. A	1
to date. Mac	1
to test, maintain	1
to isolate the	1
to 12.1a. Enable	1
to use. I	1
to use, incompatible	1
to read. It	1
to read. If	1
to lock a	1
to load. A	1
to push and	1
to verify that	1
to draw the	1
to draw each	1
to 155 test.	1
to distribute function	1
to distribute all	1
to reserve the	1
to reserve resources	1
to 11.1b automatically,	1
to test. disable	1
to respond quickly	1
to provoke error	1
to interrupts and	1
to do, at	1
to organize the	1
to organize data	1
to log, and	1
to low-level optimizations.	1
to fix the	2
to keyboard and	1
to keyboard or	1
to obey any	1
to obey certain	1
to 99 read	1
to flip the	1
to me. You	1
to a[i+2] ;	1
to answer questions	1
to C1::Disp() or	1
to resume after	1
to zero: //	1
to seek information	1
to mind. In	1
to finish. 3.8	1
to NULL. There	1
to be. The	1
to x?" or	1
to re-use a	1
to +127. An	1
to relocate, but	1
to diagnose. It	1
to 15.1c). 16	1
to thank the	1
to trace with	1
to experience. Occasionally,	1
to _endthread() cleans	1
to fine- tune	1
to date): Microsoft	1
to pool all	1
to Eclipse when	1
to print out	1
to obtain, such	1
to come. Even	1
to weigh the	1
to truly represent	1
to express any	1
to restart the	1
to vectorize, or	1
to remember that	1
to translate these	1
to query certain	1
to compose a	1
to compensate for	1
to exchange data	1
to fetch the	1
to facilitate porting	1
to perform poorly	1
to T+6, and	1
to OMF format.	1
to calculate. If	1
to localize the	1
to optimize, and	1
to T+5, then	1
to reinvent the	1
to combine the	1
to pass a	1
to reinstall a	1
to 36. There	1
to temporarily lock	1
to advertise new	1
to realize that	1
to objects) are	1
to great lengths	1
to port to	1
to controversies over	1
to deallocate the	1
to catching hardware	1
to Func1, while	1
to receive new	1
to 12.8b automatically	1
to ignore, then	1
to consult the	1
to minimize the	1
to reflect this	1
to refresh the	1
to adhere to	1
to feed into	1
to 15.1c, but	1
to a*b*c*2. It	1
to x^0/0! //	1
to collect the	1
to fake an	1
to develop. It	1
to 15.1c? We	1
to relax floating	1
to Object1.Hello(), though	1
to 151 15.1c	1
to vectorize. The	1
to multithreading that	1
to C0::f or	1
to 100000000. When	1
to mimic the	1
to adapt to	1
and the function	2
and the code	3
and the compiler	2
and the time	2
and the memory	1
and the data	2
and the program	2
and the vector	1
and the other	2
and the loop	1
and the most	3
and the Intel	1
and the library	1
and the object	1
and the number	3
and the array	1
and the elements	1
and the critical	1
and the operating	6
and the template	1
and the user	1
and the system	1
and the type	1
and the Gnu	2
and the work	1
and the result	2
and the best	1
and the speed	1
and the matrix	1
and the calculation	2
and the four	1
and the dispatching	1
and the multiplication	1
and the application	1
and the caching	1
and the cost	1
and the runtime	1
and the second	1
and the AVX2	1
and the options	1
and the whole	1
and the level-2	1
and the local	1
and the destructor	2
and the possibility	1
and the amount	1
and the entire	1
and the SSE	1
and the header	1
and the fraction	1
and the subsequent	1
and the low	1
and the derived	1
and the Gnu,	1
and the Java	1
and the CPUID	1
and the throughput	1
and the availability	1
and the rest	1
and the Digital	1
and the "Intel	1
and the 49	1
and the corresponding	1
and the 512-bit	1
and the FAQ	1
and the transitions	1
and the loader.	1
and the post-increment	1
and the EXCLUSIVE	1
and the texts	1
and the destructor,	1
and the wires	1
and the resultant	1
and is not	1
and is used	1
and is called	1
and is available	1
and is compiled	1
and is therefore	1
and a floating	1
and a pointer	1
and a 64-bit	1
and a table	1
and a member	1
and a template	1
and a hardware	1
and a Windows,	1
and a slow	1
and a level-2	1
and a processing	1
and a waste	1
and a derived	1
and a GOT	1
and a third	1
and a well-defined	1
and a release	2
and a generic	1
and a basic	1
and a server	1
and to make	2
and to optimize	1
and to put	1
and to know	1
and to mix	1
and to Eclipse	1
and in this	1
and in most	1
and in some	2
and in 32-bit	1
and for code	1
and for more	1
and for information	1
and for fast	1
and for saving	1
and for minimizing	1
and that the	1
and that there	1
and that threads	1
and that measurements	1
and that computers	1
and are in	1
and are difficult	1
and are equally	1
and can be	1
and can calculate	1
and it is	1
and it can	4
and it may	2
and it will	2
and it makes	1
and it needs	2
and it prevents	1
and it avoids	1
and it fills	1
and it understands	1
and function libraries	2
and function pointers	1
and function calls	2
and function inlining	1
and if an	1
and if you	1
and by the	1
and by not	1
and by avoiding	1
and by changing	1
and on Intel	1
and code size	1
and code addresses.	1
and not not	1
and not negative	1
and not easily	1
and not __INTEL_COMPILER	1
and an error	1
and an FPGA	1
and an addition.	1
and compiler makers.	1
and may be	1
and may produce	1
and you can	3
and you may	1
and you cannot	2
and you want	6
and you unroll	1
and have a	1
and have implemented	1
and this will	2
and this pointer	1
and this value	1
and this error	1
and time consuming.	1
and use the	2
and use a	1
and use multiple	1
and use alternative	1
and more efficient	2
and more error	1
and more efficient.	1
and more difficult	1
and more important.	1
and more compact	1
and more complex,	1
and will have	1
and then use	2
and then call	1
and then calls	1
and then transferred	1
and then convert	1
and then think	1
and then B,	1
and then interpret	1
and then 0+1.23456	1
and then merge	1
and memory access	1
and data in	1
and data are	2
and data can	1
and data A	1
and data memory	1
and data cache	2
and data caching	1
and data structures	1
and data .........................................................................................	1
and data decomposition.	1
and vector operations	1
and vector processors	1
and make the	2
and make a	2
and make it	1
and make this	1
and make one	1
and make sure	2
and make parts	1
and make appropriate	1
and make measurements	1
and different user	1
and different sizes	1
and functions consume	1
and only the	1
and only if	1
and only one	1
and only one,	1
and only if,	1
and CPU hardware.	1
and other data	1
and other compilers	1
and other extra	1
and other compiled	1
and other big	1
and other common	1
and other container	1
and other resources	2
and other things	1
and other languages	1
and other resource	2
and other features	1
and other optimizations.	1
and other protection	1
and other nearby	1
and other complications	1
and other hardware-related	1
and other system-	1
and other flaws	1
and other odd-sized	1
and other abuse	1
and instruction sets.	1
and which are	1
and which optimizations	1
and which reductions	1
and which not.	1
and all the	2
and all three	1
and all 0's	1
and used for	1
and one for	2
and one that	2
and one or	1
and one from	1
and one local,	1
and cache size.	1
and cache sizes.	1
and integer division.	1
and integer representations	1
and no branches	1
and no induction	1
and no destructor	1
and no multiplications.	1
and page 87	1
and class objects	1
and class members	1
and floating point	5
and each CPU	1
and each value	1
and most clean	1
and most up-to-date	1
and using the	1
and using advanced	1
and using overloaded	1
and double is	1
and double (see	1
and double precision	2
and double vectors	2
and double Floating	1
and double precision.	1
and size as	1
and Intel vector	1
and Intel compilers	3
and Intel compilers.	1
and pointer type	1
and b is	1
and b in	2
and b are	3
and b have	2
and b will	1
and b different	1
and b because	2
and b should	1
and b double	1
and b take	1
and b overlap.	1
and i >=	1
and static variables	1
and static const	1
and static data.	1
and 64-bit code	1
and 64-bit operating	1
and 64-bit Windows	2
and 64-bit Linux	2
and 64-bit systems.	2
and 64-bit Windows,	1
and 64-bit Linux,	1
and 64-bit mode.	1
and 64-bit Windows.	2
and 64-bit Linux.	1
and 64-bit integers,	1
and there is	2
and there are	3
and there will	1
and C++ is	1
and C++ faster	1
and also a	1
and efficient if	1
and array indices	1
and where the	1
and possible workaround.	1
and objects that	1
and objects are	1
and objects will	1
and objects should	2
and objects declared	3
and takes little	1
and variable names	1
and variable names.	1
and any other	1
and we do	1
and we don't	1
and some of	1
and some other	1
and some operating	1
and some tips	1
and so on.	1
and return a	1
and return and	1
and return operations	1
and table lookup	2
and very useful	1
and very time-	1
and software developers	1
and software engineering	1
and long double	2
and between simple	1
and 32-bit and	1
and 32-bit Windows	1
and 32-bit Linux	1
and branch is	1
and branch mispredictions.	2
and member functions	1
and makes it	1
and makes an	1
and before any	2
and stored in	1
and stored as	1
and call the	1
and call it	1
and 8 floating	1
and 8 bytes	1
and less efficient	1
and operating systems	3
and operating systems.	2
and operating system.	1
and operating systems".	3
and operating systems").	1
and operating systems"	1
and unsigned integers	4
and unsigned variables.	1
and unsigned integers.	1
and 64 bits	2
and take more	1
and often inefficient.	1
and often excessively	1
and how the	1
and how you	1
and how much	2
and test their	1
and new objects	1
and user settings	1
and these two	1
and these operations	1
and they are	2
and they can	1
and they always	1
and they waste	1
and without the	1
and without AVX	2
and even worse,	1
and always the	1
and always use	1
and SSE2 instruction	1
and system calls.	1
and system modules.	1
and system crash.	1
and system breakdown.	1
and 32 bit	1
and dynamic versions.	1
and dynamic linking.	1
and type of	1
and short vector	1
and simple to	1
and constant propagation	3
and error handling	2
and I believe	1
and making an	1
and stack entries	1
and want to	1
and Gnu compilers	1
and Gnu compilers.	2
and its return	1
and its parameters.	1
and accessed non-sequentially	1
and assembly code	2
and while the	1
and arrays can	1
and arrays by	1
and Windows platforms.	2
and Windows Template	1
and Windows 3.x.	1
and Windows Server	1
and calls alternately	1
and execution time.	1
and execution units.	1
and avoid dynamic	1
and compiled for	1
and big structures	1
and doesn't take	1
and necessary support.	1
and c are	1
and c can	1
and c __m128i	2
and c first.	1
and much time	1
and much less	1
and virtual function	1
and virtual functions	1
and several other	1
and AMD processors	1
and AMD CodeAnalyst.	1
and compile the	1
and compile them	1
and exception handling.	1
and small code	1
and integers Conversion	1
and integers ...................................	1
and Linux operating	1
and cause large	1
and cause contentions	1
and cause delays	1
and cause fatal	1
and classes Nowadays,	1
and done by	1
and therefore the	1
and therefore it	1
and therefore not	2
and therefore more	1
and therefore cannot	1
and therefore likely	1
and therefore count	1
and therefore difficult	1
and therefore fail	1
and works only	1
and optimized function	1
and manual 3:	1
and manual 5:	1
and uses more	1
and another part	1
and get a	1
and known to	1
and supported by	1
and supported on	1
and operators Integer	1
and operators Modern	1
and operators ......................................................................	1
and whether there	1
and doing multiple	1
and run any	1
and calculate it	1
and calculate *p+2	1
and 1 for	2
and add b	1
and add Divide	1
and store the	3
and store it	1
and copy the	1
and copy matrix	2
and optimizing for	1
and well thought-through	1
and simply put	1
and addresses in	1
and shared between	1
and intermediate code	1
and intermediate results	1
and write it	1
and write configuration	1
and optimize both	1
and programs compiled	1
and microprocessor microarchitecture.	1
and branches in	1
and Mac systems	1
and Mac programs	1
and Mac platforms.	1
and Mac platforms	1
and Mac OS	2
and Mac allow	1
and Mac systems,	1
and multiplication are	1
and multiplication may	1
and multiplication (27	1
and multiplication (20	1
and see which	1
and caching becomes	1
and sets all	1
and complicated algorithm	1
and their implementations	1
and don't modify	1
and model numbers	1
and model number.	3
and model numbers,	1
and development time.	1
and development tool	1
and development tools.	1
and mathematical functions	2
and mathematical operations	1
and mathematical calculations.	1
and put the	1
and put an	1
and put seldom	1
and various efficient	1
and various programming	1
and zero flags	1
and Microsoft C++	1
and what it	1
and parameter transfer	2
and division take	1
and automatic vectorization	1
and automatic vectorization.	2
and automatic parallelization.	1
and automatic parallelization	1
and automatic CPU-dispatching	1
and resources should	1
and resources cleaned	1
and induction variables	1
and string functions	1
and string instructions.	1
and string manipulation	1
and three times	1
and better at	1
and better processor	1
and | operations	1
and last the	1
and last all	1
and || are	1
and types of	1
and difficult to	2
and after the	1
and after each	1
and after executing	2
and read or	1
and give the	2
and directives which	1
and public data	1
and public variables	1
and microprocessors work.	1
and assume that	1
and later instruction	3
and later Intel	1
and later reads	1
and later deleted	1
and later discovers	1
and calling any	1
and interface frameworks.	1
and 512 bits	1
and generate a	2
and r in	1
and r are	1
and b, and	1
and reduce a	1
and 10 ms	1
and choose the	2
and choose this	1
and link with	1
and advanced prediction	1
and switch statements	2
and switch statements.............................................................................	1
and start the	1
and replaced by	1
and negative inputs	1
and negative impacts	1
and go back	1
and tested it.	1
and references in	1
and references are	1
and references Pointers	1
and references ............................................................................................	1
and loaded into	1
and VIA processors.	3
and VIA CPUs.	1
and VIA including	1
and VIA processors,	1
and VIA CPUs").	3
and VIA CPUs"	3
and VIA CPUs:	1
and VIA CPUs".	2
and C are	1
and global variables	1
and my manual	1
and off by	1
and columns in	2
and 1. The	1
and 1. Note	1
and turn on	1
and turn off	1
and inlining the	1
and network access	1
and network connections.	1
and >= operators).	1
and desired new	1
and hot spots.	1
and position-independent code	2
and output should	1
and task switches;	1
and sometimes it	1
and sometimes unacceptably	1
and local variables	1
and frame functions.	1
and prevent it	1
and prevent legitimate	1
and shift out	1
and shift operations	1
and shift Floating	1
and shift operations.	1
and prevents all	1
and d in	1
and d would	1
and Linux, 32-bit	1
and compatibility problems	2
and writing from	1
and writing data	1
and copying different	1
and causes the	1
and divide it	1
and 16-bit Windows,	1
and child are	1
and child class	1
and child class.	1
and disk space	1
and disk space.	1
and possibly also	1
and possibly save	1
and overloaded operators.	2
and classes. The	1
and % means	1
and precision. The	1
and algebraic reductions	1
and handle one	1
and handle text	1
and initialized arrays.	1
and insert the	2
and insert a	1
and insert only	1
and reading the	1
and reading them	1
and message systems.	1
and enable one	1
and keep track	1
and PathScale compilers	2
and PathScale compilers.	3
and BSD comes	1
and rarely the	1
and easier to	1
and 20 clock	1
and expect this	1
and references. Most	1
and references. Arrays	1
and similar objects	1
and similar methods	1
and back again.	4
and garbage collection	2
and garbage collection.	1
and garbage collection,	1
and templates for	1
and header files.	1
and swap these	1
and sets. Let	1
and invalid pointers.	2
and setting the	1
and checks both	1
and current operating	1
and 3 -	1
and waste of	1
and map are	1
and easy development	1
and easy development.	1
and 256-bit YMM	1
and scattered around	1
and writes may	1
and device drivers	1
and destructors of	1
and destructors to	1
and destructors A	1
and destructors ..................................................................................	1
and stores the	2
and search facilities,	1
and usability A	1
and usability ...............................................................................................	1
and vectorize the	1
and derived class	1
and standardized file	1
and memcpy is	1
and c2 for	1
and misprediction of	1
and just-in-time compilation	1
and just-in-time compilation.	1
and algorithms in	1
and PLT for	1
and PLT tables	2
and PLT lookups	1
and profiling support	1
and fragmented hard	1
and who is	1
and fixed size	1
and fixed repeat	1
and interpreted line	1
and YMM registers	2
and measure how	1
and lazy binding	2
and delete is	1
and delete to	1
and delete or	2
and delete (or	1
and distributed as	1
and generally used	1
and Linux. The	1
and Linux. Asmlib	1
and Open BSD	1
and free are:	1
and rounding 137	1
and far procedures	1
and 120 for	1
and highly compatible	1
and again for	1
and Clang compilers.	1
and log are	1
and compile-time while	1
and wait until	1
and 15 clock	1
and declare all	1
and normal unsigned	1
and show the	1
and show a	1
and c1 for	1
and efficient, but	1
and again. If	1
and deallocated in	2
and edx can	1
and edx contains	1
and soon also	1
and edx, respectively.	1
and branches. The	1
and internal functions	1
and loss of	1
and Fortran are	1
and Fortran code.	1
and drivers differ	1
and economize the	1
and maintain. Most	1
and fourteen in	1
and fourteen integer	1
and bc for	1
and Digital Mars	1
and CISC processors,	1
and 22 one	1
and searching for	1
and _WIN64 _M_X64	1
and pow at	1
and computing power	1
and 90 for	1
and understand compiler-generated	1
and returns a	1
and frameworks typically	1
and compare it	1
and manuals. I	1
and loop-invariant code	2
and jumps back	1
and 13 objects,	1
and written back.	1
and BSD, the	1
and sixteen in	2
and enables interprocedural	1
and databases with	1
and loader (requires	1
and objects. Storage	1
and mouse inputs	1
and subtraction (3	1
and ownership is	1
and drawbacks of	1
and x86-64 platforms.	2
and Watcom compilers	1
and 14.9 is	1
and maintenance -	1
and maintenance There	1
and maintenance ..........................................................................................	1
and maintenance easier.	1
and underflow except	1
and underflow neutralize	1
and splitting the	1
and video processing,	1
and sum2 are	1
and avoids many	1
and image processing.	1
and interfaces to	1
and aliasing. Operations	1
and changing then	1
and smaller. This	1
and structures. Useful	1
and reproducible as	1
and reproducible results.	1
and operators. Make	1
and (set) =	1
and fine-grained parallelism	1
and compact. The	1
and FPGA soft	1
and earlier Intel	1
and 119 for	1
and compiler-generated code	1
and perhaps };	1
and perhaps Mac	1
and main() are	1
and 14.30 will	1
and keywords relevant	1
and divisions are	1
and trigonometric functions.	1
and 64, depending	1
and copies them	1
and 135 show	1
and leave the	1
and leave them	1
and c[i] are	2
and ZMM registers	2
and logarithms take	1
and pop ebx.	1
and s3 can	1
and open source.	1
and measuring the	1
and read-only data	1
and read-only data.	1
and well-structured code	1
and multiplications. Subtractions	1
and market the	1
and frameworks, rather	1
and truncation. The	1
and truncation. Efficient	1
and deallocation of	2
and decrement operators	1
and decrement operators.	1
and free. This	1
and free. These	1
and references, which	1
and LIBM libraries	1
and complexity (en.wikipedia.org/wiki/Standard_Template_Library).	1
and memcpy, at	1
and Sum3 in	1
and Sum3 are	1
and lack of	1
and mostly relative	1
and resolve any	1
and resolve compatibility	1
and discovered that	1
and scientific vector	1
and throw. It	1
and that's what	1
and GOT. The	1
and destination both	1
and 72 for	1
and 0x4700. These	1
and 14.13b works	1
and underflow. The	1
and web browsing	1
and p2 having	1
and maintaining a	1
and maintaining such	1
and sound processing	1
and servers should	1
and MOVNTDQ require	1
and 64-bit. Supports	1
and 64-bit. They	1
and isolate the	1
and v.f are	1
and afterwards a	1
and denormals-are-zero mode	1
and machines with	1
and debugging. A	1
and synchronization between	2
and high-priority threads	1
and verify than	1
and searching, or	1
and restarted anyway.	1
and IDE's for	1
and fine-tuned for	1
and redo the	2
and deleting the	1
and deleting containers.	1
and flexible, but	1
and Gnu. There	1
and Mac. The	1
and Mac. Supports	1
and subtracting 1	1
and reusable classes.	1
and stop the	2
and attempts to	1
and recovering from	1
and direct hardware	1
and studying the	1
and press break	1
and involve a	1
and statistics, and	1
and later. The	1
and 9. Multiplications	1
and "best case"	1
and delete, and	1
and delete, or	1
and BSD. The	1
and BSD. If	1
and executables. Make	1
and clumsy, as	1
and repagination are	1
and esp+12 and	1
and "More Effective	1
and IA-32 Architectures	1
and C# and	1
and FuncB, then	1
and Newton-Raphson iterations.	1
and |) instead	1
and object-oriented programming,	1
and Adolfy Hoisie:	1
and destructors. The	1
and de-allocation of	1
and off. It	1
and unexpected behaviors.	1
and flexibility of	1
and A. Hoisie,	1
and matrixes. Algorithms	1
and uninstallation of	1
and temp++ actually	1
and 2B. There	1
and lrint. Unfortunately,	1
and communicating between	1
and USB sticks	1
and finally (4)	1
and analyzing program	1
and disadvantages. The	1
and fence instructions,	1
and 12.4c is	1
and shared_ptr. auto_ptr	1
and databases. The	1
and Fortran. These	1
and investigated by	1
and error-prone. The	1
and reorganize: //	1
and convoluted template	1
and create a	1
and popped from	1
and delete). 88	1
and classes............................................................................................ 51	1
and decoded in	1
and 3B. developer.intel.com.	1
and ||). The	1
and animations is	1
and cons of	1
and "Integrated Performance	1
and UNIX shell	1
and '$' are	1
and FPGAs. The	1
and cryptography (www.intel.com).	1
and Itanium systems.	1
and Z. Each	1
and correspondingly two	1
and hence higher	1
and systematization of	1
and memcpy: //	1
and parsing are	1
and 137, respectively.	1
and reorganize the	1
and micro-operation breakdowns	1
and _mm_free. A	1
and non-constant references	1
and irregular response	1
and temp2. Modern	1
and stopping threads.	1
and double..................................................................................... 140	1
and operators............................................................................... 29	1
and tedious. The	1
and free) causes	1
and Sum3. Whether	1
and bb[i]*cc[i] is	1
and semicolons in	1
and intelligible way	1
and b. But	1
and VIA. The	1
and SVML. The	1
and Enterprise editions).	1
and fffff is	1
and closer to	1
and foremost, in	1
and list[i].b. It	1
and flexibility, while	1
and 3A and	1
and shifts one	1
and y?" then	1
and suggestions for	1
and increment. The	1
and restoring registers,	1
and newsgroups contain	1
and non-recoverable errors;	1
and concentrate the	1
and down. Remember	1
and modular. The	1
and WritePrivateProfileString to	1
and invoked with	1
and Func2 were	1
and maintainability of	1
and relational operators	1
and decreased when	1
and publish a	1
and mirroring is	1
and Gnu). Other	1
and suggests methods	1
and mainframes, and	1
and ease of	1
and recompile it.	1
and planned solutions.	1
and API's. Memory	1
and shuffling can	1
and closes the	1
and well- tested	1
and similarly sets	1
and clarity of	1
and __intel_new_strlen in	1
and ARM platforms	1
and getting them	1
and replaces the	1
in the //	1
in the function	4
in the code	19
in the compiler	3
in the data	2
in the program	8
in the different	1
in the same	20
in the CPU	5
in the other	1
in the instruction	1
in the loop	2
in the cache	1
in the set	1
in the class	1
in the most	4
in the Intel	2
in the library	1
in the object	1
in the 64-bit	1
in the array	1
in the clock	1
in the variable	1
in the table	1
in the order	4
in the long	1
in the branch	2
in the way	3
in the critical	5
in the operating	1
in the first	1
in the code.	5
in the template	1
in the test	1
in the following	9
in the programming	1
in the case	2
in the Gnu	3
in the assembly	1
in the while	1
in the Windows	1
in the big	1
in the best	1
in the thread	2
in the matrix	1
in the AVX	1
in the optimized	1
in the calculation	1
in the container	1
in the list	1
in the likely	1
in the structure	1
in the values	1
in the memory.	2
in the shared	1
in the program.	2
in the above	5
in the optimal	1
in the particular	1
in the next	3
in the multiplication	1
in the application	1
in the expression	1
in the cache.	3
in the high	1
in the Microsoft	1
in the source	2
in the end	3
in the last	1
in the XMM	1
in the second	2
in the x86	3
in the old	4
in the innermost	5
in the compiler.	3
in the relevant	1
in the main	3
in the global	1
in the choice	1
in the STL	2
in the level-2	4
in the code,	1
in the output	1
in the level-1	4
in the database	1
in the calculations.	1
in the final	4
in the copying	1
in the so-called	1
in the logical	1
in the entire	1
in the simplest	2
in the situation	1
in the condition	1
in the previous	2
in the chapter	1
in the future	1
in the sequence	2
in the CPU.	2
in the subsequent	1
in the latter	2
in the fully	1
in the procedure	1
in the background	1
in the system.	1
in the array.	1
in the general	1
in the software.	1
in the vectors.	1
in the YMM	2
in the sections	1
in the carry	2
in the table.	1
in the machine	1
in the core.	1
in the sense	6
in the latest	1
in the scope	1
in the debugger	3
in the form	3
in the future.	4
in the rest	1
in the event	3
in the select	1
in the project	1
in the present	1
in the asmlib	1
in the SVML	1
in the appendix	1
in the unit-test	1
in the interval	3
in the early	1
in the CPU,	1
in the file,	1
in the container,	1
in the container.	1
in the planning	1
in the book	1
in the disassembly	1
in the profile.	1
in the arrays:	1
in the MKL	1
in the majority	1
in the Professional	1
in the oldest	1
in the grandparent	1
in the BTB	1
in the end.	1
in the STL.	1
in the broader	1
in the representation,	1
in the "Macro	1
in the GOT,	1
in the beginning.	1
in the former	1
in the level-	1
in the Active	1
in the sequence,	1
in the unit-	1
in the BIOS	1
in a function	3
in a use	1
in a more	3
in a memory	3
in a program	2
in a vector	2
in a different	5
in a loop	4
in a class	2
in a library	1
in a number	1
in a static	3
in a 64-bit	1
in a C++	1
in a very	1
in a way	3
in a critical	1
in a register	5
in a rather	1
in a dynamic	2
in a short	1
in a simple	1
in a large	1
in a big	2
in a specific	1
in a single	6
in a virtual	1
in a thread	1
in a small	1
in a matrix	4
in a structure	2
in a hardware	3
in a shared	4
in a particular	3
in a microprocessor	1
in a separate	10
in a linked	1
in a binary	1
in a 512	1
in a compiler.	2
in a computer	2
in a global	1
in a network	1
in a special	1
in a safe	1
in a message	1
in a vector.	2
in a module	1
in a series	2
in a low	1
in a typical	2
in a standardized	1
in a temporary	2
in a procedure	2
in a register.	2
in a DLL	2
in a non-sequential	6
in a random	1
in a far	1
in a debugger	1
in a computer.	1
in a bad	1
in a protected	2
in a suboptimal	3
in a high-level	1
in a multithreaded	1
in a register,	1
in a well-structured	1
in a pivot	1
in a computationally	1
in a PC.	1
in a programmable	1
in a high-priority	1
in a FIFO	1
in a first-in-last-out	1
in a systematic	1
in a word	1
in a union:	1
in a hand-	1
in a multitasking	1
in a DLL.	1
in a graceful	1
in a FILO	1
in a Gauss	1
in a column-wise	1
in a pre-calculated	1
in code caching	1
in an object	2
in an array	1
in an application	1
in an &&	1
in an ||	1
in an unused	1
in an STL	1
in an inefficient	1
in an integer,	1
in an array.	1
in an appendix	1
in an FPGA	1
in an import	1
in an array,	1
in compiler price	1
in this example	7
in this table	1
in this way	2
in this case	5
in this range	1
in this example:	1
in this hot	1
in this series	1
in this case.	4
in this example.	1
in this format.	1
in this column.	1
in this block:	1
in this chapter.	1
in this respect.	1
in more than	1
in more complex	1
in more detail	1
in memory is	1
in memory or	2
in memory if	1
in memory by	1
in memory then	1
in memory takes	1
in memory rather	2
in program execution	1
in program memory.	2
in vector c	2
in vector c2	1
in vector Type	1
in vector bc	1
in different C++	1
in different versions	1
in different source	1
in different parts	1
in different places	1
in different ways.	1
in different modules.	1
in different browsers,	1
in only the	1
in other programming	1
in other threads	1
in other compilers.	1
in other ways	1
in other modules	1
in other languages.	1
in other ways,	1
in which the	6
in which data	1
in which they	6
in which alloca	1
in all the	1
in all possible	1
in all systems	1
in all cases,	1
in all operands	1
in one memory	1
in one way	1
in one big	1
in one source	1
in one operation	1
in one iteration	1
in one vector.	1
in one vector,	2
in one operation.	2
in one contiguous	1
in integer registers.	1
in set number	1
in floating point	2
in each vector	1
in each CPU	1
in each part	1
in each set.	1
in each case.	1
in each core.	1
in example 15.1b	2
in example 13.1	3
in example 16.2	2
in example 15.1c	1
in example 14.8	1
in example 12.4b	1
in example 14.28	2
in example 9.6b.	2
in example 9.5a	1
in example 11.3	2
in example 14.12b	1
in example 14.14a	1
in example 12.4a	1
in example 8.15a	1
in example 14.19	1
in example 14.1c	1
in example 11.2b	1
in example 11.1a	1
in example 15.1b.	1
in example 14.23	1
in example 14.7b	1
in example 7.32b.	1
in example 8.15b.	1
in example 16.2.	1
in example 8.23b	1
in example 14.7b,	1
in example 8.24	1
in example 16.1.	1
in example 7.35	1
in example 12.1b,	1
in example 7.22.	1
in example 9.5b.	1
in example 7.43b	1
in example 14.21	1
in example 9.1b.	1
in example 7.30b.	1
in most libraries	1
in most cases	5
in most cases,	4
in most cases.	3
in most cases:	1
in using the	1
in Intel function	1
in Intel compiler	2
in Intel compilers	1
in Intel processors	1
in Intel header	1
in b to	2
in library functions	1
in library functions,	1
in library libircmt.lib.	1
in multiple versions	5
in multiple applications,	1
in multiple versions,	1
in two different	1
in two other	1
in two libraries	1
in two ways.	1
in two versions.	1
in two steps.	1
in static memory	3
in static memory.	2
in 64-bit operating	1
in 64-bit code.	1
in 64-bit systems	2
in 64-bit Windows	1
in 64-bit Linux	3
in 64-bit mode	7
in 64-bit systems.	6
in 64-bit mode.	3
in 64-bit Windows.	2
in 64-bit device	1
in C++ is	1
in C++ and	1
in C++ so	1
in C++ take	1
in C++ An	1
in C++ programs	1
in C++ programs.	1
in such a	1
in such cases.	1
in such applications.	1
in array ;	1
in many different	1
in many cases.	2
in many commercial	1
in many respects	1
in any of	1
in any situation	1
in some very	1
in some systems	1
in some cases	8
in some cases,	3
in some compilers.	1
in some cases.	3
in some embedded	1
in some situations,	1
in some rare	1
in so that	1
in table The	1
in table 19	1
in table 8.1	1
in table 9.1	1
in table 8.1.	1
in table 9.2.	1
in table 9.2,	1
in performance can	1
in performance if	1
in performance between	2
in performance over	1
in software writing	1
in software development.	1
in order to	47
in between the	1
in 32-bit or	1
in 32-bit operating	2
in 32-bit systems	7
in 32-bit Windows	1
in 32-bit Linux	1
in 32-bit mode	2
in 32-bit Mac	1
in 32-bit systems.	1
in 32-bit mode.	5
in 32-bit systems,	2
in 32-bit mode,	2
in member functions	2
in critical parts	1
in 64 bit	6
in registers in	1
in registers are	1
in registers by	1
in registers only	1
in registers rather	5
in registers (see	1
in registers instead	1
in registers anyway.	1
in registers (6	1
in registers (8	1
in test situations	1
in systems with	1
in these manuals	1
in system code	1
in system code.	1
in 32 bit	3
in programming nowadays	1
in case the	3
in case of	12
in case memory	1
in case F2	1
in cases where	5
in simple cases	1
in simple cases.	3
in stack memory	1
in Gnu compiler	3
in its own	1
in its API.	1
in assembly code.	1
in assembly language	1
in assembly language.	1
in assembly names.	1
in assembly language".	2
in assembly language",	1
in assembly language:	1
in large data	2
in large arrays.	1
in large applications.	1
in Windows 7	1
in Windows MFC).	1
in compiled C++	1
in compiled languages	1
in compiled C++.	1
in big blocks	1
in speed by	2
in speed between	3
in several stages	1
in small embedded	1
in matrix //	2
in matrix 96	1
in Linux and	3
in Linux kernel	1
in classes like	1
in optimized programs.	1
in manual 3:	2
in manual 2:	3
in manual 5:	4
in manual 4:	2
in another source	1
in another array.	1
in another module.	1
in eight consecutive	4
in list in	1
in hardware in	1
in optimizing library	1
in optimizing application-specific	1
in memory. The	1
in memory. This	1
in memory. It	1
in memory. Example:	1
in memory. Function	2
in memory. No	1
in memory. Variables	1
in memory. They	1
in shared objects	1
in both the	1
in both static	1
in both Windows	2
in both cases.	1
in both compiler,	1
in both 16-bit,	1
in programs that	1
in programs with	1
in programs where	1
in programs compiled	1
in microprocessor hardware	1
in Mac systems.	1
in Mac OS	1
in multiplication here:	1
in mathematical iterations	1
in separate threads	1
in separate modules	1
in various ways	1
in applications that	1
in applications without	1
in addition to	1
in addition to)	1
in your program	1
in your program,	1
in XMM registers	1
in vectors of	1
in x86 systems).	1
in binary representation	1
in binary form	1
in just a	1
in just one	1
in main will	2
in main has	1
in computer games	1
in computer games.	1
in C and	1
in my vector	1
in my test	1
in my blog.	1
in my experiments.	1
in my crystal	1
in STL for	1
in STL as	1
in dynamically allocated	1
in Windows, you	1
in turn calls	1
in fact be	1
in fact it	1
in fact an	1
in fact only	1
in fact using	1
in fact accessed	1
in fact doing	1
in fact represented	1
in fact addressed	1
in vectorized code	1
in special cases	1
in special mathe-	1
in Linux, BSD	1
in Linux, sched_setaffinity).	1
in registers. 64-bit	1
in registers. Except	1
in performance. A	1
in performance. There	1
in performance. I	1
in performance. Integer	1
in 16-bit systems	1
in 16-bit systems:	4
in x, and	1
in full use	1
in RAM memory.	1
in parallel if	1
in either case.	1
in ebx ;	1
in BSD work	1
in BSD Shared	1
in chapter 12.	2
in chapter 9.10,	1
in chapter 11.	1
in newer versions	1
in sequence are	1
in linear algebra)	1
in row 28	1
in Windows. It	1
in situations where	3
in situations like	1
in device drivers	1
in terms of	8
in addition, set	1
in PC processors.	1
in almost all	2
in interpreted languages	1
in interpreted script	1
in vectors. These	1
in random order.	2
in Linux. 32-bit	1
in Linux. Address	1
in memory, as	1
in memory, at	1
in memory, but	1
in details. The	1
in thousand so	1
in Intel's Math	1
in registers, not	1
in registers, regardless	1
in registers, whereas	1
in registers, totaling	1
in dispatched version	1
in column 28	1
in column 28,	1
in embedded systems	2
in 32- bit	1
in edx as	1
in one. The	1
in edx, to	1
in Fortran where	1
in list, the	1
in ever more	1
in b[i] and	1
in regular patterns	1
in parallel. Modern	1
in parallel. Small	1
in parallel. Fine-grained	1
in parallel. Coarse-grained	1
in advance and	2
in advance which	1
in advance rather	1
in efficiency. For	1
in aa: StoreVector(aa	3
in aa: a.store(aa+i);	1
in C, C++	1
in sequential order	1
in www.agner.org/optimize/cppexamples.zip. An	1
in www.agner.org/optimize/cppexamples.zip. These	1
in tests on	1
in detail in	1
in detail on	1
in advance. The	2
in advance. This	1
in character arrays	1
in Windows). There	1
in Windows). Alternatively,	1
in comparisons, such	1
in kernel code"	1
in Unix-like systems	1
in Unix-like systems.	1
in vectors, but	1
in Day for	1
in x. The	1
in a. This	1
in Sum2 and	1
in ASCII form.	1
in scientific computing,	1
in stdint.h char	1
in non- sequential	1
in itself, and	1
in 36 C++	1
in p1 and	1
in question. You	1
in question. For	1
in doubt how	1
in use. The	1
in question without	1
in develop- ment	1
in C++: An	1
in C++: Preprocessor	1
in loops. Consider	1
in Wikipedia under	1
in Java, C#,	1
in reusable and	1
in time-critical code.	1
in exclusive mode,	1
in precompiled code.	1
in eax. The	1
in popularity when	1
in y. The	1
in duration compared	1
in interactive programs	1
in relation to	1
in edx. Furthermore,	1
in general. Assume	1
in scope. A	1
in advance, because	1
in two: //	1
in 2015 or	1
in nn ifbit=1	1
in Microsoft's .NET	1
in F1? Then	1
in connection with	1
in mind, that	1
in parts, for	1
in all, it	1
in applying the	1
in 2010. This	1
in a[] which	1
in disguise. Enums	1
in question: Put	1
in Windows) to	1
in isolation have	1
in parallel: Using	1
in green. It	1
in favor of	1
in a[i]. Note	1
in Linux). Threads	1
in nature, it	1
in meaningless event	1
The function is	2
The function that	1
The function code	1
The function may	1
The function library	1
The function call	1
The function names	1
The function F1	1
The function rounds	1
The if branch	1
The if statement	1
The code is	3
The code in	5
The code for	1
The code that	1
The code can	2
The code will	1
The code has	1
The code cache	2
The code examples	1
The code becomes	3
The code goes	1
The code section	3
The compiler is	3
The compiler can	6
The compiler may	12
The compiler will	7
The compiler has	3
The compiler makes	1
The compiler cannot	1
The compiler does	1
The compiler doesn't	2
The compiler option	1
The compiler supports	1
The compiler comes	1
The compiler sometimes	1
The compiler generates	1
The compiler inserts	1
The this pointer	1
The time that	1
The time it	9
The time you	1
The time when	1
The time used	1
The time unit	1
The time stamp	1
The time measurements	1
The time consumption	1
The use of	4
The } 59	1
The memory address	1
The memory space	2
The data in	1
The data have	1
The data cache	1
The data members	1
The data section	1
The program is	1
The program can	1
The program or	1
The program code	2
The program may	1
The program will	1
The program has	2
The program should	2
The program uses	1
The program logic	1
The vector class	1
The vector operations	1
The vector instructions	1
The different versions	2
The different threads	1
The different kinds	1
The same can	2
The same example	1
The same register	1
The same method	1
The same applies	2
The same rules	1
The same advice	1
The same argument	1
The same coding	1
The functions are	1
The functions must	1
The only way	1
The only allowed	1
The only CPUID	1
The CPU can	1
The CPU will	1
The CPU dispatcher	5
The CPU dispatch	2
The CPU supports	1
The CPU family	1
The CPU market	1
The other STL	1
The instruction add	2
The loop in	2
The loop can	1
The loop will	1
The loop branch	1
The loop would	1
The loop counter	1
The loop count	1
The loop control	1
The loop unrolling	1
The loop body	2
The loop initialisation	1
The cache line	2
The cache works	1
The integer size	1
The integer division	1
The integer representation	1
The integer comparison	1
The floating point	1
The example on	1
The compilers are	2
The compilers will	1
The compilers also	1
The compilers I	1
The most efficient	2
The most critical	1
The most important	5
The most common	4
The most compatible	1
The most serious	1
The most commonly	2
The size of	7
The size should	1
The size conversion	1
The size (in	1
The Intel compiler	8
The Intel vector	1
The Intel compilers	1
The pointer is	1
The library function	1
The library has	1
The float type	1
The multiple CPU	1
The two comparisons	1
The two summation	1
The object that	1
The object oriented	1
The object pointed	1
The number of	7
The static memory	1
The static data	1
The static keyword	2
The static declaration	1
The 64-bit version	1
The 64-bit systems	1
The C++ way	1
The C++ language	2
The C++ exception	1
The C++ syntax	1
The clock frequency	3
The clock counts	1
The version that	2
The value is	1
The value of	3
The objects are	1
The objects stored	1
The return type	1
The table of	1
The table can	1
The table should	1
The table shows	2
The performance is	1
The performance can	1
The performance on	1
The performance monitor	1
The performance measurement	1
The order of	2
The order in	1
The branch inside	1
The branch target	1
The member functions	1
The way to	2
The elements at	1
The const keyword	1
The address of	2
The critical stride	3
The operating system	3
The unsigned integer	1
The first time	1
The first two	1
The first way	1
The first processors	2
The first eight	1
The first count	2
The first thing	2
The first generation	2
The register stack	1
The register keyword	2
The 64 bit	1
The 64 64	1
The libraries included	1
The template parameter	1
The need for	1
The test data	1
The test should	1
The test tool	1
The user may	1
The user interface	1
The user expects	1
The method is	2
The method of	2
The method in	1
The method used	1
The method described	1
The method currently	1
The access is	1
The SSE2 instruction	3
The following compiler	1
The following example	17
The following table	2
The following list	1
The following methods	1
The following examples	1
The following algorithm	1
The following sections	1
The following guidelines	1
The following considerations	1
The following techniques	1
The system is	1
The file will	1
The file http://www.agner.org/optimize/asmlib.zip	1
The dynamic libraries	1
The type of	1
The type __m128i	1
The type __m128	1
The type __m128d	1
The & operator	1
The instructions mov	1
The constant N1	1
The constant (2n	1
The stack is	2
The stack unwinding	2
The Gnu function	1
The Gnu compiler	6
The Gnu C++	1
The Gnu libraries	1
The extra time	1
The assembly output	1
The assembly listing	1
The Windows and	1
The Windows version	1
The calculations may	1
The execution times	1
The execution core	1
The result is	1
The result of	2
The result will	1
The result ebx	1
The threads have	1
The best function	1
The best compilers	1
The best possible	1
The best performance	3
The best way	2
The best solution	1
The best Java	1
The speed is	1
The speed of	1
The speed for	1
The speed on	1
The speed test	1
The c loop	1
The virtual processor	1
The common excuse	1
The AMD math	1
The exception is	2
The allocated memory	2
The AVX instruction	1
The AVX instructions	1
The optimized code	1
The optimized part	1
The calculation of	4
The calculation becomes	1
The calculation here	1
The parameters a	1
The problem is	1
The problem with	1
The problem only	1
The problem here	1
The solution a	1
The container class	1
The advantage of	8
The operators are	1
The operators &,	1
The few clock	1
The standard template	1
The standard stack	1
The standard solution	1
The hardware definition	1
The values of	1
The values are	2
The sign is	1
The copy constructor	1
The copy constructors	1
The copy constructor,	1
The intermediate code	1
The intermediate file	1
The intermediate files	1
The allocation of	1
The allocation and	1
The above code	3
The above example	1
The above examples	1
The optimal number	1
The space is	1
The dispatching to	1
The dispatching mechanism	1
The next time	1
The next instruction	1
The next example	1
The next two	1
The next line	1
The next section	1
The next chapter	1
The branches may	1
The multiplication by	2
The application program	2
The expression a	1
The expression that	1
The expression (Tuesday	1
The Boolean operations	1
The Boolean operators	1
The intrinsic vector	1
The development time	2
The name of	1
The name "position-independent	1
The conversion of	1
The conversion time	1
The conversion from	1
The conversion between	1
The disadvantage is	3
The disadvantage of	4
The high speed	1
The high priority	1
The Microsoft and	1
The Microsoft compiler	1
The division is	1
The source code	1
The cost of	4
The automatic dispatching	1
The automatic vectorization	1
The reason is	4
The reason for	3
The reason why	3
The reason is,	1
The dispatcher function	1
The dispatcher changes	1
The string classes	1
The string length	1
The programmer can	1
The programmer does	1
The programmer typically	1
The three functions	1
The three clauses	1
The keyword static,	4
The keyword __fastcall	1
The examples in	1
The examples are	1
The examples on	1
The difference is	1
The difference between	1
The difference lies	1
The mechanism of	1
The mechanism relies	1
The last line	1
The load time	1
The calling function	1
The XMM vector	1
The second way	1
The second thing	1
The second generation	2
The bigger vectors	1
The AVX2 instruction	1
The x86 processors	1
The process of	1
The 512 512	1
The advantages of	9
The results of	1
The results are	2
The storage of	1
The storage principles	1
The old C-style	1
The union forces	1
The link to	1
The link order	1
The appropriate version	1
The constructor or	1
The constructor sets	1
The operands of	1
The range of	1
The smaller the	1
The core clock	2
The negative effects	1
The main advantage	1
The main reason	1
The main focus	1
The positive effects	1
The overhead of	4
The change of	1
The installation of	1
The installation program	1
The installation process	1
The syntax is	1
The syntax in	1
The syntax may	1
The choice of	5
The profiler counts	1
The profiler tells	2
The profiler inserts	1
The profiler measures	1
The profiler identifies	1
The modern microprocessors	1
The network access	1
The level-2 cache	1
The fact that	4
The output goes	1
The vectorized code	1
The costs of	3
The preceding paragraph	1
The safe way	1
The Pentium 4	1
The Pentium Pro	1
The efficiency of	4
The exponent is	2
The conditions that	1
The maximum loop	1
The maximum size	1
The maximum number	3
The alignment of	1
The offset of	1
The effect is	2
The effect of	3
The so-called objects	1
The so-called nontemporal	1
The so-called iterators	1
The total size	1
The child class	1
The child classes	1
The containers in	1
The counters will	1
The 128-bit XMM	2
The names of	2
The details of	1
The details about	1
The square brackets	1
The bitwise operators	3
The bitwise AND	1
The heap can	1
The heap space	1
The heap manager	3
The target of	1
The target address	1
The nontemporal write	1
The simplest and	1
The simplest possible	1
The simplest way	1
The simplest case	1
The situation is	1
The delay is	2
The delay on	1
The newer instruction	1
The sequence of	1
The length of	2
The penalty of	1
The reasons for	1
The alternative solution	1
The 'this' pointer	1
The gain in	1
The gain depends	1
The declaration of	1
The map file	2
The microarchitecture of	1
The 256-bit YMM	1
The subsequent counts	1
The subsequent sections	1
The subsequent manuals	1
The transfer of	1
The latter is	2
The search for	1
The logic of	1
The Microsoft, Intel	1
The typical way	1
The usability may	1
The procedure to	1
The frequent allocation	1
The algorithms used	1
The PLT entry	1
The inputs for	1
The fastest execution	1
The Gnu, Intel	1
The preferred method	1
The volatile keyword	2
The YMM registers	1
The purpose is	1
The purpose of	3
The D language	1
The carry bit	1
The trick is	1
The trick of	2
The trick will	1
The trick violates	1
The disadvantages of	1
The update process	1
The developers may	1
The profilers are	1
The linker will	1
The representation of	1
The Clang compiler	2
The measured time	1
The measured results	1
The factor sizeof(S1)	1
The rules for	1
The latest versions	1
The log on	1
The CodeGear compiler	1
The principle of	2
The availability of	1
The .NET framework	2
The newest instruction	1
The prefetch instruction	1
The debugger cannot	1
The behavior of	1
The 32- bit	1
The worst case	1
The worst problem	1
The biggest disadvantage	1
The third thing	1
The CISC instruction	2
The AND operator	1
The context switches	1
The live range	1
The OR operator	1
The advice of	1
The pow function	1
The pitfalls of	2
The equivalent expression	1
The Codeplay compiler	1
The present manual	1
The highest performance	1
The highest efficiency	1
The "Intel Math	1
The pre-increment operator	1
The older MMX	1
The 17 debug	1
The empty throw()specification	1
The missing functions	1
The powN template	2
The lengths of	1
The splitting of	2
The consequence is	1
The consequence of	1
The original method	1
The returned pointer	1
The existing object	1
The explicit use	1
The MOVNTQ instruction	2
The implicit 'this'	1
The tests were	1
The conclusion is	2
The conclusion to	1
The C/C++ standard	1
The Intel-based Mac	1
The updating mechanism	1
The exponential function	1
The generality of	1
The initialization routine	1
The -fpie option	1
The easiest way	2
The history of	1
The CPU- specific	1
The InstructionSet() function	1
The unrolled loop	1
The built-in code	1
The symbol interposition	1
The fastcall modifier	1
The preprocessing macro	1
The formats can	1
The FDIV bug	1
The dynamic_cast operator	1
The opposite of	1
The opposite order	1
The proxy is	1
The const_cast operator	1
The resulting code	1
The DLLs are	1
The renaming mechanism	1
The indirect function	1
The theoretical background	1
The pragmas must	1
The branching is	1
The creation of	1
The integrated development	1
The recursion must	1
The insight you	1
The funny looking	1
The clumsy AND-OR	1
The procedures for	1
The [] operator	1
The similarity between	1
The vulnerability of	1
The 16-byte instructions	1
The dot in	1
The Core2 processor	1
The benchmark performance	1
The recommendations are	1
The radical solution	1
The absence of	1
The fallacy of	1
The benefits of	1
The allocation, deallocation	1
The ?: operator	1
The lesson we	1
The FactorialTable in	1
The CodeGear, Codeplay	1
The ultimate solution	1
The official C	1
The reinterpret_cast operator	1
The characters '?',	1
The undocumented Intel	1
The static_cast operator	1
The IPP library	1
The distinctions between	1
The inequality sign	1
The i<20 loop	1
The compactness of	1
The loop-branch is	1
The advise of	1
The sin function	1
The MASM assembly	1
for the function	1
for the compiler	7
for the memory	1
for the vector	1
for the same	6
for the functions	1
for the CPU	3
for the other	1
for the instruction	2
for the loop	1
for the class	1
for the size	1
for the Intel	1
for the two	1
for the object	1
for the C++	1
for the performance	1
for the 32-bit	1
for the critical	1
for the first	2
for the new	1
for the user	1
for the SSE2	2
for the following	3
for the cases	1
for the error	1
for the stack	1
for the result	1
for the specific	2
for the common	2
for the exception	2
for the overflow	1
for the AVX	2
for the calculation	1
for the parameters	1
for the supported	1
for the hardware	1
for the intermediate	1
for the next	1
for the programmer	4
for the three	1
for the end	2
for the difference	1
for the link	1
for the appropriate	1
for the main	1
for the installation	1
for the desired	2
for the whole	1
for the level-2	1
for the level-1	1
for the object.	1
for the sake	13
for the performance.	1
for the child	1
for the stack.	2
for the logical	1
for the simplest	1
for the CPU.	1
for the user.	2
for the Microsoft,	1
for the purpose	1
for the latest	2
for the application.	1
for the availability	1
for the .NET	1
for the project	1
for the commercial	1
for the linker.	1
for the FDIV	1
for the reinstallation	1
for the IDE,	1
for the "FDIV	1
for the label.	1
for the <,	1
for the pros	1
for the newsgroup	1
for is likely	1
for a and	1
for a very	1
for a new	1
for a Windows	1
for a result	1
for a specific	4
for a single	1
for a virtual	1
for a few	1
for a list	1
for a particular	5
for a higher	2
for a 512	1
for a given	2
for a further	1
for a discussion	2
for a low	1
for a lower	1
for a portable	1
for a console	1
for a discussion.	1
for a 2'nd	1
for // multiply	1
for function libraries	1
for function F1.	1
for code that	2
for code bloat	1
for an integer	1
for an example	2
for an explanation	6
for an increasing	1
for an explanation.	2
for an example.	1
for x to	1
for this is	1
for this instruction	1
for this manual	1
for this function,	1
for this task	1
for this shift	1
for this efficiency	1
for this purpose.	1
for this purpose,	1
for this reason.	1
for use as	1
for more than	1
for more information	1
for more complicated	1
for more advanced	1
for more discussion	1
for vector operations.	1
for vector operations,	1
for vector intrinsics.	1
for different instruction	3
for different Intel	1
for different C++	6
for different objects	1
for different processors	2
for different arrays	1
for different matrix	1
for different compilers.	1
for different CPUs.	2
for different platforms	1
for different purposes	1
for different microprocessors,	1
for functions that	1
for CPU dispatching	1
for CPU brand	1
for other integer	1
for other virtual	1
for other purposes.	2
for other brands	1
for other purposes	2
for other reasons,	1
for other optimizations,	1
for all the	2
for all functions	1
for all static	1
for all these	1
for all public	1
for all modules	1
for all platforms.	1
for all unknown	1
for all applications.	1
for all suitable	1
for all objects.	1
for all Unix-like	1
for all major	1
for all squares:	1
for one array	1
for one segment	1
for integer vector	1
for integer division	1
for integer overflow.	1
for integer constants.	1
for class member	1
for floating point	4
for floating 26	1
for each function	1
for each different	1
for each other	1
for each instruction	1
for each set	1
for each version	2
for each test	1
for each type	1
for each processor	1
for each element	1
for each thread	1
for each allocated	1
for each line	1
for each process	1
for each object.	1
for each iteration	1
for each thread.	3
for each version.	1
for each row	1
for each process.	2
for each calculation.	1
for example to	1
for example if	2
for example when	2
for example i	1
for example 32	1
for example every	1
for example 9.5	1
for compilers that	1
for most purposes	1
for using the	1
for using an	1
for using overloaded	1
for double precision.	2
for size is	1
for size and	1
for Intel CPUs.	1
for Intel CPUs,	1
for pointer conversions.	1
for library functions.	1
for float expressions	1
for multiple variables	1
for multiple purposes.	2
for 64-bit operating	1
for 64-bit Linux	1
for 64-bit integers.	1
for 64-bit Windows).	1
for C++ for	1
for such optimizations	1
for such errors	1
for such applications,	1
for array elements	1
for array bounds	3
for array sizes	1
for many of	1
for many different	2
for many common	1
for many standard	1
for many applications	1
for many computer	1
for many programmers	1
for many platforms,	1
for many years	1
for objects stored	2
for any other	1
for any library	1
for any compile-time	1
for some small	1
for some CPU-intensive	1
for some caveats.	1
for some links.	1
for variables that	1
for variables declared	1
for performance reasons.	1
for very long	1
for very large	2
for software to	1
for software users	1
for software teachers	1
for 32-bit and	2
for 32-bit software	1
for 32-bit Windows	1
for 32-bit Mac	2
for 32-bit Windows,	1
for 32-bit Windows.	2
for 32-bit integers,	1
for branch prediction	1
for branch mispredictions.	1
for member functions.	1
for elements in	1
for elements inside	1
for address calculation	1
for critical applications	1
for less intensive	1
for example, to	2
for example, that	1
for example, you	3
for register variables	1
for register variables.	1
for register storage.	1
for how to	7
for test purposes.	2
for user input	2
for user input.	3
for these variables.	1
for these calculations.	1
for these methods.	1
for even the	1
for sure whether	1
for SSE2 and	1
for SSE2 or	1
for system code.	1
for file input	1
for dynamic allocation.	1
for simple types	1
for simple tasks	1
for simple variables,	1
for simple tasks.	1
for making the	1
for making a	1
for making data	1
for making multiple	1
for making clear	1
for making plug-ins	1
for CPUs with	2
for assembly language	1
for assembly programmers	1
for assembly output.	1
for large data	1
for large libraries	1
for arrays bigger	1
for Windows and	3
for Windows are	1
for Windows applications.	1
for execution speed	1
for big objects	1
for threads that	1
for best performance.	1
for speed is	1
for speed or	1
for speed /O2	1
for specific CPU	2
for single precision	1
for several different	2
for several seconds	1
for several iterations	1
for several reasons.	1
for common mathematical	1
for AMD CPUs	1
for AMD CPUs.	1
for AMD Family	1
for exception handling	1
for small x	2
for small embedded	1
for overflow of	2
for overflow and	1
for overflow by	1
for overflow before	1
for overflow outside	1
for good code	1
for matrix a:	1
for Linux have	1
for Linux systems.	1
for Linux platforms	1
for AVX or	1
for another memory	1
for (i =	29
for support of	1
for doing two	1
for doing some	1
for doing parallel	1
for inline assembly	1
for every element	1
for every four	1
for every iteration	1
for standard tasks	1
for sign and	1
for copy constructors	1
for optimizing execution	1
for optimizing code,	1
for information stored	1
for certain tasks	1
for intermediate results,	1
for fast and	1
for fast 32-bit	1
for fast access	1
for fast division	1
for fast math	1
for (int i	13
for (int n	1
for programs that	1
for programs implemented	1
for Mac OS	1
for multiplication }	1
for handling a	1
for Boolean vector	1
for intrinsic functions	3
for intrinsic functions,	1
for mathematical functions	1
for high precision	2
for source annotation	1
for running multiple	1
for automatic CPU	1
for automatic updates,	1
for string searching	1
for better metaprogramming	1
for applications that	1
for examples of	3
for char pointers.	1
for char pointers).	1
for runtime type	1
for actually making	1
for Intel, AMD	1
for later maintenance.	1
for calling from	1
for your compiler	1
for your application	1
for XMM registers;	1
for vectors There	1
for AVX2 and	1
for x86 platforms.	1
for old processors	1
for advanced programmers	1
for switch statements	1
for switch statements,	1
for things like	1
for negative numbers.	1
for example: Use	1
for positive and	1
for positive n.	1
for my optimization	1
for my test	1
for relative addressing	1
for installation and	1
for Windows, while	1
for Windows, Linux	2
for Windows, -msse2,	1
for inlining a	1
for network resources	1
for whole program	2
for level-2 cache	1
for response from	1
for vectorization Not	1
for checking multiple	2
for checking how	1
for level-1 cache	1
for vectorized table	2
for local objects	1
for local references.	2
for constants that	1
for special position-independent	1
for special purposes	1
for further discussion	3
for further optimizations.	1
for further explanation.	1
for further discussion.	1
for further expansions	1
for discussion of	2
for testing multiple	1
for testing single	1
for tasks such	1
for optimization. For	1
for accessing the	1
for accessing a	1
for accessing arrays	1
for accessing container	1
for accessing list[i].a	1
for adding bounds-checking	1
for 16-bit mode	1
for disk operations	1
for classes. The	1
for N a	1
for N =	2
for details on	1
for details about	1
for details (www.agner.org/optimize/testp.zip).	1
for containing thread-specific	1
for initialized variables	1
for improved performance.	1
for updates should	1
for updates each	1
for updates every	1
for parallel processing.	1
for calculating the	4
for calculating a	1
for calculating row	1
for calculating self-	1
for SSE4.1 and	1
for garbage collection.	1
for buffer overflow	1
for future models	1
for unaligned arrays.	1
for significant improvements.	1
for reasons of	2
for reasons explained	4
for setting up	1
for 'this' is	1
for Windows. 10	1
for approximately two	1
for finding the	4
for finding problems	1
for finding hot	1
for finding elements.	1
for hard disk	1
for usability reasons.	1
for overflow. This	1
for overflow. Example:	1
for false and	1
for temporary storage.	1
for prediction and	1
for background services	1
for background jobs.	1
for interrupt 3.	1
for general function	1
for general purposes	1
for multiplying the	1
for random number	1
for D are	1
for debugging and	1
for debugging facilities,	1
for Linux. It	1
for Linux. 82	1
for Java today.	1
for executing the	1
for free in	1
for ( ;	1
for exceptions thrown	1
for storing function	1
for storing user	1
for storing text	1
for powers of	1
for polymorphism A	1
for details. The	1
for details. //	1
for details. Use	1
for details. Note	1
for details. Development	1
for details. Inheritance	1
for speed. Optimizing	1
for giving the	1
for giving specific	1
for converting the	1
for converting a	1
for specifying parallel	1
for self-relative addressing	1
for 32- and	2
for security reasons	1
for communication and	1
for communication between	1
for avoiding the	1
for avoiding infinite	1
for internal references.	3
for reducing the	1
for strict floating	1
for (c =	4
for lists that	1
for computing mathematical	1
for computing i/2+r.	1
for Basic soon	1
for CPU-intensive code,	1
for present processors	1
for turning off	1
for regular access	1
for true. Boolean	1
for defining constants.	1
for restrictions on	1
for overflow, and	1
for transferring composite	1
for transferring additional	1
for saving a	1
for saving memory	1
for saving registers	1
for (b +	1
for mixing different	1
for mixing single	1
for (r =	4
for detailed instructions.	1
for application-specific code.	1
for virus scanners	1
for constants. Integer	1
for prefetching data	1
for aligning data	1
for assuming no	1
for speed-critical functions	1
for speed-critical functions.	1
for calculations: for	1
for multi-core processing.	1
for generality and	1
for (i=0; i<100;	1
for (i=0; i<n;	2
for implementing a	1
for implementing polymorphic	1
for cleaning up	1
for improving the	1
for improving code	1
for organizing data	1
for metaprogramming, as	1
for InstructionSet() #include	2
for (x =	3
for free. Visual	1
for interpreting or	1
for jumping out	1
for modifying the	1
for vacant spaces.	1
for supporting multiple	1
for supporting multi-threaded	1
for uninitialized variables	1
for putting the	1
for preventing program	1
for creating and	1
for Unix applications	1
for audio and	1
for updating. The	1
for (c2 =	2
for marketing reasons.	1
for verifying the	1
for WTL applications	1
for millisecond resolution.	1
for "assume no	1
for manipulating floating	2
for parallelization in	1
for AVX. These	1
for AVX. 5.	1
for Tuesday, Wednesday	1
for dealing with	1
for trivial tasks	1
for recovering or	1
for studying a	1
for statistics, signal	1
for exclusive access	1
for assigning different	1
for relieving the	1
for shared_ptr than	1
for (r2 =	2
for exploiting fine-grained	1
for IA-32/Intel64, 2009.	1
for transposition of	1
for issuing an	1
for incrementing a	1
for Linux) 4.	1
for those who	1
for investigating performance	1
for vectorization............................................................. 117	1
for detecting errors	1
for transposing and	1
for foreground jobs	1
for minimizing memory	1
for (j =	1
for auto_ptr. Smart	1
for response. It	1
for vectors........................................................................ 119	1
for holding the	1
for (c1 =	1
for signifying one	1
for demonstration purposes.	1
for SSE2, preferably	1
for hackers. It	1
for (row =	1
for (r1 =	1
for pow(x,N) where	1
for both, while	1
for combining multiple	1
for (temp =	1
for correctness must	1
for vectorizing mathematical	1
for Nerds at	1
for everything, which	1
for analysis. If	1
for fetching a	1
for Basic. A	1
for details). The	1
for educational purposes	1
for correctness. It	1
for RTTI then	1
for 80x86 /	1
for speeding up	1
for "standard stack	1
for AVX2, or	1
for "function level	1
for raising an	1
for NOT. Instead,	1
for discussions. Turn	1
for (column =	1
for reserving memory	1
for identifying hot	1
for distinguishing between	1
that the function	6
that the if	1
that the code	5
that the compiler	8
that the use	1
that the memory	2
that the same	1
that the only	1
that the CPU	5
that the loop	2
that the cache	1
that the integer	1
that the floating	1
that the compilers	2
that the most	1
that the Intel	3
that the pointer	1
that the two	1
that the object	2
that the number	2
that the 64-bit	1
that the clock	3
that the value	7
that the objects	1
that the variable	2
that the variables	1
that the table	1
that the software	1
that the order	1
that the member	1
that the elements	1
that the address	1
that the critical	1
that the bit	1
that the operating	1
that the first	1
that the template	1
that the user	3
that the system	2
that the type	1
that the arrays	2
that the result	1
that the processor	1
that the compiled	1
that the list	1
that the values	2
that the addresses	1
that the microprocessor	4
that the next	3
that the name	1
that the conversion	1
that the dispatcher	1
that the programmer	2
that the end	2
that the last	1
that the numbers	1
that the operands	2
that the overhead	1
that the C	1
that the syntax	1
that the choice	2
that the level-2	1
that the response	2
that the repeat	1
that the alignment	1
that the compatibility	1
that the final	1
that the amount	1
that the rows	1
that the beginning	1
that the declaration	1
that the background	1
that the linker	1
that the representation	1
that the break	1
that the portability	1
that the behavior	1
that the rest	1
that the loader	1
that the original	1
that the C/C++	1
that the resulting	1
that the branching	1
that the reader	1
that the overall	1
that the remaining	1
that the producer	1
that the occurrence	1
that is a	3
that is not	1
that is an	1
that is more	1
that is used	5
that is most	1
that is two	1
that is member	1
that is stored	1
that is called	2
that is always	1
that is part	1
that is compiled	2
that is big	2
that is allocated	2
that is calculated	1
that is four	1
that is shared	1
that is optimal	1
that is n	1
that is difficult	1
that is longer	1
that is actually	1
that is divisible	3
that is compatible	3
that is obtained	1
that is initialized	1
that is easier	1
that is organized	1
that is added	1
that is almost	1
that is measured	1
that is larger	1
that is AND'ed	2
that is said	2
that is coded	1
that is slow,	1
that is ported	1
that is distributed.	1
that a is	1
that a function	3
that a compiler	1
that a will	1
that a program	1
that a loop	1
that a value	1
that a variable	3
that a call	1
that a template	1
that a new	1
that a user	1
that a must	1
that a specific	1
that a particular	4
that a binary	1
that a positive	1
that a detailed	1
that a user-defined	1
that a low-priority	1
that of yesterday's	1
that for a	1
that are not	5
that are only	1
that are used	14
that are no	1
that are so	1
that are very	1
that are stored	1
that are available	1
that are up	1
that are best	1
that are allocated	1
that are shared	1
that are members	1
that are never	2
that are running	1
that are too	1
that are needed	1
that are difficult	1
that are declared	2
that are bigger	1
that are called.	1
that are based	1
that are intended	1
that are particularly	2
that are scattered	1
that are missing	1
that are coded	1
that are modified	1
that are read-only	1
that are impossible	1
that are fine-tuned	1
that are inherently	1
that can be	16
that can make	1
that can do	1
that can call	1
that can take	1
that can reduce	1
that can go	1
that can prevent	1
that can tell	1
that can possibly	2
that can easily	1
that can benefit	1
that can skip	1
that can steal	1
that it is	15
that it can	9
that it may	3
that it will	1
that it has	2
that it takes	3
that it makes	2
that it cannot	2
that it does	2
that it doesn't	4
that it allows	2
that it becomes	1
that it calls.	2
that it rarely	1
that it writes	1
that it fits	1
that it adds	1
that it jumps	1
that it attempts	1
that if the	1
that if a	1
that if you	1
that if each	1
that code cache	1
that an object	1
that an optimizing	1
that compiler makers	1
that x is	1
that may be	4
that may need	1
that may improve	1
that you are	1
that you can	5
that you have	2
that you should	1
that you want	5
that you compile	1
that you optimized	1
that you see	1
that you don't	2
that you measure	1
that you analyze	1
that have a	1
that have to	1
that have floating	1
that have multiple	2
that have many	1
that have big	1
that have support	1
that have values	1
that have Boolean	1
that have tested	1
that have Booleans	1
that this is	1
that this method	1
that this part	1
that use the	2
that use only	1
that use these	1
that use large	1
that use big	1
that memory access	1
that data are	1
that has a	1
that has to	1
that has no	1
that has been	2
that has already	1
that make it	2
that make function	1
that make member	1
that make up	1
that make vectorization	2
that make developers	1
that different threads	1
that functions which	1
that only one	1
that all the	1
that all code	2
that all floating	1
that all variables	1
that all software	1
that all allocated	1
that all operators	1
that all destructors	3
that one function	1
that one thread	1
that should not	2
that no function	1
that no object	1
that no variable	1
that no overflow	1
that floating point	1
that each value	2
that each calculation	1
that each particular	1
that each intrinsic	1
that each statement	1
that do not	4
that do have	1
that do much	1
that most function	1
that most variables	1
that most software	1
that double precision	1
that pointer aliasing	1
that b is	1
that i can	1
that two pointers	1
that static linking	1
that there is	5
that there are	6
that there was	1
that C++ compilers	1
that also repeats	1
that such feature	1
that such devices	1
that such contrived	1
that many common	1
that many users	1
that takes a	1
that takes more	1
that takes advantage	1
that takes longer	1
that takes care	2
that we are	1
that we can	4
that we may	1
that we have	1
that we do	1
that we want	1
that we don't	2
that we know	1
that we expect	1
that some compilers	1
that some expression	1
that some development	1
that some microprocessors	1
that variables that	1
that software performance	1
that software developers	1
that software projects	1
that branch and	1
that makes code.	1
that makes sure	1
that take a	1
that take only	1
that take up	2
that need to	3
that need relocation.	1
that need relocation,	1
that pointers of	1
that pointers to	1
that pointers do	1
that these functions	1
that these integer	1
that these methods	1
that these directives	1
that they are	1
that they cannot	2
that they always	1
that they are.	1
that always goes	1
that access the	1
that access times	1
that I have	1
that I consider	1
that does the	2
that does floating	2
that must be	1
that work on	1
that calls the	2
that calls at	1
that calls other	1
that calls it.	1
that processor model	2
that big arrays	1
that doesn't call	2
that doesn't cause	1
that doesn't add	1
that doesn't automatically	1
that doesn't handle	1
that doesn't compromise	1
that threads can	1
that several variables	1
that exception handling	1
that overflow can	1
that overflow never	1
that cause the	1
that works for	1
that works on	1
that works best	2
that works well	1
that uses the	1
that uses a	1
that uses pointers	1
that uses few	1
that uses 90%	1
that container classes	1
that support the	1
that support a	1
that support this	1
that support intrinsic	1
that support it.	1
that supported 128-bit	1
that supported 256-bit	1
that contains only	1
that contains integer	1
that contains several	1
that would otherwise	1
that run in	2
that run many	1
that every function	1
that standard library	1
that add functionality	1
that simply prints	1
that certain calculations	1
that certain parts	1
that count how	1
that was used	1
that was unknown	1
that was saved	1
that particular part.	1
that branches can	1
that typically use	1
that typically take	1
that automatically reduces	1
that caching becomes	1
that allows you	2
that allows less	1
that allows bigger	1
that allows overriding	1
that allows direct	1
that don't need	1
that signed integer	1
that model N+1	1
that model N-1	1
that needs to	3
that needs them.	1
that what is	1
that source and	1
that n is	1
that string as	1
that requires several	1
that requires compilation	1
that your code	1
that generate floating	1
that r points	2
that goes one	1
that goes many	1
that goes randomly	1
that 10 is	1
that were not	1
that were unknown	5
that require cleanup	1
that depends only	1
that supports automatic	1
that supports this).	1
that my optimization	1
that p is	1
that p always	1
that index is	1
that modern processors	1
that gives the	3
that comes to	1
that comes with	1
that rely on	2
that rely heavily	1
that produce Boolean	1
that produce streaming	1
that macro parameters	1
that variable. The	1
that fit the	1
that fit their	1
that includes the	1
that allow you	1
that come with	3
that similar solutions	1
that future compilers	1
that seconds remains	1
that something takes	2
that F1 will	1
that checks whether	1
that programmers write	1
that current compilers	1
that contain pure	1
that could benefit	1
that everything that	1
that branch. The	1
that jump between	1
that volatile doesn't	1
that measurements are	1
that reads or	1
that fits the	2
that follows a	1
that computers have	1
that depend on	1
that communication between	1
that memset is	1
that specifies how	1
that select the	1
that select between	1
that created a	1
that already works	1
that relies on	1
that runs quite	1
that runs under	1
that runs alone	1
that belong to	1
that performs best	1
that produces a	1
that produces another	1
that u.f and	1
that *p+2 is	2
that chooses between	2
that 150 you	1
that avoids overflow:	1
that seldom occur	1
that begin with	1
that N1 =	1
that appears in	1
that behaves like	2
that consumes most	1
that reflects the	1
that lies r	1
that copies the	1
that allocates memory	1
that scans all	2
that delays execution	1
that holds a	1
that a+b is	1
that decide how	1
that measures the	2
that accesses data	1
that accesses b	1
that thrown exceptions	1
that treats different	1
that loads the	1
that waits for	1
that covered the	1
that begins with	1
that previously required	1
that CParent::Hello() has	1
that owns the	1
that limits the	1
that transfers ownership	1
that looses ownership	1
that hackers often	1
that dates back	1
that u <	1
that connect them.	1
that "we don't	1
that draws a	1
that violate or	1
that (b*c) overflows,	1
that saves time	1
that r+i/2 could	1
that crashes the	1
that doesn’t. The	1
that discriminates between	1
that destroys any	1
that relate to	1
that shares the	1
that detects an	1
that matters rather	1
be the one	1
be the optimal	1
be the fastest	1
be the easiest	1
be a time	1
be a class	1
be a very	2
be a member	1
be a register	1
be a simple	1
be a constant	1
be a good	1
be a power	4
be a disadvantage	1
be a better	2
be a difference	1
be a binary	1
be a destructor	1
be a waste	2
be a hundred	1
be a compromise	1
be a type.	1
be a bottleneck	1
be a viable	2
be a time-consumer	1
be a slight	1
be a million	1
be a level-3	1
be of the	1
be of some	1
be to include	1
be in the	3
be as small	1
be as standardized	1
be an efficient	3
be an advantage	2
be an expression	1
be an integer.	1
be an obvious	1
be an annoying	1
be an infinite	1
be time consuming	1
be more efficient	2
be more convenient	1
be more (128	1
be at a	1
be different for	1
be different sizes,	1
be because the	1
be only one	2
be used to	2
be used in	3
be used for	14
be used if	5
be used with	1
be used on	1
be used as	5
be used when	1
be used only	2
be used where	1
be used without	1
be used most.	1
be used freely	1
be cache contentions	1
be no extra	1
be no certain	1
be set then	1
be set up	1
be two or	1
be efficient whether	1
be possible to	6
be so many	1
be so high	1
be 2 In	1
be very efficient	1
be very long	2
be very useful	2
be very inefficient	1
be very helpful	1
be faster than	2
be faster when	1
be faster despite	1
be stored in	10
be stored with	1
be stored on	1
be stored at	2
be stored together	3
be stored together......................................	1
be called when	1
be called from	3
be called only	1
be called before	1
be called whenever	1
be 8 and	1
be less than	3
be less efficient	2
be 64 bits	1
be useful to	6
be useful in	6
be useful for	5
be useful if	1
be useful when	1
be even faster	1
be sure that	2
be 0 or	2
be cases where	2
be available in	1
be important if	1
be accessed with	2
be accessed from	2
be accessed approximately	1
be accessed sequentially	1
be while (0	1
be compiled with	1
be compiled as	1
be compiled three	1
be necessary to	3
be necessary in	1
be allocated for	1
be allocated dynamically	3
be allocated dynamically.	2
be done in	1
be done by	2
be done with	5
be done on	1
be done as	1
be done at	1
be done outside	1
be done manually	1
be optimized if	1
be optimized by	1
be optimized to:	1
be optimized further.	1
be inside the	1
be calculated in	1
be calculated by	6
be calculated with	1
be calculated as	3
be calculated more	1
be calculated at	1
be calculated using	1
be calculated independently.	1
be advantageous to	7
be advantageous or	1
be advantageous if	2
be advantageous when	1
be implemented in	6
be implemented with	1
be implemented as	5
be implemented like	1
be implemented either	2
be known at	1
be 1 b	1
be able to	12
be able do	1
be certain that	1
be shared between	1
be quite a	1
be quite inefficient	1
be quite time-consuming	1
be quite tedious	1
be quite substantial.	1
be used. If	1
be used. We	1
be used. Web	1
be fast in	1
be both cheaper	1
be optimal to	2
be optimal in	1
be signed or	1
be separate for	1
be put into	1
be put away	1
be three or	1
be better to	2
be better than	1
be better because	1
be too small.	1
be too worried	1
be too small,	1
be needed for	1
be needed because	1
be difficult to	3
be transferred in	5
be longer than	1
be read and	1
be read into	1
be read before	1
be aligned by	3
be linked into	2
be linked together	1
be linked either	1
be declared in	1
be declared const	1
be declared inside	2
be declared volatile.	1
be higher due	1
be bigger than	1
be divisible by	2
be called. It	1
be based on	1
be made for	1
be made more	1
be made available	1
be made about	1
be made much	1
be made smaller	1
be made local.	1
be just as	1
be smaller as	1
be relevant when	1
be replaced by	7
be replaced with:	2
be negative so	1
be tested in	1
be tested with	1
be tested on	2
be tested under	1
be predicted or	1
be predicted by	1
be predicted quite	1
be predicted depends	1
be predicted well.	1
be predicted perfectly	2
be predicted perfectly.	1
be loaded from	1
be loaded at	2
be loaded only	1
be loaded into	1
be loaded every	1
be loaded until	1
be loaded anyway.	1
be C or	1
be compatible with	3
be dynamically created	1
be avoided in	1
be avoided by	9
be avoided on	1
be avoided when	1
be avoided because	2
be avoided unless	1
be 2. The	1
be particularly time	1
be given a	1
be given in	1
be limited by	1
be vectorized if	2
be vectorized with	1
be vectorized as	1
be vectorized automatically.	1
be inlined for	1
be inlined or	1
be inlined by	1
be safe to	1
be safe if	1
be further tested	1
be reduced to	2
be reduced to:	1
be clear from	1
be obtained in	1
be obtained by	1
be obtained with	2
be overloaded or	1
be possible. Template	1
be changed to	2
be changed by	1
be changed without	1
be changed to:	2
be changed freely.	1
be true anyway.	1
be initialized to	2
be initialized when	1
be improved is	1
be improved in	1
be improved by	8
be loading the	1
be below the	1
be copied or	1
be copied into	1
be copied simply	1
be invalid and	1
be invalid in	1
be invalid if	1
be used, but	1
be used, even	1
be organized as	1
be organized into	1
be organized so	2
be enough to	1
be added to	1
be added at	1
be situations where	1
be chosen based	1
be scattered around	2
be applied to	4
be critical. The	1
be critical. Therefore,	1
be mentioned here:	1
be mispredicted for	1
be mispredicted even	1
be mispredicted (See	1
be mispredicted whenever	1
be mispredicted 50%	1
be standardized and	1
be false regardless	1
be converted to	4
be designed so	1
be fragmented and	1
be 8, 16	1
be preferred to	1
be interpreted as	1
be determined in	1
be determined by	2
be determined with	1
be easily available	1
be allowed and	1
be distributed to	2
be called, or	1
be called, even	1
be slower or	1
be slower than	1
be expensive in	1
be saved in	1
be saved from	1
be saved either	1
be aware of	3
be aware that	2
be aware of.	1
be available, we	1
be measured separately.	1
be equal to	1
be expected to	1
be expected for	1
be expected that	1
be convenient to	1
be convenient for	1
be poor because	1
be static, as	1
be evaluated if	2
be completely contained	1
be completely unrolled	1
be permissible if	1
be mixed with	1
be turned into	1
be overcome by	1
be worth the	2
be obvious to	2
be swapped to	1
be portable to	1
be executed as	1
be executed faster	1
be split up	1
be increased to	1
be increased by	1
be divided into	2
be seen in	1
be necessary. If	1
be updated to	1
be updated every	1
be combined into	1
be written in	1
be preferable to	1
be said that	1
be true. template<>	1
be needed, however,	1
be extended to	1
be expressed as	4
be cleaned up	1
be cleaned up,	1
be cached. This	1
be prevented in	1
be prevented by	1
be eliminated if	3
be eliminated completely.	1
be illustrated by	1
be returned in	2
be found in	2
be found elsewhere.	1
be coded in	1
be represented with	1
be represented as	1
be identified by	1
be kept small	1
be kept entirely	1
be selected during	1
be multiplied by	2
be obsolete. But	1
be obsolete. Programmers	1
be unable to	2
be modified by	2
be carried out	1
be hidden by	1
be performed with	1
be removed after	1
be considered a	1
be considered metaprogramming	1
be spaced by	2
be filled up	1
be filled up.	1
be expected. The	1
be solved by	2
be stored. All	1
be inlined. But	1
be inlined. (In	1
be infinity or	1
be taken into	3
be handled in	1
be moved out	2
be joined into	2
be joined together	1
be placed in	2
be placed immediately	1
be sufficient for	1
be evicted when	1
be evicted from	1
be manipulated with	1
be freed before	1
be justified in	1
be justified for	1
be vectorized, because	1
be vectorized, but	1
be disabled in	1
be ruled out	2
be reused elsewhere.	1
be pure. This	1
be bypassed when	1
be achieved more	1
be visible at	1
be overwritten, and	1
be annoyingly high	1
be controlled. The	1
be controlled. Small	1
be worthwhile to	1
be irrelevant within	1
be careful when	1
be profitable (see	1
be negative. The	2
be defined. The	1
be obtained. If	1
be obtained. In	1
be predicted. The	1
be predicted. This	1
be fed directly	1
be cached more	1
be shared. You	1
be shared. Any	1
be optional and	1
be deleted. User	1
be left out	1
be wrapped into	1
be slower. Many	1
be optimally aligned.	1
be fetched from	1
be avoided, if	1
be avoided, there	1
be avoided. 37	1
be misleading reports	1
be repeated 1024/4	1
be moved. A	1
be installed. The	1
be mispredicted, which	1
be tolerated. PGI	1
be regarded as	1
be obeyed. Copy	1
be restored before	1
be undesired. Example:	1
be passed as	1
be broken up.	1
be arranged in	1
be cross- compiled	1
be combined. For	1
be improved. 3.2	1
be rounded to	1
be straightforward. The	1
be prepared for	1
be non-zero, and	1
be saved. Any	1
be programmed in	1
be reached with	1
be renewed. Context	1
be weighed against	1
be reduced. This	1
be recycled? There	1
be postponed until	1
be omitted, of	1
be considered. A	1
be speeded up	1
be used: //	1
be added. This	1
be adjusted if	1
be platform-independent and	1
be made) then	1
be reloaded eight	1
be evicted. Don't	1
be mitigated by	1
be signed. Be	1
be emphasized that	1
be noticeable but	1
be reinstalled and	1
be ameliorated by	1
be scheduled in	1
be followed by	1
be caused by	1
be wired for	1
be responded to	1
be ignored if	1
be re-calculated every	1
be accomplished by	1
be mainstream next	1
be resized in	1
be overridden in	1
be huge). Far	1
be reversed if	1
be propagated through	1
be annoying. We	1
be accessed. Pointer	1
are the same	3
are the integers	1
are the following:	1
are a number	2
are a few	3
are a scarce	2
are a couple	1
are of course	1
are in fact	5
are in doubt	1
are for those	1
are that software	1
are as fast	1
are as follows:	1
are not used	2
are not very	1
are not stored	1
are not sure	1
are not always	4
are not necessary	1
are not optimized	1
are not known	1
are not supported	1
are not doing	1
are not well	1
are not able	1
are not used.	1
are not recommended	1
are not compatible	3
are not enough	1
are not critical.	1
are not fully	1
are not suitable	1
are not permissible	2
are not backwards	1
are not necessarily	1
are not optimal.	1
are not cached.	1
are not satisfied	1
are not overlapping	1
are not computationally	1
are not suited	1
are not testing.	1
are not accessible	1
are not yet	1
are not safe,	1
are not affected	1
are not used).	1
are not reproducible.	1
are time consuming.	1
are more efficient	2
are more useful	1
are more important	1
are more frequent	1
are more predictable	1
are then you	1
are then linked	1
are then output	1
are different for	1
are different ways	1
are different opinions	1
are only available	2
are only four	1
are only slightly	1
are other cache	1
are other possible	1
are used in	8
are used for	3
are used by	2
are used with	1
are used at	1
are used only	1
are used most	1
are used many	1
are used together	6
are used near	1
are used twice	1
are one byte	1
are integer expressions	1
are no cache	1
are no long	1
are no instructions	1
are no big	1
are no copy	1
are no caching	1
are no longer	2
are no checks	1
are set to	1
are floating point-to-integer	1
are most efficient	2
are most critical.	1
are using the	2
are using and	1
are using an	2
are using vector	1
are using functions	1
are using single	1
are using advanced	1
are using 8-bit	1
are using __fastcall.	1
are using unions	1
are double precision	1
are two or	2
are two different	1
are two versions	1
are two things	1
are two main	1
are two commonly	1
are there between	1
are also other	2
are also stored	4
are also 4	1
are also situations	1
are also available.	1
are also available,	1
are also deallocated	1
are also third-party	1
are also included.	1
are efficient because	1
are many function	1
are many functions	1
are many cases	1
are many allocations	1
are many branches):	2
are possible only	1
are objects in	1
are some differences	1
are some examples:	1
are so many	1
are so big	1
are so small	1
are so fast	1
are so expensive	1
are variables than	1
are very difficult	1
are very similar	1
are very fast.	1
are very expensive.	1
are very smart.	1
are 32-bit integers,	1
are faster than	2
are stored in	10
are stored can	1
are stored on	3
are stored as	1
are stored together	1
are stored near	1
are stored consecutively	1
are called and	1
are called from	1
are called every	1
are called global	1
are called near	1
are called accumulators.	1
are critical time	1
are critical resources.	1
are less efficient	3
are less likely	1
are less efficient.	1
are less strict	1
are less expensive.	1
are less susceptible	1
are first compiled	1
are 64 bits	1
are often used	3
are often much	1
are often inlined	1
are often waiting	1
are often conflicting	1
are often mispredicted.	1
are often abusing	1
are often fluctuating	1
are often unreliable.	1
are useful for	7
are useful when	1
are sure the	1
are sure to	4
are sure that	2
are sure you	1
are always stored	1
are always available	1
are always calculated	1
are always transferred	1
are always resolved	1
are out of	1
are part of	1
are cases where	1
are available to	1
are available in	3
are available for	4
are available if	1
are available as	1
are available from	2
are available at	1
are up to	1
are making a	1
are making programs	1
are making branches	1
are accessed in	7
are accessed on	2
are accessed very	1
are accessed through	5
are accessed equally	1
are accessed backwards	1
are accessed consecutively	1
are accessed sequentially.	2
are accessed column-wise.	1
are accessed row-wise,	1
are compiled with	1
are compiled without	1
are best at	1
are necessary then	1
are specific advantages	1
are much higher	1
are single instructions	1
are several different	3
are several ways	1
are several factors	2
are allocated and	2
are allocated in	1
are allocated resources	1
are integers or	1
are good for	2
are done with	2
are done at	1
are done only	1
are done under	1
are done implicitly	1
are therefore as	2
are optimized for	1
are optimized well,	1
are explained in	2
are explained on	1
are calculated faster	1
are calculated much	1
are four kinds	1
are advantageous for	1
are implemented in	1
are implemented by	1
are implemented with	1
are implemented as	2
are supported by	3
are eight floating	1
are likely to	1
are doing the	1
are doing a	1
are doing different	1
are doing exactly	1
are simply put	1
are simply treated	1
are able to	8
are certain that	1
are certain restrictions	2
are shared between	1
are quite costly	1
are used. a	1
are used. It	1
are used. See	2
are used. Example:	1
are used. Such	1
are used. Do	1
are used. Conversions	1
are fast in	1
are both positive.	1
are cases, however,	1
are particular advantageous	1
are typically stored	1
are typically small	1
are typically specified	1
are preferably aligned	1
are members of	2
are intrinsic instructions	1
are never used	2
are never called.	1
are never modified	1
are various function	1
are various methods	1
are various ways	5
are various things	1
are various discussion	1
are various profilers	1
are various alternatives	1
are running in	2
are running this	1
are three ways	2
are better at	1
are too large	1
are too big	1
are too small	1
are needed from	1
are needed even	1
are difficult to	2
are transferred in	7
are transferred by	1
are transferred on	2
are aligned to	1
are aligned or	1
are aligned by	1
are aligned at	1
are actually called	1
are actually able	1
are actually quite	1
are actually reducing	1
are linked together.	1
are declared in	1
are declared as	1
are declared outside	1
are declared whenever	1
are higher for	1
are bigger than	1
are usually stored	1
are usually included	1
are usually dealt	1
are called. The	2
are called. A	1
are called. Therefore,	1
are based on	8
are just as	1
are core clock	1
are replaced by	1
are negative or	1
are predicted most	1
are predicted well	2
are loaded at	1
are loaded into	1
are relative to	1
are intended to	1
are intended for	1
are slow unless	1
are inefficient when	1
are described in	1
are including a	1
are particularly critical	1
are particularly important	1
are particularly fast	1
are particularly critical.	1
are particularly problematic	1
are given in	2
are given on	1
are given below.	1
are sometimes more	1
are sometimes able	1
are inlined so	1
are special cases	1
are further described	1
are testing contains	1
are 100 floating	1
are writing to	1
are adding -100	1
are containers 93	1
are discussed in	2
are discussed below.	2
are reading and	1
are defined with	1
are defined as	1
are identical to	1
are identical so	1
are used, there	1
are used, while	1
are not. Supports	1
are organized as	1
are organized into	1
are approximately six	1
are situations where	1
are scattered around	2
are scattered everywhere	1
are scattered randomly	1
are independent then	1
are provided in	2
are provided below,	1
are 6 unused	1
are inefficient. If	1
are search requests	1
are executed. However,	1
are usability issues,	1
are pure functions,	1
are mentioned below.	1
are fully compatible	1
are included in	1
are temporary intermediates,	1
are frequent sources	2
are now used	1
are equally efficient	2
are equally likely	1
are equally efficient.	1
are equally near	1
are designed to	2
are listed in	4
are listed on	1
are preferred because	1
are zero. Zero	1
are exactly the	1
are exactly as	1
are resolved before	1
are poorly predictable.	1
are allowed to	1
are allowed in	1
are serious limitations	1
are disadvantages of	1
are generally not	1
are generally very	1
are instances of	1
are hardly relevant	1
are saved in	1
are integers, while	1
are highly system	1
are highly optimized	2
are highly optimized,	1
are waiting for	1
are available, i.e.	1
are powers of	1
are constant. 14.2	1
are expected to	1
are converting a	1
are costly and	1
are evaluated in	1
are evaluated every	1
are deallocated when	1
are permissible in	1
are swapping column	1
are swapped then	1
are becoming more	1
are becoming better	1
are becoming increasingly	1
are finished. This	1
are generated from	1
are equivalent to	1
are relatively costly	1
are relatively cheap	1
are frameworks that	1
are safer to	1
are combined by	1
are currently available,	1
are sufficiently large	2
are needed, and	1
are needed, or	1
are needed, but	1
are running. Such	1
are optimal. Best-case	1
are guaranteed to	1
are missing in	2
are extended to	1
are cleaned up	1
are image processing,	1
are uncached or	1
are returned by	1
are coded in	1
are smaller. The	1
are identified by	2
are kept in	1
are incompatible with	2
are normally compiled	1
are inferior to	1
are auto_ptr and	1
are modified should	1
are satisfied with	2
are assuming that	1
are long. This	1
are implemented. Use	1
are spaced a	1
are comparisons, etc.	1
are separated by	2
are annoying to	1
are supplied in	1
are overriding Intel's	2
are stored. The	1
are competing for	1
are read-only can	1
are indeed of	1
are impossible with	1
are type-casted to	1
are aligned. It	1
are disabled will	1
are CPU-specific and	1
are inherent performance	1
are uninitialized or	1
are summarized in	1
are summarized below.	1
are smarter ways	2
are capable of	1
are eliminated. Code	1
are unstable due	1
are lost. It	1
are mutually incompatible.	2
are properly aligned	1
are fine-tuned for	1
are sharing the	1
are cached as	1
are relocated by	1
are dealing with	1
are created. Far	1
are covered in	1
are overdetermined in	1
are overdetermined Boolean	1
are unnecessary for	1
are produced regularly.	2
are lots of	1
are wrapped into	1
are fetched and	1
are accessible from	1
are primitive operations	1
are inherently serial,	1
are common, and	1
are constructed. All	1
are prone to	1
are wrapper classes	1
are sufficient, and	1
are advised to	1
are seeing an	1
are doing. See	1
are among the	1
are cumbersome to	1
are dominating and	1
are instantiated at	1
are universal, flexible,	1
are undocumented. 2.7	1
are aligned, and	1
are offering profiling	1
are areas where	1
are unavoidable. It	1
are indexed in	1
are feeding an	1
are unacceptable. Each	1
are hundreds of	1
are modified, if	1
are compiler-specific. You	1
are dominating. At	1
are short. In	1
are met: the	1
are cheap, in	1
are costless in	1
are obscured in	1
are different. 64-bit	1
are risking to	1
are confined to	1
are satisfied. The	1
are satisfied: 1.	1
are breaking out	1
are CPLDs and	1
are relying on	1
are uninitialized, if	1
are removed, all	1
are incremental or	1
are limiting factors	1
are unrelated to	1
can in most	1
can be a	6
can be an	3
can be time	1
can be different	1
can be used	18
can be set	2
can be very	4
can be stored	2
can be called	1
can be less	1
can be 64	1
can be useful	12
can be important	1
can be accessed	5
can be necessary	1
can be allocated	5
can be done	7
can be optimized	3
can be calculated	11
can be advantageous	3
can be implemented	11
can be shared	1
can be quite	4
can be used.	2
can be signed	1
can be difficult	1
can be read	1
can be linked	2
can be made	5
can be replaced	6
can be predicted	4
can be loaded	2
can be avoided	8
can be particularly	1
can be given	1
can be vectorized	1
can be further	1
can be reduced	2
can be obtained	2
can be changed	4
can be initialized	2
can be improved	8
can be copied	3
can be invalid	1
can be used,	1
can be organized	1
can be added	2
can be chosen	1
can be applied	2
can be critical.	2
can be mentioned	1
can be mispredicted	2
can be converted	3
can be 8,	1
can be determined	2
can be expensive	1
can be saved	1
can be expected	3
can be completely	1
can be permissible	1
can be turned	1
can be overcome	1
can be increased	2
can be divided	2
can be updated	1
can be combined	1
can be said	1
can be extended	1
can be expressed	3
can be prevented	2
can be eliminated	2
can be illustrated	1
can be returned	2
can be found	2
can be coded	1
can be represented	2
can be carried	1
can be considered	1
can be expected.	1
can be solved	2
can be inlined.	1
can be moved	1
can be joined	1
can be placed	1
can be manipulated	1
can be justified	1
can be vectorized,	1
can be disabled	1
can be ruled	1
can be reused	1
can be bypassed	1
can be annoyingly	1
can be defined.	1
can be obtained.	1
can be predicted.	1
can be fed	1
can be shared.	1
can be left	1
can be wrapped	1
can be fetched	1
can be broken	1
can be arranged	1
can be cross-	1
can be combined.	1
can be improved.	1
can be programmed	1
can be reduced.	1
can be omitted,	1
can be speeded	1
can be used:	1
can be made)	1
can be ameliorated	1
can be wired	1
can be accomplished	1
can be overridden	1
can be propagated	1
can be accessed.	1
can not only	1
can not do.	1
can you assume	1
can have one	1
can have no	1
can have any	1
can have eight	1
can have quite	1
can use the	7
can use a	2
can use for	1
can use it	1
can use this	3
can use vector	1
can use only	1
can use 64-bit	1
can use any	1
can use standard	1
can then be	1
can then use	1
can then run	1
can make a	1
can make function	1
can make an	2
can make this	1
can make use	1
can make two	1
can make sure	1
can make dynamic	1
can make arrays	1
can make certain	1
can make thread-local	1
can only be	2
can only have	1
can only hope	2
can set multiple	1
can set up	1
can do the	1
can do is	1
can do a	2
can do to	2
can do and	1
can do with	1
can do this	2
can do because	1
can do simple	1
can do while	1
can do calculations	2
can do four	1
can do another	1
can do mathematical	1
can do whole	1
can do out-of-order	1
can do arithmetic	1
can double the	1
can also be	11
can also use	1
can also find	1
can also eliminate	1
can return with	1
can call the	1
can call all	1
can call C1::f	1
can take the	1
can take more	1
can take several	2
can take advantage	6
can take quite	2
can take care	2
can often be	3
can often optimize	1
can often happen	1
can often reveal	1
can test or	1
can even be	1
can access internal	1
can avoid the	3
can avoid this	2
can avoid virtual	1
can avoid it.	1
can avoid hyperthreading	1
can cause the	1
can cause other	1
can cause all	1
can cause cache	1
can cause branch	1
can cause problems	1
can cause caching	1
can cause contentions	1
can cause errors	1
can cause overflow.	1
can cause unpredictable	1
can cause complications	1
can cause severe	1
can cause holes	1
can therefore be	2
can therefore suffer	1
can therefore conclude	1
can get the	1
can get very	1
can get answers	1
can check the	2
can check if	1
can run in	1
can run only	1
can run eight	1
can run optimally	1
can calculate the	1
can calculate a	1
can calculate that	1
can calculate which	1
can calculate each	1
can calculate how	1
can store the	1
can optimize away	1
can optimize specifically	1
can replace a	1
can replace an	1
can replace all	1
can replace j	1
can automatically replace	1
can automatically generate	1
can automatically detect	1
can see the	1
can see that	2
can never be	2
can block the	1
can read about	1
can give some	1
can look like	1
can actually reduce	1
can assume that	4
can improve the	3
can improve this	1
can improve performance	1
can improve optimizations	1
can improve search	1
can reduce the	2
can reduce other	1
can reduce any	1
can reduce some	1
can reduce simple	1
can reduce them	1
can start a	1
can go more	1
can change the	3
can change their	1
can change what	1
can become a	1
can become very	1
can become imprecise	1
can turn on	1
can rely on	2
can produce no	1
can sometimes be	4
can sometimes take	1
can still be	2
can still run	1
can still give	1
can prevent the	1
can shift out	1
can save a	1
can save cache	1
can save several	1
can tell it	1
can tell how	1
can divide by	1
can clear or	1
can predict the	1
can predict where	1
can possibly be	2
can possibly block	1
can possibly improve	1
can possibly throw	1
can execute the	1
can execute a	1
can execute instructions	1
can convert an	1
can convert example	1
can handle eight	1
can occur in	1
can occur if	1
can occur at	1
can insert nontemporal	1
can align the	1
can expect a	1
can expect 64-bit	1
can modify x	1
can modify x,	1
can not. Static	1
can happen in	1
can happen that	1
can happen if	1
can happen with	1
can define in	1
can contain either	1
can help the	1
can multiply a	1
can multiply by	1
can share the	3
can now be	1
can easily be	1
can easily optimize	1
can easily become	1
can easily justify	1
can spend a	1
can generally assume	2
can hold many	1
can hold 8	1
can hold four	1
can hold e.g.	1
can eliminate this	1
can eliminate one	1
can eliminate common	1
can eliminate branches,	1
can increase the	1
can detect that	1
can prefetch the	1
can benefit from	2
can consume a	2
can lead to	3
can overlap the	1
can obtain most	1
can obtain much	1
can move out	1
can move outside	1
can disable exception	2
can begin the	1
can force a	1
can run. Some	1
can skip large	1
can probably be	1
can open the	1
can bypass the	2
can compute a	1
can proceed unattended.	1
can emulate a	1
can throw. In	1
can occur, but	1
can influence the	1
can add, remove	1
can see, it	1
can be, for	1
can subtract this	1
can roughly estimate	1
can build code	1
can steal the	1
can incur a	1
can surely rely	1
can toggle multiple	1
can handle. Waiting	1
can learn from	1
can safely assume	1
can overwrite the	1
can exceed 2	1
// of function	2
// The child	1
// The purpose	1
// or from	1
// function to	3
// function prototypes	1
// if above	2
// This is	5
// This function	2
// This triangle	1
// this function	1
// will give	1
// It will	1
// Example 13.1	1
// Example 16.2	1
// Example 14.9	1
// Example 14.8	1
// Example 16.1	1
// Example 9.3	1
// Example 8.26a	1
// Example 12.2	1
// Example 14.6	1
// Example 14.28	1
// Example 14.30	1
// Example 7.2	1
// Example 7.1	1
// Example 7.8	1
// Example 14.10	1
// Example 14.11	1
// Example 8.4	1
// Example 8.7	1
// Example 7.21	1
// Example 9.6b.	1
// Example 9.5a	1
// Example 7.7	1
// Example 7.11	1
// Example 7.12	1
// Example 11.3	1
// Example 7.22	1
// Example 7.23	1
// Example 7.20	1
// Example 7.27	1
// Example 7.24	1
// Example 7.25	1
// Example 7.28	1
// Example 9.4	1
// Example 7.14	1
// Example 7.16	1
// Example 7.17	1
// Example 7.13	1
// Example 7.19	1
// Example 7.18	1
// Example 12.5.	1
// Example 8.26b	1
// Example 14.12b	1
// Example 14.14b	1
// Example 15.1c.	1
// Example 14.14a	1
// Example 8.15a	1
// Example 14.13b	1
// Example 9.6a	1
// Example 12.1a.	1
// Example 14.19	1
// Example 14.1c	1
// Example 14.23b	1
// Example 11.2b	1
// Example 11.1a	1
// Example 11.1b	1
// Example 7.15b	1
// Example 15.1b.	1
// Example 14.26	1
// Example 14.27	1
// Example 14.23	1
// Example 8.21	1
// Example 14.5b	1
// Example 14.5a	1
// Example 7.6.	1
// Example 9.5b	1
// Example 13.2.	1
// Example 7.40a	1
// Example 7.40b	1
// Example 7.40c	1
// Example 14.3a	1
// Example 14.3b	1
// Example 11.2a	1
// Example 12.4a.	1
// Example 8.9b	1
// Example 8.9a	1
// Example 8.23b.	1
// Example 14.1b	1
// Example 14.1a	1
// Example 8.3a	1
// Example 12.4c.	1
// Example 12.6.	1
// Example 7.29b	1
// Example 7.29a	1
// Example 7.34a.	1
// Example 14.13c	1
// Example 14.13a	1
// Example 8.15b	1
// Example 7.10b	1
// Example 7.10a	1
// Example 12.4e.	1
// Example 8.5b	1
// Example 8.5a	1
// Example 7.31b	1
// Example 7.31a	1
// Example 7.43b.	1
// Example 14.4b	1
// Example 15.1a.	1
// Example 8.13a	1
// Example 8.13b	1
// Example 14.15b	1
// Example 9.1a	1
// Example 9.1b	1
// Example 7.33b	1
// Example 8.11b	1
// Example 8.11a	1
// Example 7.38b.	1
// Example 8.1b	1
// Example 8.1a	1
// Example 12.9b.	1
// Example 8.16	1
// Example 8.17	1
// Example 8.18	1
// Example 7.42	1
// Example 7.45	1
// Example 7.44	1
// Example 7.4.	1
// Example 12.8a.	1
// Example 7.35b	1
// Example 7.35a	1
// Example 8.23a.	1
// Example 12.8b.	1
// Example 14.18c	1
// Example 8.2a	1
// Example 8.2b	1
// Example 14.7b.	1
// Example 7.9b	1
// Example 7.9a	1
// Example 8.25	1
// Example 8.20	1
// Example 8.22	1
// Example 12.9a.	1
// Example 8.3b	1
// Example 7.38a.	1
// Example 7.43a.	1
// Example 14.21.	1
// Example 7.32a	1
// Example 14.22b	1
// Example 14.22a	1
// Example 15.1d.	1
// Example 14.18a	1
// Example 14.18b	1
// Example 9.2b	1
// Example 9.2a	1
// Example 8.24.	1
// Example 7.32b	1
// Example 8.6a	1
// Example 8.6b	1
// Example 7.15a.	1
// Example 7.5.	1
// Example 14.17b	1
// Example 14.7a.	1
// Example 14.16a	1
// Example 7.26b	1
// Example 7.26a	1
// Example 8.19.	1
// Example 8.10b	1
// Example 8.10a	1
// Example 7.30b	1
// Example 7.30a	1
// Example 7.3.	1
// Example 7.39	1
// Example 7.37	1
// Example 7.36	1
// Example 12.1b.	1
// Example 8.12a	1
// Example 8.12b	1
// Example 12.4b.	1
// Example 12.4d.	1
// Example 14.12a	1
// Example 8.14b	1
// Example 8.14a	1
// Example 7.33a	1
// Example 8.8b	1
// Example 8.8a	1
// Example 12.7.	1
// Example 7.34b.	1
// Example 14.16b	1
// Example 14.17a	1
// Example 14.15a	1
// Example 14.2a	1
// Example 14.2b	1
// Example 14.29	1
// Example 14.24	1
// Example 14.25	1
// Example 14.20	1
// Example 14.4a	1
// Example 7.41a	1
// Example 7.41b	1
// vector class	1
// make dispatcher	1
// CPU dispatching	1
// loop for	1
// loop through	2
// loop columns	2
// If Microsoft	1
// used for	1
// set a	2
// set sign	2
// do nothing	1
// number of	3
// C++ casting	1
// return 0	1
// return y	1
// return x^10	1
// 2 unused	1
// 2 bytes.	2
// You may	1
// table of	1
// 32-bit Windows,	1
// 32-bit Linux,	1
// makes intermediate	1
// 4 unused	1
// 4 bytes.	3
// call polymorphic	1
// call transpose	1
// 8 bytes.	2
// For unused	1
// test bits	1
// test sign	1
// always 1	1
// SSE2 //	1
// SSE2 version	2
// SSE2 supported	2
// constant data	1
// Gnu compiler,	1
// Windows syntax	1
// result =	2
// Use template	1
// Use signed	1
// Use mask	1
// Use ReadTSC()	1
// specific version	1
// Linux syntax	1
// AVX version	2
// AVX supported	2
// get next	1
// check if	1
// Function to	8
// Function pointer	2
// Function template	1
// Function prototype	1
// add the	1
// add 2	1
// add elements	1
// add n	1
// sign bit	1
// copy a	2
// ... for	1
// ... }	1
// next four	1
// n factorial	1
// Make the	1
// Make a	6
// Make all	1
// Make array	1
// Make dynamic	1
// Make three	1
// Table of	2
// Table //	2
// Table lookup	1
// Floating point	1
// AVX2 //	1
// constructor //	1
// constructor initializes	1
// go to	1
// Loop to	1
// Loop with	1
// Loop through	1
// Loop counter	2
// Loop r1	1
// Loop r2	1
// No cache	1
// No error	1
// sum operator	1
// exponent +	3
// Define function	2
// Define vector	4
// Define size	1
// Define SSE2	1
// Define vectors	1
// Define macro	2
// Define biggest	1
// square x	1
// Any function	1
// align by	1
// align table	1
// SSE4.1 //	1
// header for	1
// swap elements	2
// Store the	4
// Store result	1
// f is	2
// define a	1
// define function	1
// define matrix	1
// define fprintf	1
// Load eight	8
// multiply //	1
// 6 unused	1
// default constructor	1
// Time //	1
// Time before	1
// Time difference	1
// everything is	2
// parent class.	1
// Virtual function	1
// Virtual call	1
// Template for	1
// Cache contentions	1
// Now call	1
// Now 1.0	1
// Add 2	2
// Number of	1
// SSE3 required	1
// Set function	1
// Set pointer	2
// Set sign	1
// INSTRSET ==	1
// Roll out	5
// Critical function	1
// Critical innermost	1
// AND each	2
// SIZE must	1
// OR the	1
// Array of	1
// Array with	1
// Array size	1
// Calculate polynomial	1
// Only for	1
// Division by	1
// n! //	1
// n! int	1
// s +=	1
// Writes "Hello	4
// x^4 //	2
// x^4 F32vec4	1
// Multiply b	2
// u.f >	1
// Header file	2
// C-style type	1
// Bounds checking	1
// Same as	1
// MOVNTQ _mm_empty();	1
// Still faster	4
// Faster if	2
// After first	2
// Return the	1
// Return a	1
// Return reference	1
// fractional part	3
// Index out	1
// At the	1
// Get supported	2
// Get upper	1
// sum, initialize	1
// Check that	1
// Check if	1
// Call to	1
// Call critical	2
// Structure of	1
// 400 bytes.	1
// x^2 //	1
// x^2 float	1
// Full template	2
// (N &	1
// Enable exception	1
// Lowest version	2
// Initialize to	1
// Initialize loop	1
// x^n //	1
// (time after)	1
// Volatile to	1
// x^10 //	1
// _controlfp(0, _EM_OVERFLOW);	2
// Polynomial coefficients	2
// Increment loop	1
// Overflow may	1
// General case,	1
// ipow faster	1
// (This is	1
// Returns a	1
// Returns time	1
// Portability note:	1
// Catch floating	1
// Catch exceptions	1
// Update induction	2
// Mixing float	1
// Or #include	1
// EMMS }	1
// Approximate exp(x)	2
// initialize sum	1
// Remove right-most	1
// Compare each	2
// flip sign	1
// incremented every	1
// Repeat NumberOfTests	1
// Prevent optimizing	1
// Dispatcher void	1
// Re-do the	1
// x^8 //	1
// Non-polymorphic functions	1
// Error: lowest	1
// Safe []	1
// Output array	1
// Generic version	1
// polynomial(x) =	1
// u.d is	1
// Called directly	1
// Round to	1
// versions: class	1
// Entry to	1
// Truncation is	1
// Implicit type	1
// Constructor //	1
// Modulo by	1
// Branch/loop function	1
// Detect supported	1
// Place non-polymorphic	1
// Print heading	1
// x,y coordinates	1
// Reset floating	1
// x^1, x^2,	1
// Serialize //	1
// Convert to	1
// Find numerically	1
// Faster, but	1
// continue in	1
// erroneously called	1
// Read time	1
// Dispatcher. Will	1
// Constructor-style type	1
// 2-dimensional vector	1
// Partial template	1
// instrset_detect function	1
// Rounding is	1
// Prototype for	1
// abs(u.f) >	1
// Main loop	1
// (Some compilers	1
// Default version	1
= a a	3
= a -	10
= a x	1
= a +	7
= a *	9
= a &	2
= a ;	1
= a &&	1
= a |	1
= a ||	1
= a ?	2
= a ^	2
= a XOR	1
= int 4	1
= int 8	1
= x *	1
= x >	1
= x *x;	1
= { //	1
= { "Alpha",	1
= A +	2
= A |	1
= point to	1
= double 2	1
= double 4	1
= b +	5
= b *	9
= b /	4
= b >	2
= b %	3
= b ?	1
= i =	1
= i *	1
= i %	1
= float or	2
= float 4	1
= float 8	1
= 2 *	1
= 4 rows.	1
= 0; for	3
= 0; //	1
= 0; int	3
= 0; x	2
= 0; }	2
= 0; i	39
= 0; while	1
= 0; c	4
= 0; r	2
= 0; row	1
= 0; j	1
= 0; column	1
= 0; c1	1
= 0; 14.6	1
= 0; list[i+1]	1
= 0; r1	1
= 8 *	1
= 64 kb.	1
= 16 is	1
= 0 a	2
= 0 that	1
= 0 //	1
= 0 -	8
= 0 because	1
= 0 a+0=a	1
= & obj1;	1
= c +	1
= i; }	2
= a, a	4
= a, but	1
= b; A	1
= b; }	1
= b; c	1
= 1; for	1
= 1; }	2
= 1; n	1
= 1; r	2
= 1; list[i+2]	2
= 1; a[1]	1
= 256 times	1
= y +	3
= c; }	1
= char 16	2
= x; float	1
= 100; //	1
= 100; int	2
= 100; float	3
= 100; S1	1
= r +	2
= r ebx,	1
= 0, b	1
= 0, b;	1
= 0, c,	1
= 0, sum2	1
= 0, s3	1
= 0, s2	1
= 0, sum;	1
= 0, (a&b)	1
= 0, s1	1
= 2; }	2
= 2; i	1
= 2; Unfortunately,	1
= a[i] +	1
= a; b	1
= a; y	1
= p +	1
= 1. This	1
= 1. /	1
= temp *	2
= temp /	1
= shift and	1
= d +	2
= divide by	1
= 2, Tuesday	1
= true a	2
= temp; }	1
= temp; temp	1
= u; If	1
= row +	1
= 3; for	1
= multiply and	1
= multiply by	2
= *p +	3
= false where	1
= 4, we	1
= 4, Wednesday	1
= -1 -	1
= -1 x	1
= -1 (a&~b)|(~a&b)=a^b	1
= 8, Thursday	1
= (unsigned int)b	4
= (unsigned int)a	1
= 10; int	1
= 10; Templates	1
= 1, Monday	1
= 256; //	1
= (a +	1
= (a >=	1
= Induction ;	1
= int64_t 2	1
= int64_t 4	1
= log (b[i]	1
= 16; int	1
= x- x-	1
= (float *)alloca(n	1
= 1.0; for	1
= 1.0; int	1
= 1.0; while	1
= 1.0; list[i].b	1
= 1.0; temp->b	1
= 250 μs	1
= a[i]; It	1
= ~a a	1
= b[i] +	1
= C; double	1
= C; Assuming	1
= 1000; int	2
= 1000; float	1
= 1000; unsigned	1
= parabola (2.0f);	1
= 2.0; x	1
= 2.0; }	2
= 2.0; i	1
= s; An	1
= 0x2710 and	1
= (n &	1
= (b ==	1
= Induction; ;	2
= Induction; a[i+1]	1
= Induction; Induction++;	1
= 100, c	1
= 100, y;	1
= 100, max	1
= 100, NUMCOLUMNS	1
= LoadVector(cc +	3
= LoadVector(bb +	3
= r; for	1
= 100. Now,	1
= x2 *	1
= 28. This	1
= 28. We	1
= b;} vector	1
= 8; //	1
= 8; float	1
= (number of	1
= false, a	2
= 1024; int	2
= 1024; struct	1
= r1; c2	1
= r1; r2	1
= a*b -	1
= ReadTSC() -	1
= *(p++) is	1
= 0x1C. Reading	1
= _mm_set1_epi16(2); //	2
= a2 *	1
= a2 /	1
= a1 *	1
= a1 /	1
= ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x	1
= (a+b)+(c+d) a*b+a*c=a*(b+c)	2
= cos(x); }	1
= cos(x); z	1
= a+(b+c) -	2
= N&(N-1) gives	1
= 3.3; //	1
= 3.3; double	1
= 2.0f; x.i	1
= {1, 1,	2
= StringLength; i	1
= 32. This	1
= string; int	1
= string; while	1
= &Object1; p1->Hello();	1
= &Object1; p->NotPolymorphic();	1
= a*(b+c) -	2
= (bb[i] >	1
= order(i); matrix[j][0]	1
= order(i); list[j].a	1
= 2048 bytes	1
= InstructionSet(); //	2
= ((x2) 2)	2
= 512; //	2
= 20, columns	2
= bb[i] +	1
= (memory address)	1
= log(b[i]) +	2
= _mm_set1_epi16(0); //	2
= a&&(b||c) !a	1
= a&&(b||c) (a&&!b)	1
= (a&b) |	1
= 8192 bytes,	1
= _mm_cmpgt_epi16(b, zero);	2
= (double)(signed int)u;	2
= &CriticalFunction_386; }	1
= select(b >	2
= sin(x); }	1
= sin(x); z	1
= 1.f; for	1
= 1.f; float	1
= A; x.b	1
= _mm_add_epi16(c, two);	2
= 2.2, C	2
= &CriticalFunction_SSE2; }	1
= 1.23456. But	1
= 1.1, B	2
= &Object2; p->Hello();	1
= &Object2; p2->Hello();	1
= 80. The	1
= c1; c2	1
= 0x40 };	1
= !(a ||	1
= _mm_mullo_epi16 (b,	2
= (a<b &&	1
= B; x.c	1
= 1.0f +	1
= b*a -	1
= b*a (a+b)+c=a+(b+c)	1
= &CriticalFunction_AVX; }	1
= (a+1) *	1
= (a+1) /	1
= a&(b|c) -	1
= a&(b|c) x-xxxx--x	1
= 10, columns	1
= b+a a*b	1
= x8*x2; return	1
= 128. These	1
= i+1; The	1
= -abs(x);. There	1
= b.y +	1
= sin(0.8); The	1
= x∙xn-1, and	1
= 6.0f; Constant	1
= a1/b1 +	1
= &SelectAddMul_AVX2; (iset	1
= 64; //	1
= list[j].b +	1
= 1.23456, y;	1
= x2*x2; double	1
= -100, b	1
= {2.6f, 1.5f};	1
= (int)n -	1
= a[i].u[1] *	1
= 110; int	1
= lookup[b]; If	1
= pow(x,n) As	1
= 2.5*x^2 -	1
= a<<(b+c) -	1
= {1.1, 0.3,	1
= A*x*x +	1
= 1.0E8, c	1
= (short int)i;	1
= (s0+s1)+(s2+s3); Now	1
= &SelectAddMul_dispatch; //	1
= (a&b)&(c&d) a	1
= n∙(n-1)!. If	1
= (total cache	1
= _mm_or_si128(c2, bc);	1
= (a1*b2 +	1
= OneOrTwo5[b!=0]; will	1
= b[r][c]; }	1
= *(++p) because	1
= array[++i] because	1
= (10000 /	1
= {1.0f, 2.5f};	1
= (int)d; //	1
= absvalue; largest_index	1
= _mm_andnot_si128(mask, bc);	1
= 0x20, Saturday	1
= instrset_detect(); 116	1
= (b*c)/d, it	1
= Y; Y	1
= Func1(2); ...	1
= &list[0]; temp	1
= a|(b&c) x-xxxx--x	1
= 32; float	1
= WhateverFunction(i); //	1
= array[i++] is	1
= 100000001.23456. The	1
= Func(a[i]); }	1
= -1.0E8, b	1
= 0x10, Friday	1
= y.d +	1
= y.a +	1
= y.b +	1
= y.c +	1
= (float)i; f	1
= 0.0; //	1
= &CriticalFunction_Dispatch; //	1
= 5.0f; b	1
= lrint(d); //	1
= 123; are	1
= OneOrTwo5[b &	1
= MAX(f(x), g(x));	1
= Func(ab[i].a); }	1
= log(2.0); ...	1
= 50; float	1
= (int)(&list[0]) +	1
= MultiplyBy<8>(10); a	1
= &SelectAddMul_SSE2; //	1
= b+a, a*b	1
= _mm_blendv_epi8(bc, c2,	1
= CriticalFunction(b, c);	1
= _mm_hadd_ps(x, x);	1
= r1+1; r2	1
= 10000, then	1
= (A &	1
= !a; can	1
= __rdtsc(); return	1
= b++; will	1
= a*4 -	1
= float(i); f	1
= ++b; the	1
= (*CriticalFunction)(b, c);	1
= Multiply(10,8); b	1
= b.x +	1
= select_gt(b, zero,	1
= (0x2710 /	1
= x4*x4; double	1
= _mm_hadd_ps(s, s);	1
= ((x2)2)2 a+a+a+a=a*4	1
= ReadTSC(); CriticalFunction();	1
= FactorialTable[b]; ...	1
= static_cast<float>(i); //	1
= a&&b (a&&b)	1
= 18, then	1
= 1.6; int	1
= &SelectAddMul_SSE41; (iset	1
= _mm_and_si128(c2, mask);	1
= dummy[0]; clock	1
= a+1; b	1
or the function	1
or the other	1
or the loop	1
or the number	1
or the user	1
or the error	1
or the specific	1
or the negative	1
or the series	1
or the __assume_aligned	1
or a function	1
or a make	1
or a CPU	1
or a static	1
or a member	1
or a simple	1
or a few	3
or a separate	1
or a binary	1
or a pointer.	1
or a smart	1
or a similar	1
or a hash	2
or a reasonable	1
or a nearby	1
or a not-too-big	1
or a non-const	1
or to an	1
or to exit	1
or in the	1
or in a	3
or for the	1
or for issuing	1
or for combining	1
or function call	1
or function libraries	1
or function calls.	1
or if the	6
or if it	4
or if this	1
or if different	1
or if one	1
or if there	1
or if pointers	1
or if they	2
or if its	1
or by an	1
or by memory	1
or by using	1
or by making	1
or by type-casting	1
or by turning	1
or by extending	1
or by keys	1
or with the	1
or with an	1
or with compile-time	1
or code lines.	1
or as a	1
or not in	1
or not at	1
or an integer	1
or an assembly	1
or an input	1
or an anonymous	1
or an over-	1
or int 4	1
or int 8	1
or you may	1
or use the	1
or use objconv	1
or more of	1
or more then	1
or more integer	1
or more performance	2
or more template	1
or more dynamic	1
or more versions	2
or more threads	1
or more iterations	1
or more complex	1
or more jobs	1
or more cores,	1
or more constants.	1
or when the	3
or when code	1
or when accessing	1
or from example	1
or from knowing	1
or memory pool.	1
or at run	1
or data used	1
or data exceeds	1
or program size,	1
or vector classes	2
or make files	1
or because the	1
or CPU cores,	1
or other data	1
or other error	1
or other hardware	2
or other resources.	1
or other device	1
or one clock	1
or cache access	1
or no other	1
or no overhead	1
or no offset	1
or no idea	1
or class is	3
or class for	1
or class that	1
or class with	1
or class should	1
or class into	1
or class declaration	1
or class separately	1
or class elements.	1
or class objects.	1
or floating point	1
or each of	1
or do more	1
or do other	1
or double to	3
or double because	1
or double takes	1
or double plus	1
or double precision,	2
or Intel compiler.	1
or pointer to	1
or library has	1
or library files.	1
or multiple times	1
or multiple configurations	1
or multiple elements?	1
or two floating	2
or two integers	1
or two 128-	1
or object is	1
or object that	1
or object as	1
or object through	1
or static or	1
or static storage	1
or 64-bit integers	1
or 64-bit mode.	1
or 64-bit systems).	1
or C++ code.	1
or C++ file	1
or C++ based	1
or array coincides	1
or variable is	1
or variable having	1
or any other	1
or any higher	1
or any particularly	1
or performance problems.	1
or long dependency	1
or between different	1
or member function	1
or member functions.	1
or const reference	1
or cannot be	1
or See page	1
or critical parts	1
or less each	1
or unsigned 2	1
or unsigned 4	1
or unsigned 8	1
or unsigned 1	1
or first in	1
or libraries that	1
or pointers to	1
or they may	1
or without the	1
or even a	2
or even swapped	1
or even telling	1
or method should	1
or always false:	1
or 16 8	1
or 16 bits	1
or 16 Table	1
or SSE2 instruction	1
or out of	1
or 32 bits	1
or 32 bytes).	1
or dynamic link	2
or error prone.	1
or Gnu compilers	1
or accessed in	1
or does so	1
or assembly language	1
or assembly language.	1
or threads simultaneously.	1
or specific models	1
or common names.	1
or thread are	1
or thread does	1
or small sequences	1
or line separately	1
or optimized away.	1
or four single	1
or four float's	1
or another error	1
or get ReadTSC	1
or container is	1
or container without	1
or eight single	1
or structure is	3
or structure are	1
or structure object	1
or every code	1
or 1 and	1
or 1 by	1
or 1 (see	1
or add an	1
or simply zero.	1
or addresses that	1
or shared objects),	1
or write it	1
or write less	1
or replace it	1
or operator that	1
or Mac operating	1
or cache. Most	1
or 256 bytes)	1
or model the	1
or mathematical functions	1
or Microsoft compiler	1
or what a	1
or reference is	1
or reference to	8
or reference can	1
or reference may	1
or reference parameters).	1
or three levels	1
or too long.	1
or transferred from	1
or after the	1
or give it	1
or graphics accelerator	1
or assume that	1
or later //	1
or later with	1
or later instruction	6
or higher instruction	1
or goes into	1
or union can	1
or require a	1
or require more	1
or require runtime	1
or #define makes	1
or switch statement	1
or modules with	1
or references then	1
or VIA processor	1
or global arrays	1
or global variables.	1
or 1. The	1
or 1. This	1
or 1. See	1
or 1. Writing	1
or turn off	1
or size. Today,	1
or network resources.	1
or #pragma optimize("a",on).	1
or #pragma novector	1
or hot spot	1
or comes from	1
or limited in	1
or class. The	1
or class. This	1
or database is	1
or strings of	1
or writing a	3
or writing to	1
or writing big	1
or writing small	1
or accessing databases,	1
or until the	1
or full speed.	1
or overloaded operator	1
or models that	1
or fail completely	1
or compiling the	1
or structures are	1
or logical processors	2
or subexpression containing	1
or reading disk	1
or resource files	1
or enable the	1
or PathScale compiler	1
or references. It	1
or come from	1
or modify the	1
or modify objects	1
or setting an	1
or input data.	1
or not. The	4
or not. There	1
or not. See	1
or not. I	1
or approximately so.	1
or easy linking	1
or writes a	1
or writes to	1
or non-static member	1
or false (0);	1
or 8, but	1
or __restrict or	1
or 1, but	1
or update automatically	1
or int64_t MS	1
or log off	1
or compile-time generation	1
or remove any	1
or constant. If	1
or reads to	1
or reference, the	1
or reference, or	1
or reference, 64-bit	1
or reference, 32-bit	1
or compilation before	1
or completely absent	1
or structure. The	1
or structure. This	1
or loss of	1
or multidimensional array	2
or lists of	1
or created it	1
or key in	1
or key press.	1
or malloc is	1
or malloc and	2
or division. The	1
or __asm ("int	1
or two. Often,	1
or sixteen vector	1
or estimate of	1
or mouse input.	1
or mouse move.	1
or *.so). The	2
or video should	1
or unsigned. The	1
or another. Therefore,	1
or mask out	1
or structures. Accessing	1
or otherwise optimize	1
or uint64_t MS	1
or API function	1
or multi-core CPUs,	1
or manipulate all	1
or bypassing syntax	1
or C++. Critical	1
or (requires no	1
or moving the	2
or infinity or	1
or reference. Registers	1
or micro-op cache.	1
or moved with	1
or bypass the	1
or typedef instead	1
or inline. This	1
or modified. This	2
or 3-dimensional vectors	2
or post-increment. The	1
or interpretation on	1
or send data	1
or ten years	1
or four, depending	1
or NAN (not	1
or NAN (Not	1
or -0 }	1
or namespaces. Therefore,	1
or microseconds as	1
or re- allocating	1
or column. The	1
or integrated in	1
or -Ofast /O3	1
or Friday is	1
or x64 141	1
or 0x40 bytes	1
or later. Example:	1
or better, make	1
or circumvent operating	1
or CString uses	1
or she is	1
or .a), but	1
or more. Many	1
or QueryPerformanceCounter functions	1
or decrementing a	1
or __debugbreak();. If	1
or "frame pointer".	1
or -axAVX. This	1
or bitmap than	1
or double) /arch:SSE2	1
or network. Various	1
or clearing arrays	1
or PSDK). Supports	1
or friend function	1
or g(x) is	1
or seemingly simultaneously.	1
or remotely. If	1
or -fno-strict-overflow. You	1
or while-loop is	1
or animation. It	1
or Espresso) that	1
or "__attribute__((visibility ("hidden")))".	1
or inttypes.h is	1
or __attribute__((fastcall)). The	1
or C1::f. But	1
or C2::Disp() is	1
or hide them	1
or p->member is	1
or /Ox -O3	1
or intranet for	1
or PathScale. 2.	1
or 2016. The	1
or NAN. Avoiding	1
or tiling. This	1
or *.so) that	1
or modifies many	1
or __attribute__((aligned(16))). Specifies	1
or bottleneck, it	1
or memory-intensive functions	1
or CString. This	1
or "how many	1
or removable media	1
or glitches in	1
or (5) make	1
or First-In-Last-Out access,	1
or aliasing, but	1
or void. Returning	1
or references: If	1
or /Fa for	1
or Verilog. Common	1
or sizes? It	1
or iterative in	1
or malloc. Handles	1
or malloc) is	1
or __restrict__, if	1
or vice versa.	1
or C2, then	1
or .so). There	1
or YMM) which	1
or -fsource-asm). This	1
or makefile. You	1
or __declspec(thread). Such	1
or malloc/free should	1
it the first	1
it is the	3
it is a	3
it is to	1
it is and	1
it is on	1
it is not	20
it is an	1
it is more	5
it is only	2
it is used	2
it is also	3
it is possible	13
it is very	3
it is long	1
it is faster	1
it is stored	3
it is called	2
it is less	1
it is often	2
it is even	1
it is sure	1
it is short	1
it is available	1
it is important	9
it is accessed	4
it is necessary	9
it is much	1
it is small	1
it is good	2
it is done	2
it is inside	1
it is advantageous	6
it is known	3
it is likely	3
it is doing	1
it is certain	1
it is quite	1
it is recommended	7
it is optimal	2
it is never	1
it is running	2
it is too	1
it is difficult	1
it is usually	1
it is relevant	1
it is intended	2
it is inefficient	2
it is outside	1
it is still	1
it is safe	1
it is clear	2
it is possible.	1
it is true	1
it is initialized	2
it is discussed	1
it is rarely	1
it is slightly	1
it is independent	1
it is executed.	1
it is almost	1
it is preferred	1
it is poorly	1
it is hardly	1
it is convenient	1
it is deallocated	1
it is safer	1
it is preferable	1
it is finished	1
it is run.	1
it is filled	1
it is certainly	2
it is sufficient	2
it is evicted	1
it is impossible	1
it is compiled.	1
it is worthwhile	1
it is profitable	1
it is compiling.	1
it is correlated	1
it is advisable	1
it is unrealistic	1
it is servicing.	1
it is cached,	1
it is unlikely	1
it a pointer	1
it a template:	1
it to the	2
it to a	1
it to any	1
it to signed	1
it to do.	1
it to begin	1
it and create	1
it in the	1
it in a	1
it in one	1
it in order	1
it for lists	1
it for improving	1
it can be	14
it can not	1
it can have	1
it can use	2
it can do	1
it can also	1
it can call	1
it can take	1
it can often	1
it can cause	1
it can calculate	1
it can start	1
it can save	1
it can happen	1
it can multiply	1
it can move	2
it can run.	1
it can handle.	1
it can overwrite	1
it by a	1
it by 100	1
it with the	1
it with many	1
it with 1:	1
it with 2n	1
it as a	1
it may be	19
it may not	2
it may take	2
it may cause	2
it may go	1
it may detect	1
it may involve	1
it this by	1
it more clear	1
it will be	1
it will not	3
it will point	1
it will often	1
it will run	3
it will generate	2
it will still	1
it will break	1
it will recognize	1
it from a	1
it from making	1
it from fully	1
it at the	1
it at compile	1
it has the	2
it has to	1
it has not	1
it has an	1
it has i	1
it has many	1
it has allocated	1
it has been	4
it has done	1
it has calculated	1
it has chosen	1
it has finished	2
it has incomplete	1
it only once.	1
it point to	1
it used to	1
it should be	1
it should save	1
it into multiple	1
it also makes	1
it possible to	7
it possible for	1
it takes to	24
it takes more	1
it takes only	1
it takes before	1
it takes too	1
it takes six	1
it takes 40%	1
it takes hours	1
it some heavy	1
it so that	1
it makes it	1
it makes program	1
it makes no	1
it makes floating	1
it makes sure	1
it makes dispatching	1
it makes sense	1
it cannot be	2
it cannot access	1
it cannot inline	1
it cannot rule	1
it less efficient.	1
it often contains	1
it often gives	1
it does not	1
it does have	1
it does some	1
it does not,	1
it does incredibly	1
it must return	1
it work cannot	1
it Use a	1
it doesn't have	3
it doesn't need	2
it doesn't work	2
it doesn't generate	1
it doesn't matter	1
it doesn't depend	1
it doesn't occur.	1
it necessary to	1
it works well	1
it inside {}	1
it uses more	1
it would be	2
it count up	1
it was executed.	1
it was programmed.	2
it was assigned	1
it allows the	1
it allows larger	1
it needs to	3
it needs an	1
it needs only	1
it becomes invalid	1
it becomes full.	1
it requires the	1
it requires that	1
it requires an	1
it actually is.	1
it goes the	1
it goes another	1
it goes automatically	1
it points to	2
it points to.	1
it off and	1
it gives more	1
it comes to	1
it comes before	1
it still uses	1
it prevents the	2
it prevents certain	1
it calls. The	1
it calls. 48	1
it rarely justifies	1
it easier for	2
it might be	1
it might not	1
it checks which	1
it checks whether	1
it returns. But	1
it writes only,	1
it to. It	1
it could free	1
it involves the	1
it involves allocation	1
it involves pure	1
it had a	1
it is. It	1
it fits into	1
it follows a	1
it defines electrical	1
it adds an	1
it gets from	1
it jumps to.	1
it avoids the	1
it is, and	1
it is, but	1
it appears to	1
it opens the	1
it takes. The	1
it takes. Debugging.	1
it explicitly. In	1
it optimizes the	1
it occurs, but	1
it occurs, (2)	1
it allocates the	1
it unusual that	1
it took several	1
it expects a	1
it locally in	1
it increases the	1
it handles eight	1
it obviously takes	1
it decides whether	1
it attempts to	1
it sees a	1
it compares the	1
it exits. For	1
it unwise to	1
it uses. There	1
it fills up	1
it twice. You	1
it lacks the	1
it (&ArraySize) is	1
it feeds a	1
it matters: Division	1
it says. A	1
it changes. A	1
it understands only	1
it has. Assuming	1
it supports. An	1
it directly. The	1
function is a	4
function is by	1
function is as	1
function is not	4
function is time	1
function is also	2
function is so	1
function is faster	2
function is called	7
function is less	1
function is always	1
function is available	1
function is compiled	1
function is big	1
function is small	1
function is advantageous	1
function is doing	1
function is never	2
function is usually	2
function is called.	9
function is replaced	1
function is intended	1
function is given	1
function is OS	1
function is needed.	1
function is defined	2
function is pure	2
function is called,	4
function is simpler	1
function is inlined.	1
function is big.	1
function is pure.	1
function is inserted	1
function is InstructionSet().The	1
function is 83	1
function is expanded	1
function a =	1
function a different	1
function a member	2
function a constructor	1
function of the	3
function of a	2
function of i	1
function of 2	1
function of 4	1
function to be	2
function to use	1
function to test	1
function to work	1
function to measure	1
function to transpose	3
function to another.	1
function and the	1
function and to	1
function and you	1
function and branch	1
function and these	1
function and calculate	1
function and later	1
function and replaces	1
function in the	1
function in a	6
function in which	4
function in Intel	1
function in system	1
function in case	2
function in terms	1
function in isolation	1
function for the	2
function for a	1
function for this	1
function for different	1
function for each	1
function for register	1
function for CPUs	1
function that is	4
function that has	1
function that I	1
function that does	1
function that calls	2
function that doesn't	3
function that simply	1
function that needs	2
function that reads	1
function that allocates	1
function that draws	1
function that detects	1
function are stored	2
function are called	1
function are simply	1
function can be	3
function can use	1
function can modify	2
function can throw.	1
function // Function	1
function // Call	1
function or in	1
function or by	1
function or class	4
function or variable	2
function or method	1
function or every	1
function or operator	1
function or hot	1
function or otherwise	1
function or friend	1
function if the	1
function if it	1
function by inlining	2
function by adding	1
function with the	2
function with a	2
function on a	1
function on CPUs	1
function code is	1
function as described	1
function may be	2
function may return	1
function when the	2
function will be	1
function will most	1
function will return	1
function will wait	1
function } };	1
function then the	1
function from the	1
function from www.agner.org/optimize/asmlib.zip.	1
function at runtime.	1
function has only	2
function because the	2
function because it	2
function because this	1
function which in	1
function which then	1
function which we	1
function which cannot	1
function which returns	1
function which transposes	1
function but outside	1
function should also	1
function should preferably	1
function should never	2
function using assembly	1
function pointer is	2
function pointer a	1
function pointer to	2
function pointer and	1
function pointer if	1
function pointer has	2
function pointer which	1
function pointer typically	1
function pointer points	1
function pointer follows	1
function into a	1
function into multiple	1
function library and	2
function library for	1
function library that	3
function library or	1
function library with	3
function library then	1
function library at	2
function library made	1
function library asmlib,	1
function also has	1
function such as	1
function In some	1
function where you	1
function many times	1
function version //	1
function version CriticalFunctionType	1
function we want	1
function so that	1
function return a	1
function return addresses	1
function return value.	1
function cannot be	1
function cannot access	1
function cannot rely	1
function cannot modify	1
function called only	2
function address in	1
function call is	1
function call to	2
function call if	1
function call by	1
function call with	1
function call so	1
function call makes	1
function call inline	1
function call statement	2
function call (other	1
function libraries is	1
function libraries and	2
function libraries in	1
function libraries for	2
function libraries that	2
function libraries are	6
function libraries with	1
function libraries have	2
function libraries do	1
function libraries available	1
function libraries Some	1
function libraries available.	1
function libraries distributed	1
function libraries Test	1
function libraries published	1
function template because	1
function pointers if	2
function pointers It	1
function they are	1
function type and	1
function type with	1
function type typedef	1
function does not	1
function must then	1
function must check	1
function calls is	1
function calls to	1
function calls and	2
function calls in	4
function calls are	1
function calls can	1
function calls may	1
function calls more	1
function calls because	1
function calls faster	2
function calls another	1
function through a	2
function through function	1
function uses by	1
function uses logarithms	1
function parameters to	1
function parameters are	1
function parameters because	1
function was called	1
function name is	1
function name ;	1
function name depending	1
function name Instruction	1
function name ;startofFunc	1
function parameter is	1
function parameter and	1
function means that	1
function instead of	1
function dispatch mechanism	1
function dispatch process.	1
function calling more	1
function calling method	1
function calling conventions	1
function calling conventions.	1
function goes in	1
function feature is	1
function just because	1
function #define MAX(a,b)	1
function go to	1
function relative to	1
function inlining is	2
function inlining and	1
function inlining are:	1
function #pragma optimize(...)	1
function calls. The	4
function calls. It	1
function calls. If	1
function calls. There	1
function calls. Example:	1
function calls. Unfortunately,	1
function calls. Internal	1
function library. The	1
function library. If	1
function library. 78	1
function libraries. C++	1
function libraries. Use	1
function libraries. Several	1
function libraries. Numbers	1
function names and	3
function names in	1
function names are	1
function directly if	1
function modify an	1
function F1 is	1
function returns. The	2
function returns. This	1
function returns. There	1
function returns. Make	1
function returns. Alternatively,	1
function returns. alloca	1
function returns. Global	1
function returns. Every	1
function writes to	1
function stores the	1
function stores a	1
function could be	1
function parameter. But	1
function body inside	1
function call. Load	1
function call. Algebraic	1
function call. (2)	1
function __fastcall __attribute((	1
function names. But	1
function 250 times	1
function library, but	1
function adds the	1
function returns even	1
function _mm256_zeroupper() before	1
function opens a	1
function parameters, local	1
function parameters, pointers,	1
function libraries, but	1
function parameter, or	1
function looks like	1
function scans a	1
function definition. This	1
function longjmp is	1
function ReadTSC listed	1
function F2 that	1
function argument to	1
function implicitly when	1
function Size of	1
function inline. This	1
function inline. Replacing	1
function ten times	1
function construct an	1
function prototype to	1
function declaration. This	1
function decides which	1
function swapd(a[r][c], a[c][r]);	1
function body. A	1
function libraries........................................................................................ 12	1
function local: 1.	1
function __intel_cpu_features_init_x() does	1
function calls, if	1
function inlining, common	1
function prototype: void	1
function billions of	1
function rounds a	1
function F1. However,	1
function add_horizontal) static	1
function prototypes for	1
function bodies above,	1
function (n!) as	1
function __intel_cpu_features_init() sets	1
function vectorized: void	1
function inlining. Reducible	1
function tables. The	1
function scanf. Violation	1
function calling. __fastcall	1
if the function	4
if the code	6
if the compiler	2
if the time	1
if the data	4
if the program	6
if the same	1
if the CPU	1
if the loop	7
if the integer	1
if the class	1
if the most	1
if the size	5
if the library	1
if the object	3
if the number	4
if the array	2
if the clock	1
if the value	5
if the objects	2
if the variable	1
if the table	1
if the software	1
if the branch	1
if the member	1
if the elements	2
if the address	1
if the critical	2
if the first	2
if the template	1
if the new	1
if the user	3
if the SSE2	2
if the following	1
if the type	1
if the case	1
if the constant	1
if the processor	3
if the threads	4
if the necessary	1
if the AVX	2
if the calculation	1
if the uses	1
if the problem	1
if the list	1
if the inline	1
if the branches	1
if the application	2
if the expression	1
if the conversion	1
if the parameter	1
if the source	1
if the cost	1
if the programmer	1
if the results	1
if the operands	3
if the index	1
if the inlining	1
if the network	2
if the constants	1
if the destructor	1
if the repeat	2
if the offset	1
if the full	1
if the RAM	1
if the rows	2
if the handle	1
if the target	2
if the subexpression	1
if the condition	2
if the SSE4.1	1
if the sequence	1
if the length	1
if the current	1
if the typical	1
if the prediction	1
if the inputs	1
if the changes	1
if the dispatched	1
if the 7	1
if the bottleneck	1
if the image	1
if the distance	1
if the dividend	2
if the goal	1
if the unsafe	1
if the time-critical	1
if the evaluation	1
if the bias	1
if is resolved	1
if a is	2
if a and	4
if a program	3
if a loop	1
if a floating	1
if a simple	1
if a large	1
if a thread	1
if a matrix	1
if a certain	1
if a was	1
if a lot	1
if a high	1
if a parameter	1
if a piece	1
if a reasonable	1
if and compile-time	1
if it is	25
if it can	1
if it has	4
if it cannot	1
if it involves	1
if it had	1
if it is.	1
if it follows	1
if it opens	1
if an int	1
if an array	1
if an exception	2
if an overflow	1
if you are	9
if you can	3
if you have	2
if you cannot	1
if you take	1
if you want	5
if you avoid	1
if you write	1
if you don't	2
if you look	1
if you change	1
if you expect	1
if you had	1
if you declare	1
if you follow	1
if you forget	1
if this is	2
if this can	1
if this prevents	1
if this appears	1
if time intervals	1
if memory access	1
if data are	1
if data access	1
if different versions	1
if because #if	1
if functions that	1
if functions have	1
if only you	1
if other nearby	1
if instruction sets	1
if all the	3
if all of	1
if all functions	1
if all bits	1
if one is	1
if no other	2
if no exception	1
if each bit	1
if each addition	1
if pointer arithmetic	1
if b is	3
if b and	1
if i <	1
if multiple threads	2
if static linking	1
if there is	11
if there are	9
if such a	1
if such dependency	1
if possible and	1
if any of	1
if any objects	1
if we use	1
if we want	2
if we change	1
if we specify	1
if branch is	1
if branch in	1
if elements have	2
if unsigned The	1
if unsigned //	2
if unsigned You	1
if pointers are	1
if they are	7
if they don't	1
if they come	1
if they otherwise	1
if SSE2 is	1
if out of	1
if dynamic linking	1
if I write	1
if its address	1
if its body	1
if speed is	1
if c <	1
if a, b,	1
if AVX is	1
if implemented on	1
if (i <	2
if (i >=	2
if (i %	1
if supported by	2
if certain options	1
if certain conditions	1
if intermediate calculations	1
if above doesn't	1
if above line	1
if both are	1
if both positive	1
if else if	2
if else {	1
if their live-ranges	1
if your optimization	1
if your modifications	1
if XMM registers	2
if statement and	1
if statement in	1
if level-2 cache	1
if possible. The	1
if possible. This	1
if possible. See	1
if possible. SSE2	1
if possible. Use	1
if possible. Don't	1
if possible. Smaller	1
if true ;	1
if N is	1
if condition can	1
if statements (called	1
if F1 has	1
if F1 calls	1
if alternative implementations	1
if organized as	1
if available. See	1
if required for	1
if (b) {	7
if exceptions can	1
if (a *	1
if (a >	1
if (a ==	1
if (a !=	1
if possible, and	3
if possible, or	1
if possible, so	1
if portability is	1
if protection against	1
if ((unsigned int)i	2
if ((unsigned int)n	2
if ((unsigned int)(i	1
if nonzero and	1
if nonzero u.i	1
if pieces of	1
if b[i] and	1
if divisor is	2
if (u.i *	1
if (u.i &	2
if (u.i >	1
if powN is	1
if unsigned. This	1
if (n &	1
if (n >	1
if (b ==	1
if (b !=	1
if (level >=	4
if necessary, to	1
if necessary, by	1
if necessary, each	1
if (Day &	1
if (Day ==	1
if (y) {	2
if appropriate. 8.	1
if any, is	1
if any, must	1
if (handle !=	1
if (true) {	1
if (absvalue >	1
if (u.i[1] <	1
if (SIZE >	1
if our estimate	1
by the function	1
by the code	1
by the compiler	4
by the use	3
by the memory	1
by the program	1
by the vector	3
by the same	1
by the CPU	2
by the loop	1
by the cache	2
by the floating	1
by the size	3
by the Intel	1
by the number	2
by the clock	1
by the value	1
by the branch	1
by the critical	1
by the operating	4
by the test	1
by the following	1
by the Gnu	1
by the processor	1
by the calculated	1
by the program.	1
by the microprocessor	1
by the application	1
by the methods	1
by the constructor	1
by the compiler.	2
by the unroll	3
by the processing	1
by the heap	1
by the program,	2
by the compiler,	1
by the user.	1
by the Gnu,	1
by the body	1
by the linker	2
by the throughput	1
by the requirements	2
by the rest	1
by the latency	2
by the 107	1
by the loader	1
by the programmer.	1
by the caller	1
by the formula:	1
by the application,	1
by the series:	1
by is (columns	1
by a float	1
by a multiple	2
by a variable	2
by a table	4
by a const	1
by a system	1
by a constant	9
by a single	2
by a power	3
by a list	1
by a second	1
by a shift	1
by a variable.	1
by a factor	2
by a macro,	1
by a blend	1
by a key?	1
by a conditional	1
by a plain	1
by a unique	1
by a constant:	1
by // Example	6
by not using	1
by - reciprocal	1
by an induction	2
by an executable	1
by an interrupt	1
by an EMMS	1
by compiler There	1
by compiler .......................................................................	1
by more than	1
by more efficient	1
by memory access.	1
by at least	1
by vector size.	1
by only 50%	1
by CPU Modern	1
by CPU brand.	1
by other constants	1
by all other	1
by all means	1
by all modern	1
by one function	1
by one makes	1
by cache line	1
by each thread.	1
by most CPUs	1
by using the	10
by using a	8
by using function	1
by using an	1
by using vector	1
by using different	1
by using only	1
by using one	1
by using static	1
by using short	1
by using assembly	1
by using intrinsic	1
by using vectors	1
by using references	1
by using nontemporal	1
by using rounding	1
by using indexes,	1
by using memset:	1
by Intel have	1
by Intel but	1
by multiple threads	2
by two and	1
by two then	1
by two gives:	1
by many users	1
by value in	1
by any of	1
by any other	3
by some very	1
by some formula	1
by 2 in	1
by 2 ;	1
by 2 (See	1
by 4 float	1
by 4 ;	1
by 8 in	1
by 8 rather	1
by template template	1
by pointers or	1
by 16 is	1
by 16 to	1
by 16 for	1
by 16 float	1
by 16 (see	1
by 16 __declspec(	1
by 32 and	1
by constant =	4
by making the	5
by making a	2
by making an	1
by making i	1
by making objects	1
by making critical	1
by making sure	1
by making another	1
by making longer	1
by making them	1
by its value	1
by calls to	1
by element 0	1
by several different	1
by exception handlers	1
by line when	1
by another function	1
by another thread	1
by another thread.	2
by eight to	4
by doing the	1
by optimizing the	1
by optimizing database	1
by both the	1
by preferably using	1
by their address	1
by their values	1
by their index	1
by their actual	1
by n and	1
by n additions	1
by better standardization	1
by means of	2
by calling the	1
by calling vector::reserve	1
by calling WritePrivateProfileString,	1
by piece in	1
by r is	1
by storage on	1
by my comments,	1
by columns in	1
by p is	1
by consecutive indices	1
by inlining the	2
by inlining all	2
by 2. The	2
by 2. (See	1
by including the	1
by checking if	1
by testing and	1
by testing all	1
by 100 so	1
by copying the	3
by copying all	1
by copying them	1
by adding the	1
by adding a	2
by adding an	1
by adding one	1
by adding n	1
by adding throw()	1
by compiling the	1
by compiling in	1
by unrolling the	2
by F1 also	1
by setting the	2
by setting a	1
by setting pointers	1
by setting these	1
by default in	1
by default unless	1
by default anyway	1
by *p or	1
by Microsoft, Intel,	1
by OpenMP directives	1
by multiplying with	1
by random events	1
by executing instructions	1
by storing the	1
by storing intermediate	1
by 16. This	1
by 16. In	1
by 16. You	1
by 16. Library	1
by 16. Alignment	1
by giving it	1
by Agner Fog.	1
by Agner Fog	1
by specifying the	1
by comparing bits	1
by comparing them	1
by avoiding the	1
by avoiding pointer	1
by avoiding any	1
by type-casting i	1
by type-casting its	2
by physical factors.	1
by unacceptably long	1
by increasing the	1
by 16, i.e.	2
by 8. The	2
by 8. There	1
by 8. 71	1
by itself. But	1
by turning the	1
by turning off	2
by one, into	1
by declaring the	2
by declaring it	1
by defining a	1
by defining _mm_malloc	1
by choosing the	1
by choosing a	1
by modifications of	1
by transferring 'this'	1
by default, which	1
by default, so	1
by default, even	1
by default, conform	1
by 2n by	2
by individual installation	1
by unit-testing is	1
by me manually,	1
by changing the	1
by changing this	1
by considerations such	1
by reordering the	1
by well-tested container	1
by step. In	1
by 64, but	1
by bypassing the	1
by F2 and	1
by organizing the	1
by measuring the	1
by returning a	1
by joining the	1
by joining a	1
by joining identical	1
by modifying only	1
by four, we	1
by rolling out	2
by invoking the	1
by putting the	1
by TILESIZE //	1
by S. Goedecker	1
by __fastcall. The	1
by looking at	1
by default. This	1
by default. Position-independent	1
by consistent modularity	1
by performing an	1
by extending the	1
by extending with	1
by subtracting n	1
by 3, 5	1
by replacing a	1
by replacing an	1
by removing the	1
by assigning a	1
by writing: 103	1
by writing: __declspec(align(64))	1
by ignoring the	1
by (partial) template	1
by x<<3, which	1
by assignment, as	1
by assignment. shared_ptr	1
by u[0]. 14.10	1
by requesting a	1
by emulating the	1
by controlling the	1
by inverting the	1
by initializing pointers	1
by dropping the	1
by keys within	1
by commas. There	1
by hand and	1
by constructing the	1
by wrapping the	1
by summing up	1
by selecting optimize	1
by fetching, decoding	1
by causing return	1
by XOR'ing it	1
by semicolons, while	1
by AND'ing it	1
by CPU.............................................................................81 8.5	1
by xx-xx--x- reciprocal	1
by allowing two	1
by 5-10% for	1
by thousands of	1
with the function	1
with the time	2
with the use	2
with the same	8
with the functions	2
with the other	1
with the double	1
with the Intel	1
with the pointer	1
with the static	2
with the C++	1
with the value	1
with the performance	1
with the way	1
with the operating	1
with the &	1
with the constant	1
with the Gnu	2
with the best	1
with the option	7
with the calculated	1
with the four	1
with the operators	1
with the sign	1
with the problems	1
with the last	1
with the appropriate	1
with the SSE	1
with the loops	1
with the compiler,	1
with the beginning	1
with the current	1
with the Gnu,	1
with the Borland	1
with the expected	1
with the application.	1
with the ^	1
with the requirements	1
with the ever	1
with the bit-mask:	1
with the highest	1
with the resolution	1
with the correct	1
with the AVX-512	1
with the inverted	2
with the LLVM	1
with the sizeof	1
with the rightmost	1
with the reciprocal:	1
with a different	2
with a pointer	1
with a table	1
with a very	2
with a 32-bit	1
with a branch	1
with a 64	1
with a &	1
with a simple	1
with a constant	1
with a single	1
with a small	1
with a line	2
with a well	1
with a lot	1
with a high	1
with a better	1
with a lookup	1
with a |	1
with a graphics	1
with a higher	2
with a relative	1
with a profiler	1
with a slow	2
with a special	1
with a shift	1
with a destructor	1
with a total	1
with a square	1
with a little	1
with a default	1
with a fully	1
with a prediction	1
with a suitable	2
with a constant.	1
with a remote	1
with a realistic	2
with a well-defined	2
with a combination	1
with a micro-op	1
with a debugger.	1
with a decimal	1
with a top-of-stack	1
with a wealth	1
with a 50-50	1
with a password.	1
with a lineage	1
with a non-recursing	1
with and without	2
with in a	1
with in assembly	1
with that branch.	1
with or without	1
with code compiled	1
with an error	1
with an inline	1
with an intermediate	1
with an Intel,	1
with an index	1
with an offset	1
with an example.	1
with an extended	1
with this code	1
with this instruction	1
with this problem:	1
with this rule.	1
with this mask,	1
with more RAM	1
with more heuristic	1
with memory access.	1
with vector integer	1
with vector operations	1
with vector classes	1
with vector parameters	1
with vector access.	1
with vector operands:	1
with different set	1
with different compilers	1
with different versions	1
with different matrix	1
with different compilers.	1
with different brands	1
with different strides.	1
with different priorities	1
with only the	1
with only one	2
with only four	1
with CPU dispatching.	1
with CPU dispatching,	1
with other compilers	2
with other objects	1
with other calculations	1
with other compilers.	1
with other local	1
with other microprocessors.	1
with other subtasks	1
with all the	2
with all CPUs	1
with all compilers.	1
with all x86	2
with all relevant	3
with all 0's	1
with all 1's	1
with integer parameters.	1
with floating point	3
with each their	1
with each instance	1
with compilers and	1
with most modern	1
with most distributions	1
with Intel C++	1
with Intel processors.	1
with multiple memory	1
with multiple CPU	1
with multiple CPUs	1
with multiple overloaded	1
with multiple cores	1
with multiple cores.	1
with multiple counters,	1
with two decimals,	1
with two entries.	1
with many of	1
with many function	2
with many different	1
with many such	1
with many branches	1
with many Boolean	1
with many instances	1
with many features,	1
with many labels	1
with many decimals.	1
with any function	1
with any type	1
with some of	1
with some changes	1
with some legacy	1
with long double	1
with long latencies.	1
with branch //	1
with branch void	1
with member pointers	1
with member functions,	1
with unsigned integers	2
with 64 bits,	1
with template metaprogramming.	1
with template metaprogramming,	1
with pointers that	1
with new and	4
with new or	2
with SSE2 #include	1
with system calls	1
with dynamic memory	1
with short or	1
with making software	1
with its value.	1
with its limit,	1
with CPUs that	1
with large data	1
with execution units	2
with element matrix[c][r]	1
with element matrix[c][r].	1
with single or	1
with virtual functions	1
with virtual member	1
with option -fpie	1
with option -fwrapv	1
with option -Wstrict-overflow=2,	1
with AVX support	2
with line 29.	1
with four numbers	1
with four cores	1
with another vector	1
with another dynamic	1
with another thread	1
with another compiler.	1
with few or	1
with 1 for	1
with sign bit	1
with both static	1
with programs written	1
with sets rather	1
with members of	1
with Boolean variables	1
with intrinsic functions	1
with signed than	1
with Microsoft or	1
with Microsoft compiler.	1
with automatic CPU	3
with automatic vectorization.	1
with induction variables	1
with induction variables.	1
with end of	1
with old CPUs	1
with old microprocessors	2
with old CPUs.	1
with just two	1
with #define is	1
with C or	1
with C functions	1
with Windows, Linux,	1
with network access	1
with slow bit	1
with desired parameters	1
with out-of-order capabilities	3
with limited resources.	1
with preceding branches	1
with non-Intel CPUs.	1
with alignment problem	1
with 100 and	1
with 100 in	1
with reduced speed	1
with accessing 32	1
with 16-bit programs.	1
with full debugging	1
with N elements	1
with little or	1
with bitwise operators	1
with bounds checking	2
with bounds checking,	1
with reading the	1
with references. You	1
with SSE4.1 //	1
with templates //	1
with templates instead	1
with invalid pointers	1
with destructors to	1
with low power	1
with low priority.	1
with Microsoft, Intel	1
with lower priority	1
with lower priority.	1
with heavy traffic	1
with profiling support.	1
with j <<	1
with fixed size	1
with fixed size,	1
with fixed strides.	1
with non-sequential access	1
with -fpic and	1
with hardly any	1
with profilers are:	1
with compile-time polymorphism.	1
with Intel's compilers	1
with normal writes	1
with column 28	1
with embedded microcontrollers.	1
with internal multi-threading,	1
with CISC instruction	1
with contiguous memory.	1
with macros is	1
with older microprocessors	1
with 1: //	1
with structured exception	1
with pointers. The	1
with 2n -1.	1
with existing systems	1
with sequential labels	1
with fine-grained parallelism	1
with earlier CPUs.	1
with big-endian storage.	3
with character arrays.	1
with external libraries.	1
with 14.14b automatically	1
with suffixes such	1
with coarse-grained parallelism	1
with debugging. A	1
with millisecond resolution	1
with alloca. This	1
with Gnu. It	1
with lots of	1
with legacy code,	1
with certainty that	1
with certainty which	1
with interpretation. The	1
with x87 style	1
with -mcmodel=large, but	1
with C++0x support.	1
with segmented memory,	1
with _mm. These	1
with real time	1
with zero-bits if	1
with enum, const,	1
with First-In-First-Out or	1
with profiling, but	1
with carry) instructions	1
with full-size execution	1
with alloca: //	1
with alloca, because	1
with #) are	1
with _finite()) and	1
with nagging pop-up	1
with double's. It	1
with u.i[1] ^=	1
with widely different	1
with IsPowerOf2 =	1
with massively parallel	1
with truncation, and	1
with these. The	1
on the compiler	2
on the time	1
on the same	2
on the CPU	1
on the other	1
on the size	1
on the Intel	1
on the object	1
on the number	1
on the value	1
on the way	1
on the first	1
on the user	1
on the type	1
on the processors	1
on the available	1
on the stack	12
on the work	1
on the calculations	1
on the execution	1
on the result	3
on the processor	1
on the option	1
on the standard	1
on the hardware	1
on the values	1
on the intermediate	1
on the microprocessor	1
on the next	1
on the Mac	1
on the data.	1
on the second	1
on the x86	1
on the old	1
on the compiler.	1
on the advanced	1
on the costs	1
on the preceding	1
on the Pentium	1
on the efficiency	1
on the variable.	1
on the total	1
on the stack.	5
on the PathScale	1
on the previous	1
on the CPU.	1
on the device	1
on the hard	1
on the system,	1
on the CPUID	1
on the processor.	3
on the newest	3
on the strict	1
on the actual	1
on the assumption	1
on the stack,	3
on the Internet	1
on the specified	1
on the microprocessor.	2
on the past	1
on the context.	1
on the screen.	1
on the market.	2
on the processor).	2
on the stack).	1
on the processor)	1
on the essential	1
on is the	1
on a program	1
on a CPU	1
on a variable	1
on a 2	1
on a system	1
on a Linux	1
on a store	1
on a particular	2
on a graphics	2
on a platform	1
on a modern	1
on a network	1
on a Pentium	4
on a non-Intel	1
on a sequence	1
on a hard	2
on a typical	1
on a PC	2
on a thousand	1
on a complex	1
on a computer.	1
on a command	1
on a unit-test	1
on a First-In-Last-	1
on a First-In-First-	1
on and off.	1
on that particular	1
on that variable.	1
on function calls	1
on with a	1
on code optimization	1
on an Intel	2
on an object	1
on an interpreter	1
on compiler optimization	1
on compiler optimization.	1
on x so	1
on this part	1
on this option.	2
on this topic,	1
on when objects	1
on program performance.	1
on different test	1
on different processors.	1
on different platforms,	1
on only the	1
on CPU dispatching	1
on CPU efficiency	1
on other platforms	1
on instruction set	1
on which a	1
on which it	1
on which this	1
on which instruction	1
on which imprecisions	1
on all the	1
on all data	1
on all 64-bit	1
on all C++	1
on all elements	1
on all compilers.	1
on all relevant	1
on all platforms	1
on all sizes	1
on all newer	1
on all non-static	1
on all brands	1
on all major	1
on one computer	1
on integer code.	1
on integer expressions	2
on integer variables.	1
on page 8	1
on page 16.	1
on page 134	1
on page 146	2
on page 164	1
on page 136	1
on page 15.	1
on page 39	1
on page 105.	1
on page 93.	2
on page 26.	1
on page 122.	1
on page 58	1
on page 72.	2
on page 22.	1
on page 153.	1
on page 107.	1
on page 60.	1
on page 62.	1
on page 96.	1
on page 44.	1
on page 134.	1
on page 132.	1
on page 87.	1
on page 130.	1
on page 158.	1
on page 27.	1
on floating point	3
on compilers that	1
on most other	1
on most processors	1
on most newer	1
on most microprocessors.	1
on using the	2
on using alloca.	1
on Intel compiler	1
on Intel processors.	2
on Intel CPUs:	1
on Intel CPU’s.	1
on Intel Atom	1
on b can	1
on multiple data	1
on static or	1
on C++ Performance	1
on C++ Performance".	1
on such systems	1
on such processors	1
on such small	2
on any brand	1
on some processors	1
on some systems.	1
on some processors.	1
on some microprocessors	1
on variables in	1
on table lookup	1
on very small	1
on software that	1
on branch predictions	1
on first call	2
on first call.	1
on optimization of	3
on how to	1
on how they	1
on how well	1
on how predictable	1
on test theory.	1
on these data.	1
on instructions that	1
on processors that	2
on processors with	2
on stack ;	1
on its own	1
on its final	1
on its family	1
on important work.	1
on CPUs with	2
on CPUs without	1
on large data	1
on Windows platforms.	1
on calculations inside	1
on processor X?"	1
on big runtime	1
on several different	1
on AMD and	3
on AMD CPUs	1
on AMD CPUs.	1
on AMD processors,	1
on exception handling.	1
on small devices	1
on overflow and	1
on Linux platforms,	1
on another computer.	1
on whether CriticalFunction	1
on every call	2
on every call.	1
on hardware identification.	1
on certain Intel	1
on intermediate code	2
on Mac platform.	1
on complicated criteria	1
on signed and	1
on mathematical applications	1
on what is	1
on what instruction	1
on what fits	2
on automatic vectorization.	1
on automatic prefetching	1
on n here	1
on runtime dispatch	1
on compilers. Several	1
on bigger systems.	1
on vectors of	1
on vectors and	1
on process is	1
on process may	1
on old operating	1
on advanced C++	1
on my own	1
on my study	1
on network resources	2
on Pentium 4	1
on non-Intel processors	2
on non-Intel CPUs	3
on non-Intel processors,	1
on non-Intel machines?	1
on non-Intel processors).	1
on it. Instead	1
on alignment and	1
on until you	1
on performance. 7.18	1
on access. Sequential	1
on access. Run	1
on bounds checking).	1
on reading and	1
on future processors.	1
on future CPUs.	1
on future processors,	1
on newer processors.	1
on input data	1
on current Intel	1
on PC platforms.	1
on just-in-time compilation	1
on algorithms and	1
on lazy binding	1
on executing library	1
on executing instructions	1
on registers, not	1
on CodeGear compiler).	1
on CodeGear compiler)	1
on deciding which	1
on completely independent	1
on anything else	1
on seven different	2
on remote or	1
on BSD, but	1
on n, including	1
on older processors	1
on structured exception	1
on mixing code	1
on multi-core CPUs,	1
on contemporary processors.	1
on contemporary 106	1
on longjmp in	1
on improving performance.	1
on x. It	1
on hacks that	1
on non- standardized	1
on servers that	1
on usability, but	1
on publicly available	1
on system-specific graphical	1
on arranging data	1
on Intel/x86-compatible microprocessors.	1
on redesigning a	1
on correction for	1
code the offset	1
code is the	1
code is a	1
code is that	4
code is not	4
code is more	1
code is used	1
code is so	2
code is very	1
code is critical	1
code is compiled	4
code is optimized	1
code is implemented	1
code is likely	2
code is fast	1
code is running	2
code is needed	1
code is later	1
code is smaller	1
code is intended	1
code is limited	1
code is inlined	1
code is chosen	1
code is executed.	1
code is included	1
code is fragmented	1
code is fastest	1
code is exactly	1
code is distributed	3
code is compact	1
code is inefficient,	1
code is __asm	1
code is serial	2
code is selected	1
code is translated	1
code is indeed	1
code is repetitive.	1
code of the	1
code to the	1
code to a	1
code to be	1
code to call	1
code to test	1
code to access	1
code to check	1
code to support	1
code to see	1
code to give	1
code to tell	1
code to non-AVX	2
code to test.	1
code and for	1
code and can	1
code and you	1
code and data	6
code and table	1
code and how	1
code and doesn't	1
code and compile	1
code and intermediate	1
code and put	1
code and divide	1
code and just-in-time	2
code and lazy	2
code and main()	1
code and read-only	1
code in the	2
code in a	3
code in this	1
code in which	1
code in example	6
code in multiple	4
code in order	1
code in addition	1
code in either	1
code in details.	1
code in general.	1
code for the	4
code for this	1
code for Intel	1
code for making	1
code for AMD	1
code for actually	1
code for vectorization	1
code for accessing	1
code for vectorization.............................................................	1
code that the	1
code that is	5
code that a	1
code that are	1
code that can	2
code that it	1
code that you	1
code that use	1
code that makes	1
code that does	1
code that works	1
code that uses	2
code that contains	1
code that allows	1
code that current	1
code that produces	1
code that copies	1
code that accesses	2
code that matters	1
code are compiled	1
code are relative	1
code are uncached	1
code are modified,	1
code can be	8
code can then	1
code can therefore	1
code can become	1
code can possibly	1
code can now	1
code can probably	1
code or in	1
code or use	1
code or not.	1
code if no	1
code if we	1
code if possible,	1
code by making	1
code by default.	1
code by emulating	1
code with a	1
code with an	1
code with CPU	1
code with automatic	2
code as example	1
code may be	1
code may run	1
code you are	1
code you want	1
code have been	1
code more efficient	2
code more complicated	1
code more efficient.	1
code more compact	1
code more efficient,	1
code more complex,	1
code when the	1
code when you	1
code will be	3
code will not	1
code will work	1
code will run	1
code will read	1
code will load	1
code will fail	1
code will catch	1
code then it	1
code then you	2
code from example	3
code at each	1
code at all.	1
code has a	4
code has to	1
code has no	1
code because of	1
code because it	1
code because they	1
code which the	1
code one line	1
code cache is	1
code cache and	3
code cache or	1
code cache if	1
code cache use	1
code cache works	2
code should be	1
code should have	1
code should therefore	1
code size or	1
code size have	1
code size has	1
code into multiple	1
code where speed	1
code version is	2
code version on,	1
code version performs	2
code takes no	1
code so that	2
code performance is	1
code branch to	1
code branch for	2
code faster because	1
code makes caching	2
code cannot be	1
code address and	1
code less clear	1
code 64 bit	1
code often contains	1
code rather than	2
code optimization Intel:	1
code 16 will	1
code up to	1
code must compute	1
code versions for	1
code versions work	1
code compiled for	1
code compiled with	2
code compiled without	1
code big and	1
code works only	1
code inside square:	1
code uses an	1
code Function libraries	1
code contains only	1
code contains natural	1
code memory. The	1
code branches works	1
code branches separately	1
code automatically in	1
code automatically or	1
code caching is	2
code caching and	1
code caching for	1
code implementation works	1
code like the	1
code cache. The	2
code examples in	1
code examples for	1
code difficult to	1
code instead of	1
code becomes the	1
code becomes more	2
code becomes bigger	1
code becomes smaller	1
code becomes simpler	1
code becomes contiguous.	1
code becomes bulky	1
code together near	1
code goes through	1
code smaller and	1
code section is	1
code section and	1
code section can	1
code section will	1
code section so	1
code section contains	1
code section needs	1
code section position-independent,	1
code gives an	1
code size. In	1
code still needs	1
code prevent the	1
code further by	1
code Assume that	1
code optimization. See	1
code execute faster	1
code execute faster.	1
code containing pure	1
code version. 2.	1
code to: //	1
code could benefit	1
code involves multiplication	1
code once the	1
code explicitly by	1
code line. Time-based	1
code itself is	1
code Shared objects	1
code automatically. It	1
code Static linking	1
code generated by	2
code relies on	1
code addresses. The	1
code itself. Another	1
code flag in	1
code lines. The	1
code incompatible with	1
code cache, branch	1
code only. This	1
code motion A	1
code motion Induction	1
code motion manually	1
code explicitly. There	1
code looks like	1
code caching. This	1
code took 50	1
code carefully to	1
code ....................................................... 20	1
code everywhere by	1
code (option -fno-pic).	1
code generality. The	1
code bloat and	1
code mixes float	1
code (release version)	1
code slower, especially	1
code optimization", Coriolis	1
code (byte code).	1
code motion. See	1
code section, but	1
as the function	1
as the compiler	1
as the other	1
as the example	1
as the size	1
as the number	1
as the error	1
as the standard	1
as the Microsoft	1
as the difference	1
as the binary	1
as the Microsoft,	1
as the Gnu,	1
as the latency	1
as the "Intel	1
as the C-style	1
as the basis	1
as the operands.	1
as the .exe	1
as is often	1
as is commonly	1
as a function	5
as a time	1
as a memory	1
as a vector	2
as a make	1
as a pointer	1
as a library	1
as a *	1
as a table	1
as a very	1
as a 32-bit	2
as a member	3
as a register	2
as a template	2
as a dynamic	1
as a large	1
as a result	2
as a single	1
as a virtual	1
as a structure	1
as a Boolean	1
as a parameter	1
as a runtime	1
as a means	1
as a linked	3
as a global	1
as a shift	1
as a so-called	1
as a temporary	1
as a normal	1
as a base	1
as a circular	3
as a subexpression.	1
as a biased	1
as a plug-in	1
as a valuable	1
as a learning	1
as a stand	1
as a scalar	1
as a subset,	1
as to the	1
as to make	1
as in example	5
as in Linux	1
as in Linux.	1
as for switch	1
as for (i=0;	1
as it is	2
as it is,	2
as function parameters	1
as function parameter.	1
as function inlining.	1
as if it	1
as if you	1
as an integer	1
as an example	1
as an object	1
as an array	3
as an unsigned	1
as an integer.	3
as an example.	1
as an appendix	1
as an implicit	1
as an 8-bit	2
as you are	1
as you can	1
as you have	1
as you will	1
as you avoid	1
as you don't	1
as this is	1
as when contentions	1
as memory leak.	1
as memory leaks.	1
as vector operations.	1
as vector register.	1
as different functions.	1
as loop counter	1
as cache and	1
as integer arithmetic	1
as floating point.	1
as example 7.15b	1
as example 12.4b,	1
as example 13.1,	1
as most sorting	1
as using a	1
as i modulo	1
as multiple inheritance	1
as two 32-bit	1
as two 128-bit	1
as object or	1
as static arrays	1
as static link	2
as C++ for	1
as C++ compilers.	1
as efficient as	6
as efficient functions	1
as many encryption	1
as possible for	1
as possible or	1
as possible at	1
as possible into	1
as any other	1
as very time-consuming	1
as long as	7
as long time	1
as 32-bit integer	1
as code. Metaprogramming	1
as template parameters	1
as template parameter.	1
as template parameters,	1
as pointers and	1
as pointers unless	1
as 32 sets	1
as part of	1
as simple variables,	1
as constant references	1
as error handling	1
as important usability	1
as much as	1
as much data	1
as single precision.	1
as common subexpression	1
as AMD and	1
as small as	1
as good as	4
as explained in	6
as explained on	12
as explained at	1
as explained below.	4
as explained above,	1
as explained above.	1
as parameters to	1
as supported instruction	1
as few branches	1
as inline function	1
as well as	8
as well use	1
as well specify	1
as well developed	1
as fast as	6
as their uses	1
as Boolean vectors,	1
as string or	1
as three branches.	1
as last time	2
as calling a	1
as bigger than	1
as binary executable	1
as p and	1
as intended (see	1
as dynamically allocated	1
as index then	1
as described in	4
as described below.	1
as position-independent has	1
as given in	1
as output can	1
as task switches	1
as writing data.	1
as copying an	1
as accessing it	1
as possible. The	1
as possible. However,	1
as possible. Typically	1
as little work	1
as discussed on	1
as directly compiled	1
as e.g. .R.	1
as well. The	1
as well. This	1
as input less	1
as input check	1
as integers. 7.5	1
as mentioned above.	1
as addition, subtraction,	1
as standardized as	1
as heavy mathematical	1
as Gnu, Clang,	1
as listed in	1
as xn =	1
as follows: //	1
as follows: struct	1
as follows: Instruction	2
as follows: Type	1
as follows: Matrix	1
as follows: floatvalue	1
as machine code	1
as powers of	1
as possible, and	1
as follows in	1
as follows (using	1
as soon as	1
as int, float,	1
as list, set	1
as -(-a) =	1
as n! =	1
as true, if	1
as macros are	1
as well, but	1
as Taylor expansions	1
as alternatives to	1
as illustrated in	1
as 8-bit integers	1
as entry point.	1
as Intel-based Mac	1
as character arrays.	1
as expected. I	1
as DOS and	1
as logarithms and	1
as C#, Visual	1
as pivot in	1
as memcpy, memmove,	1
as shown in	2
as semaphores, mutexes	1
as floppy disks	1
as arguments while	1
as price, compatibility,	1
as pragmas in	1
as _mm_empty() as	1
as logarithms, exponential	2
as additions. When	1
as additions. Divisions	1
as command-line versions	1
as Java, use	1
as 0/a =	1
as accurate and	1
as sorting and	1
as coprocessors to	1
as sqrt and	1
as b*(2.0/3.0) unless	1
as C- style	1
as 2eee 1.fffff,	1
as (int)&matrix[0][0] +	1
as eliminating the	1
as buffers for	1
as spell-checking and	1
as GetPrivateProfileString and	1
as sorting, searching,	1
as strcpy, strcat,	1
as x4∙xn-4. There	1
as (critical stride)	1
as VHDL or	1
as recursive templates.	1
as versatile. Fortran	1
as flush and	1
as pow, log,	1
as email and	1
as required, but	1
as <. The	1
as (b*2.0)/3.0 rather	1
as ((a+b)+c)+d. This	1
as replacements for	1
as integers: //	1
as ReadB needs	1
as gates, flip-flops,	1
as 'this'. We	1
as OneOrTwo5[(b!=0) ?	1
as follows. The	1
as reflecting it	1
as AQtime, Intel	1
as intended, while	1
not the more	1
not the case	1
not the compiled	1
not the best	1
not the optimized	1
not the columns.	1
not a good	1
not a power	1
not a manual	1
not a problem	1
not a safe	1
not a profiler.	1
not a vector).	1
not a textbook	1
not to mix	1
not to vectorize.	1
not in the	2
not in a	2
not in some	1
not in memory.	1
not in use.	1
not for other	1
not be necessary	1
not be advantageous	1
not be able	4
not be optimal	1
not be too	1
not be compatible	2
not be safe	2
not be evaluated	2
not be worth	2
not be portable	1
not be cached.	1
not be visible	1
not be negative.	1
not be optimally	1
not be passed	1
not if the	1
not if it	1
not if b	1
not if static	1
not by the	1
not with a	1
not with earlier	1
not on Intel	1
not on variables	1
not on AMD	1
not on publicly	1
not as a	1
not not _WIN32	1
not an advantage	1
not an optimal	1
not an Intel,	1
not an issue	1
not have the	2
not have to	2
not have this	1
not have such	1
not have its	1
not have inherent	1
not use the	3
not use a	2
not use one	1
not use lookup	1
not use runtime	1
not use STL	1
not use GOT	1
not use branches,	1
not at all	1
not make the	1
not make a	1
not make this	1
not make variables	1
not make induction	1
not only the	1
not only a	1
not only be	2
not only when	1
not only improve	1
not all libraries	1
not used for	2
not do such	1
not do so	1
not using position-independent	1
not i but	1
not possible to	4
not possible if	1
not possible when	1
not any other	1
not very good	1
not long enough	1
not stored contiguously	1
not call WriteFile	1
not less than	1
not take the	1
not need the	1
not need to	1
not need any	1
not need updating	1
not need relocation	1
not even compatible	1
not even temporarily.	1
not sure you	1
not always for	1
not always as	1
not always possible	1
not always work	1
not always able	1
not always apply	1
not always fully	1
not always avoiding	1
not always true.	1
not always work.	1
not always accurate,	1
not always comparable	1
not always sequential,	1
not always optimal,	1
not out of	1
not dynamic libraries	1
not part of	1
not up to	1
not making any	1
not accessed by	2
not work in	1
not work on	1
not necessary to	2
not necessary for	1
not necessary if	1
not necessary when	1
not necessary because	1
not thread safe	1
not good to	1
not been a	1
not been tested	1
not been given	1
not been updated	2
not optimized for	1
not get the	1
not get any	1
not check for	1
not check if	1
not advantageous to	3
not advantageous by	1
not advantageous then	1
not known at	6
not support the	1
not support static	1
not support SSE.	1
not supported at	1
not supported fprintf(stderr,	1
not doing divisions.	1
not add to	1
not well documented.	1
not able to	2
not certain to	1
not shared between	1
not quite as	1
not used. The	1
not recommended to	3
not recommended for	1
not recommended if	1
not optimize as	1
not optimize well.	1
not optimal to	1
not optimal from	1
not optimal because	2
not cost anything	1
not efficient. If	1
not needed in	2
not needed for	1
not needed if	2
not read or	1
not give the	1
not look at	1
not load all	1
not declared volatile	1
not improve the	1
not divisible by	2
not know that	1
not appropriate here.	1
not require a	1
not negative by	1
not predicted well.	1
not compatible with	2
not compatible across	1
not intended for	1
not turn on	1
not produce any	3
not safe unless	1
not clear whether	1
not mix single	1
not fit into	1
not needed. You	1
not needed. Obviously,	1
not needed. Even	1
not copied because	1
not allow vector	1
not expect to	1
not swap the	1
not significant as	1
not enough registers	1
not apply to	2
not allocate more	1
not critical. It	1
not vectorize automatically.	1
not include any	1
not fully optimized	1
not standardized across	1
not included in	1
not easily ported	1
not resolved when	1
not allowed to	1
not allowed in	1
not suitable for	1
not spend time	1
not free the	1
not do. The	1
not evaluated at	1
not edx but	1
not permissible to	1
not permissible for	2
not overlap. If	1
not overlap. You	1
not overlap. See	1
not overlap. 27	1
not backwards compatible	1
not portable to	1
not _WIN64 not	1
not _WIN64 64	1
not necessarily stored	1
not necessarily done	1
not necessarily stay	1
not necessarily newer.	1
not divided into	1
not seen in	1
not wrap around	1
not necessary. A	1
not all. Fortunately,	1
not doubled. A	1
not present in	1
not overlap or	1
not optimal. There	1
not optimal. Use	1
not guaranteed to	1
not expensive. You	1
not going to	1
not __INTEL_COMPILER __INTEL_COMPILER	1
not cached. The	1
not cached. See	1
not optimized. Jumps	1
not normally use	1
not satisfied with	1
not alias any	1
not alias anything	1
not separated from	1
not cover graphics	1
not unusual for	2
not solve all	1
not occur. The	1
not occur. See	1
not _WIN32 n.a.	1
not throw exceptions	1
not modified. Unlike	1
not overlapping or	1
not computationally intensive	1
not vacant then	1
not suited for	1
not supported. The	1
not visible in	1
not allowed. Non-public	1
not testing. Trying	1
not uncommon for	2
not 123 correspond	1
not accessible from	1
not noticed that	1
not recognized in	1
not human readable	1
not yet as	1
not referenced from	1
not selected. Compiler	1
not evaluated, because	1
not detected until	1
not supported"); return;	1
not safe, of	1
not standardized. It	1
not affected by	1
not aliased #pragma	1
not backwards. Copying	1
not traditionally considered	1
not used). You	1
not satisfactory. The	1
not met then	1
not alias, if	1
not reproducible. Such	1
This is the	12
This is a	14
This is of	2
This is not	2
This is data	1
This is because	8
This is only	3
This is all	1
This is used	1
This is one	2
This is no	1
This is also	1
This is efficient	1
This is very	1
This is faster	2
This is called	7
This is less	1
This is often	2
This is how	1
This is useful	3
This is sure	1
This is necessary	1
This is small	1
This is done	2
This is advantageous	2
This is quite	1
This is optimal	1
This is typically	1
This is actually	1
This is usually	1
This is just	1
This is intended	1
This is slow	2
This is inefficient	1
This is safe	1
This is approximately	1
This is equally	1
This is efficient,	1
This is inefficient,	1
This is coded	1
This is unfortunate	1
This is annoying	1
This is supplied	1
This can be	23
This can have	1
This can cause	4
This can actually	1
This can improve	1
This can save	1
This can lead	1
This function is	3
This function writes	1
This function stores	1
This function adds	1
This code will	1
This code has	1
This code works	1
This code took	1
This compiler is	1
This compiler does	1
This may be	4
This may take	1
This may cause	2
This may typically	1
This may improve	1
This may require	1
This may enable	1
This time is	1
This will be	1
This will make	4
This will generate	1
This will prevent	1
This will enable	1
This will allow	1
This will happen	1
This will provoke	1
This memory space	1
This data conversion	1
This has the	4
This has a	3
This has three	1
This has hardly	1
This has influence	1
This instruction set	3
This loop repeats	1
This loop calculates	1
This should be	1
This example is	1
This pointer is	1
This library has	4
This library contains	1
This also makes	1
This also applies	1
This makes the	2
This makes a	1
This makes it	3
This makes function	1
This makes code	1
This makes data	7
This makes sure	3
This makes operations	1
This makes inlining	1
This makes position-	1
This new insight	1
This method is	10
This method can	2
This method may	1
This method also	1
This method works	1
This method requires	2
This extra check	1
This extra cost	1
This does not	2
This large memory	1
This processor has	1
This option makes	2
This works in	2
This works by	1
This manual is	3
This manual does	1
This manual discusses	1
This calculation requires	1
This check makes	1
This problem can	1
This problem has	1
This solution is	1
This solution can	1
This advantage comes	1
This would not	1
This would double	1
This would require	1
This structure or	1
This standard is	1
This information is	1
This above code	1
This typically takes	1
This typically happens	1
This allows the	2
This allows it	1
This allows common	1
This expression is	1
This implementation uses	1
This needs a	1
This conversion takes	1
This cost is	1
This mechanism is	1
This means that	7
This requires a	1
This requires that	1
This requires no	1
This framework typically	1
This results in	1
This feature is	1
This feature uses	1
This section discusses	1
This index must	1
This gives a	1
This operation will	1
This task must	1
This prevents the	4
This prevents it	1
This alignment can	1
This effect can	1
This so-called virtual	1
This so-called symbol	1
This includes the	1
This includes static	1
This includes pointers	1
This includes languages	1
This delay is	1
This chapter is	1
This garbage collection	1
This penalty should	1
This gain in	1
This series of	1
This applies to	2
This tool is	1
This tool can	1
This principle is	1
This happens when	1
This tells the	1
This enables the	2
This enables interprocedural	1
This non-inlined copy	1
This unit-testing is	1
This normally belongs	1
This reordering has	1
This removed the	1
This wasteful behavior	1
This reflects the	1
This reduces the	1
This safety problem	1
This worked sufficiently	1
This technique is	1
This dilemma can	1
This fragmentation of	1
This ends the	1
This corresponds to	1
This closely follows	1
This behaviour is	1
This requires, of	1
This triangle is	1
This '1' is	1
- a &	4
- a |	1
- a ^a	1
- to make	1
- in terms	1
- - -	68
- - x	27
- - n.a.	32
- - Integer	1
- - xxxxxxxxx	1
- - x-xx----x	1
- - 76	1
- x -	27
- x x	37
- x 74	1
- no need	1
- n.a. -	12
- n.a. x	4
- n.a. n.a.	35
- n.a. Floating	1
- n.a. -(-a)	1
- n.a. a-a	1
- n.a. x*x*x*x*x*x*x*x	1
- n.a. a+b	1
- n.a. a*0	1
- n.a. a*1	1
- n.a. a+0	1
- n.a. a*b+a*c	1
- n.a. !(a	1
- n.a. (-a)*(-b)	1
- n.a. (a+b)+c	1
- n.a. a+a+a+a	1
- there is	1
- 2 clock	1
- 4 clock	1
- 8 clock	1
- 64 Kbytes	1
- they are	1
- 16 clock	1
- Integer XMM	1
- preferably isolated	1
- 1; }	2
- Table 8.1.	1
- 10 clock	1
- 5 clock	1
- 100 clock	1
- 2, x	1
- 20 clock	2
- 6 clock	1
- reciprocal n.a.	1
- x-xxxx--x x-xxxx--x	1
- 80 clock	2
- xxxxxxxxx --	1
- -(-a) =	1
- 5. www.amd.com.	1
- 45 clock	2
- a-a =	1
- Divide by	1
- 30 //	1
- ----- x----	1
- 25 clock	1
- a*0 =	1
- a*1 =	1
- time1; //	1
- a+0 =	1
- (time before)	1
- vectorclass www.agner.org/optimize/#vectorclass.	1
- a*b+a*c =	1
- 0/a =	1
- (a&b)|(a&c) =	1
- masm=intel /FA	1
- a<<b<<c =	1
- x-xxx -	1
- min) <=	1
- a/1 =	1
- a+b+c =	1
- xx x	1
- x-xx----x x-xxxxxx-	1
- andnot(a,a) =	1
- xx(-)x- -	1
- 2014. Last	1
- 8*x +	1
- 76 Boolean	1
- min)) {	1
- 8.0f) *	1
an int is	2
an int uses	1
an instruction that	1
an instruction set	1
an integer is	2
an integer of	1
an integer to	2
an integer in	3
an integer that	1
an integer can	1
an integer if	2
an integer with	1
an integer because	1
an integer size	1
an integer takes	1
an integer variable	1
an integer constant	1
an integer known	1
an integer counter	1
an integer addition,	1
an integer variable,	1
an integer comparison,	1
an integer constant,	1
an example of	3
an example in	1
an Intel function	1
an Intel before	1
an Intel Pentium	1
an Intel compiler,	1
an Intel CPU.	1
an Intel processor.	1
an object is	2
an object of	7
an object to	1
an object that	1
an object by	1
an object with	1
an object It	1
an object file	1
an object must	1
an object through	1
an object after	1
an object oriented	1
an efficient way	1
an efficient solution.	2
an array of	3
an array to	2
an array and	1
an array can	1
an array or	2
an array with	1
an array element	1
an array index	3
an array element.	1
an array index.	1
an array grows	1
an address divisible	5
an address below	1
an operating system	1
an operating system.	1
an unsigned int	1
an unsigned integer	2
an unsigned variable	1
an even faster	1
an error can	1
an error if	1
an error code	2
an error then	1
an error simply	1
an error message	5
an error condition	1
an error handler	1
an error message.	1
an important part	1
an important distinction	1
an extra cache	1
an extra register	2
an extra cost	1
an extra framework	1
an extra iteration	1
an extra level	1
an extra jump	1
an extra dummy	1
an extra layer	1
an assembly language	1
an assembly output	1
an assembly listing.	1
an execution unit.	1
an element in	1
an exception in	2
an exception or	1
an exception then	1
an exception without	1
an exception occurs	2
an overflow and	1
an overflow or	1
an overflow check.	1
an option for	5
an option that	1
an option (Windows:	1
an optimized function,	1
an advantage to	2
an advantage in	2
an advantage if	1
an advantage because	1
an inline function	1
an inline assembly	1
an optimizing compiler	5
an intermediate code	5
an intermediate code.	1
an intermediate file	1
an intermediate code,	1
an optimal solution	1
an application to	1
an application program	1
an expression that	2
an expression or	1
an induction variable	2
an induction variable.	1
an && expression,	1
an addition to	1
an addition with	1
an || expression.	1
an Intel, even	1
an Intel, AMD	1
an old computer	1
an appropriate error	1
an advanced and	1
an advanced high-level	1
an unused copy	1
an unused fourth	1
an STL vector	1
an STL container	1
an index of	1
an index multiplied	1
an inefficient way.	1
an instance of	1
an output file.	1
an inlined function.	1
an inlined 15.1b	1
an algorithm of	1
an offset that	1
an operand is	1
an unknown CPU	1
an overloaded function	1
an overloaded operator	1
an overloaded assignment	1
an entire cache	1
an executable file	1
an input file.	1
an explanation of	5
an explanation and	1
an integer, and	1
an integer, or	1
an integer, then	1
an integer, so	1
an integer, usually	1
an interrupt should	1
an interrupt occurs	1
an arithmetic expression.	1
an array. The	1
an update when	1
an integer. The	1
an integer. If	1
an integer. But	1
an integer. 158	1
an equal amount	1
an 9 extra	1
an int, without	1
an obvious thing	1
an excessive number	3
an increasing number	2
an explanation. Note	1
an explanation. (The	1
an explanation. Please	1
an exception. The	1
an exception. A	1
an exception. Therefore,	1
an additional integer	1
an additional floating	1
an example. The	1
an example. A	1
an example. My	1
an appendix to	2
an empty throw()	2
an IDE. Does	1
an IDE. Free	1
an extended number	1
an underflow and	1
an assumption is	1
an uncached read	1
an existing object	1
an existing program.	1
an explicit CPU	1
an explicit induction	1
an implicit parameter	1
an implicit 'this'	1
an 8-bit signed	2
an inferior version	1
an arbitrary memory	1
an arbitrary cache	1
an arbitrary name	1
an FPGA in	1
an FPGA as	1
an error. //	1
an addition. If	1
an addition. Comparing	1
an unfortunate method	1
an approximate comparison	1
an annoying time	1
an up-to-date function	1
an up-to-date version.	1
an initialization routine	2
an issue because	1
an odd number	1
an insufficient amount	1
an import table	2
an anonymous object.	1
an anonymous namespace.	1
an infinite loop.	1
an immediate response	1
an array, or	1
an interpreter for	1
an interpreter which	1
an EMMS instruction	1
an obstacle to	1
an IDE with	1
an update, or	1
an acceptable limit,	1
an over- loaded	1
an integral number	1
an MFC application.	1
an attribute which	1
an imported pointer,	1
an ordinary procedure	1
an if-else structure),	1
an estimated calculation	1
an illegal operation	1
an hour. Neither	1
an unrecoverable error	1
an antivirus program	1
an n'th degree	1
an integer). All	1
an interrupt, e.g.	1
an error; and	1
int is 16	1
int is 32	1
int is 4.	1
int a =	1
int in the	1
int in one	1
int in 16-bit	4
int or by	1
int if (i	1
int int 256	1
int x =	2
int one :	1
int size =	12
int i =	1
int * p)	1
int * __restrict	1
int before dividing	1
int 4 AVX	1
int 4 AVX2	1
int 8 AVX2	2
int unsigned int	1
int unsigned char	1
int 64 0	1
int 64 Is32vec2	1
int 64 Is16vec4	1
int 64 Iu16vec4	1
int 16 4	1
int 16 8	1
int 16 16	1
int 16 0	1
int 16 -32768	1
int 32 2	1
int 32 4	1
int 32 8	1
int 32 16	1
int 32 -231	1
int & r)	2
int i; for	6
int i; if	1
int i; int	1
int i; }	8
int i; float	6
int i; long	1
int i; const	1
int i; short	2
int i; ...	3
int i; p	1
int i; for(i=0;	5
int i; 45	1
int i; 84	1
int a, b;	3
int a, b,	6
int 128 Is16vec8	1
int 128 Iu32vec4	1
int 128 Is32vec4	1
int 128 Iu16vec8	1
int uses more	1
int b; a	1
int b; //	1
int b; int	3
int b; static	1
int sign :	1
int sign :1;//signbit	2
int 256 unsigned	1
int c; int	1
int c; };	2
int instead of	1
int x; for	1
int x; const	1
int x; public:	1
int b, c;	1
int i, a,	1
int i, sum	1
int i, f	1
int i, a[100];	1
int i, i_div_3;	1
int i, j;	3
int i, a[100],	3
int i, StringLength;	1
int i, a[2];	1
int i, largest_index	1
int a; //	1
int a; int	2
int a; double	1
int a; Plus2	1
int d; //	2
int exponent :	3
int rows =	3
int level =	2
int u; double	3
int CriticalFunction ();	1
int fraction :	3
int declaration may	1
int 3; or	1
int n; static	1
int n; switch	1
int n; #if	1
int n; u.i	1
int n; 143	1
int factorial (int	2
int bb[], short	9
int aa[], short	9
int cc[]) {	8
int a[100]; //	1
int a[100]; int	1
int Induction =	1
int parm2) {	1
int parm2) {...}	6
int int64_t 256	1
int SomeFunction (int	5
int SIZE =	3
int a[size], b[size];	1
int a[size], b[size],	1
int list[300]; int	4
int Multiply (int	1
int n) {	1
int s; s	1
int s; 40	1
int lrint (double	2
int N> class	2
int r, c;	4
int b;}; Sab	1
int main() {	2
int list[100]; Func1(list,	1
int A, B,	2
int (16 bits),	1
int CriticalFunction_386(int parm1,	2
int a[2]; a[0]	1
int b:2; int	2
int MultiplyBy (int	1
int c:2; };	2
int TILESIZE =	1
int Func(int); const	2
int a[1000]; float	1
int a[1000]; F1(a);	1
int CriticalFunction_SSE2(int parm1,	2
int lrintf (float	1
int ArraySize =	1
int ABC =	1
int parm2); //	1
int NumberOfTests =	1
int min =	1
int Func2() {	1
int order(int x);	2
int a:4; int	2
int ARRAYSIZE =	1
int FactorialTable[13] =	2
int CriticalFunction_AVX(int parm1,	2
int matrix[NUMROWS][NUMCOLUMNS]; int	1
int CriticalFunctionType(int parm1,	1
int Sum2(S3 *	1
int c;}; abc	1
int dummy; double	1
int row, column;	1
int Sum3(S3 &	1
int r1, r2,	1
int BigArray[1024] __attribute__((aligned(64)));	1
int FuncRow(int); int	1
int bb[size] );	1
int NUMROWS =	1
int UnusedFiller; };	1
int List[ArraySize]; ...	1
int Func1(int x)	1
int absvalue, largest_abs	1
int BigArray[1024]; //	1
int cc[size] );	1
int u[2]} a[size];	1
int m) {	1
int arraysize =	1
int CriticalFunction_Dispatch(int parm1,	1
int x[]) {	1
int DontSkip; long	1
int list[301]; int	1
int c1::*MemberPointer; Here,	1
int Size() {	1
int ReadB() {return	1
int iset =	1
int aa[size] );	1
int 832 256	1
int Sum1() {return	1
int i[2]; }	1
int dummy[4]; volatile	1
int FuncCol(int); const	1
int seconds; //	1
int cc[]); //	1
than the function	1
than the code	1
than the time	4
than the program	1
than the vector	1
than the CPU	1
than the other	1
than the one	1
than the cache	3
than the library	1
than the number	2
than the variable	1
than the table	1
than the 32-bit	1
than the user	1
than the simple	1
than the Gnu	1
than the speed	1
than the specific	1
than the hardware	2
than the programs	1
than the application	1
than the complicated	1
than the Boolean	1
than the intrinsic	1
than the runtime	1
than the parts	1
than the main	1
than the level-2	1
than the level-1	1
than the alternative	1
than the subsequent	2
than the throughput	1
than the largest	1
than the actual	1
than the equivalent	1
than the C-style	1
than the product	1
than the external	1
than the heap.	1
than the destination	1
than the ones	1
than the other,	1
than a function	2
than a program	1
than a floating	1
than a static	1
than a simple	1
than a thread	1
than a small	1
than a few	3
than a hardware	1
than a certain	1
than a frame	1
than a linear	1
than a non-static	2
than a hundred	1
than a dedicated	2
than a float.	1
than a polymorphous	1
than a minute	1
than to use	1
than to access	1
than to type	1
than to calculate	1
than to store	1
than to write	2
than to execute	1
than to allocate	1
than to delete	1
than to draw	1
than to temporarily	1
than in the	1
than in a	5
than in other	1
than in 64-bit	3
than in 32-bit	1
than in 32	1
than in optimizing	1
than in memory.	1
than for double	1
than for level-1	1
than for auto_ptr.	1
than it is	2
than it can	1
than it used	1
than it takes	1
than it actually	1
than it says.	1
than if the	2
than if because	1
than by the	3
than by a	1
than by using	1
than by pointers	1
than by optimizing	1
than by 16.	1
than by individual	1
than with unsigned	1
than with fine-grained	1
than on the	6
than on floating	1
than code generality.	1
than as a	1
than as b*(2.0/3.0)	1
than an uncached	1
than an MFC	1
than an hour.	1
than x =	3
than when a	1
than when compiled	1
than when n	1
than from the	1
than from floating	1
than memory access	1
than at runtime	1
than at runtime.	1
than CPU time.	1
than other CPUs	1
than other methods	1
than other languages	1
than other kinds	1
than other CPUs,	1
than one variable	1
than one way	1
than one call	1
than one line	1
than one instance	1
than one thing	1
than integer comparisons.	1
than floating point	2
than each time	2
than example 12.4a,	1
than most other	1
than using a	1
than double if	1
than double precision	1
than two 32-bit	1
than two ways.	1
than static memory.	1
than static link	1
than 64-bit Windows	1
than there are	1
than there is,	1
than any non-vector	1
than 2 gigabytes	1
than 2 GB.	1
than 32-bit programs	1
than pointers to	1
than pointers because	1
than pointers are:	1
than 16 bytes	1
than 32 bits.	1
than dynamic linking	1
than 0 and	2
than 0 or	5
than type casting	1
than short int	1
than making a	2
than making it	1
than its name	1
than its brand,	1
than its reputation.	1
than processor features.	1
than single precision.	1
than done to	1
than 128 because	1
than four parameters.	1
than functions. See	1
than doing arithmetic	1
than standard PCs.	1
than optimizing CPU	1
than Boolean expressions.	1
than signed when	1
than signed integers.	1
than division by	2
than end users	1
than addition and	1
than needed in	1
than last time.	1
than linked lists	1
than calling the	1
than references are:	1
than C if	1
than intended because	1
than frame functions	1
than accessing a	2
than processing the	1
than needed. This	1
than mov eax,0.	1
than reading or	2
than calculating the	1
than future processors.	1
than seconds or	1
than 65 bytes	1
than finding the	1
than addition, subtraction	2
than once then	1
than 8, 16,	1
than multiplying by	1
than random access.	1
than rounding unless	1
than 127 bytes	1
than speed. This	1
than normal on	1
than half the	1
than half speed	1
than comparing it	1
than comparing i	1
than truncation when	1
than anything else	1
than third party	1
than pow The	1
than 250 ms.	1
than necessary. Take	1
than two. Some	1
than 2n and	1
than another. Therefore,	1
than RISC in	1
than moving each	1
than allocating more	1
than allocating piecewise	1
than "what works	1
than post-increment. For	1
than Sum2 and	1
than generating denormal	1
than rounding. This	1
than PCs. Therefore,	1
than loops, etc.	1
than 1.23456. The	1
than 99% of	1
than normal. This	1
than normal. 157	1
than relocation, especially	1
than sequences of	1
than non-virtual functions.	1
than 231. This	1
than 1/50 of	1
than 2-20, but	1
than ARRAYSIZE. Another	1
than 1% goes	1
than 20. The	1
than investing in	1
than nine, even	1
than 200. Next,	1
than rendering graphics	1
than looping through	1
than log) inside	1
than others. While	1
than -156. Surprisingly,	1
than 33% when	1
than non-object oriented	1
than 15.1b, and	1
than isolating a	1
than self-styled hacks	1
than normally. There	1
than doubled for	1
compiler is a	4
compiler is that	1
compiler is not	1
compiler is more	1
compiler is less	1
compiler is available	2
compiler is likely	1
compiler is able	2
compiler is usually	1
compiler is used,	1
compiler is prevented	1
compiler is unable	2
compiler is mostly	1
compiler is capable	1
compiler to the	1
compiler to be	1
compiler to make	2
compiler to do	5
compiler to always	1
compiler to work	1
compiler to inline	1
compiler to store	1
compiler to optimize	4
compiler to assume	2
compiler to reduce	2
compiler to predict	1
compiler to evaluate	1
compiler to ignore	1
compiler to vectorize,	1
compiler and the	1
compiler and it	1
compiler and call	1
compiler in the	1
compiler in many	1
compiler in favor	1
compiler for 32-bit	3
compiler for Windows	2
compiler for Linux	1
compiler for Mac	1
compiler for Windows,	1
compiler for 32-	2
compiler for Basic	1
compiler for restrictions	1
compiler for Unix	1
compiler that the	2
compiler that a	1
compiler that can	1
compiler that you	1
compiler that this	1
compiler that automatically	1
compiler that supports	1
compiler can use	4
compiler can then	1
compiler can make	1
compiler can do	1
compiler can also	1
compiler can often	1
compiler can optimize	2
compiler can replace	4
compiler can automatically	2
compiler can see	2
compiler can look	1
compiler can insert	1
compiler can align	1
compiler can easily	1
compiler can eliminate	2
compiler can bypass	1
compiler can safely	1
compiler // Same	1
compiler if the	1
compiler by including	1
compiler with the	1
compiler with other	1
compiler with many	1
compiler with C++0x	1
compiler on the	1
compiler not to	1
compiler may in	2
compiler may be	1
compiler may not	4
compiler may avoid	1
compiler may calculate	1
compiler may replace	5
compiler may actually	1
compiler may reduce	2
compiler may change	2
compiler may try	1
compiler may reorder	1
compiler may report	1
compiler may interleave	1
compiler you are	1
compiler you will	1
compiler have been	1
compiler when called	1
compiler A feature	1
compiler will make	1
compiler will do	1
compiler will always	1
compiler will calculate	1
compiler will store	1
compiler will optimize	1
compiler will replace	1
compiler will see	1
compiler will choose	1
compiler will change	1
compiler will produce	1
compiler will convert	3
compiler will vectorize	2
compiler will recognize	1
compiler from the	1
compiler from making	4
compiler from doing	2
compiler from aligning	1
compiler at compile	1
compiler has to	3
compiler has not	1
compiler has an	2
compiler has no	1
compiler has some	1
compiler has replaced	1
compiler has chosen	1
compiler has solved	1
compiler because it	1
compiler which is	1
compiler should produce	1
compiler Intel compiler	1
compiler Intel compilers	1
compiler There are	2
compiler takes the	1
compiler takes care	1
compiler makes a	1
compiler cannot make	1
compiler cannot know	2
compiler cannot rule	2
compiler often inserts	1
compiler optimization than	1
compiler I have	1
compiler does not	3
compiler does It	1
compiler does some	1
compiler does quite	1
compiler does what	1
compiler does .............................................................................	1
compiler must calculate	1
compiler must convert	1
compiler (see page	1
compiler Windows Intel	2
compiler Windows Gnu	3
compiler Windows Linux	1
compiler versions were	1
compiler versions 7	1
compiler doesn't have	4
compiler doesn't make	1
compiler doesn't need	1
compiler doesn't know	2
compiler doesn't provide	1
compiler option for	2
compiler option -fno-pic	2
compiler option "assume	1
compiler Linux Intel	3
compiler Linux Align	1
compiler Linux Optimize	1
compiler works only	1
compiler manual for	1
compiler manual or	1
compiler uses a	1
compiler uses position-independent	1
compiler would be	1
compiler would assume	1
compiler optimize example	1
compiler allows you	1
compiler allows "__attribute__((visibility("hidden")))".	1
compiler needs to	2
compiler mechanism because	1
compiler optimizations that	1
compiler options to	1
compiler options Table	1
compiler #define Alignd(X)	1
compiler supports this	1
compiler supports vector	1
compiler supports CPU	1
compiler supports intrinsic	1
compiler comes with	1
compiler output can	1
compiler sometimes uses	1
compiler reduced 15.1b	1
compiler reduced 15.1a	1
compiler optimization. en.wikipedia.org/wiki/Compiler_optimization.	1
compiler includes standard	1
compiler e.g. how	1
compiler might store	1
compiler explicitly that	1
compiler itself is.	1
compiler generates the	2
compiler generates is	1
compiler generates to	1
compiler manual. This	1
compiler .......................................................................................... 66	1
compiler combined with	1
compiler additional information	1
compiler 8.1 How	1
compiler documentation for	2
compiler inserts extra	1
compiler optimizes a	1
compiler bypassing the	1
compiler packages include	1
compiler ......................................................................... 128	1
compiler ......................................................................... 130	1
compiler became available.	1
compiler .................................................................................................... 10	1
compiler warning for	1
compiler sees the	1
compiler treat a	1
compiler interpret the	1
compiler recognizes it	1
compiler technology, and	1
compiler price GNU	1
compiler puts the	1
compiler options....................................................................................... 160	1
compiler (parallel composer)	1
compiler ....................................................................... 77	1
compiler knows that	1
compiler makers assume	1
compiler makers. 4.	1
x is treated	1
x is type-casted	1
x to the	3
x to 0	1
x and y?"	1
x in memory	1
x The syntax	1
x for approximately	1
x can be	1
x // get	1
x // align	1
x // x^n	1
x = a	1
x = 2	1
x = 10;	1
x = 2.0;	1
x = *(p++)	1
x = -abs(x);.	1
x = *(++p)	1
x = array[++i]	1
x = array[i++]	1
x by using	1
x as an	1
x - -	34
x - x	35
x - n.a.	3
x - 8.0f)	1
x x -	38
x x x	111
x x Loop	1
x x x-	3
x x (x)	1
x x ((a*x+b)*x+c)*x+d	1
x x --	1
x when it	1
x + 1.0f;}	2
x + 2.0f;	1
x n.a. -	2
x n.a. x	2
x n.a. Constant	1
x * x	2
x * x;	1
x * m;}	2
x so we	1
x < 100;	2
x must wait	1
x > y	1
x Loop invariant	1
x *= x;	1
x <= n;	1
x x- x	4
x 43 speculatively	1
x x-- x	2
x ----- -	1
x (x) x	2
x (x) x-xx--xx-	1
x ((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x	1
x 74 x	1
x -- -	1
x *const_cast<int*>(&x) +=	1
x *x; double	1
x --- -	1
may of course	1
may in some	4
may in fact	1
may be the	1
may be a	6
may be of	1
may be more	3
may be at	1
may be because	1
may be only	1
may be used	7
may be no	1
may be two	1
may be possible	2
may be so	2
may be faster	2
may be stored	1
may be called	2
may be useful	7
may be cases	2
may be necessary	2
may be advantageous	2
may be able	3
may be quite	1
may be fast	1
may be both	1
may be optimal	2
may be three	1
may be better	2
may be needed	1
may be difficult	2
may be bigger	1
may be just	1
may be smaller	1
may be replaced	1
may be loaded	1
may be given	1
may be inlined	1
may be changed	1
may be enough	1
may be situations	1
may be scattered	1
may be preferred	1
may be convenient	1
may be poor	1
may be completely	1
may be obvious	1
may be swapped	1
may be necessary.	1
may be preferable	1
may be needed,	1
may be selected	1
may be modified	2
may be removed	1
may be considered	1
may be moved	1
may be sufficient	1
may be freed	1
may be justified	1
may be worthwhile	1
may be undesired.	1
may be mitigated	1
may be caused	1
may as well	2
may not be	14
may not take	1
may not need	1
may not work	1
may not load	1
may not vectorize	1
may have a	3
may have to	4
may have big	1
may have undesired	1
may use the	3
may use a	1
may use an	1
may use more	1
may use double	1
may use 64-bit	1
may use single	1
may make multiple	1
may make some	1
may make member	1
may make separate	1
may also be	2
may also see	1
may also look	1
may some day	1
may return an	1
may very well	1
may call the	1
may take a	1
may take more	2
may take only	1
may take up	1
may take 3	1
may need to	3
may need extra	1
may need assembly	1
may need modification	1
may need metaprogramming.	1
may even be	1
may even have	1
may even add	1
may want to	2
may work with	1
may avoid the	1
may avoid this	1
may avoid multiple	1
may cause the	1
may cause a	3
may cause cache	1
may cause slight	1
may therefore fail	1
may get a	2
may run with	1
may run at	1
may run slightly	1
may calculate it	1
may add the	1
may add counter	1
may store the	1
may store all	1
may write your	1
may write FatalAppExitA(0,"Array	1
may replace the	1
may replace this	5
may typically look	1
may preferably be	1
may preferably avoid	1
may put the	1
may read the	1
may give inconsistent	1
may look at	1
may look like	2
may actually be	1
may actually add	1
may improve the	4
may improve efficiency	1
may reduce this	2
may choose the	2
may choose a	1
may choose to	2
may choose one	1
may choose either	1
may require a	1
may require that	1
may start at	1
may go through	1
may go undetected.	1
may change the	1
may change this	1
may slow down	2
may produce undesired	1
may save by	1
may save RAM	1
may possibly be	1
may fail to	1
may fail in	1
may occur in	1
may occur as	1
may insert any	1
may consider the	1
may consider if	2
may consider whether	2
may enable the	1
may come unpredictably	1
may happen quite	1
may apply to	2
may define a	1
may contain pointers	1
may try to	1
may remove the	1
may declare the	1
may detect the	1
may prefer to	2
may move the	1
may think that	1
may mirror the	1
may behave differently	1
may catch programming	1
may seem a	1
may seem illogical	1
may ignore the	1
may skip this	1
may decide to	1
may reorder instructions	1
may report that	1
may interfere with	1
may involve the	1
may reuse the	1
may sample more	1
may fill up	1
may interleave the	1
may actively invalidate	1
may occasionally predict	1
may deviate from	1
may view the	1
may write: y	1
may neverthe- less	1
may argue that	1
may supply such	1
may vary dynamically	1
you to use	1
you to define	1
you to manipulate	1
you to override	1
you to reserve	1
you are in	1
you are not	4
you are using	8
you are sure	4
you are making	3
you are doing	1
you are certain	1
you are including	1
you are testing	1
you are satisfied	1
you are overriding	2
you are dealing	1
you are doing.	1
you are feeding	1
you are risking	1
you can have	2
you can use	5
you can make	3
you can only	1
you can set	1
you can do	6
you can double	1
you can also	1
you can take	1
you can avoid	4
you can get	3
you can read	1
you can assume	2
you can reduce	1
you can turn	1
you can rely	2
you can clear	1
you can predict	1
you can expect	2
you can generally	1
you can increase	1
you can obtain	2
you can toggle	1
you may of	1
you may as	2
you may have	1
you may use	3
you may make	2
you may also	1
you may call	1
you may want	2
you may get	2
you may store	1
you may write	1
you may put	1
you may read	1
you may improve	2
you may consider	5
you may define	1
you may reuse	1
you may actively	1
you may view	1
you have to	11
you have this	1
you have two	1
you have even	1
you have big	2
you have special	1
you have ample	1
you use is	1
you use pre-increment	1
you will be	1
you will have	1
you will get	2
you will see	1
you will never	1
you will notice	2
you will soon	1
you make a	1
you make sure	1
you make your	1
you only need	1
you should be	2
you should by	1
you should not	1
you should test	1
you should avoid	3
you should look	1
you should choose	1
you should apply	2
you should multiply	1
you should disable	1
you do use	1
you cannot be	1
you cannot make	1
you cannot always	1
you cannot avoid	1
you cannot replace	1
you cannot assume	1
you cannot find	1
you cannot rely	1
you cannot expect	1
you cannot swap	2
you cannot increase	1
you take into	1
you need to	4
you need it.	1
you access a	1
you access to	1
you access part	1
you want the	3
you want a	1
you want to	22
you want it	1
you want as	1
you want this	1
you want when	1
you want vectorization	1
you want them	1
you must be	1
you must make	2
you must do	1
you must consider	1
you avoid the	1
you avoid an	1
you compile the	2
you compile with	1
you optimized for	1
you get four	1
you would have	1
you run the	1
you write a	1
you see in	1
you don't have	3
you don't need	2
you don't even	1
you don't want	1
you don't care	1
you don't understand	1
you put a	1
you read the	1
you look at	3
you assume that	1
you know that	1
you know what	1
you choose to	1
you just want	1
you start to	3
you change pre-increment	1
you turn them	1
you unroll by	1
you divide the	1
you divide an	1
you consider making	1
you expect the	2
you gain in	1
you gain by	1
you could calculate	1
you had used	1
you measure are	1
you spend on	1
you declare an	1
you follow the	1
you specify an	1
you prefer is	1
you forget to	2
you know). The	1
you discover that	1
you analyze all	1
you activate a	1
{ a =	10
{ The effect	1
{ for (int	2
{ for (c	3
{ for (c2	2
{ for (c1	1
{ // function	1
{ // loop	3
{ // do	1
{ // table	1
{ // test	2
{ // SSE2	2
{ // AVX	2
{ // check	1
{ // Make	4
{ // Table	1
{ // Floating	1
{ // go	1
{ // Loop	3
{ // No	1
{ // Define	2
{ // f	1
{ // Load	4
{ // Cache	1
{ // Array	1
{ // n!	2
{ // u.f	1
{ // Bounds	1
{ // Get	2
{ // Check	1
{ // (N	1
{ // Overflow	1
{ // Returns	1
{ // Catch	1
{ // Remove	1
{ // Safe	1
{ // Generic	1
{ // polynomial(x)	1
{ // Round	1
{ // Detect	1
{ // 2-dimensional	1
{ // abs(u.f)	1
{ // Main	1
{ if (i	1
{ if (b)	4
{ if (n	2
{ if (b	2
{ if (y)	1
{ int a	1
{ int i;	3
{ int a,	2
{ int b,	1
{ int a;	1
{ int r,	2
{ int list[100];	1
{ int a[1000];	1
{ int a:4;	2
{ int dummy[4];	1
{ has the	1
{ double b;	1
{ double y	1
{ double d;	1
{ double x2	1
{ float a,	1
{ float f;	8
{ float xn	1
{ float b[1000];	1
{ static float	1
{ static const	1
{ return a	4
{ return x	4
{ return 0;	1
{ return x;	1
{ return 1.0;	1
{ return _mm_loadu_si128((__m128i	3
{ return Func1(x)	1
{ return pow(x,10);	1
{ return IntegerPower<10>(x);	1
{ return x*x	1
{ return ipow(x,10);	1
{ return powN<true,N/2>::p(x)	1
{ return _mm_load_si128((__m128i	1
{ return square(x)	1
{ return _mm_cvtss_si32(_mm_load_ss(&x));}	1
{ return N;	1
{ return vector(x	1
{ return _mm_cvtsd_si32(_mm_load_sd(&x));}	1
{ const int	2
{ unsigned int	3
{ case 0:	1
{ short int	1
{ c =	1
{ ... a	1
{ ... can	1
{ ... }	1
{ ... There	1
{ ... Here,	1
{ ... Here	1
{ ... Conversions	1
{ y =	4
{ public: int	3
{ public: static	4
{ public: void	5
{ public: virtual	4
{ public: ...	1
{ public: B2	1
{ r =	1
{ union {	1
{ a[i] =	8
{ S1 x,	1
{ temp =	1
{ d =	1
{ sum +=	1
{ struct {	1
{ list[i] +=	2
{ cout <<	8
{ seconds =	1
{ *p =	2
{ try {	1
{ j =	2
{ C1 x;	1
{ C1 obj1;	1
{ C1 Object1;	1
{ sum1 +=	1
{ b[i] =	1
{ __declspec(align(16)) static	1
{ CChild1 Object1;	1
{ 89 int	1
{ _mm_storeu_si128((__m128i *)d,	3
{ Vec16s a,	1
{ (iset >=	1
{ __m128 s;	1
{ F2(b); }	1
{ aa[i] =	2
{ FuncA(i); }	1
{ FuncA(i); FuncC(i);	1
{ s0 +=	1
{ F1(a); }	1
{ goto CFALSE;	1
{ goto DTRUE;	1
{ DoThisThreeTimesAWeek(); }	2
{ list[i].a =	1
{ swapd(a[r2][c2],a[c2][r2]); }	2
{ memset(a, 0,	1
{ Sunday, Monday,	1
{ largest_abs =	1
{ Table[x] =	2
{ b.load(bb+i); c.load(cc+i);	1
{ Sunday =	1
{ time1 =	1
{ protected: T	1
{ FuncB(i); }	1
{ CFALSE: c	1
{ DTRUE: d	1
{ "Alpha", "Beta",	1
{ __declspec(__align(64)) double	1
{ ab[i].b =	1
{ _mm_store_si128((__m128i *)d,	1
{ F1(); }	1
{ StoreNTD(&a[c][r], b[r][c]);	1
{ temp->a =	1
{ a[c][r] =	1
{ _mm_stream_pi((__m64*)dest, *(__m64*)&source);	1
{ 92 DynamicArray[i]	1
have the time	1
have the same	1
have the member	1
have the following	1
have the best	1
have the necessary	1
have the line	1
have the disadvantage	1
have the disadvantages	1
have the selected	1
have a =	1
have a function	1
have a standard	1
have a high	1
have a graphics	1
have a feature	2
have a special	1
have a destructor	2
have a reduced	1
have a 'this'	1
have a false	1
have a strict	1
have a larger	1
have a non-inlined	1
have a dedicated	1
have a natural	2
have a built-in	1
have a physics	1
have a niche	1
have a balanced	1
have a temp1	1
have a strategy	1
have to be	7
have to make	1
have to set	1
have to do	5
have to call	2
have to take	1
have to test	1
have to avoid	1
have to check	1
have to calculate	1
have to add	1
have to store	1
have to replace	1
have to save	2
have to unroll	1
have to execute	1
have to vectorize	1
have to include	1
have to care	1
have to wait	1
have to identify	1
have to prefetch	1
have to distinguish	1
have to worry	2
have to push	1
have to distribute	1
have to fix	1
have to obey	1
have to reinvent	1
have to consult	1
have to adapt	1
have as few	1
have not been	1
have an operating	1
have an extra	1
have an assembly	1
have an option	4
have an empty	1
have an up-to-date	1
have an attribute	1
have an estimated	1
have this problem	1
have this problem.	1
have more than	1
have more references	1
have more powerful	1
have memory caches.	1
have vector instructions	1
have functions for	1
have only one	2
have CPU dispatching	1
have other values	3
have used the	1
have used char	1
have one and	1
have one addition	1
have one instance	1
have no more	1
have no other	3
have no cache	1
have no branch	1
have no specific	2
have no check	2
have no checking	1
have no out-of-order	1
have no explanation	1
have no native	1
have floating point	1
have each their	1
have multiple //	1
have multiple versions.	1
have two or	2
have two different	2
have such a	1
have such checks.	1
have efficient table-based	1
have many different	1
have many file	1
have many keywords	1
have variable lengths	1
have any other	1
have any brand	1
have some disadvantages	1
have very different	1
have very good	1
have very few	1
have long double	1
have less computing	1
have even a	1
have access to	1
have its pointer	1
have its own	1
have execution units,	1
have big data	2
have big arrays	1
have big endian	1
have much less	1
have several versions	1
have several advantages	1
have been stored	1
have been replaced	1
have been tested	1
have been initialized	1
have been defined	1
have been added	1
have been added?	2
have been lost	1
have been reordered,	1
have been found,	1
have been unsatisfied	1
have been identified.	1
have done the	1
have done a	1
have four numbers	1
have implemented a	2
have support for	2
have eight numbers	1
have values far	1
have information about	1
have certain instructions	1
have addresses divisible	1
have quite dramatic	1
have fast ways	1
have Boolean variables	1
have separate containers	1
have put the	1
have various optimization	1
have various options	1
have three values	1
have public variables	1
have made a	1
have just two	1
have tested the	2
have tested can	1
have tested were	1
have tested implement	1
have tested seem	1
have become more	1
have become bigger	1
have inefficient code-based	1
have described some	1
have particularly slow	1
have special reasons	1
have names that	1
have names with	1
have little or	1
have similar CPU	1
have features for	1
have added a	1
have provided several	1
have #if directives	1
have family number	1
have exactly the	1
have spent fighting	1
have powerful facilities	1
have mixed precision	1
have mixed types	1
have constructors and	1
have unacceptably long	1
have seen many	1
have AND'ed b	1
have ever seen	1
have facilities for	1
have finished the	1
have (set) =	1
have supplied in	1
have undesired effects.	1
have discovered that	1
have developed a	1
have extern "C"	1
have inherent support	1
have got low	1
have got RISC	1
have inserted UnusedFiller	1
have difficulties making	2
have worked well	1
have Booleans as	1
have occurred. This	1
have ample resources.	1
have studied do	1
have confirmed this	1
have sent me	1
have little-endian storage,	1
have exploited. A	1
have gone to	1
have tested. The	1
have tried. The	1
this the time	3
this is the	3
this is a	1
this is to	2
this is that	2
this is not	7
this is only	1
this is possible	1
this is often	1
this is likely	1
this is permissible	1
this is sufficiently	1
this is extremely	1
this is obvious,	1
this to be	2
this to i	1
this in a	2
this for testing	1
this can be	1
this can cause	1
this can eliminate	1
this or for	1
this function is	1
this function to	1
this function and	1
this function can	1
this function on	1
this by //	5
this by using	1
this by making	1
this by preferably	1
this by measuring	1
this by invoking	1
this by assigning	1
this by writing:	1
this with an	1
this with induction	1
this code is	1
this code can	1
this code with	1
this code version	1
this may work	1
this may improve	1
this time has	1
this time lag.	1
this will use	1
this will make	1
this will trigger	1
this memory block	1
this only happens	1
this instruction set	2
this instruction set?".	1
this loop by	1
this loop will	1
this example is	2
this example can	2
this example has	1
this example only	1
this example should	1
this example so	1
this pointer is	1
this pointer in	1
this library with	2
this number of	1
this number we	1
this value will	1
this value from	1
this table may	1
this way is	1
this way includes	1
this makes the	1
this address is	1
this example, the	3
this example, we	1
this example, a,	1
this example, f(x)	1
this bit scan	1
this first manual.	1
this optimization automatically	1
this optimization explicitly.	1
this code. For	1
this method is	3
this method for	1
this method if	1
this method only	1
this method doesn't	1
this method works	1
this part of	2
this case is	2
this case it	3
this case you	1
this case there	1
this case we	1
this case so	1
this error is	1
this error by	1
this important new	1
this extra element	1
this does not	1
this work on	1
this result in	1
this language gained	1
this option only	1
this line by	1
this works and	1
this works only	1
this manual for	1
this manual at	3
this calculation implemented	1
this problem is	3
this problem are	1
this problem by	2
this problem when	1
this solution is	2
this solution can	1
this would be	1
this would give	1
this every time	1
this information to	1
this multiplication will	1
this complicated template	1
this requires static	1
this feature is	3
this function, though	1
this range then	1
this section for	1
this section if	1
this section by	1
this example: 38	1
this statement so	1
this hot spot.	1
this fact by	1
this task when	1
this shift in	1
this prevents a	1
this efficiency lies	1
this discussion that	1
this alignment automatically.	1
this effect is	1
this time, any	1
this optimization. 8.2	1
this address. Step	1
this might be	1
this problem. The	1
this problem. If	1
this problem. These	1
this problem. 7.11	1
this problem. Vectors	1
this series of	1
this to: //	5
this brand was	1
this involves the	1
this unit is	1
this kind of	3
this jump by	1
this case. The	1
this case. A	1
this case. You	1
this case. Loop	1
this polynomial can	1
this principle for	1
this method. Your	1
this manual. You	1
this manual. 2.3	1
this case, the	1
this example. We	1
this option. This	1
this option. Use	1
this option. 8.4	1
this appears to	1
this unit-test may	1
this manually. This	1
this format. Other	1
this reordering easier	1
this distance the	1
this wasteful copying	1
this purpose. It	1
this condition. In	1
this bookkeeping depends	1
this argument is	1
this problem: 1.	1
this problem: (1)	1
this purpose, or	1
this column. Number	1
this "override" feature.	1
this initialization, or	1
this manual, but	1
this manual, I	1
this limitation). 14.11	1
this interval, for	1
this did not	1
this works, here's	1
this topic, see	1
this rule. Splitting	1
this delaying process	1
this limitation and	1
this block: 62	1
this chapter. Using	1
this loop? Certainly	1
this reason. A	1
this reason, you	1
this mask, and	1
this place. This	1
this respect. 7.15	1
this capability: //	1
this chapter, I	1
time the function	9
time the program	2
time the variable	1
time the software	2
time the critical	1
time the computer	1
time the statement	1
time is so	1
time is typically	1
time is needed	1
time is actually	1
time is included	1
time is interpreted	1
time is determined	1
time is measured	1
time is spent	2
time is doubled.	1
time is consistent	1
time is wasted	2
time a function	2
time a new	3
time a string	2
time a thousand	1
time of programming	1
time of 250	1
time of programming.	2
time to call	1
time to user	1
time to calculate	1
time to copy	1
time to load	1
time to execute	1
time to e.g.	1
time to share	1
time to eliminate	1
time to transpose	2
time to evaluate	1
time to load.	1
time to answer	1
time to calculate.	1
time and it	1
time and b	1
time and compatibility	1
time and insert	1
time and rarely	1
time and show	1
time and resolve	1
time and afterwards	1
time and maintainability	1
time in the	1
time in most	1
time in library	1
time in case	1
time in vectors	1
time in thousand	1
time for the	2
time for software	1
time for WTL	1
time that is	1
time that it	1
time can be	1
time or a	2
time it is	2
time it takes	23
time it was	3
time it takes.	2
time it uses.	1
time if and	1
time if it	1
time on the	1
time on processors	2
time on executing	1
time on deciding	1
time as the	1
time as long	1
time an object	1
time int CriticalFunction_Dispatch(int	1
time than the	2
time than other	1
time than single	1
time than addition	1
time than accessing	1
time than processing	1
time than addition,	2
time than rounding	1
time than normal	1
time than anything	1
time than looping	1
time than normally.	1
time may be	1
time you would	1
time you spend	1
time you activate	1
time when the	3
time when code	1
time when performance	1
time then the	1
time then there	2
time at unpredictable	1
time has been	1
time because the	2
time because of	1
time because it	1
time because each	1
time which version	1
time but avoids	1
time used for	1
time used by	1
time each part	1
time we are	1
time so that	2
time You can	1
time before the	1
time before and	1
time rather than	2
time they are	1
time Some developers	1
time while if	1
time doing the	1
time both during	1
time unless the	1
time too small	1
time goes to	1
time loading files	1
time delay that	1
time under worst-case	1
time loops or	1
time unit is	1
time applications. Remember	1
time stamp counter	5
time stamp counter.	2
time consuming because	2
time consuming parts	1
time consuming updates	1
time T to	1
time measurements to	1
time measurements may	1
time waiting for	2
time spent in	1
time spent on	1
time Func is	2
time here. It	1
time regardless of	1
time consuming. A	1
time consuming. Therefore,	2
time consuming. Sometimes	1
time searching for	1
time consumption of	2
time consumption as	1
time consumption was	1
time slices is	1
time slices of	1
time slices to	1
time slices allocated	1
time cleaning up	1
time compared to	1
time consumers ................................................................................	1
time consumers 3.1	1
time intervals are	1
time MemberPointer is	1
time consumer to	1
time consumer if	1
time T+1 to	1
time slices. This	1
time consumers. Choose	1
time consuming, especially	1
time intervals. Some	1
time packed into	1
time lag. Thinking	1
time measurement. If	1
time slice are	1
time measure. This	1
time measurements: warm	1
use the same	12
use the functions	1
use the CPU	1
use the most	1
use the Intel	2
use the static	1
use the 64-bit	1
use the value	1
use the software	1
use the const	1
use the bit	1
use the best	1
use the AVX	1
use the copy	1
use the well	1
use the name	1
use the high	1
use the zero	1
use the source	1
use the induction	1
use the XMM	1
use the vectors	1
use the core	1
use the #pragma	1
use the local	1
use the safe	1
use the so-called	1
use the bitwise	1
use the header	1
use the default	1
use the memcpy	1
use the Gnu,	1
use the smallest	3
use the newest	1
use the upper	1
use the lrint	1
use the GetTickCount	1
use the _mm_clflush	1
use is a	1
use a function	1
use a compiler	1
use a different	2
use a loop	2
use a set	2
use a version	1
use a table	2
use a new	1
use a constant	1
use a stack	1
use a container	2
use a lot	1
use a lookup	2
use a linked	1
use a negative	1
use a database	1
use a smart	1
use a linear	2
use a hash	1
use a console	1
use a sorted	1
use a systematic	1
use a #define,	1
use a union,	1
use a queue.	1
use of the	3
use of vector	1
use of integer	1
use of floating	1
use of Intel	1
use of two	1
use of register	1
use of assembly	1
use of arrays	1
use of threads	1
use of classes	1
use of intrinsic	1
use of <<	1
use of RAM	1
use of structures	1
use of templates	1
use of software.	1
use of memset	1
use of longjmp	1
use of coprocessors	1
use and data	1
use and returns	1
use in system	1
use in case	1
use in programs	1
use for a	1
use for each	1
use for many	1
use for recovering	1
use that for	1
use can be	1
use it for	2
use on such	1
use as pivot	1
use an integer	1
use an object	2
use an intermediate	1
use an advanced	1
use than pointers	1
use than others.	1
use this function	1
use this library	2
use this number	1
use this method	1
use this information	1
use this complicated	1
use this principle	1
use time searching	1
use more time	1
use more resources	1
use vector operations	3
use vector instructions	1
use vector operations.	1
use vector classes,	1
use different memory	2
use different execution	1
use only the	1
use only a	1
use only compilers	1
use one container	1
use one 256-bit	1
use integer operations	1
use double precision	1
use Intel VTune,	1
use float rather	1
use multiple CPU	1
use multiple CPUs	1
use multiple accumulators	1
use static variables.	1
use static linking,	1
use 64-bit systems	1
use 64-bit integers	2
use such methods	1
use any of	1
use 32-bit integers	1
use unsigned integers	1
use 64 bits	1
use rather than	1
use pointers may	1
use these methods	1
use 32 bits	1
use dynamic memory	6
use assembly code	1
use assembly language.	1
use large amounts	1
use big endian	1
use single precision	1
use single precision.	1
use AMD CodeAnalyst.	1
use exception handling	1
use AVX only	1
use inline assembly	1
use standard user	1
use standard API	1
use intrinsic functions	1
use induction variables	1
use string classes,	1
use lookup tables	1
use runtime type	1
use linked lists.	1
use later in	1
use binary search	1
use depends on	1
use STL containers.	1
use #pragma vector	1
use position-independent code	2
use vectorized code	1
use it. Complicated	1
use full 64-bit	1
use algebraic manipulations	1
use situation where	1
use alternative implementations.	1
use standardized installation	1
use #if instead	1
use just-in-time compilation	1
use just-in-time compilation.	1
use GOT and	1
use absolute references	1
use truncation towards	1
use excessive loop	1
use pre-increment or	1
use hyperthreading or	1
use branches, provided	1
use relocation. The	1
use internet or	1
use denormal numbers.	1
use hexadecimal numbers	1
use ~ for	1
use thread-safe functions.	1
use objconv or	1
use SafeArray: //	1
use inappropriate CPU	1
use segmentation of	1
use try, catch,	1
more of the	1
more and more	1
more by the	1
more by choosing	1
more on this	1
more than the	2
more than a	2
more than it	2
more than an	1
more than one	6
more than two	1
more than 2	1
more than four	1
more than calling	1
more than once	1
more than half	1
more than 250	1
more than 99%	1
more than 33%	1
more than doubled	1
more time to	4
more time than	9
more time but	1
more time loading	1
more then the	1
more memory resources	1
more memory blocks	1
more data than	1
more vector instructions	1
more CPU time	1
more cache space.	1
more integer to	1
more integer vector	1
more integer units,	1
more efficient to	14
more efficient and	1
more efficient in	4
more efficient if	1
more efficient than	14
more efficient when	2
more efficient because	1
more efficient way	1
more efficient solution	1
more efficient container	1
more efficient code,	1
more efficient alternatives	1
more efficient today	1
more clock cycles	1
more performance monitor	2
more time. Single	1
more template instances	1
more useful methods	1
more dynamic libraries	1
more bits than	1
more error prone.	2
more important to	1
more important it	1
more important than	2
more versions of	2
more threads with	1
more threads writing	1
more common to	1
more advantageous the	1
more advantageous if	1
more likely to	1
more information about	1
more space in	1
more space than	1
more space 91	1
more complicated to	1
more complicated and	2
more complicated in	1
more complicated if	1
more complicated because	1
more complicated functions	1
more complicated solution	1
more complicated implementation	1
more complicated mathematical	1
more complicated reductions.	1
more resources than	5
more efficient. The	2
more efficient. This	1
more efficient. 64-bit	1
more efficient. You	1
more efficient. 64	1
more efficient. Variables	1
more examples of	1
more difficult to	1
more difficult for	1
more advanced data	1
more relevant to	1
more reductions on	1
more references to	1
more syntax check.	1
more safe to	1
more safe than	1
more discussion of	1
more clear to	1
more clear and	2
more clear program	1
more clear unless	1
more efficiently by	1
more efficiently with	1
more efficiently than	1
more efficiently from	1
more details on	1
more RAM than	2
more time-consuming than	1
more frequent if	1
more iterations back.	1
more fragmented when	1
more general method	1
more random than	1
more important. 9.2	1
more serious when	1
more expensive and	1
more expensive than	1
more reliable and	1
more reliable than	1
more reliable results.	1
more predictable than	2
more compact and	1
more compact if	1
more compact by	1
more compact than	1
more compact so	1
more complex and	1
more complex if	1
more complex integer	1
more complex cases	1
more convenient to	2
more efficient, and	1
more powerful solution	1
more powerful computers	2
more popular and	1
more realistic goal	1
more jobs simultaneously	1
more resources, even	1
more cores, and	1
more dramatic when	1
more detailed explanation	1
more reproducible time	1
more constants. For	1
more detail in	1
more compact. Accessing	1
more (128 or	1
more focus on	1
more readable when	1
more readable but	1
more well-structured program	1
more difficult. The	1
more difficult. On	1
more complex, that	1
more complex, but	1
more efforts in	1
more efficiently. It	1
more distant future.	1
more efficient: //	1
more primitive, but	1
more complicated. If	1
more heuristic guidelines.	1
more manageable and	1
more powerful. The	1
when the function	7
when the code	5
when the data	1
when the program	9
when the loop	1
when the floating	3
when the size	3
when the pointer	1
when the library	1
when the object	2
when the number	2
when the clock	1
when the optimization	1
when the SSE2	7
when the arrays	1
when the work	2
when the result	1
when the virtual	1
when the hardware	1
when the next	2
when the XMM	3
when the computer	1
when the #pragma	1
when the repeat	1
when the exponent	2
when the final	1
when the amount	1
when the total	1
when the heap	2
when the row	1
when the CPUID	3
when the factor	1
when the AVX512	1
when the highest	1
when the original	1
when the 145	1
when a is	1
when a function	1
when a memory	1
when a program	1
when a pointer	1
when a new	1
when a user	1
when a thread	1
when a global	1
when a task	1
when a fixed-size	1
when a genuine	1
when in fact	1
when it is	6
when it has	1
when it would	1
when it goes	1
when it comes	1
when it returns.	1
when it involves	1
when it occurs,	1
when it sees	1
when it exits.	1
when it changes.	1
when code and	2
when code caching	1
when not selected.	1
when an operand	1
when you are	3
when you want	2
when you compile	1
when you divide	1
when you discover	1
when data are	2
when CPU access	1
when instruction sets	1
when all threads	1
when used for	1
when used as	1
when no reasonable	1
when no attempt	1
when using references.	1
when Intel libraries	1
when b is	4
when i is	2
when static linking	1
when there is	2
when C++ is	1
when objects of	2
when objects can	1
when we read	1
when we roll	1
when performance is	1
when software uses	1
when long double	1
when elements are	1
when called from	3
when they are	4
when I die.	1
when accessed from	1
when arrays are	1
when compiled with	1
when compiled without	1
when speed is	2
when several applications	1
when doing calculations	1
when doing calculations,	1
when optimizing multithreaded	1
when shared objects	1
when their live	1
when running in	1
when running on	3
when n is	2
when parts of	1
when AVX2 is	1
when r =	1
when just a	1
when contentions do	1
when contentions occur	2
when columns is	1
when efficiency is	1
when testing which	1
when testing worst-case	1
when alignment by	1
when compatibility with	1
when copying a	1
when accessing an	1
when needed. The	1
when compiling for	6
when compiling module2.cpp.	1
when calculating the	1
when applied to	5
when converted to	1
when multiplying with	1
when portability and	1
when converting to	1
when deciding whether	5
when type-casting pointers:	1
when swapping the	1
when running. Programs	1
when choosing a	1
when going from	1
when mixing code	1
when alloca is	1
when interprocedural optimization	1
when returning from	1
when none of	1
when CriticalInnerFunction is	1
when false. The	1
when bb[i] >	1
when activated by	1
when exiting the	1
A is not	1
A is finished.	1
A is slow,	1
A and then	1
A = 1.1,	2
A function is	1
A function that	3
A function library	1
A code that	2
A code branch	1
A compiler for	1
A compiler that	1
A compiler can	1
A compiler may	1
A compiler has	1
A more efficient	1
A more complicated	1
A more general	1
A more realistic	1
A more detailed	1
A more primitive,	1
A program with	1
A CPU dispatcher	1
A CPU dispatch	1
A loop with	2
A loop counter	1
A cache is	1
A cache works	1
A class member	1
A class doesn't	1
A floating point	1
A double is	1
A pointer is	1
A pointer can	1
A pointer or	1
A + A;	1
A + B;	1
A static member	3
A C++ implementation	1
A possible negative	1
A clock cycle	1
A variable is	1
A variable in	1
A variable that	1
A variable can	1
A variable number	1
A variable cannot	1
A performance monitor	1
A very time-consuming	1
A software developer	1
A long dependency	1
A branch that	4
A branch can	2
A branch instruction	1
A branch tree	1
A const pointer	1
A const member	1
A const reference	1
A critical innermost	1
A call to	1
A call from	1
A register is	1
A template is	1
A template with	1
A template class	1
A template parameter	1
A template instance	1
A test setup	1
A user interface	1
A method with	1
A dynamic library	3
A part of	1
A short int	1
A simple way	1
A simple solution	1
A simple constructor	1
A simple alternative	1
A simple periodic	1
A constant can	1
A large array	1
A large block	1
A big file	1
A language based	1
A much higher	1
A virtual processor	1
A virtual destructor	1
A common situation	1
A thread that	1
A good compiler	3
A good way	1
A good optimizing	1
A good implementation	1
A matrix or	2
A calculation may	1
A problem with	1
A few files,	1
A few decades	1
A list of	1
A structure of	1
A copy constructor	2
A shared object	2
A lot of	2
A microprocessor with	2
A dependency chain	1
A model with	1
A conversion from	1
A disadvantage is	1
A disadvantage of	2
A reference is	1
A dispatcher function	1
A better performing	1
A | (B	1
A runtime DLL	1
A longer loop-	1
A look in	1
A linked list	2
A higher level	1
A process or	1
A binary tree	2
A union is	1
A union can	2
A feature called	1
A constructor is	1
A switch statement	1
A switch statements	1
A negative integer	1
A negative list,	1
A positive overflow	1
A computer with	1
A profiler is	1
A particularly useful	1
A limited number	1
A limited "express"	1
A database can	1
A frame function	2
A destructor is	1
A Pentium M	1
A further extension	1
A discussion of	1
A non-Intel processor	1
A macro will	1
A macro declared	1
A little math	1
A smart pointer	2
A situation where	1
A similar method	1
A newer method	1
A metaprogramming implementation	1
A default constructor	1
A typical implementation	1
A pure function	1
A graphical user	1
A hash table	2
A hash map	2
A collection of	1
A complex digital	1
A debugger can	1
A leaf function	2
A 32- bit	1
A mixed implementation	1
A considerable delay	1
A popular user	1
A context switch	1
A multidimensional array	1
A realistic performance	1
A console mode	2
A command received	1
A safer implementation	1
A commercial compiler	1
A queue should	1
A missing check	1
A redesign can	1
A competing product	1
A complete redesign	1
A for-loop or	1
A for-loop has	1
A GNU Free	1
A programmable logic	1
A WTL application	1
A command-line version	1
A thread-safe function	1
A Number) if	1
A sourcebook for	1
A little-known alternative	1
A light-weight alternative	1
A Pragmatic Look	1
will be an	1
will be different	1
will be used	1
will be cache	1
will be no	1
will be efficient	1
will be 2	1
will be very	2
will be faster	1
will be stored	4
will be less	1
will be allocated	1
will be calculated	1
will be advantageous	1
will be 1	1
will be able	2
will be better	1
will be replaced	1
will be loaded	1
will be compatible	1
will be 2.	1
will be improved	1
will be loading	1
will be used,	1
will be mispredicted	1
will be interpreted	1
will be called,	1
will be unable	2
will be filled	1
will be infinity	1
will be joined	2
will be evicted	1
will be misleading	1
will be rounded	1
will be non-zero,	1
will be mainstream	1
will not be	3
will not have	1
will not use	2
will not only	1
will not do	2
will not get	2
will have to	1
will have an	2
will have more	1
will have only	1
will have one	1
will use the	2
will use different	1
will use one	1
will use full	1
will then be	1
will make the	3
will make a	1
will make only	1
will make all	1
will make multiple	1
will make any	1
will make 32	1
will make applications	1
will make temp	1
will make exactly	1
will make two.	1
will point to	1
will do the	1
will do this	1
will do such	1
will most likely	1
will also work,	1
will return the	1
will call this	1
will take only	1
will take approximately	1
will take 1000	1
will take precedence,	1
will often be	1
will often take	1
will often replace	1
will always run	1
will always select	1
will always compete	1
will work only	1
will work better.	1
will cause the	3
will cause a	1
will therefore be	1
will therefore need	1
will get the	1
will get time	1
will get one	1
will get no	1
will support the	1
will run the	1
will run an	1
will run at	1
will run faster	2
will calculate xn	1
will calculate (1./1.2345)	1
will store the	1
will optimize this	1
will both get	1
will replace the	1
will replace this	1
will typically use	1
will typically get	1
will automatically replace	1
will automatically choose	1
will see that	1
will see shortly.	1
will never be	1
will never spend	1
will never throw	1
will read four	1
will give you	1
will give -2.0	1
will look different	1
will load the	1
will generate the	1
will generate a	1
will generate an	3
will generate relative	1
will generate relocations	1
will generate -128,	1
will usually unroll	1
will reduce int	1
will choose the	1
will start to	1
will start garbage	1
will go into	1
will go based	1
will change the	1
will change during	1
will become available	1
will produce the	1
will still take	1
will prevent the	1
will shift out	1
will save temp	1
will unroll loops	1
will fail if	3
will convert example	2
will convert these	1
will occur in	1
will consider if	1
will delay the	1
will enable the	1
will enable optimizations	1
will align data	1
will align large	1
will allow the	1
will happen if	1
will vectorize the	1
will vectorize a	1
will try to	1
will wait until	1
will break at	1
will notice that	2
will detect an	1
will soon be	1
will soon get	1
will benefit from	1
will appear as	1
will prefer to	1
will recognize that	3
will catch an	1
will evict the	1
will evict number	2
will remain locked	1
will invalidate each	1
will conclude this	1
will crash the	1
will crash on	1
will provoke an	1
will interfere with	1
will contend for	1
will crash. See	1
will stay on	1
will dominate in	1
will trigger the	1
will grow in	1
will cut off	1
will propagate through	1
will occur: if	1
} The function	1
} The code	1
} The compiler	5
} The data	1
} The same	1
} The loop	2
} The most	1
} The Intel	1
} The two	1
} The execution	1
} The advantage	1
} The multiplication	1
} The Microsoft	1
} The declaration	1
} The factor	1
} The pow	1
} The InstructionSet()	1
} The resulting	1
} The indirect	1
} The FactorialTable	1
} // Use	1
} // Function	3
} // No	1
} // Now	1
} // At	1
} // x^2	1
} // ipow	1
} // Catch	1
} // Or	1
} // Approximate	1
} // Non-polymorphic	1
} // Entry	1
} // Branch/loop	1
} // continue	1
} // Default	1
} if (b)	1
} if (a	1
} if (level	1
} This is	1
} This can	3
} This function	1
} This code	2
} This has	1
} This loop	2
} This calculation	1
} This implementation	1
} int main()	2
} int Size()	1
} A possible	1
} A branch	1
} A good	1
} A problem	1
} } The	10
} } //	2
} } This	3
} } A	1
} } }	11
} } Example	1
} } In	1
} } void	1
} } else	2
} } Using	1
} } Loop	1
} } Assume	1
} } Obviously,	1
} } Here	1
} } #if	1
} } Transposing	1
} } 34	1
} It is	2
} Example 14.30	1
} Example 14.26	1
} Example 14.27	1
} If Func1	1
} double xpow10(double	1
} In this	2
} In order	1
} There will	1
} return a	1
} return y;	1
} return sum;	1
} return add_elements(s);	1
} You have	1
} const int	1
} void SelectAddMul(short	1
} void Func2()	1
} void FuncB	1
} void F0()	1
} An array	1
} These two	1
} }; //	7
} }; class	2
} }; void	2
} else if	1
} else {	19
} Using a	1
} We can	1
} x; x.f	1
} Here, the	2
} Here, it	1
} Here, each	1
} Here, we	1
} Here, log(2.0)	1
} Loop unrolling	1
} Assume that	1
} sum =	1
} u; if	2
} u; int	2
} u; u.i	2
} Obviously, a	1
} Here it	1
} #if INSTRSET	1
} Induction variables	1
} T &	1
} polynomial //	1
} #endif //	1
} Can be	1
} z =	1
} catch (...)	1
} 135 The	1
} 73 Without	1
} Microprocessors with	1
} FuncC(i); }	1
} u, v;	2
} By giving	1
} 109 }	1
} Transposing a	1
} 34 else	1
} module2.cpp int	1
} 59 third	1
} printf("\nResults:"); for	1
} 68 else	1
} 70 Induction	1
} 152 If	1
} 138 A	1
} 115 from	1
} 111 }	1
} 112 Vectorized	1
} list[300] =	1
then the code	4
then the compiler	3
then the CPU	1
then the loop	2
then the most	1
then the pointer	1
then the version	1
then the value	1
then the critical	1
then the first	1
then the user	1
then the even	1
then the &	1
then the error	1
then the exception	1
then the line	2
then the solution	2
then the optimal	2
then the microprocessor	1
then the multiplication	2
then the expression	1
then the dispatch	1
then the second	2
then the profiler	1
then the instance	1
then the offset	1
then the effect	1
then the target	1
then the nontemporal	1
then the length	1
then the DLL	1
then the mirror	1
then the sampling	1
then the transformation	1
then a simple	2
then a linear	1
then a sorted	1
then be placed	1
then be repeated	1
then it is	21
then it can	2
then it may	9
then it will	5
then it must	1
then it becomes	1
then it obviously	1
then an optimizing	1
then you are	1
then you can	7
then you may	12
then you have	3
then you will	3
then you should	2
then you cannot	3
then you need	1
then you must	1
then you don't	1
then this can	1
then this loop	1
then this might	1
then use a	3
then use an	1
then use this	1
then use only	1
then use binary	1
then use #pragma	1
then make it	1
then make an	1
then make sure	2
then all the	1
then all five	1
then each vector	1
then each thread	1
then there is	9
then there may	1
then many times	1
then we can	2
then we have	2
then we will	1
then we need	1
then we would	1
then stored at	1
then call _mm256_zeroupper()	3
then call __intel_cpu_features_init_x().	1
then its value	1
then calls a	1
then calls exit.	1
then c is	1
then check for	1
then run on	1
then add the	1
then add a	1
then both can	1
then replace it	1
then sets a	1
then put the	3
then transferred as	1
then linked together	1
then become invalid.	1
then turn it	1
then output after	1
then tell the	1
then convert the	1
then convert it	1
then handle its	1
then f is	1
then F1 has	1
then try to	1
then measurements can	1
then follow the	1
then think that	1
then B, and	1
then N&(N-1) is	1
then sizeof(S1) would	1
then interpret that	1
then 0+1.23456 =	1
then de-referenced in	1
then merge the	1
then FuncC. Unrolling	1
then d+e, then	1
It is the	6
It is a	1
It is not	12
It is more	8
It is used	1
It is also	3
It is possible	17
It is very	1
It is faster	3
It is less	1
It is often	8
It is useful	2
It is important	10
It is accessed	1
It is best	1
It is necessary	2
It is common	4
It is good	1
It is therefore	11
It is advantageous	1
It is simply	2
It is quite	2
It is recommended	14
It is difficult	4
It is usually	1
It is just	1
It is intended	2
It is sometimes	1
It is discussed	2
It is rarely	2
It is easier	1
It is used,	1
It is easy	2
It is almost	1
It is preferred	1
It is free	1
It is measured	1
It is expected	1
It is safer	1
It is 102	1
It is unacceptable	1
It is assumed	1
It is OK,	1
It is strongly	1
It is tempting	1
It can be	3
It can also	3
It can call	1
It can take	1
It can therefore	1
It can contain	1
It may in	1
It may be	9
It may not	3
It may even	1
It may fail	1
It may catch	1
It may seem	1
It may neverthe-	1
It will not	1
It will look	1
It will fail	1
It will crash	1
It has the	1
It has some	1
It has excellent	1
It should be	2
It should therefore	1
It should never	1
It also works	1
It also prevents	1
It takes some	1
It takes between	1
It takes longer	1
It makes a	1
It does the	1
It does not	1
It does this	1
It must be	1
It doesn't prevent	1
It works somewhat	1
It uses the	1
It uses ebx	1
It simply stores	1
It requires support	1
It just happened	1
It supports 32-bit	1
It comes with	1
It might be	1
It reveals a	1
It compares eax	1
Example 13.1 //	1
Example 16.2 #include	1
Example 14.9 struct	1
Example 14.8 const	1
Example 12.4b shows	1
Example 12.4b executes	1
Example 16.1 #include	1
Example 9.3 #include	1
Example 8.26a void	1
Example 8.26a compiled	1
Example 12.2 __declspec(align(16))	1
Example 14.6 float	1
Example 14.28 union	1
Example 14.30 const	1
Example 14.30 finds	1
Example 7.2 a	1
Example 7.1 float	1
Example 7.8 if	1
Example 14.10 int	1
Example 14.11 int	1
Example 8.4 double	1
Example 8.7 int	1
Example 7.21 int	1
Example 9.6b. #include	1
Example 9.5a const	1
Example 7.7 unsigned	1
Example 7.11 bool	1
Example 7.12 void	1
Example 11.3 const	1
Example 7.22 short	1
Example 7.23 int	1
Example 7.20 int	1
Example 7.27 float	1
Example 7.24 float	1
Example 7.25 unsigned	1
Example 7.28 class	1
Example 9.4 const	1
Example 7.14 class	1
Example 7.16 float	1
Example 7.17 const	1
Example 7.13 struct	1
Example 7.19 int	1
Example 7.18 int	1
Example 12.5. Aligned	1
Example 8.26b void	1
Example 8.26b compiled	1
Example 14.12b int	1
Example 14.14b double	1
Example 15.1c. Calculate	1
Example 14.14a double	1
Example 8.15a struct	1
Example 14.13b int	1
Example 9.6a const	1
Example 9.6a Time	1
Example 12.1a. Automatic	1
Example 14.19 static	1
Example 14.1c void	1
Example 14.23b and	1
Example 14.23b union	1
Example 11.2b const	1
Example 11.1a float	1
Example 11.1b float	1
Example 7.15b SafeArray	1
Example 15.1b. Calculate	1
Example 14.26 does	1
Example 14.26 union	1
Example 14.27 union	1
Example 14.27 assumes	1
Example 14.23 union	1
Example 8.21 is	1
Example 8.21 void	1
Example 14.5b if	1
Example 14.5a const	1
Example 7.6. Set	1
Example 9.5b void	1
Example 13.2. CPU	1
Example 7.40a struct	1
Example 7.40b union	1
Example 7.40c x.abc	1
Example 14.3a int	1
Example 14.3b int	1
Example 11.2a const	1
Example 12.4a. Loop	1
Example 8.9b int	1
Example 8.9a int	1
Example 8.23b. Calculate	1
Example 14.1b int	1
Example 14.1a int	1
Example 8.3a float	1
Example 12.4c. Same	1
Example 12.6. Function	1
Example 7.29b floata;	1
Example 7.29a float	1
Example 7.34a. Use	1
Example 14.13c int	1
Example 14.13a int	1
Example 8.15b struct	1
Example 7.10b char	1
Example 7.10a bool	1
Example 12.4e. Same	1
Example 8.5b a	1
Example 8.5a void	1
Example 7.31b char	1
Example 7.31a char	1
Example 7.43b. Compile-time	1
Example 14.4b if	1
Example 15.1a. Calculate	1
Example 8.13a int	1
Example 8.13b int	1
Example 14.15b if	1
Example 9.1a int	1
Example 9.1b int	1
Example 7.33b const	1
Example 8.11b int	1
Example 8.11a int	1
Example 7.38b. Alternative	1
Example 8.1b float	1
Example 8.1a float	1
Example 12.9b. Taylor	1
Example 8.16 float	1
Example 8.17 char	1
Example 8.18 float	1
Example 7.43 on	1
Example 7.42 int	1
Example 7.45 //	1
Example 7.44 class	1
Example 7.4. Signed	1
Example 12.8a. Sum	1
Example 7.35b struct	1
Example 7.35a struct	1
Example 9.6b 64	1
Example 8.23a. Loop	1
Example 12.8b. Sum	1
Example 14.18c double	1
Example 8.2a double	1
Example 8.2b a	1
Example 14.7b. Testing	1
Example 7.9b char	1
Example 7.9a bool	1
Example 8.25 void	1
Example 8.20 module1.cpp	1
Example 8.22 #ifdef	1
Example 12.9a. Taylor	1
Example 8.3b a	1
Example 7.38a. Multiple	1
Example 7.43a. Runtime	1
Example 14.21. //	1
Example 7.32a double	1
Example 14.22b unsigned	1
Example 14.22a unsigned	1
Example 15.1d. Integer	1
Example 14.18a float	1
Example 14.18b float	1
Example 9.2b void	1
Example 9.2a void	1
Example 8.24. Integer	1
Example 7.32b double	1
Example 8.6a int	1
Example 8.6b int	1
Example 7.15a. Array	1
Example 7.5. Set	1
Example 14.17b double	1
Example 14.7a. Testing	1
Example 14.16a double	1
Example 7.26b float	1
Example 7.26a float	1
Example 8.19. Devirtualization	1
Example 8.10b a	1
Example 8.10a if	1
Example 7.30b int	1
Example 7.30a int	1
Example 7.3. Explain	1
Example 7.39 union	1
Example 7.37 class	1
Example 7.36 class	1
Example 12.1b. Vectorization	1
Example 8.12a int	1
Example 8.12b int	1
Example 12.4b. Vectorized	1
Example 12.4d. Same	1
Example 14.12a int	1
Example 8.14b int	1
Example 8.14a int	1
Example 7.33a const	1
Example 8.8b double	1
Example 8.8a double	1
Example 12.7. Vector	1
Example 7.34b. Replace	1
Example 14.16b double	1
Example 14.17a double	1
Example 14.15a if	1
Example 14.2a float	1
Example 14.2b float	1
Example 14.29 union	1
Example 14.24 union	1
Example 14.25 union	1
Example 14.20 double	1
Example 14.4a const	1
Example 7.41a class	1
Example 7.41b a.x	1
from the function	1
from the compiler	1
from the same	5
from the loop	1
from the cache	2
from the library	2
from the value	2
from the stack	1
from the function.	2
from the shared	2
from the above	2
from the application	1
from the dispatcher	1
from the main	1
from the level-2	1
from the exponent	1
from the message	1
from the previous	3
from the beginning	1
from the command	1
from the larger	1
from the counts.	1
from the linker.	1
from the caller	1
from the server.	1
from the IDE	1
from the leftmost	1
from a number	1
from a value	1
from a variable	1
from a table	2
from a branch	1
from a pointer.	1
from a previous	1
from a hard	1
from a reliable	1
from a command	1
from a project	1
from a buffer.	1
from a technological	1
from a website.	1
from a higher-priority	1
from this is	1
from this discussion	1
from time T	1
from time T+1	1
from memory a	1
from memory each	1
from memory address	1
from memory plus	1
from different compilers	1
from different addresses	1
from same module	2
from functions that	1
from only one	1
from other applications	1
from other modules.	1
from other processes.	1
from one function	1
from one object	1
from one iteration	1
from one place	1
from one auto_ptr	1
from integer to	2
from set 0x1C.	1
from floating point	4
from each other	1
from example 15.1b	2
from example 16.1	1
from example 8.26a	1
from example 8.26b:	1
from example 9.5a:	1
from compilers that	1
from using registers	1
from Intel and	2
from library asmlib..	1
from float or	2
from multiple parent	1
from static memory	4
from static libraries	1
from 64-bit MMX	1
from array static	4
from many different	1
from any other	2
from any function.	1
from address 0x2710	3
from address 0x2700	1
from register storage.	1
from programming languages	1
from 0 to	2
from error conditions	1
from making a	1
from making an	2
from making optimizations	2
from stack ;	1
from its many	1
from single precision	1
from AVX code	2
from another module.	2
from operators that	1
from doing the	1
from doing multiple	1
from doing optimizations	1
from doing out-of-order	1
from addresses 0x2F00,	1
from both compiler,	1
from string functions.	1
from Intel, AMD	1
from main through	1
from unknown sources.	1
from RAM memory	2
from loading any	1
from 20 to	1
from setting the	1
from within the	1
from row 28	1
from Microsoft, Intel	1
from fully utilizing	1
from disk. Memory-hungry	1
from Func 87	1
from poor branch	1
from www.agner.org/optimize/asmlib.zip. //	1
from www.agner.org/optimize/asmlib.zip. Currently	1
from mispredictions. 44	1
from cc into	4
from optimal. The	1
from seldom used	1
from Intel: "IA-32	1
from bb into	4
from errors. The	1
from errors. If	1
from aligning the	1
from assuming that	1
from exceptions. See	1
from -128 to	1
from -128 generates	1
from cleaning up	1
from 0x2700 to	2
from overlapping calculations.	1
from 0x4700. Reading	1
from testing. Here,	1
from www.intel.com. (See	1
from www.intel.com. Manual	1
from me. My	1
from www.agner.org/optimize. Copyright	1
from everybody. So	1
from main, but	1
from attempting to	1
from Intel. See	1
from scratch. This	1
from www.agner.org/optimize/testp.zip. This	1
from www.agner.org/optimize/testp.zip or	1
from knowing that	1
from a=a*2; to	1
memory is a	1
memory is also	1
memory is contiguous	1
memory is mirrored	1
memory a function	1
memory a hundred	1
memory to the	2
memory to be	1
memory to stack	2
memory to become	1
memory to disk.	2
memory and will	1
memory and we	1
memory and therefore	1
memory and string	2
memory and disk	1
memory and insert	1
memory and computing	1
memory in a	1
memory in advance.	1
memory for a	1
memory for all	1
memory that is	1
memory can take	1
memory can cause	1
memory or other	1
memory or accessed	1
memory or cache.	1
memory if the	1
memory if it	1
memory if organized	1
memory by requesting	1
memory with new	1
memory on the	1
memory may not	1
memory may even	1
memory when the	1
memory when exiting	1
memory will be	1
memory will benefit	1
memory then there	1
memory at the	1
memory which is	1
memory used by	2
memory page size	1
memory each time	1
memory into a	1
memory takes only	1
memory takes much	1
memory called the	1
memory address a	1
memory address and	1
memory address that	2
memory address by	1
memory address at	1
memory address which	1
memory address cannot	1
memory rather than	2
memory without loading	1
memory even when	1
memory access is	2
memory access and	1
memory access are	1
memory access .............................................................................................	1
memory access 9.1	1
memory inside the	1
memory store An	1
memory addresses is	1
memory addresses divisible	1
memory used. You	1
memory allocation is	5
memory allocation in	1
memory allocation for	1
memory allocation can	2
memory allocation with	1
memory allocation may	1
memory allocation when	1
memory allocation using	1
memory allocation also	1
memory allocation are:	2
memory allocation Dynamic	1
memory allocation Any	1
memory allocation Objects	1
memory allocation ......................................................................................	1
memory allocation (new	1
memory space is	3
memory space to	1
memory space can	1
memory space by	1
memory space where	1
memory space never	1
memory space becomes	1
memory model is	1
memory model used	1
memory model where	1
memory block is	2
memory block and	2
memory block for	1
memory block that	2
memory block than	1
memory block from	1
memory block should	1
memory block into	1
memory block every	2
memory block turns	1
memory resources than	1
memory needed in	1
memory pointer. This	1
memory outside the	1
memory access. The	1
memory access. Assume	1
memory access. 12	1
memory buffer and	1
memory address. Pointer	1
memory allocation. This	1
memory allocation. There	1
memory allocation. You	1
memory allocation. See	1
memory allocation. Some	1
memory allocation. Dynamic	1
memory allocation. Do	1
memory allocation. Container	1
memory blocks is	1
memory blocks than	1
memory blocks makes	1
memory block. This	2
memory block. A	1
memory block. Do	1
memory required is	1
memory space. A	2
memory Memory allocated	1
memory plus the	1
memory swapping and	1
memory addresses. If	1
memory pool. See	2
memory pool. 15	1
memory pool. Alignment?	1
memory area for	2
memory blocks, for	1
memory blocks, or	1
memory blocks, either	1
memory space, even	1
memory caching. 3.14	1
memory allocations of	1
memory heap. The	1
memory footprint is	1
memory footprint than	1
memory area. The	1
memory area. Join	1
memory spaces for	1
memory management and	1
memory leaks and	1
memory leaks if	1
memory leak. An	1
memory blocks. A	1
memory areas. Data	1
memory areas, and	1
memory pool, as	1
memory re-allocation is	1
memory block, but	1
memory economy and	1
memory fragmentation. Bounds	1
memory economy, cache	1
memory bus is	1
memory footprint. If,	1
memory ports, etc.	1
memory caches. Typically,	1
memory released when	1
memory pooling. It	1
memory leaks. It	1
memory requirement. Useful	1
at the function	1
at the code	2
at the compiler	1
at the time	9
at the vector	2
at the same	8
at the CPU	1
at the example	1
at the object	1
at the possible	1
at the assembly	1
at the cost	1
at the end	1
at the last	1
at the second	1
at the start	2
at the diagonal	1
at the label	1
at the interrupt	1
at the actual	1
at the diagonal.	1
at the "worst	1
at a time	6
at a memory	3
at a time.	4
at a disadvantage	1
at a high	1
at a higher	1
at a link	1
at a time,	1
at a lower	1
at to see	1
at an address	5
at an arbitrary	1
at this place.	1
at more than	1
at different memory	1
at different places	1
at different times:	1
at CPU brand	1
at which a	1
at all is	1
at all to	1
at all on	1
at all because	1
at page 150.	1
at each function	1
at each access.	1
at any time,	1
at address [ecx+eax*4].	1
at address esp+8	1
at less than	1
at its mirror	1
at specific places	1
at compile time	12
at compile time.	16
at compile time,	1
at compile time?	1
at doing equivalent	1
at run time.	1
at every function	1
at every access.	1
at 1 byte	1
at optimizing away	1
at certain events,	1
at their own	1
at what happens	1
at runtime if	1
at runtime from	1
at runtime here	1
at load time.	2
at 0, last	3
at installation time.	1
at least the	2
at least a	1
at least in	2
at least at	1
at least one	2
at least temporarily.	1
at once The	1
at 8, last	2
at random times	1
at 19 };	1
at vectorization. 3.	1
at compile-time whether	1
at 15 byte	1
at half speed	1
at 7 int	1
at reducing integer	1
at www.agner.org/optimize/asmlib.zip. The	1
at www.agner.org/optimize/asmlib.zip. If	1
at 16, last	1
at all. This	2
at all. Can	1
at 13 //	1
at 11 short	1
at initialization. The	1
at initialization. Each	1
at regular time	1
at round memory	1
at round addresses.	1
at inconvenient times	1
at inconvenient times.	2
at www.agner.org/optimize/cppexamples.zip for	1
at www.agner.org/optimize/cppexamples.zip contains	1
at www.agner.org/optimize/cppexamples.zip containing	1
at www.agner.org/optimize/cppexamples.zip. 9.9	1
at Exception Specifications,	1
at runtime. Example	1
at runtime. #define	1
at runtime. Polymorphism	1
at unpredictable times	1
at unpredictable intervals	1
at compile- time,	1
at 12, last	1
at once................................... 135	1
at hand. Low-level	1
at runtime). The	1
at 403 int	1
at www.agner.org/optimize/asmlib.zip contains	1
at Wikibooks. The	1
at explaining the	1
at 400, last	1
at runtime, if	1
at 399 int	1
data is a	1
data is to	1
data is that	1
data is more	1
data to the	1
data to optimize	1
data and make	1
data and resources	1
data and local	1
data and measure	1
data in the	2
data in a	2
data in this	1
data in different	1
data in order	2
data in large	1
data in Linux	1
data The prefetch	1
data for the	1
data for one	1
data for regular	1
data for analysis.	1
data that are	2
data that don't	1
data are not	1
data are used	1
data are stored	3
data are accessed	3
data are likely	1
data are aligned	2
data are scattered	2
data are cached	1
data can be	1
data can exceed	1
data // constructor	1
data or pointers	1
data with all	1
data as an	1
data as possible	1
data than it	1
data have to	1
data have three	1
data more random	1
data more compact.	1
data A cache	1
data A variable	1
data from a	1
data from static	1
data from RAM	1
data memory used	1
data because the	1
data used in	1
data cache is	2
data cache of	1
data cache and	1
data cache are	1
data cache use	1
data cache (see	1
data should contain	1
data set into	1
data size that	1
data into the	1
data into a	1
data into multiple	1
data into classes	1
data into groups	1
data object in	1
data object through	1
data member is	2
data member of	1
data member or	1
data member pointer	1
data member relative	1
data elements and	1
data elements are.	1
data without caching	1
data access can	1
data file in	1
data through function	1
data structure and	1
data structure then	1
data files and	1
data files while	1
data automatically thanks	1
data caching more	2
data caching very	1
data caching less	5
data caching inefficient.	2
data sets where	1
data members is	1
data members of	1
data members to	1
data members that	1
data members can	1
data members or	2
data members with	1
data members come	1
data members within	1
data members share	1
data members (properties)	2
data cache. The	1
data cache. If	1
data cache. These	1
data cache. 2.2	1
data cache. Single	1
data cache. Bit-fields	1
data block to	1
data conversion and	1
data instead of	1
data storage is	1
data storage and	1
data section is	1
data section may	1
data section needs	1
data fit into	1
data fit nicely	1
data structures to	1
data structures in	1
data structures for	1
data structures that	1
data structures with	2
data structures It	1
data structures .............................................................	1
data sets. However,	1
data sets. Covers	1
data within the	1
data explicitly if	1
data sections can	1
data members. This	1
data members. A	1
data members. It	1
data members. If	1
data members. But	1
data base access,	1
data files. This	1
data area is	1
data ...................................................................................................... 90	1
data ......................................................................................... 87	1
data structures. For	1
data structures. On	1
data cache, code	1
data cache, where	1
data sequentially A	1
data sequentially ..........................................................................................	1
data processing. Running	1
data manipulation is	1
data flow and	1
data types: long	1
data types: char,	1
data shuffling, such	1
data compression and	1
data compression Most	1
data decomposition. It	1
data decomposition. Functional	1
data exceeds 64	1
data segment by	1
data together. Data	1
data #ifdef _MSC_VER	1
data (low numbers	1
data optimally, or	1
data locally. Access	1
data decomposition, we	1
data elements, as	1
data bases, but	1
data object: (1)	1
data Loading data	1
data structure, data	1
data conversion, shuffling,	1
program is an	1
program is more	1
program is often	1
program is useful	1
program is compiled	2
program is exception	1
program is likely	1
program is never	1
program is actually	1
program is bigger	1
program is loaded	2
program is executed.	1
program is running.	2
program is run.	2
program is loaded.	1
program is compiled.	1
program is achieved	1
program is dividing	1
program is started.	1
program is loaded,	2
program is busy	1
program is fast,	1
program is terminated	1
program is shut	1
program of occupying	1
program to use	1
program to turn	1
program to measure	1
program to issue	1
program and whether	1
program and concentrate	1
program in a	1
program in multiple	1
program in case	1
program for the	1
program that is	1
program that are	1
program that can	1
program that calls	2
program that created	1
program that already	1
program that runs	1
program that produces	1
program that scans	1
program that waits	1
program are in	1
program are also	1
program are often	1
program are typically	1
program can take	1
program can check	1
program or data	1
program or because	1
program or library	1
program if there	1
program by their	1
program by turning	1
program with many	1
program with profiling	1
program on the	1
program code is	3
program code for	1
program code are	1
program as long	1
program as well	1
program - preferably	1
program than to	2
program may in	1
program may be	1
program may have	1
program may need	1
program you want	1
program have been	1
program more clear	1
program when the	1
program will be	3
program will not	1
program will crash.	1
program then it	1
program then you	1
program has to	1
program has an	1
program has one	1
program has most	1
program has two	1
program has many	2
program has several	1
program has too	1
program should be	1
program should automatically	1
program should leave	1
program do the	1
program where the	1
program takes too	1
program performance and	1
program performance because	1
program makes a	1
program before the	1
program before and	1
program less efficient.	1
program optimization or	1
program optimization cannot	1
program optimization Some	1
program optimization Integer	1
program optimization /GL	1
program without invoking	1
program must clean	1
program execution may	1
program execution then	1
program exception safe.	1
program uses a	2
program uses more	1
program uses many	1
program contains no	1
program contains many	1
program contains calls	1
program contains automatic	1
program structure in	1
program memory. This	1
program memory. If	1
program their own	1
program development more	1
program errors in	1
program efficiency is	1
program optimization. This	1
program optimization. 2.4	1
program performance. The	1
program updates should	1
program loading can	1
program under test	2
program under test,	1
program happen to	1
program logic may	1
program logic allows	2
program (or part	1
program had read	1
program itself and	1
program itself when	1
program size, while	1
program reads from	1
program structure. It	1
program development, and	1
program package is	1
program relies on	1
program itself. You	1
program appear to	1
program runs satisfactorily	1
program repeats 1000	1
program chooses between	1
program starts running	1
program starts up.	1
program execution, even	1
program optimization, which	1
program 81 optimization	1
program 153 spends	1
program flow and	1
program flow at	1
program flow. However,	1
program flow. Failure	1
program afterwards reads	1
program loads the	1
program slower. Another	1
program saying that	1
program starts. The	2
program compactness, and	1
program executable: a	1
program logic. Some	1
program creates or	1
program /Qipo -ipo	1
program dictates that	1
has the same	3
has the value	1
has the following	1
has the advantage	2
has the disadvantage	3
has the feature	1
has the special	1
has the SSE	1
has the unfortunate	1
has the correct	1
has the complication	1
has a different	2
has a CPU	1
has a pointer	1
has a table	1
has a very	1
has a long	1
has a branch	2
has a good	2
has a particular	2
has a smaller	1
has a parallel	1
has a garbage	1
has a significant	1
has a graphical	1
has a jump	1
has a composite	1
has a latency	1
has a virus	1
has to be	5
has to use	1
has to make	1
has to take	1
has to check	1
has to assume	1
has to start	1
has to turn	1
has to keep	1
has to wait	3
has to invest	1
has to obey	1
has to reinstall	1
has not been	2
has not noticed	1
has an instruction	1
has an option	2
has an implicit	1
has an initialization	2
has at least	1
has only a	1
has only one	3
has one or	1
has one big	1
has one operator	1
has no instruction	1
has no pointer	1
has no virtual	1
has no AVX	1
has no copy	1
has no information	1
has no cost	1
has no negative	1
has no effect.	1
has no side-effects	1
has most cache	1
has i instead	1
has multiple instances	1
has two loop-carried	1
has two arrays,	1
has many of	2
has many calls	1
has many branches	1
has many advantages	1
has many advanced	1
has many features,	1
has some support	1
has some syntax	1
has const twice	1
has its parameters	1
has its own	3
has several different	1
has several large	1
has several meanings	1
has several flaws:	1
has allocated with	1
has been called	1
has been accessed	1
has been allocated	1
has been reduced	1
has been copied	1
has been increased	1
has been doubled.	1
has been loaded.	1
has been translated	1
has been deallocated.	2
has been incremented	1
has been incremented,	1
has been alleviated	1
has been identified,	1
has been calculated.	1
has been introduced	1
has been criticized	1
has been brutally	1
has been wasted.	1
has done by	1
has calculated in	1
has four physical	1
has support for	2
has hardware support	3
has both positive	1
has problems separating	1
has high priority.	1
has three conditions	1
has three clauses:	1
has three advantages:	1
has too much	1
has higher priority	1
has advantages and	1
has made the	2
has replaced i	1
has become a	1
has become less	1
has become too	1
has become fragmented.	1
has reduced performance	3
has full metaprogramming	1
has changed then	1
has changed five	1
has defined a	1
has something to	1
has enough bits	1
has chosen the	1
has chosen for	1
has hardly any	1
has saved all	1
has already been	1
has nothing between	1
has finished the	2
has solved this	1
has insufficient information	1
has preprocessing directives	1
has disadvantages: The	1
has disadvantages: It	1
has hyperthreading. If	1
has hyperthreading, then	1
has changed. 7.8	1
has influence on	1
has occurred. //	1
has side effects	1
has excellent support	1
has occurred anywhere	1
has incomplete information	1
vector of two	1
vector of four	1
vector of eight	1
vector of e.g.	1
vector of (0,0,0,0,0,0,0,0)	3
vector of vectors,	1
vector of (2,2,2,2,2,2,2,2)	3
vector in eight	4
vector can be	1
vector can hold	1
vector or the	1
vector function libraries.	1
vector as two	1
vector { //	1
vector from array	4
vector functions have	1
vector integer operations,	1
vector class library	8
vector class library.	1
vector class library,	1
vector class library).	1
vector size for	1
vector size then	1
vector size often	1
vector size (16	1
vector into array	4
vector library is	1
vector objects //	1
vector objects as	1
vector objects Vec8s	1
vector so that	1
vector register is	1
vector register for	1
vector register which	1
vector register size	1
vector register size.	1
vector register containing	1
vector register sizes	1
vector libraries and	1
vector registers in	1
vector registers are	1
vector registers can	1
vector registers when	1
vector registers has	1
vector registers are:	1
vector registers had	1
vector registers (XMM	1
vector method may	1
vector always to	1
vector always #pragma	1
vector always Optimize	1
vector operations is	1
vector operations of	1
vector operations and	1
vector operations are	1
vector operations on	1
vector operations use	1
vector operations when	2
vector operations where	1
vector operations An	1
vector operations automatically	1
vector operations require	1
vector operations mentioned	1
vector operations (chapter	1
vector operations Today's	1
vector instructions that	1
vector instructions cannot	1
vector instructions (see	1
vector instructions SSE4.1	1
vector instructions SSE4.2	1
vector processors are	1
vector element level	2
vector c __m128i	2
vector a, b,	1
vector classes is	1
vector classes and	1
vector classes are	1
vector classes //	1
vector classes than	1
vector classes void	1
vector classes #include	1
vector classes Agner's	1
vector classes Fortunately,	1
vector classes .............................................................................................	1
vector classes looks	1
vector classes Programming	1
vector classes (Intel)	1
vector classes 114	1
vector parameters Vec4f	1
vector operator +	1
vector implementation is	1
vector data. The	1
vector aligned or	1
vector aligned #pragma	1
vector aligned Assume	1
vector processors. Henry	1
vector goes faster	1
vector just as	1
vector depends on	1
vector size. There	1
vector size. Unpredictable	1
vector size. Later	1
vector math library	2
vector math libraries.	1
vector math libraries:	3
vector registers. The	2
vector registers. It	1
vector operations. You	1
vector operations. Algorithms	1
vector operations. 7.6	1
vector operations. 105	1
vector processing capabilities	1
vector processing instructions,	1
vector libraries. To	1
vector classes. Including	1
vector containing integers.	1
vector access. 12.9	1
vector nontemporal is	1
vector nontemporal Table	1
vector nontemporal #pragma	1
vector stores all	1
vector c2 with	1
vector register. The	1
vector register. Factors	1
vector simultaneously. This	1
vector algebra reductions:	1
vector Type of	1
vector turned up	1
vector bc with	1
vector library, you	2
vector elements. 12.1	1
vector division. 12.4	1
vector 56 public:	1
vector c: CPU	1
vector c: __m128i	2
vector c: Is16vec8	1
vector b: from	1
vector b: __m128i	2
vector b: Is16vec8	1
vector operations, as	1
vector operations, see	1
vector register, do	1
vector register, add	1
vector classes, as	1
vector operations............................................................................................... 105	1
vector classes): //	1
vector operands: minimum,	1
vector intrinsics and	1
vector classes: //	1
vector (1,2,3,4), and	1
vector intrinsics, automatic	1
vector intrinsics. Digital	1
make the function	2
make the code	5
make the compiler	1
make the data	1
make the program	3
make the functions	1
make the most	1
make the number	1
make the array	1
make the value	1
make the address	2
make the access	1
make the overflow	1
make the matrix	1
make the values	1
make the next	1
make the division	1
make the source	1
make the induction	1
make the local	1
make the rows	1
make the measurements	1
make the scope	1
make the SelectAddMul	1
make a function	1
make a CPU	1
make a loop	1
make a pointer	1
make a variable	1
make a test	2
make a new	2
make a single	1
make a small	1
make a few	1
make a multiplication	1
make a complicated	1
make a Boolean	1
make a piece	2
make a negative	1
make a positive	1
make a destructor	1
make a misprediction	1
make a DLL	1
make a reliable	1
make a non-inlined	1
make a round	1
make a variable-size	1
make a sensible	1
make a lookup-table	1
make a thread-like	1
make a zip	1
make a destructor.	1
make a bit-mask	1
make and therefore	1
make it a	1
make it in	1
make it possible	3
make it work	1
make function calls	1
make function calling	1
make code that	1
make an update	1
make an additional	1
make an approximate	1
make this extra	1
make this work	1
make this kind	1
make this reordering	1
make use of	1
make more efficient	1
make different objects	1
make only one	1
make all dynamic	1
make one version	1
make one instance	1
make floating point	3
make multiple code	1
make multiple versions	2
make two different	1
make two versions	1
make such an	1
make any call	1
make any assumption	1
make some tests	1
make variables global	1
make table of	1
make software that	1
make software packages	1
make member functions	2
make member pointers	1
make register variables	1
make pointers efficient,	1
make sure the	7
make sure that	13
make sure it	3
make sure you	1
make sure its	1
make sure allocated	1
make sure everything	1
make 32 AND-operations	1
make dynamic link	1
make up a	1
make arrays of	1
make overflow checks	2
make container classes	1
make support for	1
make certain kinds	1
make shared objects	1
make files smaller.	1
make their software	1
make separate executables	1
make induction variables	1
make dispatcher in	1
make better use	1
make applications run	1
make parts of	1
make aligned arrays	1
make your program	1
make your own	2
make appropriate error	1
make position-independent code	1
make vectorization less	1
make vectorization favorable:	1
make temp a	1
make special versions	1
make 16-bit programs,	1
make algebraic reductions	1
make profiling feasible.	1
make exactly identical	1
make developers choose	1
make measurements on	1
make two. Some	1
make explicit checks	1
make CPU- specific	1
make thread-specific data	1
make Sum1 slightly	1
make utility. The	1
make utility. It	1
make thread-local storage	1
make log2 a	1
make memory-hungry software	1
different in other	1
different for different	1
different for each	2
different function library.	1
different function libraries.	1
different code address	1
different compiler by	1
different memory addresses.	1
different memory spaces	1
different memory areas,	1
different functions and	1
different functions in	1
different CPU cores.	1
different instruction sets	2
different instruction sets...........................	1
different cache lines	1
different integer types	2
different set values	1
different floating point	1
different compilers is	1
different compilers then	1
different compilers I	1
different compilers succeeded	1
different size matrices,	2
different Intel CPUs.	1
different object file	1
different C++ compilers	8
different C++ language	1
different C++ constructs	1
different C++ constructs........................................................................	1
different value of	1
different objects even	1
different objects share	1
different so that	1
different way or	1
different operating systems	1
different libraries and	1
different test examples.	1
different user access	1
different system color	1
different type by	1
different type conversions	1
different cases for	1
different instructions sets.	1
different processors and	1
different processors are	1
different CPUs to	1
different CPUs if	1
different arrays even	1
different versions of	7
different versions for	1
different versions have	1
different versions alternatingly	1
different execution units.	1
different execution units	1
different threads in	1
different threads are	1
different threads need	1
different matrix sizes	1
different matrix sizes.	1
different functions. There	1
different addresses with	1
different implementation when	1
different intrinsic functions	1
different methods have	1
different name for	1
different source files	1
different parts of	4
different types of	4
different types or	1
different types with	1
different types cannot	2
different compilers. The	1
different compilers. This	1
different compilers. Dispatch	1
different processors. In	1
different platform is	1
different ways of	3
different CPUs. This	2
different CPUs. On	1
different CPUs. (See	1
different compiler. Object	1
different dynamically allocated	1
different platforms as	1
different platforms because	1
different registers. You	1
different tasks in	1
different tasks were	1
different priority in	1
different thread. If	1
different kinds of	5
different purposes. The	1
different purposes. All	1
different purposes. However,	1
different cores is	1
different implementations of	2
different sizes of	1
different sizes are	2
different way. There	1
different address. A	1
different module or	1
different brands of	3
different purposes is	1
different kind of	1
different algorithms in	1
different algorithms for	1
different profiling methods:	1
different factors as	1
different array. //	1
different applications. Therefore,	1
different places when	1
different places making	1
different ways. Example:	1
different microprocessors. 7.13	1
different modules. This	1
different platforms, different	2
different threads, but	1
different type. Likewise,	1
different lengths in	1
different tasks. For	1
different strides. Therefore,	1
different screen resolutions,	2
different priorities to	1
different priorities then	1
different precisions take	1
different executables. This	1
different meaning. 2.	1
different alignments and	1
different targets is	1
different speeds. If	1
different places). Some	1
different meaning for	1
different compilers............................................................................. 74	1
different browsers, different	1
different types. A	1
different sizes, and	1
different times: Dispatch	1
different opinions on	1
different microprocessors, different	1
because the function	1
because the code	1
because the compiler	4
because the memory	1
because the same	2
because the CPU	4
because the cache	2
because the integer	1
because the size	1
because the two	1
because the static	1
because the 64-bit	1
because the value	1
because the critical	1
because the register	1
because the template	2
because the file	1
because the stack	1
because the result	1
because the threads	1
because the speed	1
because the overflow	1
because the container	1
because the hardware	1
because the addresses	1
because the write	1
because the microprocessor	1
because the expression	1
because the block	1
because the high	1
because the programmer	1
because the response	2
because the out-of-order	1
because the offset	1
because the macro	1
because the total	1
because the interpreted	1
because the debugging	1
because the body	1
because the linker	1
because the x86-64	1
because the consequence	1
because the 33	1
because the contents	1
because the relocations	1
because the factorials	1
because the insertion	1
because the integer-to-float	1
because the non-reduced	1
because a float	1
because a good	1
because a fixed	1
because a typo	1
because of the	5
because of a	3
because of cache	1
because of its	1
because of their	1
because of alignment	1
because of disk	1
because of lazy	1
because of technical	1
because in the	2
because in most	1
because it is	7
because it can	3
because it may	3
because it has	2
because it takes	1
because it makes	2
because it cannot	1
because it often	1
because it doesn't	4
because it needs	3
because it requires	1
because it goes	1
because it gives	1
because it comes	1
because it prevents	1
because it involves	1
because it defines	1
because it handles	1
because it lacks	1
because an optimizing	1
because you can	1
because you will	1
because you should	1
because this is	2
because this may	1
because this method	1
because this would	2
because this brand	1
because all the	2
because all caches	1
because integer operations	1
because each value	1
because each call	1
because b has	1
because static data	1
because there is	1
because there are	1
because there may	1
because we are	2
because we can	1
because we forgot	1
because registers is	1
because these are	1
because these time	1
because they are	2
because they can	1
because they do	1
because they cannot	1
because they must	1
because they fail	1
because optimizing compilers	1
because both the	1
because their live	3
because various corrections	1
because switch statements	1
because relative addresses	1
because relative references	1
because modern CPUs	1
because testing a	1
because algebraic manipulations	1
because #if is	1
because serious errors	1
because computers have	1
because truncation takes	1
because communication and	1
because nothing inside	1
because partial template	1
same in a	1
same in both	1
same for simple	1
same can be	1
same can happen	1
same or a	1
same function or	1
same function on	1
same function may	1
same function calling	1
same code and	1
same code in	1
same code can	1
same code as	1
same as the	2
same as a	1
same as for	2
same as if	1
same as i	1
same as last	1
same as C-	1
same as reflecting	1
same compiler option	1
same time to	2
same time that	1
same time as	1
same time regardless	1
same memory space.	1
same memory pool.	1
same memory area	2
same memory area.	2
same memory areas.	1
same memory block,	1
same data in	1
same instruction set.	1
same cache is	1
same cache line.	2
same cache lines.	2
same cache line,	1
same set in	1
same class and	1
same class will	1
same example using	1
same size as	1
same object (except	1
same array for	1
same version of	1
same member pointer.	1
same way is	1
same way as	3
same address so	1
same critical part	1
same register for	2
same register can	1
same register because	2
same time. The	1
same time. A	2
same time. There	1
same time. Example:	1
same without discriminating	1
same method can	1
same dynamic library	1
same dynamic libraries	1
same part of	3
same bits in	1
same bits differently.	1
same type to	1
same result if	1
same processor core	1
same processor core.	3
same thread as	1
same precision in	1
same precision as	1
same few parameters.	1
same structure or	1
same inline assembly	1
same shared object.	1
same space for	1
same cache. Multithreaded	1
same name for	1
same name as	2
same source code.	2
same source file.	1
same induction variable	1
same reason that	1
same after this	1
same piece of	2
same function, each	1
same compiler. It	1
same range of	1
same core will	1
same errors can	1
same variables. In	1
same operation is	2
same level-1 cache.	1
same resources. But	1
same class. The	1
same object. There	1
same time, except	1
same priority is	1
same priority than	1
same thing and	3
same thing as	1
same logical register.	1
same subexpression occurs	1
same resource then	1
same generation can	1
same address. There	1
same module then	1
same module static	1
same module (i.e.	1
same module __attribute__	1
same features as	1
same applies to	2
same value. This	1
same unit as	1
same register. Everything	1
same DLL at	1
same object, except	1
same core. It	1
same rules apply	1
same constant. Example:	1
same principle as	1
same regardless of	1
same result. A	1
same advice applies	1
same resources, such	1
same cache, at	1
same brand. Future	1
same way, the	1
same argument does	1
same chip can	1
same name. In	1
same arguments are	1
same executable. SSE2	1
same machine. The	1
same thing. Example:	1
same thing. An	1
same template. 57	1
same chip. Such	1
same effect. Which	1
same class). If	1
same computer, including	1
same name, regardless	1
same coding rules	1
same algorithm, then	1
same directory as	1
same divisor. In	1
same queue, list,	1
functions is not	1
functions is also	1
functions is called	1
functions is higher	1
functions of a	1
functions of parent	2
functions and a	1
functions and it	1
functions and function	1
functions and you	1
functions and data	1
functions and some	1
functions and simply	1
functions and public	2
functions and hot	1
functions and frame	1
functions in the	2
functions in a	2
functions in memory	1
functions in other	1
functions in C++	1
functions The different	1
functions The most	1
functions The keyword	1
functions for the	1
functions for integer	1
functions for these	1
functions for common	1
functions for string	1
functions for vectors	1
functions for vectorized	1
functions for reasons	1
functions for audio	1
functions for millisecond	1
functions for statistics,	1
functions for vectors........................................................................	1
functions for distinguishing	1
functions that are	9
functions that it	2
functions that have	2
functions that need	1
functions that access	1
functions that require	1
functions that 150	1
functions are not	1
functions are more	1
functions are used	2
functions are less	1
functions are often	1
functions are optimized	1
functions are calculated	1
functions are supported	1
functions are doing	1
functions are typically	1
functions are never	1
functions are actually	1
functions are usually	1
functions are included	1
functions are listed	1
functions are highly	1
functions are missing	1
functions are kept	1
functions are supplied	1
functions are primitive	1
functions are unrelated	1
functions can be	2
functions can not.	1
functions // This	1
functions // Function	1
functions or code	1
functions or when	1
functions or vector	2
functions if the	1
functions if possible.	1
functions by using	1
functions with integer	1
functions as well	1
functions than in	1
functions may not	1
functions have a	2
functions have to	1
functions have more	1
functions have no	2
functions have several	1
functions have names	2
functions A macro	1
functions A pure	1
functions then the	1
functions then it	1
functions then you	1
functions then there	1
functions It is	1
functions because the	1
functions only makes	1
functions which are	1
functions should work	1
functions class CHello	1
functions static or	1
functions static where	1
functions such as	8
functions You have	1
functions faster by	1
functions called by	2
functions take more	1
functions take most	1
functions take microseconds	1
functions often belong	1
functions without CPU	1
functions Some programming	1
functions must have	1
functions must use	1
functions An inline	1
functions Use predefined	1
functions inline or	1
functions like sin.	1
functions like sqrt,	1
functions separate from	1
functions look clumsy	1
functions linked from	1
functions go here	1
functions local A	1
functions (e.g. GetLogicalProcessorInformation	1
functions counts a	1
functions scattered around	1
functions Virtual functions	1
functions (i.e. Microsoft,	1
functions memset and	1
functions consume a	1
functions malloc and	1
functions .............................................................................................. 56	1
functions ....................................................................................... 145	1
functions lrintf and	1
functions ........................................................................................ 53	1
functions ........................................................................................ 109	1
functions (methods) Each	1
functions /Gr Function	1
functions Sum1, Sum2	1
functions directly: Library	1
functions Encryption, decryption,	1
functions (methods)......................................................................... 53	1
only the code	1
only the time	1
only the most	1
only the first	1
only the SSE2	2
only the part	1
only the Gnu	1
only the innermost	1
only the simplest	1
only the lower	1
only the lowest	1
only the even-numbered	1
only a single	2
only a small	1
only a few	1
only a limited	1
only a negligible	1
only a hint	1
only a minimal	1
only to the	1
only to show	1
only in the	3
only for compilers	1
only for Intel	1
only for objects	1
only for very	1
only for big	1
only for positive	1
only for classes.	1
only for powers	1
only for avoiding	1
only for speed-critical	1
only be a	2
only be used	1
only be applied	2
only if the	3
only if it	2
only if you	1
only if all	1
only if AVX	1
only if certain	1
only with Intel	1
only on the	1
only on some	2
only on CPUs	1
only on PC	1
only on registers,	1
only on n,	1
only on Intel/x86-compatible	1
only an integer	1
only an advantage	1
only an addition.	1
only you make	1
only have four	1
only when the	1
only when a	1
only when it	3
only when instruction	1
only when b	1
only when elements	1
only when called	1
only when they	1
only when running	1
only when AVX2	1
only when needed.	1
only when activated	1
only from same	2
only from one	1
only used in	1
only one of	1
only one that	1
only one or	1
only one time	1
only one CPU	2
only one floating	1
only one clock	2
only one call	2
only one constant	1
only one element	1
only one addition	1
only one statement	1
only one instance	1
only one logical	1
only one free	1
only one instance.	2
only compilers and	1
only 64-bit execution	1
only possible if	2
only 32-bit Windows.	2
only way to	2
only makes the	1
only called once.	1
only first time	1
only need a	1
only simple standard	1
only available if	1
only available with	1
only calculated the	1
only calculated once,	1
only four function	1
only four cache	1
only four multiplications.	1
only known processors.	1
only supported on	1
only few of	1
only run on	1
only calculate element	1
only 256 clock	1
only after all	1
only after they	1
only read the	1
only read this	1
only improve the	1
only 5 μs	1
only constants will	1
only safe if	1
only until the	1
only situation where	1
only within the	1
only slightly more	2
only slightly less	1
only once for	1
only allowed inputs	1
only CPUID information	1
only show a	1
only half the	1
only half a	1
only half of	1
only occurs because	1
only happens rarely.	1
only six instructions	1
only one, auto_ptr	1
only 50% or	1
only reasonable solution	1
only once. Example:	1
only once. One	1
only if, a	1
only once, while	1
only hope that	2
only self- relative	1
only 10% of	1
only 2-3 clock	1
only SSE). The	1
only _mm_permutevar_ps 4	1
CPU is limited	1
CPU is designed	1
CPU of a	1
CPU of unknown	1
CPU to generate	1
CPU to start	1
CPU to increment	1
CPU to overlap	1
CPU and the	4
CPU and prevent	1
CPU that each	1
CPU can do	1
CPU can hold	1
CPU or other	1
CPU it is	1
CPU by giving	1
CPU with the	1
CPU with a	1
CPU with multiple	1
CPU than the	1
CPU may occasionally	1
CPU time on	1
CPU time then	1
CPU use in	1
CPU will start	1
CPU from doing	2
CPU from overlapping	1
CPU has hardware	2
CPU has problems	1
CPU which can	1
CPU used for	1
CPU cache (en.wikipedia.org/wiki/L2_cache).	1
CPU clock by	1
CPU clock cycles	1
CPU clock frequency	2
CPU time. But	1
CPU time. Another	1
CPU access and	1
CPU doesn't support,	1
CPU doing multiple	1
CPU was started.	1
CPU dispatching to	1
CPU dispatching and	3
CPU dispatching in	6
CPU dispatching or	1
CPU dispatching with	1
CPU dispatching on	1
CPU dispatching then	1
CPU dispatching only	1
CPU dispatching works	1
CPU dispatching #include	1
CPU dispatching are:	1
CPU dispatching explicitly	1
CPU dispatching 125	1
CPU model is	2
CPU model and	1
CPU model has	1
CPU dispatcher to	1
CPU dispatcher in	1
CPU dispatcher that	1
CPU dispatcher then	1
CPU dispatcher should	3
CPU dispatcher does	1
CPU dispatcher based	1
CPU dispatcher checks	1
CPU dispatcher treats	1
CPU dispatcher updated.	1
CPU dispatch mechanism	4
CPU dispatch Automatic	1
CPU dispatch methods.	1
CPU dispatch strategies........................................................................................	1
CPU dispatch strategies	1
CPU dispatch mechanisms,	1
CPU based on	1
CPU feature on	1
CPU core is	1
CPU core by	1
CPU core then	1
CPU core during	1
CPU supports the	1
CPU supports this	1
CPU supports then	1
CPU efficiency then	1
CPU (See manual	2
CPU time, RAM	1
CPU models if	1
CPU cores is	2
CPU cores and	1
CPU cores or	1
CPU dispatching. The	1
CPU dispatching. This	1
CPU dispatching. For	2
CPU dispatching. Many	1
CPU dispatching. Unfortunately,	1
CPU dispatching. Obviously,	1
CPU dispatching. Add	1
CPU dispatching. Test	1
CPU dispatching. Underestimating	1
CPU Modern CPUs	1
CPU brands and	1
CPU brands or	1
CPU brand check	1
CPU brand simply	1
CPU brand names	1
CPU detection function	5
CPU detection mechanism	1
CPU detection function,	1
CPU detection mechanism.	1
CPU family and	1
CPU family number,	1
CPU core. There	1
CPU cores. A	1
CPU cores. You	2
CPU cores. 60	1
CPU development, each	1
CPU cores, we	1
CPU dispatcher. See	2
CPU brand. The	1
CPU brand. Critical	1
CPU market is	1
CPU dispatchers are	1
CPU dispatchers up	1
CPU chip. Such	1
CPU only) -O3	1
CPU only) (Intel	1
CPU core). The	1
CPU dispatching: 1.	1
CPU dispatching, then	1
CPU core, but	1
CPU models. However,	1
CPU brands, and	1
CPU hardware. Porting	1
CPU vendors are	1
CPU model, which	1
CPU cores: Define	1
CPU supports, rather	1
other is inefficient	1
other is -0	1
other in the	2
other in order	1
other in memory.	1
other are also	2
other function is	1
other with a	1
other code that	1
other than the	1
other than short	1
other than its	1
other than 8,	1
other then put	1
other data structure	1
other data structures	1
other functions is	1
other functions that	1
other functions can	1
other cache control	1
other integer expressions	1
other compilers can	1
other compilers or	1
other compilers have	1
other compilers will	1
other compilers at	1
other compilers (Microsoft,	1
other possible ways	1
other value than	3
other objects on	1
other variable in	1
other variables to	1
other member functions.	1
other way is	2
other way three	1
other address in	1
other less well-known	1
other libraries when	1
other systems may	1
other access patterns.	1
other programming languages	2
other programming languages,	1
other programming languages.	1
other bits to	1
other error condition.	1
other error reporting	1
other CPUs for	1
other function. A	2
other extra software	1
other work that	1
other calculations to	1
other compiled programming	1
other big objects	1
other threads with	1
other threads have	1
other virtual processors	1
other common programming	1
other thread increments	1
other allocated resource.	1
other container class	1
other hardware often	1
other hardware conditions.	1
other values if	1
other values than	4
other cases, it	1
other methods of	1
other resources than	1
other resources locally	1
other applications such	1
other parts of	2
other types of	1
other compilers. This	1
other compilers. #include	1
other optimizations such	1
other optimizations possible	1
other advantages that	1
other ways than	1
other modules than	1
other modules call	1
other things very	1
other languages in	1
other languages that	1
other STL containers	1
other platforms and	1
other platforms with	1
other platforms as	1
other resources. There	1
other local variables	1
other constants because	1
other tasks that	1
other thread. However,	1
other kinds of	1
other details that	1
other purposes. The	1
other purposes. This	1
other resource problems	1
other resource conflicts.	1
other way. A	1
other module then	1
other processors, only	1
other features it	1
other device should	1
other brands of	1
other purposes than	2
other CPUs, but	1
other optimizations. In	1
other number. Therefore,	1
other form of	1
other protection means	1
other branches. A	1
other cleanup that	1
other processes running	1
other hand, the	1
other hand, a	1
other hand, it	1
other hand, if	1
other hand, does	1
other factor. If	1
other microprocessors. Integer	1
other microprocessors. Many	1
other modules. This	2
other modules. You	1
other words, the	1
other words, it	1
other words, you	2
other languages. But	1
other module. The	1
other programs, 99%	1
other input/output than	1
other way, etc.	1
other nearby parts	1
other nearby branches.	1
other (not member	1
other resource, such	1
other exceptions: __except	1
other ways, as	1
other complications that	1
other compilers). The	1
other processes. The	1
other reasons, but	1
other hardware-related details	1
other situations: The	1
other optimizations, as	1
other constructors. A	1
other system- specific	1
other flaws in	1
other odd-sized vector	1
other subtasks is	1
other abuse is	1
other volumes in	1
instruction is executed	1
instruction to localize	1
instruction and have	1
instruction and expect	1
instruction for interrupt	1
instruction for self-relative	1
instruction that the	1
instruction that you	1
instruction can be	1
instruction if the	1
instruction set is	34
instruction set and	6
instruction set in	1
instruction set for	2
instruction set that	2
instruction set are	1
instruction set can	2
instruction set or	1
instruction set it	1
instruction set if	2
instruction set not	1
instruction set int	1
instruction set than	1
instruction set may	1
instruction set when	2
instruction set then	1
instruction set has	3
instruction set also	1
instruction set where	1
instruction set makes	2
instruction set SSE2	1
instruction set was	1
instruction set supports	2
instruction set gives	1
instruction set (or	1
instruction set #if	1
instruction set available,	1
instruction set opens	1
instruction set (requires	1
instruction set (128	2
instruction set specified.	1
instruction set (called	1
instruction set Suppl.	1
instruction set extensions.	1
instruction set (/arch:SSE2,	1
instruction takes typically	1
instruction cannot be	1
instruction before any	1
instruction code. You	1
instruction must be	1
instruction doesn't give	1
instruction add ebx,	1
instruction add eax,1	1
instruction was certain	1
instruction sets the	1
instruction sets is	2
instruction sets and	2
instruction sets are	2
instruction sets can	1
instruction sets have	2
instruction sets from	1
instruction sets enable	1
instruction sets include	1
instruction sets Microprocessor	1
instruction set. The	6
instruction set. This	1
instruction set. A	1
instruction set. It	1
instruction set. If	2
instruction set. These	1
instruction set. Therefore,	1
instruction set. Make	1
instruction set. Do	1
instruction set. 120	1
instruction set. Aligning	1
instruction set. 13.6	1
instruction set. More	1
instruction set. Neither	1
instruction set. High	1
instruction prevents the	1
instruction mov DWORD	1
instruction sets. The	1
instruction sets. Most	1
instruction sets. Supports	1
instruction sets. Vector	1
instruction sets. Likewise,	1
instruction sets. Does	1
instruction set, and	1
instruction set, as	1
instruction set, then	1
instruction set, but	2
instruction set, one	1
instruction set, using	2
instruction set, another	1
instruction set, e.g.	1
instruction xor eax,eax.	1
instruction sets, cache	1
instruction sets........................... 122	1
instruction latencies are	1
instruction latencies, throughputs	1
instruction set: //	1
instruction timing, assembly	1
instruction set?". A	1
instruction directly, or	1
point is that	1
point is faster	2
point is 1.	1
point of view.	1
point of attack	1
point to the	4
point to a	1
point to are	1
point to integer	2
point to end	1
point to become	1
point to integer.	1
point to a[i+2]	1
point and integer	1
point in your	1
point if the	1
point code and	1
point code more	1
point code rather	1
point code slower,	1
point library which	1
point number is	1
point number to	2
point number in	1
point number by	1
point number simply	1
point where it	1
point value written	1
point variable as	1
point variables is	1
point variables and	2
point variables in	1
point variables use	1
point variables do	1
point variables Floating	1
point variables .........................	1
point register variables	3
point register stack	1
point register variables.	1
point register variables,	1
point code. The	2
point code. If	1
point registers and	1
point registers are	1
point registers available	1
point registers organized	1
point operations and	1
point operations are	1
point operations without	1
point operations involves	2
point operations (addition,	1
point constant always	1
point stack registers	3
point calculations and	1
point calculations or	1
point calculations as	1
point calculations will	1
point calculations should	1
point calculations inside	1
point calculations unless	1
point calculations usually	1
point calculations whenever	1
point execution units.	1
point overflow has	1
point overflow but	1
point precision (see	1
point precision conversion	1
point parameters are	2
point counter then	1
point multiplication at	1
point multiplication units.	1
point division to	1
point division by	1
point division takes	1
point division Floating	1
point division ...........................................................................................	1
point induction variables	2
point addition and	1
point addition with	1
point addition on	1
point addition takes	2
point addition every	1
point addition units,	1
point addition unit,	1
point expressions or	1
point expressions may	1
point expressions (see	1
point numbers is	2
point numbers to	1
point numbers and	2
point numbers are	1
point numbers can	1
point numbers simply	1
point XMM (vector)	1
point operands cannot	1
point operation on	1
point operation takes	1
point constants are	2
point library. If	1
point calculations. Even	1
point operations. You	1
point precision. The	1
point instructions. This	1
point instructions. Each	1
point expressions. It	1
point expressions. For	1
point expressions. Most	1
point expressions. Floating	1
point addition, and	1
point variables, if	1
point Conversion of	1
point vectors. There	1
point algebra reductions:	1
point rounding mode	1
point capabilities (except	1
point representation directly	1
point number. We	1
point comparisons are	3
point comparisons more	1
point numbers. It	1
point numbers. Therefore,	1
point division. Correction	1
point underflow in	1
point constants, string	2
point format is	1
point addition. This	1
point multiplication, to	1
point numbers: //	1
point comparisons, which	1
point overflow: _controlfp_s(&dummy,	1
point expressions, even	1
point extern "C"	1
point precisions when	1
point status: _fpreset();	1
point comparison. On	1
point variable: //	1
point multiply-and-add Table	1
point -ffast-math /fp:fast	1
point exceptions, etc.	1
loop is to	1
loop is in	1
loop is long	1
loop is inside	1
loop is predicted	1
loop is interpreted	1
loop is rolled	1
loop of a	3
loop of ADC	1
loop and have	1
loop and use	1
loop and without	1
loop and splitting	1
loop and reorganize:	1
loop in the	1
loop in a	1
loop in this	1
loop in example	6
loop for //	1
loop for calculations:	1
loop for trivial	1
loop that also	1
loop that does	1
loop that contains	1
loop that includes	1
loop are finished.	1
loop can be	1
loop can change	1
loop can still	1
loop or the	1
loop or add	1
loop or not.	1
loop if the	2
loop if it	1
loop if you	1
loop if this	1
loop if all	1
loop if true	1
loop if powN	1
loop by the	1
loop by using	1
loop by two	2
loop by 16	1
loop by eight	4
loop by n	1
loop by storing	1
loop by four,	1
loop with a	2
loop with multiple	1
loop with few	1
loop A function	1
loop will use	1
loop will take	3
loop then you	1
loop because nothing	1
loop should preferably	1
loop double ipow	1
loop where each	1
loop where almost	1
loop takes up	1
loop branch should	1
loop branch must	1
loop without checking	1
loop does not	1
loop ; a[i]	1
loop ; unused	1
loop ; compute	1
loop through rows	2
loop contains floating	1
loop would be	1
loop doing mathematical	1
loop counter is	2
loop counter and	1
loop counter can	3
loop counter by	1
loop counter with	1
loop counter when	1
loop counter should	1
loop counter i	1
loop counter outside	1
loop counter ahead	1
loop count is	4
loop count that	2
loop count should	1
loop count down	1
loop count (ArraySize)	1
loop automatically if	1
loop needs a	1
loop becomes a	1
loop control it	1
loop control branch	5
loop control statement	1
loop control condition	2
loop control branch.	2
loop control condition:	1
loop bigger than	1
loop depends on	1
loop columns below	2
loop further if	1
loop unroll option	1
loop unroll factor.	1
loop condition i	1
loop buffer that	1
loop unrolling is	1
loop unrolling in	1
loop unrolling so	1
loop iterations are:	1
loop body is	1
loop body now	1
loop body begins	1
loop is. The	1
loop counter. Example:	1
loop counter. Any	1
loop increment i++.	1
loop repeats a	1
loop repeats 20	1
loop index. The	1
loop counters, function	1
loop counters, etc.	1
loop manually unless	1
loop unrolled double	1
loop calculates four	1
loop counter, which	1
loop counter, comparing	1
loop count. The	1
loop predictor. On	1
loop exits, when	1
loop counter: //	1
loop overhead. Example:	1
loop initialisation i=0;	1
If the code	3
If the compiler	3
If the program	4
If the vector	1
If the different	1
If the same	2
If the CPU	1
If the loop	1
If the cache	2
If the class	1
If the size	1
If the Intel	1
If the object	1
If the number	6
If the version	1
If the value	1
If the variable	1
If the software	1
If the member	1
If the critical	1
If the first	1
If the template	1
If the arrays	1
If the AVX	1
If the problem	1
If the container	1
If the standard	1
If the microprocessor	2
If the application	1
If the computer	1
If the response	1
If the repeat	1
If the offset	1
If the final	1
If the total	2
If the length	1
If the latter	1
If the carry	1
If the key	1
If the combined	1
If the bottleneck	1
If the wrong	1
If the word	1
If the granularity	1
If a and	2
If a function	3
If a program	3
If a loop	2
If a floating	1
If a template	1
If a piece	1
If a bool	1
If a future	1
If a profiling	1
If a dispatched	1
If it is	3
If an error	1
If you are	7
If you can	1
If you make	1
If you do	1
If you cannot	1
If you need	1
If you access	2
If you want	5
If you run	1
If you don't	1
If you read	1
If you look	1
If you know	1
If you just	1
If you consider	1
If you forget	1
If this is	1
If this address	1
If time is	1
If different versions	1
If one operand	2
If each floating	1
If i is	1
If two threads	1
If two integers	1
If there is	2
If there are	3
If objects are	3
If any of	2
If we want	1
If we compile	1
If we assume	1
If we modify	1
If part of	1
If I write	1
If arrays are	1
If c =	1
If virtual functions	1
If several functions	1
If exception handling	1
If caching is	1
If Microsoft compiler	1
If n =	1
If your optimization	1
If columns had	1
If N is	1
If seconds was	1
If F1 calls	1
If search facilities	2
If frequent updates	1
If not, then	2
If hyperthreading is	1
If Func1 and	1
If MultiplyBy in	1
If so, then	1
which the array	1
which the variable	2
which the elements	1
which the calling	1
which the modules	2
which is the	3
which is a	1
which is more	1
which is only	1
which is all	1
which is used	2
which is very	3
which is called	1
which is less	1
which is useful	1
which is 0	1
which is available	2
which is much	2
which is calculated	1
which is implemented	1
which is known	1
which is likely	1
which is quite	1
which is typically	2
which is difficult	1
which is transferred	1
which is divisible	1
which is slow	1
which is similar	1
which is faster.	1
which is fast.	1
which is 15	1
which is contiguous	1
which is double.	1
which is 50%	1
which a code	1
which a dynamic	1
which of the	2
which in turn	1
which are used	1
which are called	1
which are 64	1
which are useful	1
which are implemented	1
which are relatively	1
which are cheap,	1
which can be	7
which can only	1
which can take	1
which it is	1
which it has	1
which function to	1
which code branch	1
which compiler will	1
which may be	1
which may cause	1
which may happen	1
which may interfere	1
which this code	1
which will generate	1
which will change	1
which will delay	1
which will enable	1
which then calls	1
which data are	1
which functions take	1
which instruction set	2
which instruction sets	1
which one is	2
which one works	1
which set of	1
which version of	4
which version to	1
which we assume	1
which variables will	1
which software development	1
which way a	1
which makes the	1
which makes it	1
which makes data	1
which makes detailed	1
which cannot be	1
which they are	4
which they appear	2
which method is	2
which method to	1
which programming language	1
which part of	1
which does the	1
which processor models	2
which solution is	1
which few programs	1
which contains the	1
which would be	1
which quite likely	1
which allows the	1
which implementation is	1
which resources are	1
which optimizations you	2
which range from	1
which reductions the	1
which reductions they	1
which gives access	1
which comes with	1
which platforms and	1
which prevents out-of-order	1
which causes a	1
which not. You	1
which counts at	1
which happens quite	1
which returns a	1
which gets information	1
which alloca was	1
which otherwise can	1
which opens and	1
which consumes CPU	1
which initially points	1
which can't be	1
which calculates the	1
which determines the	1
which transposes a	1
which redirects it	1
which affects other	1
which supposedly is	1
which interprets the	1
which imprecisions should	1
all the functions	2
all the CPU	1
all the cache	1
all the integer	1
all the compilers	2
all the array	1
all the objects	3
all the dynamic	2
all the bits	1
all the necessary	1
all the problems	2
all the numbers	1
all the modules	1
all the relevant	1
all the additions	1
all the inputs	1
all the factors	1
all the B	1
all the G	1
all the R	1
all is for	1
all of the	1
all of these	1
all to the	1
all be below	1
all on AMD	1
all code has	1
all code versions	1
all code branches	2
all use single	1
all data in	2
all data members	1
all data members.	1
all because the	1
all functions and	1
all functions static	1
all functions called	1
all other bits	1
all other processes	1
all but the	1
all class objects	1
all floating point	1
all compilers are	1
all static data,	1
all 64-bit CPUs	1
all C++ compilers	1
all possible cases	1
all objects have	3
all variables and	1
all software be	1
all elements of	1
all elements to	1
all elements have	1
all libraries have	1
all pointers and	1
all systems that	1
all these table	1
all these purposes.	1
all dynamic libraries	1
all bits except	2
all CPUs that	1
all threads have	1
all allocated objects	2
all good compilers	1
all done in	1
all operators that	1
all information about	2
all files on	2
all cases, while	1
all branches for	1
all source files	1
all resources are	1
all three versions	1
all runtime libraries	1
all means avoid	1
all compilers. Some	1
all compilers. Use	1
all optimizations of	1
all optimizations on	1
all public and	1
all x86 and	2
all x86 platforms.	3
all operands in	1
all modules that	1
all relevant optimization	3
all relevant options.	1
all conversions from	1
all platforms. PathScale	1
all installation options	1
all modern microprocessors	1
all modern CPUs.	1
all modern computers	1
all variables. Obviously,	1
all platforms and	1
all local non-member	1
all strings in	2
all unknown processors	1
all kinds of	1
all sizes of	1
all newer Intel	1
all newer models	1
all writes to	1
all non-static variables	1
all non-static member	1
all subsequent elements	1
all destructors for	1
all destructors are	2
all brands of	1
all applications. 2.8	1
all suitable functions	1
all instances of	2
all five values	1
all cleanup of	1
all .cpp modules	1
all belong to	1
all objects. This	1
all caches have	1
all Unix-like platforms.	1
all 0's when	1
all 0's gives	1
all major platforms.	2
all disturbing influences	1
all squares: for	1
all respects relevant	1
all 1's is	1
all 1's when	1
all zeroes. Example:	1
all intrin.h (MS)	1
all occurrences of	1
but the function	1
but the code	1
but the compiler	4
but the program	1
but the point	1
but the variable	1
but the performance	1
but the first	1
but the method	1
but the calculation	1
but the programmer	1
but the examples	1
but the syntax	1
but the alignment	1
but the asmlib	1
but is not	1
but is less	2
but is currently	1
but in a	1
but in this	1
but in example	1
but in registers	1
but in applications	1
but for most	1
but for studying	1
but are identified	1
but it is	7
but it can	3
but it may	4
but it will	1
but it has	1
but it often	1
but it doesn't	2
but it uses	1
but it would	1
but it requires	1
but it took	1
but it increases	1
but if we	1
but on what	1
but as long	1
but not the	2
but not in	1
but not if	3
but not on	2
but not any	1
but not long	1
but not always	1
but not dynamic	1
but not safe	1
but not all.	1
but may be	1
but you can	1
but you may	1
but you should	1
but you cannot	1
but this is	6
but this will	1
but this memory	1
but this makes	1
but this method	1
but this feature	2
but this unit	1
but will save	1
but has a	1
but only if	1
but only an	1
but only after	1
but only show	1
but only self-	1
but other systems	1
but no compiler	1
but no other	1
but no compile-	1
but there is	2
but there are	2
but also the	2
but also when	1
but also very	1
but also less	1
but also supports	1
but also inconvenient	1
but also safer.	1
but such expressions	1
but any of	1
but 32-bit systems	1
but less optimized.	1
but these are	1
but these address	1
but they are	2
but part of	1
but I think	1
but its data	1
but must go	1
but several hundred	1
but eight logical	1
but operators that	1
but quite inefficient	1
but don't count	1
but read one	1
but slow or	1
but outside the	1
but possibly not	1
but rarely in	1
but risk of	1
but who would	1
but expensive if	1
but efficient, way	1
but unfortunately the	1
but unfortunately it	1
but unfortunately this	1
but unfortunately there	1
but avoids the	1
but none of	2
but that's about	1
but waits until	1
but neither faster	1
but i*12, because	1
but risky. The	1
but event-counters do.	1
used the trick	1
used is branch	1
used to avoid	1
used to speed	1
used to read	1
used to be.	1
used and this	1
used and searching	1
used and popped	1
used in the	9
used in a	3
used in example	1
used in multiple	1
used in two	2
used in 64-bit	1
used in any	1
used in some	1
used in so	1
used in small	1
used in shared	1
used in STL	1
used in almost	1
used for the	1
used for function	1
used for an	1
used for other	1
used for all	1
used for pointer	1
used for multiple	2
used for any	1
used for variables	1
used for branch	1
used for file	1
used for doing	1
used for multiplication	1
used for vectorized	1
used for accessing	1
used for calculating	2
used for finding	1
used for temporary	1
used for debugging	1
used for Java	1
used for storing	1
used for giving	2
used for converting	1
used for internal	2
used for reducing	1
used for turning	1
used for defining	1
used for saving	1
used for constants.	1
used for prefetching	1
used for implementing	2
used for improving	1
used for metaprogramming,	1
used for jumping	1
used for relieving	1
used for fetching	1
used that most	1
used or if	1
used if the	1
used if instruction	1
used if there	1
used if elements	2
used by the	1
used by a	1
used by all	1
used by multiple	1
used by many	1
used by element	1
used by exception	1
used by default	1
used by thousands	1
used with other	2
used on bigger	1
used on completely	1
used as a	2
used as an	2
used as macros	1
used as alternatives	1
used as command-line	1
used as coprocessors	1
used as buffers	1
used an intermediate	1
used more efficiently.	1
used when the	1
used when a	1
used when it	1
used at the	2
used at all	1
used data members	1
used functions separate	1
used only for	3
used only when	1
used only within	1
used cache line	1
used set of	1
used most for	1
used where execution	1
used many times	1
used variables in	1
used variables are	1
used without restrictions.	1
used inside the	1
used simply to	1
used above the	1
used branches such	1
used members in	1
used intrinsic functions.	1
used methods for	1
used char (or	1
used data. The	1
used parts of	1
used together are	2
used together should	4
used here is	1
used functions, and	1
used during program	1
used near each	1
used here. The	1
used twice for	1
used most. The	1
used freely without	1
one is called	1
one is 0	1
one is best.	1
one is fastest.	1
one of the	11
one of these	1
one and only	1
one in a	1
one for the	2
one for AVX2	1
one for constants	1
one for initialized	1
one for SSE4.1	1
one for uninitialized	1
one that is	2
one that takes	1
one that works	2
one that gives	1
one that saves	1
one that doesn’t.	1
one that discriminates	1
one or a	3
one or more	4
one or multiple	1
one or two	2
one it is	1
one function to	1
one function and	1
one function can	1
one if the	1
one by means	2
one by one,	1
one time in	1
one more integer	1
one from Intel	1
one from me.	1
one memory block	1
one memory pool.	1
one CPU core	1
one CPU core,	1
one other function.	1
one set of	1
one class to	1
one floating point	1
one object to	1
one array rather	1
one clock cycle	2
one clock cycle.	3
one version that	1
one variable if	1
one way in	1
one way or	2
one way most	1
one way two	1
one makes the	1
one call to	3
one register less	1
one constant needs	1
one (see page	1
one big memory	1
one big block	1
one big problem.	1
one element then	1
one virtual member	1
one thread is	1
one thread can	1
one thread than	1
one line at	2
one works best.	1
one container for	1
one : 1;	1
one operator less.	1
one division by	1
one source file	1
one addition every	2
one byte longer	1
one function, if	1
one computer is	1
one global and	1
one statement in	1
one operation rather	1
one instance of	1
one instance for	5
one instance then	1
one operand is	2
one iteration of	1
one iteration to	1
one iteration should	1
one iteration before	1
one thread. A	1
one square at	1
one thing at	1
one logical processor	1
one vector. It	1
one fraction 2	1
one 256-bit vector	1
one parameter. Further	1
one unit of	1
one register. Registers	1
one vector, the	1
one vector, while	1
one free register	1
one operation. A	1
one operation. For	1
one contiguous memory	1
one place to	1
one place in	1
one auto_ptr to	1
one way, then	1
one instance. The	1
one instance. Non-static	1
one segment then	1
one tread can	1
one local, and	1
cache is a	1
cache is that	1
cache is used	2
cache is 8	1
cache is optimized	1
cache is 512	2
cache is organized	1
cache of 8	2
cache of 256	1
cache to load	1
cache and the	2
cache and it	1
cache and data	1
cache and accessed	1
cache and execution	1
cache in between	1
cache in just	1
cache for the	2
cache that can	1
cache are so	1
cache are critical	1
cache are less	1
cache or micro-op	1
cache if there	1
cache as when	1
cache may not	1
cache use and	1
cache use can	1
cache will be	1
cache will evict	1
cache then you	1
cache from the	1
cache from loading	1
cache because the	1
cache size is	1
cache so we	1
cache between each	1
cache cannot prefetch	1
cache called the	1
cache always chooses	1
cache access rather	1
cache (see page	1
cache (see p.	1
cache line to	1
cache line in	1
cache line that	2
cache line can	1
cache line will	1
cache line then	1
cache line has	1
cache line size	5
cache line would	1
cache line size,	1
cache works most	3
cache works less	1
cache space and	1
cache space or	1
cache space by	1
cache space used	1
cache control instructions	1
cache control ..............................................................................................	1
cache control Microprocessors	1
cache contentions is	1
cache contentions can	1
cache contentions if	2
cache contentions than	1
cache contentions will	1
cache size. This	1
cache size. If	1
cache size. When	1
cache size. Alternatively,	1
cache lines to	1
cache lines in	3
cache lines for	1
cache lines from	1
cache lines we	1
cache lines follow	1
cache lines belong	1
cache efficiency and	1
cache (e.g. Sandy	1
cache problems. It	1
cache space. The	1
cache space. A	1
cache space. Excessive	1
cache space. Putting	1
cache line. The	1
cache line. This	1
cache line. Some	1
cache line. But	1
cache line. Only	1
cache line. 132	1
cache misses is	1
cache misses and	2
cache misses by	1
cache misses have	1
cache size, etc.	1
cache effects into	1
cache lines. The	1
cache lines. This	1
cache size) /	1
cache MOVNTQ _mm_stream_pi	1
cache organization for	1
cache level, and	1
cache space, as	1
cache sizes. Fortunately,	1
cache misses, branch	3
cache efficiency, then	1
cache miss can	1
cache miss on	1
cache MOVNTDQ _mm_stream_si128	1
cache MOVNTPD _mm_stream_pd	1
cache contentions. See	1
cache contentions. Use	1
cache (en.wikipedia.org/wiki/L2_cache). The	1
cache evictions and	1
cache MOVNTPS _mm_stream_ps	1
cache MOVNTI _mm_stream_si32	1
cache line: static	1
cache line, because	1
cache contention. You	1
cache contentions, as	1
cache miss. But	1
should of course	1
should be a	1
should be of	1
should be as	1
should be only	1
should be used	1
should be possible	1
should be stored	6
should be accessed	1
should be compiled	1
should be done	1
should be implemented	2
should be used.	1
should be separate	1
should be longer	1
should be aligned	1
should be linked	1
should be declared	2
should be based	1
should be made	1
should be tested	4
should be avoided	3
should be clear	1
should be organized	2
should be standardized	1
should be easily	1
should be allowed	1
should be saved	1
should be aware	3
should be measured	1
should be split	1
should be seen	1
should be written	1
should be true.	1
should be identified	1
should be multiplied	1
should be hidden	1
should be performed	1
should be taken	3
should be handled	1
should be predicted.	1
should be optional	1
should be avoided,	1
should be regarded	1
should be obeyed.	1
should be prepared	1
should be weighed	1
should be postponed	1
should be scheduled	1
should by all	1
should not be	2
should not call	1
should not look	1
should not include	1
should have as	1
should have its	1
should have #if	1
should use this	1
should use such	1
should use standard	1
should then handle	1
should only be	1
should do as	1
should also be	2
should also proceed	1
should take installation	1
should test the	1
should always be	1
should always use	1
should work efficiently	1
should avoid any	1
should avoid these	1
should avoid making	1
should avoid macros	1
should therefore be	2
should therefore not	1
should therefore preferably	3
should get a	1
should run in	1
should preferably be	14
should preferably have	1
should automatically detect	1
should never use	1
should never return	1
should never interrupt	1
should never respond	1
should give a	1
should look at	1
should choose an	1
should rely on	1
should produce the	1
should save one	1
should allow compile-	1
should apply the	1
should apply CPU	1
should contain a	1
should multiply it	1
should include not	1
should depend on	1
should definitely be	3
should disable it	1
should leave a	1
integer is within	1
integer is added	1
integer is converted	1
integer is returned.	1
integer is signed,	1
integer of a	1
integer to the	1
integer to a	3
integer to floating	2
integer to zero	1
integer and this	1
integer and floating	1
integer and double	1
integer and 8	1
integer in the	2
integer in a	1
integer in one	1
integer in disguise.	1
integer that holds	1
integer can be	2
integer if the	1
integer if it	1
integer if there	1
integer with a	1
integer with vector	1
integer int n;	1
integer may be	1
integer will be	1
integer has a	1
integer has enough	1
integer vector from	4
integer vector into	4
integer vector instructions	1
integer vector division.	1
integer because the	1
integer size is	2
integer size in	1
integer size that	4
integer size if	1
integer size on	1
integer value of	1
integer takes a	2
integer takes longer	1
integer variable by	1
integer register variables	1
integer rather than	1
integer code. It	1
integer registers is	1
integer registers in	1
integer registers available	1
integer without SSE2	1
integer operations for	3
integer operations are	1
integer operations use	1
integer operations do	1
integer operations such	1
integer operations in-between	1
integer type size_t	1
integer constant with	1
integer calculations in	1
integer doesn't cause	1
integer overflow with	1
integer overflow will	1
integer overflow doesn't	1
integer power using	1
integer parameters and	1
integer parameters are	2
integer known at	1
integer counter and	1
integer multiplication by	1
integer multiplication prior	1
integer expression -a	1
integer conversion Conversion	1
integer parameter comes	1
integer division in	1
integer division with	1
integer division prevents	1
integer types of	1
integer types Unfortunately,	1
integer types available.	1
integer expressions than	2
integer expressions rather	1
integer expressions Induction	1
integer expressions (except	1
integer vectors FMA3	1
integer variables. 31	1
integer registers. Typical	1
integer calculations. The	1
integer calculations. It	1
integer operations. This	1
integer expressions. See	1
integer overflow. Signed	1
integer addition, a	1
integer addition, subtraction	1
integer factorial function	1
integer arithmetic operations.	1
integer vectors. Code	1
integer parameters. Floating	1
integer representation of	1
integer constant. //	1
integer Common subexpression	1
integer Register variables,	1
integer counter. A	1
integer counter. Example:	1
integer division. Older	1
integer type. Interrupt	1
integer overflow, and	1
integer constants. Register	1
integer units, one	1
integer operations, and	1
integer variable, it	1
integer comparison is	1
integer comparison, which	1
integer According to	1
integer power, loop	1
integer division: Integer	1
integer representations in	1
integer constant, unless	1
integer comparisons. The	1
no function or	1
no compiler I	1
no more than	1
no more time	2
no more threads	1
no other value	2
no other threads	1
no other values	2
no other modules	1
no other branches.	1
no other exceptions:	1
no instruction for	1
no loop if	1
no cache (see	1
no cache problems.	1
no pointer aliasing	3
no pointer aliasing.	3
no pointer aliasing"	2
no object is	1
no such advantage	1
no variable or	1
no performance cost	1
no performance penalty	1
no long dependency	1
no branch prediction	1
no way the	1
no way to	2
no operating system,	1
no need to	7
no need for	1
no instructions for	1
no extra code	1
no extra time	3
no extra time.	3
no extra cost	1
no extra overhead	1
no calls to	1
no big difference	1
no big arrays,	1
no specific order	1
no specific recommendation	1
no specific option)	1
no virtual member	1
no exception handling.	1
no exception ever	1
no overflow can	1
no AVX support,	1
no check for	4
no problem if	1
no advantage to	1
no copy constructor	1
no copy constructors	1
no information about	1
no certain limit	1
no branches inside	1
no caching problems	1
no cost to	1
no cost in	2
no cost because	1
no automatic check	1
no induction variable	1
no reason to	5
no difference in	5
no difference for	1
no difference between	1
no difference whether	1
no longer used	1
no longer used.	2
no graphics processing	1
no negative effect	1
no overhead while	1
no checking for	2
no out-of-order execution.	1
no destructor the	1
no offset at	1
no clear correspondence	1
no risk of	3
no penalty for	1
no checks for	1
no easy way	2
no explanation why	1
no try block	1
no heavy marketing	1
no absolute addresses	1
no loop-carried dependency	1
no 51 performance	1
no modification of	1
no idea how	1
no reasonable upper	1
no compile- time	1
no multiplications. The	1
no doubt obtained	1
no warning from	1
no effect. GOT	1
no attempt is	1
no native floating	1
no guarantee that	1
no side-effects and	1
no yes License	1
page and 90	1
page size (4096).	1
page 8 below.	1
page 16 for	1
page 32 for	1
page 128 below.	1
page 3 for	1
page 130 for	4
page 120 for	1
page 16. If	1
page 87 for	1
page 87 about	1
page 122 for	2
page 80 for	1
page 90 for	1
page 107 for	1
page 103 for	1
page 51 for	1
page 43 for	1
page 43 about	1
page 88 for	1
page 134 and	1
page 134 on	1
page 150 for	1
page 146 below.	2
page 26 about	1
page 29 for	1
page 31 for	1
page 49 and	1
page 49 for	1
page 101 for	1
page 93 for	1
page 164 below.	1
page 81 for	1
page 89 for	2
page 137 about	1
page 136 and	1
page 153 for	1
page 145 and	1
page 140 for	1
page 141 for	1
page 78 for	2
page 107). The	1
page 107). Agner's	1
page 16) shows	1
page 71). The	1
page 71). In	1
page 131. Intel	1
page 131. AMD	1
page 127. The	1
page 15. C++	1
page 52. The	1
page 52. You	1
page 73 and	1
page 73). It	1
page 73). Current	1
page 39 shows	1
page 105. Floating	1
page 105. 8.7	1
page 93. Avoid	1
page 93. 7.10	1
page 26. The	1
page 26. Avoid	1
page 78). A	1
page 78). Adding	1
page 137). The	1
page 137). This	1
page 80. The	1
page 43). The	1
page 122. The	2
page 87). Data	1
page 58 shows	1
page 105). If	1
page 105). Using	1
page 140). The	1
page 140). Mathematical	1
page 72. It	1
page 72. You	1
page 95 and	1
page 51). The	1
page 119). The	1
page 22. Avoid	1
page 153. A	1
page 27). The	1
page 107. A	1
page 78. Assume	1
page 60. In	1
page 103) will	1
page 107), OpenMP	1
page 122) for	1
page 62. If	1
page 96. 14.5	1
page 141. Applications	1
page 53). No	1
page 93). All	1
page 44. The	1
page 143. The	1
page 96). Virtual	1
page 134. The	1
page 103), but	1
page 34. In	1
page 142). 30	1
page 54. It	1
page 81). 77	1
page 90. 15	1
page 84). The	1
page 53. 7.24	1
page 45. This	1
page 134) return	1
page 135). This	1
page 140. Avoid	1
page 132. Unfortunately,	1
page 87. This	1
page 38). Is	1
page 87) is	1
page 130. It	1
page 72). The	1
page 61. It	1
page 158. This	1
page 150. Using	1
page 73) automatically	1
page 73. Runtime	1
page 70). The	1
page 27. An	1
set the flush-to-zero	1
set the parentheses	1
set the denormals-are-zero	1
set is the	2
set is that	2
set is not	1
set is available	1
set is supported	7
set is used.	1
set is better	1
set is particularly	1
set is enabled.	7
set is available.	3
set is available,	1
set is enabled	2
set is supported.	1
set is specified.	1
set is available:	1
set is enabled:	1
set is maintained	1
set a to	2
set a breakpoint	1
set of data	1
set of cache	1
set of performance	1
set of template	1
set of test	4
set of CPUs.	1
set of special	1
set of containers	1
set of counters	1
set to NULL.	1
set to relax	1
set and one	1
set and insert	1
set and map	1
set and YMM	2
set and ZMM	2
set in the	2
set in order	1
set for the	2
set that is	1
set that you	1
set are expected	1
set can be	1
set can run	1
set can still	1
set or any	1
set it supports.	1
set if possible.	2
set by using	1
set not supported	1
set an array	1
set int iset	1
set than the	1
set may actually	1
set when running	1
set when compatibility	1
set then the	1
set then it	1
set has no	1
set has support	1
set has nothing	1
set into sub-vectors	1
set multiple bits	1
set number 28.	1
set number 0x1C.	1
set also allows	1
set where the	1
set makes floating	2
set SSE2 or	1
set SSE2 not	1
set up the	1
set up to	1
set up and	1
set AVX instr.	1
set values then	1
set sign bit	2
set was originally	1
set char 8	1
set needed _mm_shuffle_epi8	1
set control no	1
set supports self-relative	2
set gives the	1
set Automatic CPU	1
set SSE4.1 instr.	1
set seconds to	1
set (or higher)	1
set #if INSTRSET	1
set available, e.g.	1
set Header file	1
set opens the	1
set (requires a	1
set (128 bit	1
set (128 vectors	1
set 0x1C. If	1
set specified. Insert	1
set (called x86)	1
set Suppl. SSE3	1
set extensions. If	1
set Prefetch PREFETCH	1
set (/arch:SSE2, /arch:AVX	1
set Important features	1
class is more	1
class is less	1
class is 128	1
class is implemented	1
class is declared	2
class is given	1
class is converted	1
class is declared.	1
class is responsible	1
class of the	1
class of object	1
class to a	1
class and a	1
class and store	1
class and derived	1
class in one	1
class in another	1
class for containing	1
class that the	1
class that is	1
class that takes	1
class that behaves	1
class are stored	2
class are called	1
class are accessed	2
class can be	1
class or structure	5
class or give	1
class or structure.	2
class by type-casting	1
class with a	2
class with members	1
class code with	1
class will be	1
class data member	1
class data members	1
class has a	1
class has at	1
class vector {	1
class which gets	1
class should be	1
class into an	1
class library can	1
class library have	1
class library will	1
class library has	2
class library Intel	1
class library makes	1
class library #include	1
class library exp	1
class objects and	1
class objects can	1
class objects Conversions	1
class objects (rather	1
class member function	1
class member functions	1
class member variable	1
class member function.	1
class libraries use	1
class libraries 113	1
class template rather	1
class need not	1
class must have	1
class (see page	1
class doesn't need	1
class through a	3
class members may	1
class name and	1
class name as	1
class library. Open	1
class Variables declared	1
class containing the	2
class templates in	1
class templates are	1
class declaration and	1
class D :	2
class C1 or	1
class C1 {	1
class C1 :	2
class members. The	1
class c1 {	1
class c1 other	1
class library, SSE4.1	1
class gets information	1
class separately in	1
class elements. The	1
class objects. The	1
class powN {	1
class CChild1 :	2
class CHello {	1
class C0 {	1
class Vec16s when	1
class definition. This	1
class definition. Inlining	1
class CChild2 :	1
class templates, as	1
class B1; class	2
class CParent :	1
class CGrandParent {	1
class declaration. The	1
class C2 :	1
class c1; int	1
class SafeArray {	1
class B2; class	1
class B2; 54	1
class powN<true,0> {	1
class powN<true,N> {	1
class S2 {	1
class S3 {	1
class (also called	1
class (CGrandParent) contains	1
class library). The	1
class C1, so	1
class powN<true,1> {	1
class (CParent<>) contains	1
floating point is	2
floating point to	3
floating point and	1
floating point if	1
floating point code	4
floating point library	1
floating point number	6
floating point value	1
floating point variable	1
floating point variables	4
floating point register	6
floating point code.	3
floating point registers	4
floating point operations	5
floating point constant	1
floating point stack	3
floating point calculations	8
floating point execution	1
floating point overflow	1
floating point precision	1
floating point parameters	1
floating point counter	1
floating point multiplication	2
floating point division	1
floating point induction	1
floating point addition	7
floating point expressions	3
floating point numbers	7
floating point operands	1
floating point operation	2
floating point constants	2
floating point library.	1
floating point calculations.	1
floating point operations.	1
floating point precision.	1
floating point instructions.	2
floating point expressions.	4
floating point addition,	1
floating point variables,	1
floating point Conversion	1
floating point vectors.	1
floating point rounding	1
floating point capabilities	1
floating point representation	1
floating point number.	1
floating point comparisons	2
floating point numbers.	2
floating point division.	1
floating point underflow	1
floating point constants,	1
floating point format	1
floating point addition.	1
floating point multiplication,	1
floating point numbers:	1
floating point comparisons,	1
floating point overflow:	1
floating point expressions,	1
floating point precisions	1
floating point status:	1
floating point comparison.	1
floating point variable:	1
floating point multiply-and-add	1
floating point -ffast-math	1
floating point exceptions,	1
floating point. The	1
floating point. Use	1
floating point. Conversion	1
floating 26 point	1
floating point: //	1
floating point-to-integer conversions	1
floating point). There	1
each of the	1
each of its	1
each function is	1
each function and	1
each function or	1
each function call	2
each function relative	1
each compiler with	1
each time the	4
each time it	1
each time slice	1
each vector can	2
each vector register	1
each vector depends	1
each different value	1
each CPU model	1
each CPU core).	1
each other is	1
each other in	4
each other are	2
each other (not	1
each instruction set.	1
each integer type.	1
each set of	1
each floating point	1
each object in	1
each object are	1
each object should	1
each object separately	1
each array is	1
each array element	1
each version of	1
each version void	1
each version FuncType	1
each value is	1
each value of	2
each value from	1
each value depends	1
each value xn	1
each table element	1
each member function	1
each address by	1
each call to	1
each bit of	1
each bit in	2
each bit indicates	1
each time. An	1
each test //	1
each new version	1
each new generation	1
each part of	2
each part takes.	1
each type of	1
each constant a	1
each processor model	1
each compiled for	1
each element in	6
each element __m128i	1
each element matrix[r][c]	1
each thread than	1
each thread may	1
each thread will	1
each thread its	1
each allocated block.	1
each line written.	1
each optimized for	1
each calculation depends	2
each run in	1
each particular branch	1
each their stack.	1
each their smart	1
each intrinsic function	1
each string is	1
each addition has	1
each addition depends	1
each set. If	1
each process when	1
each statement that	1
each instance of	1
each task or	1
each object. A	1
each iteration is	1
each iteration it	1
each iteration needs	1
each thread. This	2
each thread. It	1
each thread. Pointers	1
each thread. Thread-local	1
each access. The	1
each version. The	1
each row or	1
each row by	1
each label is	1
each case. Inlined	1
each factor rather	1
each core. For	1
each step of	1
each process. A	1
each process. Obviously,	1
each other. This	1
each other. See	2
each carefully optimized	1
each element, bits	2
each calculation. In	1
each method, it	1
each other's caches	1
each pixel or	1
each call, and	1
each clause are	1
do the CPU	1
do the optimization	1
do the extra	1
do the best	1
do the necessary	1
do the check	1
do the dispatching	1
do the reductions	1
do the calculations.	1
do the algebraic	1
do the job	1
do the reduction	1
do the divisions	1
do the conversion.	1
do the devirtualization	1
do is to	2
do a floating	1
do a lot	3
do a thorough	1
do to make	1
do to take	1
do and which	1
do and what	1
do it explicitly.	1
do function inlining	1
do with bitwise	1
do as much	1
do as little	1
do not have	5
do not use	2
do not make	2
do not need	1
do not always	2
do not support	2
do not add	1
do not know	1
do not produce	1
do not expect	1
do not free	1
do not overlap.	4
do not wrap	1
do not overlap	1
do not normally	1
do not occur.	1
do not 123	1
do not alias,	1
do an integer	1
do an addition	1
do have to	1
do have such	1
do this by	1
do this optimization	2
do this every	1
do this optimization.	1
do this manually.	1
do use the	1
do more than	1
do more complicated	1
do more reductions	1
do when you	1
do different kinds	1
do because it	1
do other input/output	1
do integer operations	1
do multiple things	1
do two additions	1
do two jobs	1
do such a	1
do such optimizations	1
do such obvious	1
do any algebraic	1
do some measurements	1
do so is	2
do so will	1
do so unless	1
do so (i.e.	1
do operations on	1
do simple integer	1
do simple algebraic	1
do must be	1
do while waiting	1
do calculations on	1
do calculations while	2
do much of	1
do four additions	1
do another addition	1
do mathematical calculations.	1
do automatic vectorization.	1
do optimizations such	1
do things in	2
do things with	1
do whole program	1
do out-of-order execution.	1
do something about	2
do arithmetic operations	1
do this: Use	1
do this. Unfortunately,	1
do nothing while	1
do so. The	1
do so. See	1
do so. 58	1
do manually. It	1
do interprocedural optimizations	1
do experiments in	1
do immediately before	1
do so). A	1
do cross-module optimizations	1
do searches of	1
example is a	3
example is called	1
example is specific	1
example is Perl.	1
example of a	1
example of how	3
example to produce	1
example in the	1
example can be	2
example if you	2
example with floating	1
example with u.i[1]	1
example on page	1
example may fail	1
example use #if	1
example when you	1
example when r	1
example has three	1
example only to	1
example should be	1
example using Agner's	1
example i =	1
example so that	1
example 32 bits	1
example container classes	1
example every time	1
example sets the	1
example shows the	2
example shows a	1
example shows this	1
example shows first	1
example shows how	6
example shows what	1
example containers in	1
example below shows.	1
example 15.1b is	2
example 15.1b to	4
example 15.1b and	1
example 13.1 can	1
example 13.1 page	1
example 13.1 below.	1
example 16.2 calls	1
example 16.2 above,	1
example 15.1c is	1
example 14.8 and	1
example 12.4b and	1
example 12.4b can	1
example 16.1 const	1
example 9.5 because	1
example 9.5 so	1
example illustrates the	1
example illustrates such	1
example illustrates how	1
example illustrates this.	1
example 8.26a by	1
example 8.26a (32-bit	1
example 15.1a to	2
example 14.28 can	1
example 14.28 will	1
example 7.4 we	1
example 9.6b. The	2
example 9.5a on	1
example 9.5a goes	1
example 11.3 is	1
example 11.3 even	1
example explains why	1
example 14.12b and	1
example 14.14a with	1
example 12.4a where	1
example 12.4a so	1
example 8.15a were	1
example 14.19 below.	1
example 14.1c is	1
example 11.2b was	1
example transposes a	1
example 11.1a to	1
example 7.15b below	1
example 15.1b. Branches	1
example 14.23 page	1
example (12.4e) with	1
example 14.7b is	1
example 12.4a, depending	1
example 7.32b. A	1
example 8.15b. The	1
example 8.21, you	1
example 16.2. The	1
example 12.2, the	1
example 8.23b has	1
example 15.1d to	1
example 14.7b, we	1
example 8.24 can	1
example 12.1a, the	1
example 12.1b to	1
example 8.26b: ;	1
example 16.1. This	1
example 12.8a to	1
example 7.35 page	1
example converts a	1
example 12.1b, the	1
example 9.5a: 98	1
example 12.4b, rewritten	1
example 7.22. //	1
example 9.5b. //	1
example 12.3a, for	1
example 13.1, Requires	1
example 7.43b is	1
example 14.21 is	1
example 9.1b. On	1
example 7.30b. The	1
compilers is generally	1
compilers to see	1
compilers to choose	1
compilers and function	2
compilers and operating	6
compilers and optimized	1
compilers and development	1
compilers and microprocessors	1
compilers and invoked	1
compilers The register	1
compilers The tests	1
compilers for Windows	1
compilers for Linux.	1
compilers that a	1
compilers that are	1
compilers that have	1
compilers that support	1
compilers that rely	1
compilers are not	2
compilers are able	6
compilers are better	1
compilers are actually	1
compilers are mentioned	1
compilers are becoming	1
compilers are inferior	1
compilers can in	1
compilers can be	1
compilers can use	1
compilers can make	1
compilers can do	2
compilers can automatically	1
compilers can reduce	3
compilers can compute	1
compilers or function	1
compilers may be	1
compilers may not	1
compilers may behave	1
compilers you can	1
compilers have a	2
compilers have an	4
compilers have efficient	1
compilers have many	1
compilers have support	1
compilers have various	2
compilers have inefficient	1
compilers have difficulties	2
compilers use the	2
compilers will not	2
compilers will use	2
compilers will make	3
compilers will do	2
compilers will often	1
compilers will replace	1
compilers will automatically	2
compilers will reduce	1
compilers will unroll	1
compilers will align	2
compilers will recognize	1
compilers then it	1
compilers from Microsoft,	1
compilers at the	1
compilers has several	1
compilers make Sum1	1
compilers do not	2
compilers also have	1
compilers such as	1
compilers cannot do	1
compilers cannot reduce	1
compilers need assembly	1
compilers without problems	1
compilers I have	7
compilers optimize Modern	1
compilers optimize ............................................................................................	1
compilers don't vectorize	1
compilers Intel, Microsoft	1
compilers produce less	1
compilers unroll too	1
compilers reduced 15.1a	1
compilers allow assembly-like	1
compilers include standard	1
compilers available, though	1
compilers due to	1
compilers work. The	1
compilers behave differently	1
compilers offer the	2
compilers offer profile-guided	1
compilers (Microsoft, Intel)	1
compilers www.agner.org/ optimize/#vectorclass	1
compilers succeeded in	1
compilers exist for	1
most of the	8
most of its	3
most of their	2
most for register	1
most function libraries	1
most other libraries	1
most other microprocessors.	1
most used data.	1
most used parts	1
most cache misses,	1
most compilers you	1
most compilers will	1
most compilers do	1
most library functions	1
most C++ compilers	1
most efficient for	1
most efficient if	2
most efficient memory	1
most efficient vector	1
most efficient loop	1
most efficient integer	1
most efficient library	1
most efficient solution	3
most efficient solution.	1
most efficient alternative.	1
most variables in	1
most software runs	1
most critical integer	1
most critical part	8
most critical parts	1
most critical modules	1
most often used	3
most often true	1
most libraries it	1
most time. Uses	1
most useful for	1
most cases the	1
most cases be	1
most cases it	1
most cases you	1
most cases when	1
most cases where	1
most cases they	1
most simple reductions	1
most processors (when	1
most important or	1
most important functions	1
most important method	1
most important disadvantage	1
most important addition	1
most important thing	1
most important remedy	1
most CPUs and	1
most common memory	1
most common cause	1
most common mathematical	1
most common platforms	1
most common math	1
most common implementations	1
most common pitfalls	1
most common obstacles	1
most common time-consumers	1
most likely be	1
most cases, the	2
most cases, an	1
most cases, you	1
most cases, but	1
most cases, double	1
most cases, there	1
most cases, even	1
most cases, regardless	1
most complicated implementation	1
most development methods	1
most appropriate for	1
most advanced code	1
most compatible way	1
most cases. The	1
most cases. This	1
most cases. Don't	1
most modern C++	1
most efficiently if	3
most efficiently when	1
most newer processors.	1
most significant part	1
most critical. However,	1
most time-consuming part	1
most time-consuming parts	1
most purposes the	1
most systems, you	1
most frequent causes	1
most serious problem	1
most reliable solution.	1
most predictable operand	1
most popular version	1
most microprocessors. Multiplication	1
most commonly used	2
most clean solution	1
most up-to-date solution.	1
most cases: The	1
most sorting algorithms,	1
most distributions of	1
using the vector	1
using the same	3
using the integer	1
using the performance	1
using the register	1
using the optimization	1
using the instructions	1
using the virtual	1
using the above	1
using the keyword	3
using the |	2
using the so-called	2
using the bitwise	1
using the previous	1
using the declaration	1
using the smallest	1
using the normal	1
using the newest	1
using the larger	1
using the directive	1
using the fundamental	1
using a function	1
using a compiler	1
using a different	1
using a 64-bit	1
using a software	1
using a long	1
using a template	1
using a constant	1
using a common	1
using a particular	1
using a lookup	1
using a shift	1
using a six	1
using a profiler.	1
using a pipeline	1
using a ready-made	1
using and turn	1
using function inlining,	1
using an Intel	2
using an inline	1
using an intermediate	2
using this for	1
using vector operations	1
using vector classes	1
using different types	1
using functions such	1
using only the	1
using CPU clock	1
using CPU dispatching	1
using loop double	1
using one or	1
using one register	1
using each bit	1
using example 9.5a	1
using Intel vector	1
using static linking	2
using static here	1
using such a	1
using template metaprogramming	1
using registers for	1
using pointers and	1
using pointers rather	1
using new and	1
using dynamic memory	1
using short int	1
using & enum	1
using assembly language	2
using assembly language.	1
using single precision	1
using exception handling	1
using integers as	1
using intrinsic functions	1
using signed and	1
using vectors if	1
using advanced algorithms	1
using advanced facilities	1
using references rather	1
using references instead	1
using position-independent code	1
using overloaded functions.	1
using overloaded operators	1
using classes. 7.2	1
using bitwise operators	1
using smart pointers	1
using nontemporal writes.	1
using references. References	1
using templates (see	1
using rounding instead	1
using exceptions is	1
using powers of	3
using Agner vector	1
using Agner's vector	1
using asmlib library	2
using 8-bit integers	1
using exceptions. The	1
using templates. Two	1
using templates. Ready	1
using namespaces. 65	1
using __fastcall. Function	1
using hyperthreading. On	1
using hyperthreading, but	1
using multiplications only.	1
using alloca. 9.7	1
using ready made	1
using InstructionSet(): //	1
using indexes, working	1
using new. The	1
using new/delete or	1
using memset: //	1
using unions rather	1
using inheritance. There	1
double the number	1
double the speed	1
double is that	1
double is bad	1
double is represented	1
double a =	1
double to int	1
double to integer	2
double and long	2
double if the	1
double by modifying	1
double A =	2
double because all	1
double which gives	1
double Intel SVML	1
double In example	1
double There is	1
double takes 4	1
double takes 8	1
double 2 AVX2	1
double const &	1
double before multiplying	1
double 4 AVX2	1
double 8 8	1
double 64 2	1
double 64 4	1
double 64 8	1
double take no	1
double without loading	1
double 32 bits	1
double (see page	1
double a, b;	4
double precision is	2
double precision in	2
double precision or	2
double precision by	1
double precision when	2
double precision takes	1
double precision before	1
double precision without	1
double precision constant	1
double precision calculations	2
double precision constant.	1
double precision (80	1
double 128 float	1
double uses 64	1
double b; a	1
double b; //	1
double b; int	1
double 256 F32vec4	1
double y =	1
double c; b	1
double vectors AVX2	1
double vectors SSE3	1
double Floating point	1
double d; int	1
double d; d	3
double d =	1
double x, y;	1
double x, n,	2
double x, y,	1
double precision. You	1
double precision. But	1
double precision. Conversions	1
double precision. Long	1
double temp; for	2
double temp; //	1
double 8, 10,	1
double plus 6	1
double p(double x)	4
double precision, and	1
double precision, but	1
double y, a1,	2
double xpow10(double x)	4
double a1, a2,	2
double Y =	1
double format. The	1
double b;}; S1	2
double x2 =	1
double reflects the	1
double Z =	1
double x4 =	1
double Table[100]; int	2
double ipow (double	1
double log2 =	1
double b[SIZE][SIZE]) {	2
double precision: //	1
double A2 =	1
double x10 =	1
double x8 =	1
double Func2(double x)	1
double a[arraysize], b[arraysize],	1
double Func1(double) pure_function	1
double matrix[SIZE][SIZE]; transpose(matrix);	1
double IntegerPower (double	1
size is a	3
size is not	1
size is different	1
size is big	1
size is done	1
size is typically	1
size is relevant	1
size is handled	1
size is insufficient.	1
size a multiple	1
size of the	11
size of a	3
size of code	1
size of an	2
size of data	1
size of program	1
size of vector	1
size of all	2
size of each	5
size of 64	1
size of integers	1
size of vector,	2
size of abc	3
size of squares:	1
size of 64.	1
size to avoid	1
size and type	1
size and optimizing	1
size in the	1
size in order	1
size in cases	1
size for the	1
size that is	3
size that doesn't	1
size that fits	1
size are only	1
size can be	2
size // define	1
size = 100;	5
size = 256;	1
size = 16;	1
size = 1000;	2
size = 1024;	3
size or data	1
size if you	1
size by extending	1
size with a	1
size on AMD	1
size as vector	1
size as template	1
size may possibly	1
size have got	1
size when doing	1
size then add	1
size has higher	1
size only when	1
size other than	1
size should always	1
size array or	1
size cannot be	1
size often have	1
size arrays inside	1
size execution units.	1
size doesn't matter	1
size known at	1
size known before	1
size conversion //	1
size conversion often	1
size parameter is	2
size needed before	1
size divisible by	1
size comes only	1
size right from	1
size causes misses	2
size vector. The	1
size Time per	1
size (in bytes)	2
size Total kilobytes	1
size Alignd (	1
size (16 or	1
size matrices, clock	2
size grows by	1
size (typically 64)	1
size (4096). This	1
Intel and one	1
Intel and Gnu	2
Intel and Microsoft	1
Intel and PathScale	2
Intel and Gnu.	1
Intel and Gnu).	1
Intel The Intel	1
Intel or Microsoft	1
Intel or PathScale	1
Intel or PathScale.	1
Intel function library	1
Intel function libraries	2
Intel function libraries,	1
Intel compiler is	5
Intel compiler in	1
Intel compiler for	2
Intel compiler can	1
Intel compiler has	2
Intel compiler because	1
Intel compiler Intel	2
Intel compiler Windows	3
Intel compiler versions	1
Intel compiler Linux	2
Intel compiler works	1
Intel compiler allows	1
Intel compiler supports	1
Intel compiler reduced	1
Intel compiler includes	1
Intel compiler generates	1
Intel compiler .........................................................................	1
Intel compiler puts	1
Intel have similar	1
Intel vector class	1
Intel vector classes	1
Intel vector math	2
Intel vector classes):	1
Intel vector classes:	1
Intel CPU dispatcher	1
Intel CPU detection	1
Intel but is	1
Intel compilers and	1
Intel compilers for	2
Intel compilers can	1
Intel compilers have	1
Intel compilers has	1
Intel library function	1
Intel library functions	1
Intel C++ compiler	1
Intel C++ compilers.	1
Intel C++ compiler.	1
Intel C++ compiler,	2
Intel C++ Compiler	2
Intel before it	1
Intel libraries are	1
Intel libraries do	1
Intel short vector	1
Intel processors is	1
Intel processors are	1
Intel CPUs can	1
Intel CPUs have	1
Intel CPUs use	1
Intel CPUs cannot	1
Intel mechanism executes	1
Intel compilers. We	1
Intel processors. The	1
Intel processors. A	1
Intel processors. AMD	1
Intel processors. Details	1
Intel microprocessors are	1
Intel CPUs. It	1
Intel CPUs. New	1
Intel compiler. This	1
Intel compiler. Use	1
Intel math function	1
Intel Pentium 4.	1
Intel libraries. Supports	1
Intel header files	1
Intel compiler, then	1
Intel CPU. See	1
Intel Vector class,	1
Intel CPUs, not	1
Intel CPUs, but	1
Intel Math Kernel	1
Intel processor. The	1
Intel Borland Microsoft	1
Intel CodeGear Microsoft	1
Intel Performance Primitives	1
Intel Agner Available	1
Intel Core and	1
Intel Core 2	3
Intel SVML +	1
Intel SVML v.10.3	1
Intel SVML v.10.2	1
Intel Architecture Software	2
Intel CPUs: use	1
Intel Technology Journal	1
Intel VTune, for	1
Intel VTune and	1
Intel CPU’s. Another	1
Intel Atom processors,	1
pointer is the	1
pointer is in	1
pointer is an	1
pointer is then	1
pointer is 4	1
pointer is simply	2
pointer is used.	1
pointer is needed	1
pointer is aligned	1
pointer is deleted.	1
pointer is created,	1
pointer a =	1
pointer of a	1
pointer to the	9
pointer to a	6
pointer to an	1
pointer to one	2
pointer to its	1
pointer to another	1
pointer to it.	1
pointer and makes	1
pointer in an	1
pointer in member	2
pointer in assembly	1
pointer can be	3
pointer or a	3
pointer or member	1
pointer or const	1
pointer or reference	12
pointer or reference,	4
pointer or reference.	1
pointer it gets	1
pointer if else	1
pointer not aliased	1
pointer may be	1
pointer then you	1
pointer then its	1
pointer at initialization.	1
pointer has to	1
pointer has been	2
pointer has changed	1
pointer has changed.	1
pointer which is	1
pointer which does	1
pointer which initially	1
pointer set to	1
pointer takes up	1
pointer stored in	1
pointer type casting.	1
pointer does not	3
pointer (see page	1
pointer known in	1
pointer well before	1
pointer simply stores	1
pointer typically takes	1
pointer actually points	1
pointer points to	1
pointer points to.	1
pointer p has	1
pointer No runtime	1
pointer alignment and	1
pointer eax to	1
pointer aliasing is	1
pointer aliasing does	1
pointer aliasing (see	1
pointer aliasing (/Oa).	1
pointer aliasing /Oa	1
pointer arithmetic calculations	1
pointer follows a	1
pointer aliasing. The	1
pointer aliasing. See	1
pointer aliasing. __declspec(noalias)	1
pointer initially points	1
pointer aliasing" if	1
pointer aliasing" (if	1
pointer refers to.	1
pointer -fomit- frame-	1
pointer serves as	1
pointer conversions. It	1
pointer arithmetics and	1
b is a	2
b is an	3
b is floating	1
b is always	1
b is true	1
b is true,	1
b is guaranteed	1
b is 400	1
b to 0	2
b and c	5
b in a	1
b in example	1
b for (i	1
b are the	1
b are 32-bit	1
b are swapped	1
b can be	1
b = a	3
b = 0,	1
b = temp	1
b = (unsigned	1
b = 100,	1
b = LoadVector(bb	3
b = (a+1)	1
b = 6.0f;	1
b = 1.0E8,	1
b = lrint(d);	1
b = MultiplyBy<8>(10);	1
b = !a;	1
b if b	2
b with a	2
b with 1	1
b as a	1
b than to	1
b have other	1
b have been	1
b when a	1
b will be	1
b will both	1
b from single	1
b has to	1
b different so	1
b because of	1
b because b	1
b because their	1
b should be	1
b double precision:	1
b into a	1
b + c	2
b + 1	1
b + 1;	3
b + c;	3
b + a;	1
b + 2.0	1
b + 0.666666666666666666667;	1
b * b	2
b * c;	2
b * 5	1
b * c);	3
b * 2.5	1
b * 3.5;	1
b * 1.2;	2
b * 1.5f;	1
b * 5).	1
b * (1.	1
b * 1.2f;	1
b member by	1
b take the	1
b & 1	1
b through a	1
b / c;	1
b / 10;	1
b / 16;	1
b / c)	1
b / 1.2345;	1
b : c	2
b needs to	1
b && a	1
b > 0	2
b % c;	1
b % 10;	1
b % 16;	1
b ? a	2
b ? 1.5f	1
b overlap. You	1
b ---xx---- a<<b<<c=a<<(b+c)	1
b Bit vector	1
b memcpy(b, a,	1
into the code	2
into the data	1
into the program	1
into the vector	1
into the same	1
into the list	1
into the Microsoft	1
into the algorithm	2
into the right	2
into the least	1
into the executable	1
into the vector.	1
into the beginning	1
into the carry	1
into the pipeline	2
into the individual	1
into the technical	1
into the pipeline.	1
into the for-loop:	1
into a and	1
into a vector	4
into a class	2
into a single	6
into a container	2
into a separate	3
into a union	1
into a 128-bit	3
into a leaf	2
into a place	1
into an intermediate	1
into an STL	1
into an excessive	1
into an arbitrary	1
into an anonymous	1
into memory when	1
into memory even	1
into vector c:	4
into vector b:	4
into one of	2
into one if	1
into one by	2
into one thread.	1
into each thread.	1
into multiple threads	1
into multiple functions.	1
into multiple smaller	1
into multiple blocks	1
into multiple threads.	5
into multiple threads,	1
into two 64-bit	1
into two 128-bit	1
into C++ classes	1
into array static	4
into many small	1
into threads with	1
into small pieces	1
into classes or	1
into eight different	1
into memory. This	1
into memory. If	1
into separate threads	1
into three parts:	1
into smaller squares	1
into lines and	1
into registers. A	1
into account in	1
into account that	1
into account when	5
into ecx and	1
into vectors. A	1
into machine code	1
into force when	1
into projects made	1
into sub-vectors that	1
into sleep mode.	1
into groups of	1
into account. You	1
+ b than	1
+ b +	5
+ b *	1
+ 2 return	1
+ 2 :	2
+ 2 thenaandbcannot	1
+ c +	2
+ i; Here,	1
+ 1 is	1
+ 1; for	1
+ 1; }	6
+ 1; return	1
+ 1; x[1]	1
+ 1; 69	1
+ c; The	1
+ c; y	1
+ c; Here,	1
+ i, a);	3
+ 2; }	5
+ a; 72	1
+ b) +	1
+ d; //	1
+ d; This	1
+ d =	2
+ 2, b	2
+ f; The	1
+ 3; }	1
+ j *	1
+ 2) :	1
+ i); //	6
+ 1.; }	3
+ 1.; Eliminate	1
+ 1.; x.b	1
+ (c +	1
+ C; }	1
+ 1.0f; The	1
+ esp ;	1
+ esp ebx	1
+ esp ;alignby4	1
+ b;} };	1
+ 1.0f;} The	2
+ 1.0f;} 66	1
+ a. You	1
+ c*x +	2
+ b*x*x +	2
+ 2.0f; }	1
+ 2.0 /	1
+ 3.5; Here,	1
+ c) The	1
+ column; Do	1
+ A; double	1
+ 2;} int	1
+ B; for	1
+ a2*b1) /	1
+ (vector const	1
+ log(c[i]); //	1
+ e +	1
+ d); Now	1
+ list[j].c; }	1
+ FuncCol(i)) *	1
+ 0.666666666666666666667; This	1
+ i/2; }	1
+ d.y; Fortunately,	1
+ B*x +	1
+ a.x, y	1
+ b[i]; c[i]	1
+ r.b;} The	1
+ 0x3FF unsigned	1
+ 0x3FFF unsigned	1
+ two, b	1
+ sign(i) ;	1
+ 4.; };	1
+ a.y);} vector	1
+ a2/b2; Here	1
+ d.x; a.y	1
+ 2.; x.c	1
+ 0x7F unsigned	1
+ 100*16, and	1
+ 3.; x.d	1
+ ia32intrin.h _mm_exp_ps	1
+ c.x +	1
+ c.y +	1
+ p->b;} int	1
+ log(c[i]);. This	1
n.a. - a	6
n.a. - -	27
n.a. - x	3
n.a. - n.a.	6
n.a. - Table	1
n.a. - (a&b)|(a&c)	1
n.a. - a<<b<<c	1
n.a. - a+b+c	1
n.a. - andnot(a,a)	1
n.a. x -	3
n.a. x x	3
n.a. x n.a.	3
n.a. n.a. -	32
n.a. n.a. x	3
n.a. n.a. _MSC_VER	1
n.a. Floating point	1
n.a. -(-a) =	1
n.a. MS compiler	1
n.a. Constant folding	1
n.a. a-a =	1
n.a. x*x*x*x*x*x*x*x =	1
n.a. a+b =	1
n.a. _MSC_VER and	1
n.a. a*0 =	1
n.a. a*1 =	1
n.a. a+0 =	1
n.a. a*b+a*c =	1
n.a. !(a <	1
n.a. __unix__ __linux__	1
n.a. 1.00 0.25	1
n.a. 1.00 0.35	1
n.a. 2.23 0.95	1
n.a. (-a)*(-b) =	1
n.a. (a+b)+c =	1
n.a. a+a+a+a =	1
library is that	1
library is very	1
library is loaded	2
library is needed.	1
library is resolved	1
library of math	1
library and the	1
library and you	1
library and economize	1
library for a	1
library for Windows	1
library that is	1
library that has	1
library that takes	1
library that works	1
library that comes	1
library can be	4
library can change	1
library can emulate	1
library or a	1
library or API	1
library function will	1
library function from	1
library function which	1
library function calls.	1
library function 250	1
library function __intel_cpu_features_init()	1
library if possible.	1
library with the	2
library with a	2
library with CPU	1
library int level	2
library than in	1
library may be	1
library have functions	1
library will use	1
library then make	1
library at www.agner.org/optimize/asmlib.zip.	2
library at initialization.	1
library at www.agner.org/optimize/asmlib.zip	1
library has a	1
library has not	1
library has an	1
library has no	1
library has many	1
library has reduced	3
library has preprocessing	1
library because it	1
library functions than	1
library functions have	1
library functions then	1
library functions called	1
library functions often	1
library functions without	1
library functions like	1
library functions linked	1
library functions directly:	1
library other than	1
library which is	1
library Intel Agner	1
library into memory.	1
library makes it	1
library file and	1
library function. 12.2	1
library does not	1
library versions instead.	1
library through the	1
library functions. The	2
library functions. 9.4	1
library functions. Time-	1
library contains many	2
library contains optimized	1
library contains similar	1
library files are	1
library #include <stdio.h>	1
library made for	1
library function, and	1
library modules and	1
library functions, or	1
library (or at	1
library files. Use	1
library www.agner.org/optimize/asmlib.zip. The	1
library exp exp	1
library (*.dll or	2
library (STL) is	1
library (STL) if	1
library requiring the	1
library (DLL) which	1
library asmlib, which	1
library libircmt.lib. Function	1
library (SVML). This	1
library asmlib.. //	1
library (VML, MKL).	1
library libmmt.lib and	1
i is not	1
i is stored	1
i is outside	1
i is interpreted	1
i to float	1
i to unsigned	1
i to four	1
i to p	1
i and use	1
i and shifts	1
i in order	1
i can never	1
i = 0;	14
i = 0	1
i = s;	1
i = 18,	1
i by a	1
i by 2.	2
i with 100	1
i an unsigned	1
i will appear	1
i which can	1
i which will	1
i but i*12,	1
i into the	1
i + sign(i)	1
i * 9	1
i < 0	1
i < 100;	11
i < 2;	1
i < size;	11
i < n;	1
i < 256;	6
i < 1000;	1
i < 100.	2
i < 20;	2
i < rows;	2
i < NumberOfTests;	2
i < arraysize;	1
i < ArraySize;	1
i < list.Size();	1
i must be	1
i ; i	1
i += 2)	3
i += 4)	1
i += 8)	4
i += 16)	1
i / 3;	1
i > 0;	1
i instead of	1
i >= size	1
i >= 0;	1
i >= size)	1
i % 3;	1
i <= n;	1
i <= max)	1
i modulo 16.	1
float a =	1
float to int.	1
float and double	4
float and double.....................................................................................	1
float in this	1
float or int	2
float or double	6
float * DynamicArray	1
float 4 4	1
float 4 AVX2	1
float 8 AVX2	1
float register temp;	1
float rather than	1
float 32 4	1
float 32 8	1
float 32 16	1
float type holds	1
float a, b;	3
float a, b,	4
float 128 double	1
float uses 32	1
float 256 double	1
float conversion Conversion	1
float expressions Automatic	1
float instead of	1
float x; for	2
float x; *(int*)&x	1
float vectors SSE2	1
float a; int	2
float a; double	1
float a; bool	1
float conversions can	1
float b) {x	1
float sum =	2
float variable. Example:	1
float x, y;	1
float x, y,	1
float square (float	1
float f; int	7
float f; unsigned	1
float f; f=i;	1
float additions in	1
float xn =	1
float a[100]; int	2
float a[100]; float	2
float SomeFunction (int	1
float Register variables,	1
float a[size], b[size];	2
float a[size], b[size],	1
float parabola (float	3
float x2 =	1
float matrix[rows][columns]; int	3
float list[100]; memset(list,	1
float 140 a	1
float x4 =	1
float Exp(float x)	2
float nfac =	1
float list[size]; ...	1
float list[size], sum	1
float list[size], sum1	1
float Live range	1
float s0 =	1
float b[1000]; };	1
float b[1000]; F2(b);	1
float OneOrTwo5[2] =	1
float coef[16] =	1
float add_elements(__m128 const	1
float vectors) /arch:SSE	1
float lookup[2] =	1
float list[16]; int	1
float i2; for(i=0,i2=0;	1
float list[] =	1
float list[ARRAYSIZE]; if	1
multiple of the	8
multiple of 0x800	1
multiple // versions:	1
multiple function calls.	1
multiple code versions	1
multiple memory blocks	1
multiple memory blocks,	1
multiple data elements	1
multiple data structures	1
multiple CPU cores	3
multiple CPU cores.	1
multiple CPU cores:	1
multiple variables as	1
multiple operating systems.	1
multiple pointers to	1
multiple programming languages,	1
multiple dynamic libraries.	1
multiple bits in	1
multiple bits with	2
multiple times in	1
multiple CPUs or	3
multiple calculations in	2
multiple calculations simultaneously	1
multiple versions of	3
multiple versions for	3
multiple versions with	1
multiple versions should	1
multiple versions even	1
multiple processor cores.	1
multiple threads and	1
multiple threads in	1
multiple threads that	1
multiple threads are	1
multiple threads can	1
multiple threads on	1
multiple threads should	1
multiple threads must	1
multiple threads writing	1
multiple threads Parallelization	1
multiple functions. I	1
multiple values at	2
multiple smaller functions	1
multiple things at	1
multiple platforms or	1
multiple conditions in	1
multiple conditions using	1
multiple conditions enum	1
multiple overloaded operators	1
multiple purposes. All	1
multiple purposes. Floating	1
multiple cores are	1
multiple statements within	1
multiple blocks in	1
multiple parent classes	1
multiple instances that	1
multiple threads. The	2
multiple threads. There	1
multiple threads. Each	1
multiple threads. Out-of-order	1
multiple cores. 3.15	1
multiple inheritance by	1
multiple inheritance class	1
multiple inheritance where	1
multiple processes or	1
multiple processes because	1
multiple threads, but	2
multiple threads, while	1
multiple .cpp files	2
multiple .cpp modules	1
multiple cores, and	1
multiple versions. This	1
multiple layers and	1
multiple counters, as	1
multiple accumulators if	1
multiple applications, but	1
multiple processes. The	1
multiple configurations with	1
multiple versions, each	1
multiple streams with	1
multiple elements? If	1
multiple logically distinct	1
multiple inheritance, virtual	1
two and making	1
two = _mm_set1_epi16(2);	2
two or more	8
two or three	1
two then there	1
two data members	1
two different versions	1
two different types	2
two different registers.	1
two different kinds	1
two different implementations	2
two functions are	2
two other situations:	1
two integer parameters	1
two floating point	3
two double precision	1
two 64-bit operations	1
two array elements:	1
two clock cycles	1
two clock cycles.	1
two clock counts.	1
two 32-bit integers	1
two 32-bit integers,	1
two operating systems	1
two libraries It	1
two pointers of	1
two pointers requires	2
two simple expressions.	1
two instructions add	1
two times the	1
two times and	1
two versions of	2
two versions and	1
two threads in	2
two threads are	1
two threads with	1
two threads from	1
two threads where	1
two integers of	1
two integers are	1
two functions. The	1
two values is	1
two branches to	1
two induction variables	1
two induction variables:	1
two types of	1
two expressions for	1
two modules contiguous	1
two things to	1
two main principles	1
two positive floating	1
two gives the	1
two constants are	1
two constants can	1
two 128-bit vectors.	1
two 128-bit reads.	1
two kinds of	1
two loops would	1
two loops (except	1
two iterations in	1
two additions by	1
two additions with	1
two comparisons by	1
two comparisons i	1
two AND operations:	1
two ways. The	1
two ways. Switch	1
two loop-carried dependency	1
two jobs simultaneously.	1
two commonly used	1
two versions. A	1
two double. The	1
two books contain	1
two arrays, a	1
two elements: #define	1
two parentheses can	1
two (three on	1
two suggested improvements).	1
two decimals, for	1
two formulas in	1
two steps. All	1
two entries. This	1
two branches: one	1
two names, one	1
two 128- bit	1
two summation variables	1
two gives: //	1
object is not	2
object is no	1
object is so	1
object is accessed	2
object is large	1
object is allocated	1
object is copied	2
object is called,	1
object is treated	1
object is deleted	1
object is overwritten,	1
object is known.	1
object is accessed,	1
object is moved,	1
object of the	4
object of a	5
object of class	1
object of known	1
object to the	1
object to a	1
object to another.	1
object in the	1
object in case	1
object in its	1
object for the	1
object for (b	1
object that is	1
object that behaves	1
object that looses	1
object are called	1
object can be	3
object or library	1
object or array	1
object it points	1
object by *p	1
object with new	1
object on its	1
object as if	1
object x when	1
object then you	1
object It is	1
object has a	1
object has no	2
object because the	1
object which is	1
object should preferably	1
object static then	1
object where most	1
object takes no	1
object cannot be	1
object rather than	1
object without the	1
object without -fpic	1
object file format.	1
object file level,	1
object file disassembler.	1
object file level.	1
object file formats.	1
object does not	1
object must be	1
object compiled without	1
object doesn't need	1
object through a	2
object through this	1
object files and	1
object files from	1
object files need	1
object instead of	1
object after it	1
object made with	1
object p points	1
object defined inside	1
object oriented programming	6
object oriented programs	1
object file. This	2
object file. Use	1
object pointed to	2
object pointed to.	1
object separately if	1
object (except for	1
object belongs to	1
object owns. A	1
number is not	1
number is zero	1
number of function	1
number of different	1
number of CPU	1
number of cache	1
number of integer	1
number of floating	1
number of possible	3
number of clock	1
number of objects	5
number of variables	1
number of elements	13
number of registers	3
number of bits	1
number of available	1
number of times	2
number of arrays	1
number of calls	1
number of threads	1
number of branches	1
number of separate	1
number of points	1
number of unused	1
number of columns	4
number of lines	1
number of constants	1
number of rows	2
number of logical	2
number of cores	3
number of purposes	1
number of iterations	1
number of devices	1
number of vectors.	1
number of machine	1
number of bits.	2
number of branches.	1
number of context	2
number of physical	1
number of allocations	1
number of accumulators	1
number of dangers	1
number of iterations.	1
number of sources.	1
number of DLLs,	1
number of rows/columns	1
number of jumps,	1
number to the	1
number to be	1
number to an	1
number to reflect	1
number and sets	1
number and types	1
number in the	1
number by 2n	1
number when i	1
number when converted	1
number then we	1
number one in	1
number we get	1
number 16 in	1
number simply by	1
number 1. Number	1
number 2, etc.	1
number (e.g. with	1
number information. It	1
number 28. The	1
number 0x1C. There	1
number i. The	1
number (the instruction	1
number 6! The	1
number generators. In	1
static is removed	1
static to the	2
static and dynamic	2
static and global	1
static or by	1
static or global	2
static or inline.	1
static if they	1
static then it	1
static memory is	1
static memory to	4
static memory and	2
static memory can	1
static data is	1
static data are	1
static data area	1
static has a	1
static double p(double	4
static float list[]	1
static object defined	1
static static static	2
static static Assume	1
static where appropriate.	1
static version if	1
static variables if	1
static member function	3
static const int	2
static const double	1
static const float	3
static libraries (.lib	1
static part of	1
static arrays in	1
static arrays automatically	1
static inline int	3
static inline double	1
static inline float	1
static inline void	5
static inline __m128i	4
static inline T	1
static memory. If	1
static memory. Example:	1
static memory. Most	1
static keyword to	1
static keyword has	2
static keyword also	1
static char const	1
static data. 148	1
static linking is	4
static linking and	1
static linking for	1
static linking rather	1
static linking (e.g.	1
static storage Variables	1
static link library	1
static link libraries	2
static link libraries.	1
static here is	1
static variables. See	1
static Assume member	1
static library. A	1
static libraries. A	1
static buffer or	1
static declaration makes	1
static variables, floating	1
static library, except	1
static modifier will	1
static linking. A	1
static data, including	1
static if), but	1
static linking, as	1
static keyword: //	1
static keyword, for	1
64-bit code for	1
64-bit vector operations	1
64-bit instruction set	1
64-bit integer rather	1
64-bit integer calculations.	1
64-bit compilers are	1
64-bit double is	1
64-bit double 32	1
64-bit version is	1
64-bit version for	1
64-bit operating systems	2
64-bit operating systems.	1
64-bit code. However,	1
64-bit systems and	1
64-bit systems can	1
64-bit systems if	1
64-bit systems by	1
64-bit systems will	1
64-bit systems we	1
64-bit operations so	1
64-bit CPUs and	1
64-bit Windows and	2
64-bit Windows if	1
64-bit Windows may	1
64-bit Windows allows	2
64-bit Windows (See	1
64-bit execution units.	1
64-bit integers in	1
64-bit integers if	1
64-bit integers with	1
64-bit Linux is	1
64-bit Linux and	2
64-bit Linux as	1
64-bit Linux than	3
64-bit mode or	4
64-bit mode than	1
64-bit mode because	3
64-bit mode where	1
64-bit mode 8	1
64-bit mode Parameter	1
64-bit addresses for	1
64-bit shared object	1
64-bit shared objects	1
64-bit programs to	1
64-bit Mac OS	1
64-bit systems. The	2
64-bit systems. A	1
64-bit systems. It	1
64-bit systems. If	1
64-bit systems. Some	1
64-bit systems. Floating	1
64-bit systems. Applications	1
64-bit systems. 67	1
64-bit vectors then	1
64-bit Windows, the	1
64-bit Windows, Linux	1
64-bit Linux, the	1
64-bit Linux, BSD	1
64-bit Linux, BSD,	1
64-bit mode. A	1
64-bit mode. Therefore,	1
64-bit mode. Make	1
64-bit mode. 16-bit	1
64-bit mode. Much	1
64-bit Windows. The	2
64-bit Windows. In	1
64-bit Windows. Borland	1
64-bit device drivers	1
64-bit integers. The	1
64-bit integers. Many	1
64-bit systems, you	1
64-bit systems, there	1
64-bit integer, signed	1
64-bit mode, the	1
64-bit mode, as	1
64-bit Linux. Has	1
64-bit integers, as	1
64-bit integers, but	1
64-bit MMX to	1
64-bit versions. The	1
64-bit Windows). The	1
64-bit Linux: long	1
64-bit Linux: unsigned	1
64-bit double, then	1
64-bit Unix systems	1
64-bit software, but	1
64-bit systems). 28	1
64-bit extension to	1
there is a	13
there is an	4
there is more	2
there is only	3
there is other	2
there is no	24
there is often	1
there is always	1
there is simply	1
there is something	1
there is hardly	1
there is nothing	1
there is virtually	1
there are a	3
there are not	1
there are more	1
there are different	2
there are no	5
there are floating	1
there are two	2
there are many	6
there are objects	1
there are some	1
there are cases	1
there are specific	1
there are allocated	1
there are various	1
there are special	1
there are 100	1
there are 6	1
there are search	1
there are serious	1
there are disadvantages	1
there are inherent	1
there are smarter	2
there are wrapper	1
there may be	4
there when the	1
there will be	1
there between x	1
there was hardly	1
there is, in	1
C++ is an	1
C++ is also	1
C++ is supported	1
C++ is quite	1
C++ is Microsoft	1
C++ is chosen	1
C++ is fully	1
C++ is definitely	1
C++ and assembly	2
C++ and Fortran	1
C++ and Fortran.	1
C++ for several	1
C++ for doing	1
C++ or assembly	2
C++ as 'this'.	1
C++ compiler is	2
C++ compiler for	2
C++ compiler (parallel	1
C++ program that	1
C++ program are	1
C++ program (or	1
C++ has many	1
C++ but is	1
C++ should allow	1
C++ compilers to	2
C++ compilers and	6
C++ compilers The	2
C++ compilers are	1
C++ compilers have	2
C++ compilers allow	1
C++ compilers www.agner.org/	1
C++ compilers exist	1
C++ takes only	1
C++ so you	1
C++ way of	1
C++ faster than	1
C++ take more	1
C++ code. Compilers	1
C++ template feature	1
C++ template metaprogramming,	1
C++ file and	1
C++ programming language	1
C++ An optimization	1
C++ language is	2
C++ language also	1
C++ language elements	1
C++ language While	1
C++ language relates	1
C++ exception handling	1
C++ classes and	1
C++ program. This	1
C++ programs and	1
C++ implementation may	1
C++ compilers. The	1
C++ compilers. 2.5	1
C++ compilers. Wikipedia	1
C++ based on	1
C++ compiler. This	1
C++ syntax in	1
C++ syntax has	1
C++ v. 3.1,	1
C++ v. 4.1.0,	1
C++ v. 7.1-4,	1
C++ program, you	1
C++ compiler, which	1
C++ compiler, v.	1
C++ Compiler v.	2
C++ Compiler Documentation	1
C++ Compiler Documentation".	1
C++ casting operator	1
C++ Performance for	1
C++ programming, how	1
C++ programs. Writing	1
C++ projects can	1
C++ language, all	1
C++ constructs Most	1
C++ relates to	1
C++ constructs........................................................................ 26	1
C++ imple- mentations	1
C++ builder. Not	1
C++ 5.82 (Embarcadero/CodeGear/Borland	1
C++ builder Has	1
C++ language...................................................... 14	1
C++ Builder 5,	1
C++ Performance". www.open-	1
also the time	1
also the innermost	1
also a cache	1
also a possible	1
also a language	1
also a common	1
also a lookup	1
also a kind	1
also be a	2
also be an	1
also be used	5
also be advantageous	1
also be tested	1
also be predicted	1
also be vectorized	1
also be convenient	1
also be eliminated	1
also be considered.	1
also be huge).	1
also have a	2
also have an	1
also have fast	1
also time consuming,	1
also use vector	1
also when called	1
also has something	1
also has disadvantages:	2
also other advantages	1
also other details	1
also used in	1
also used for	1
also used when	1
also page 119).	1
also possible to	2
also very expensive.	1
also makes the	1
also makes various	1
also makes testing	1
also stored together	1
also stored near	3
also called from	1
also called shared	2
also called Single-Instruction-Multiple-Data	1
also 4 unused	1
also less safe.	1
also useful to	1
also useful in	1
also useful for	1
also available in	1
also available from	1
also work when	1
also works on	1
also likely to	1
also quite efficient,	1
also recommended to	1
also see emulated	1
also allows 256-bit	1
also look at	1
also 512 bits	1
also relevant to	1
also supports Linux	1
also find more	1
also costs in	1
also prevents the	1
also occur quite	1
also includes the	1
also discussed which	1
also situations where	1
also applies to	3
also available. Microsoft	1
also involves the	1
also eliminate i	1
also available, such	1
also deallocated in	1
also repeats 1000	1
also inconvenient to	1
also treated like	1
also deallocated. Failure	1
also proceed in	1
also third-party profilers	1
also treat non-Intel	1
also safer. It	1
also de-allocated. This	1
also work, 133	1
also included. Combining	1
also tends to	1
such a way	1
such a check	1
such a complicated	1
such a framework	2
such a feature	1
such a response	1
such a subexpression	1
such a case:	1
such a formalism.	1
such code is	1
such as the	3
such as a	2
such as function	1
such as cache	1
such as most	1
such as multiple	1
such as C++	1
such as many	1
such as 32-bit	1
such as simple	1
such as error	1
such as common	1
such as AMD	1
such as supported	1
such as string	1
such as dynamically	1
such as copying	1
such as e.g.	1
such as addition,	1
such as heavy	1
such as Gnu,	1
such as int,	1
such as list,	1
such as -(-a)	1
such as Taylor	1
such as DOS	1
such as logarithms	1
such as C#,	1
such as memcpy,	1
such as semaphores,	1
such as floppy	1
such as price,	1
such as logarithms,	2
such as Java,	1
such as sorting	1
such as sqrt	1
such as eliminating	1
such as spell-checking	1
such as GetPrivateProfileString	1
such as sorting,	1
such as strcpy,	1
such as VHDL	1
such as flush	1
such as pow,	1
such as email	1
such as <.	1
such as ReadB	1
such as gates,	1
such as AQtime,	1
such an object	1
such an application	1
such an assumption	1
such systems than	1
such processors requires	1
such small devices	1
such small devices,	1
such container classes.	1
such advantage in	1
such programs installed	1
such cases, you	1
such dependency chains	1
such methods only	1
such applications are	1
such runtime frameworks	1
such expressions may	1
such optimizations with	1
such optimizations automatically,	1
such feature will	1
such contentions is	1
such errors is	1
such errors in	2
such cases. The	1
such loops by	1
such checks makes	1
such devices typically	1
such applications. Alternatively,	1
such obvious reductions	1
such errors. See	1
such applications, but	1
such contrived examples	1
such checks. But	1
efficient the calculation	1
efficient to have	1
efficient to use	2
efficient to make	2
efficient to store	2
efficient to convert	1
efficient to allocate	1
efficient to define	1
efficient to implement	1
efficient to determine	1
efficient to re-use	1
efficient to pool	1
efficient and you	1
efficient and enables	1
efficient in 64-bit	3
efficient in some	2
efficient for such	1
efficient for simple	1
efficient if the	3
efficient if it	1
efficient if all	1
efficient code caching.	1
efficient as a	3
efficient as using	1
efficient as any	1
efficient as integers.	1
efficient than the	2
efficient than a	2
efficient than if	1
efficient than x	2
efficient than when	1
efficient than 64-bit	1
efficient than functions.	1
efficient than signed	1
efficient than frame	1
efficient than accessing	1
efficient than mov	1
efficient than comparing	1
efficient than necessary.	1
efficient than post-increment.	1
efficient than Sum2	1
efficient than relocation,	1
efficient than investing	1
efficient than non-object	1
efficient use of	1
efficient when the	1
efficient when b	1
efficient when there	1
efficient when arrays	1
efficient memory space	1
efficient vector operations	1
efficient because the	2
efficient because it	1
efficient because they	1
efficient because relative	1
efficient functions for	1
efficient loop control	1
efficient integer size	1
efficient library and	1
efficient way of	2
efficient way if	1
efficient (see page	1
efficient solution in	2
efficient solution for	1
efficient solution that	1
efficient solution may	1
efficient solution because	1
efficient container class	1
efficient container classes.	2
efficient whether the	1
efficient code, but	1
efficient solution. Is	2
efficient solution. Sort	1
efficient thanks to	1
efficient alternatives that	1
efficient today where	1
efficient because, in	1
efficient alternative. The	1
efficient table-based methods	1
In the same	1
In the case	4
In the cases	1
In the simple	1
In the Windows	1
In the above	2
In the preceding	1
In the future	1
In the latter	1
In a C++	1
In this example,	6
In this case	4
In this case,	1
In this manual,	1
In this chapter,	1
In other cases,	1
In other words,	4
In other programs,	1
In example 7.4	1
In example 8.21,	1
In example 12.2,	1
In example 12.1a,	1
In example 12.3a,	1
In most cases	2
In most cases,	5
In most systems,	1
In 64-bit systems	1
In 64-bit mode	1
In 64-bit Windows,	1
In 64-bit Linux,	1
In 64-bit systems,	2
In C++ template	1
In such cases,	1
In many cases	1
In many cases,	2
In any event,	1
In some cases	8
In some cases,	5
In some programs,	1
In order to	3
In 32-bit Linux	1
In these examples	1
In cases where	1
In simple cases,	1
In large arrays,	1
In Linux and	1
In difficult cases	1
In Windows, you	1
In general, the	1
In general, it	1
In general, you	3
In general, there	1
In C++, it	1
In 50 simple	1
In multithreaded applications	1
In fact, the	2
In fact, you	1
* x -	1
* x +	3
* b +	2
* 2 >	1
* const Greek[4]	1
* 4 =	1
* 8 =	1
* 32 with	1
* c >	1
* c; a	1
* c; Is16vec8	1
* x; //	1
* 2; //	1
* 2; }	2
* 2; return	2
* 5 *	1
* 5 /	1
* p =	1
* 100 *	1
* temp; c	1
* temp; 104	1
* CriticalFunction =	1
* 3; }	2
* 3; return	2
* p) {	7
* p) {return	1
* __restrict aa,	1
* __restrict bb)	1
* 2) {	1
* c); //	2
* c); a.store(aa+i);	1
* d, __m128i	4
* 9 +	1
* SelectAddMul_pointer =	1
* reciprocal_divisor; y2	1
* reciprocal_divisor; 14.7	1
* 2.5 may	1
* (2n /	1
* CriticalFunctionDispatch(void) {	1
* CriticalFunctionDispatch(void) __asm__	1
* p; int	1
* p; p	1
* 3.5; c	1
* 1.2; //	2
* (columns *	1
* Func1(x) +	1
* m;} int	1
* m;} template	1
* b2); y1	1
* p1; p1	1
* powN<true,N/2>::p(x); }	1
* cc[i]); }	1
* c[i]); }	1
* powN<true,N-N1>::p(x); #undef	1
* sizeof(float)); //	1
* sizeof(float)). Now,	1
* a;} float	1
* _mm_load_ps(coef+i); //	1
* 17is calculated	1
* 1.5f; is	1
* 16is calculated	1
* 5; to	1
* b2 *	1
* b1 *	1
* (a+1); c	1
* 5). As	1
* sizeof(float)) =	1
* dest, double	1
* sizeof(float) in	1
* DynamicArray =	1
* (1. /	1
* x2; //	1
* 0.5 ns	1
* p2; p2	1
* 1.2f; //	1
* 2.5; //	1
There is a	10
There is an	2
There is no	24
There is very	1
There is nothing	1
There are a	3
There are only	1
There are other	2
There are no	2
There are two	5
There are also	5
There are so	1
There are several	6
There are four	1
There are eight	1
There are certain	2
There are cases,	1
There are intrinsic	1
There are various	10
There are three	2
There are approximately	1
There are situations	1
There are lots	1
There are hundreds	1
There may be	5
There may also	1
There will be	1
There should of	1
There should be	1
array is the	1
array is a	1
array is not	1
array is less	1
array is implemented	1
array is made	1
array is stored.	1
array is defined.	1
array a and	1
array of structure	1
array of n	1
array of 100	1
array of thousand	1
array of structures:	1
array to make	1
array to all	1
array to zero.	1
array and for	1
array for the	1
array for multiple	1
array can be	3
array can cause	1
array or the	1
array or object	1
array or container	2
array or setting	1
array with a	1
array with bounds	1
array with alloca:	1
array may need	1
array will be	1
array should be	2
array using the	1
array size a	1
array size right	1
array pointer eax	1
array into a	1
array static inline	8
array elements of	1
array elements more	1
array elements then	1
array elements Induction	1
array before calling	1
array address is.	1
array rather than	1
array must begin	1
array ; jump	1
array ; i++	1
array element is	1
array element in	1
array element if	1
array element }	1
array element has	1
array element a[i]	1
array overflow can	1
array after all	1
array index is	2
array index than	1
array index then	1
array index operator	1
array initialized by	1
array bounds is	1
array bounds violations,	1
array bounds violations	1
array bounds violation,	1
array sizes and	1
array cout <<	1
array element. In	1
array element. Matrix	1
array element. Rather	1
array elements. The	1
array elements. Example:	1
array index. The	1
array sequentially. Some	1
array elements: #define	1
array indices when	1
array grows during	1
array i) {	1
array 800 bytes	1
array initializer lists,	1
array coincides with	1
where the function	1
where the compiler	2
where the data	1
where the same	1
where the loop	1
where the size	2
where the object	1
where the number	3
where the performance	1
where the critical	1
where the type	1
where the parameters	1
where the dispatch	1
where the storage	1
where the main	1
where the network	1
where the level-1	1
where the chosen	1
where the logic	1
where the parallelism	2
where the carry	1
where the compilation	1
where the reduction	1
where the combined	1
where the obstacles	1
where is the	1
where a program	2
where a vector	1
where a long	1
where a much	1
where a hardware	1
where a particular	1
where a high	1
where a #define	1
where a task	1
where a soft	1
where it is	5
where it should	1
where it makes	1
where it still	1
where it expects	1
where it matters:	1
where code caching	1
where you can	1
where you want	2
where data members	1
where only few	1
where one thread	1
where cache size	1
where each bit	1
where each calculation	1
where each addition	1
where each iteration	1
where each label	1
where most of	1
where static has	1
where there is	1
where there are	1
where we are	1
where template metaprogramming	1
where they are	1
where they cannot	1
where dynamic linking	1
where instructions are	1
where execution speed,	1
where necessary (see	1
where speed is	2
where automatic vectorization	1
where n is	1
where r is	1
where 10 elements	1
where operands have	1
where N is	1
where RAM memory	1
where current compilers	1
where everything happens	1
where almost the	1
where security matters.	1
where necessary. Fast	1
where pre-increment is	1
where appropriate. Compiler-specific	1
many of the	4
many of these	1
many function calls	1
many function calls.	1
many function calls,	1
many different cases	1
many different CPUs	1
many different purposes.	2
many different factors	1
many different applications.	1
many different places).	1
many functions for	3
many functions scattered	1
many such programs	1
many objects can	1
many objects together	1
many variables and	1
many software products	1
many branch mispredictions.	1
many elements are	1
many bit manipulation	1
many optimization features	1
many useful mathematical	1
many file input/output	1
many cases it	1
many cases where	1
many times the	2
many times in	1
many times with	1
many times an	1
many times one	1
many times each	2
many times faster	1
many calls and	1
many common programs	1
many common purposes	1
many small dynamically	1
many small subtasks,	1
many good optimization	1
many standard container	1
many standard tasks	1
many files to	1
many programs use	1
many cases, the	1
many cases, however,	1
many branches and	1
many branches or	1
many Boolean expressions.	1
many applications even	1
many examples of	1
many advantages when	1
many advanced optimizing	1
many reductions involving	1
many computer users	1
many cases. For	1
many cases. Integer	1
many unknown factors	1
many programmers and	1
many programmers do	1
many processors, a	1
many hard working	1
many instances makes	1
many rules of	1
many users in	1
many users will	1
many branches. If	1
many processes simultaneously.	1
many platforms, including	1
many features, but	1
many features, see	1
many commercial compilers	1
many years to	1
many keywords and	1
many labels that	1
many allocations of	1
many users. Firewalls,	1
many branches): if	2
many respects and	1
many tips on	1
many renamed instances	1
many encryption algorithms,	1
many decimals. It	1
many people who	1
many strings. In	1
possible to use	3
possible to make	6
possible to do	8
possible to access	1
possible to avoid	1
possible to compile	2
possible to get	1
possible to calculate	1
possible to add	1
possible to store	2
possible to write	1
possible to replace	3
possible to see	2
possible to give	1
possible to improve	1
possible to reduce	1
possible to start	1
possible to tell	1
possible to insert	2
possible to come	1
possible to implement	2
possible to contain	1
possible to vectorize	1
possible to select	1
possible to obtain	2
possible to utilize	1
possible to construct	1
possible to distribute	1
possible to organize	1
possible to express	1
possible and by	1
possible in some	1
possible in Linux).	1
possible for the	3
possible for usability	1
possible or when	1
possible if the	2
possible if F1	1
possible on Linux	1
possible when parts	1
possible memory requirement.	1
possible at compile	1
possible vector objects	1
possible because the	1
possible only if	1
possible instruction set	1
possible point of	1
possible pointer aliasing	1
possible into the	1
possible version of	1
possible branch if	1
possible user interface	1
possible access to	1
possible case and	1
possible cases of	1
possible exception handling	1
possible overflow on	1
possible implementation if	1
possible ways of	1
possible negative value	1
possible performance. We	1
possible version. See	1
possible inputs is	1
possible alternatives to	1
possible minor increase	1
possible inputs. Let's	1
possible workaround. Supports	1
possible remedies against	1
clock = __rdtsc();	1
clock by using	1
clock cycles to	3
clock cycles in	1
clock cycles for	1
clock cycles that	1
clock cycles if	2
clock cycles on	2
clock cycles than	1
clock cycles more	2
clock cycles then	1
clock cycles at	1
clock cycles before	1
clock cycles rather	1
clock cycles even	1
clock cycles counter	1
clock cycles after	2
clock cycles later	1
clock cycles per	5
clock cycles whenever	1
clock cycles spent	1
clock cycles (depending	1
clock count before	1
clock cycles. The	3
clock cycles. It	1
clock cycles. If	1
clock cycles. In	1
clock cycles. You	2
clock cycles. But	1
clock cycles. Floating	1
clock cycles. Obviously,	1
clock cycles. Division	1
clock cycles. Calculations	1
clock frequency is	4
clock frequency of	1
clock frequency that	1
clock frequency than	1
clock frequency may	2
clock frequency goes	1
clock frequency dynamically	1
clock frequency (in	1
clock counts that	1
clock counts are	1
clock counts should	1
clock cycle is	3
clock cycle if	1
clock cycle on	3
clock cycle counter	2
clock cycles, then	2
clock cycles, but	1
clock cycles, depending	5
clock cycle. The	3
clock cycle. This	1
clock cycle. In	1
clock counts. The	1
clock frequency. The	1
clock frequency. For	1
clock cycle? In	1
clock cycle? ......................................................................................	1
clock frequency, as	1
clock pulses since	1
clock cycles). Floating	1
clock period and	1
version is implemented	2
version is better	1
version is preferred	1
version is currently	1
version of the	26
version of a	3
version of most	1
version of object	1
version of C++	1
version of Intel's	1
version of Basic	2
version of Mathcad	1
version to use	1
version and a	1
version in a	1
version in main	1
version for the	1
version for CPUs	1
version for best	1
version for specific	1
version for marketing	1
version that is	1
version that takes	1
version that works	1
version that fits	1
version that performs	1
version // Get	1
version if speed	1
version with all	1
version with full	1
version on the	1
version on all	1
version int CriticalFunction_386(int	2
version int CriticalFunction_SSE2(int	2
version int CriticalFunction_AVX(int	1
version because the	1
version return &CriticalFunction_386;	1
version return (*SelectAddMul_pointer)(aa,	2
version return (*CriticalFunction)(parm1,	1
version without the	1
version void FUNCNAME(short	1
version control tool.	1
version causes problem	1
version CriticalFunction =	1
version changes then	1
version 127 int	1
version on, then	2
version performs well.	1
version performs poorly.	1
version CriticalFunctionType *	1
version (May use	2
version FuncType *	1
version FuncType SelectAddMul,	1
version 2.11 ifunc	1
version 2.20 or	1
version satisfies the	1
version 2.20, glibc	1
version 2.6.30 and	1
value is less	1
value is calculated	2
value is zero	1
value is poorly	1
value is already	1
value is multiplied	1
value of the	16
value of a	2
value of A	1
value of b	1
value of i	4
value of register	1
value of temp	1
value of sum	1
value of N	1
value of ebx	1
value of seconds	1
value of n!	1
value of ebx.	1
value of m	1
value of b+c	1
value of cc[i]+2	1
value of i&15	1
value of temp.	1
value of sum.	1
value to make	1
value and write	1
value in the	2
value in one	1
value in most	1
value in edx	1
value in stdint.h	1
value that is	5
value that lies	1
value it was	1
value by setting	1
value as xn	1
value as n!	1
value than from	1
value than 0	3
value will propagate	1
value from the	2
value from a	2
value from memory	1
value at compile	1
value has changed	1
value each time	1
value before the	1
value 0 for	1
value 10 *	1
value depends on	1
value depends only	1
value maximum value	1
value pointed to	2
value xn is	1
value wrap around.	1
value written as	1
value 1000. The	1
value -100+100+100 =	1
value infinity, and	1
value 0x2C so	1
objects is not	1
objects is often	1
objects is known	1
objects is high	1
objects of a	1
objects of different	3
objects of variable	1
objects to a	1
objects and is	1
objects and arrays	1
objects and keep	1
objects and fixed	1
objects in the	2
objects in a	1
objects in 64	1
objects in 32	1
objects in Mac	1
objects in computer	2
objects in Linux,	1
objects in BSD	2
objects in Unix-like	2
objects for intermediate	1
objects that are	1
objects that take	1
objects are not	3
objects are also	1
objects are stored	1
objects are accessed	3
objects are called.	1
objects are instances	1
objects are returned	1
objects are identified	1
objects are normally	1
objects are aligned.	1
objects can be	4
objects can often	1
objects // Roll	1
objects if no	1
objects with each	1
objects on the	1
objects as function	1
objects have a	1
objects have been	3
objects have mixed	1
objects will be	1
objects should preferably	3
objects stored in	3
objects stored are	1
objects they point	1
objects they contain	1
objects without position-independent	1
objects even when	1
objects accessed in	2
objects inside the	1
objects together in	1
objects together into	1
objects declared in	2
objects declared inside	2
objects come last	1
objects share the	1
objects Conversions involving	1
objects simultaneously. In	1
objects identified by	1
objects Vec8s a,	1
objects (memory pooling)	1
objects (*.dll, *.so).	2
objects numbered consecutively?	1
objects (rather than	1
takes the hint	1
takes a very	1
takes a long	2
takes a few	1
takes a considerable	1
takes to make	2
takes to do	2
takes to call	3
takes to calculate	3
takes to add	1
takes to load	1
takes to start	1
takes to execute	2
takes to transpose	1
takes to install	2
takes to recover	1
takes to reload	2
takes to develop	2
takes to refresh	1
takes time to	1
takes more time	4
takes more memory	1
takes memory space.	1
takes memory space,	1
takes only a	1
takes only slightly	2
takes only 2-3	1
takes one clock	1
takes no more	1
takes no extra	4
takes some experience	1
takes between 2	1
takes before the	1
takes 4 -	2
takes 8 bytes	1
takes time. Dispatch	1
takes up more	1
takes up one	1
takes extra time.	1
takes extra time,	1
takes much more	2
takes much longer	3
takes advantage of	1
takes typically 0	1
takes zero or	1
takes too long	1
takes too much	1
takes longer time	3
takes longer time.	1
takes 10 clock	1
takes 10 μs	1
takes 5 clock	2
takes little space	1
takes 3 -	1
takes care of	3
takes 14 -	1
takes six times	1
takes 11 clock	1
takes 50 -	1
takes 40 -	1
takes 40 clock	1
takes 40% more	1
takes hours to	1
variable is the	1
variable is only	1
variable is stored	2
variable is accessed	2
variable is used.	1
variable is never	2
variable is declared.	1
variable to be	1
variable in the	3
variable in a	2
variable in memory	1
variable in example	1
variable in many	1
variable in main	1
variable in memory,	1
variable in eax.	1
variable in parts,	1
variable for test	1
variable for accessing	1
variable that is	1
variable that r	1
variable that could	1
variable can be	3
variable or object	3
variable or replace	1
variable if their	1
variable by a	1
variable with the	1
variable as function	1
variable as an	1
variable as loop	1
variable from address	1
variable from RAM	1
variable at the	1
variable because it	1
variable because optimizing	1
variable which is	1
variable size can	1
variable two names,	1
variable number of	2
variable where it	1
variable cannot be	1
variable even smaller	1
variable method unfavorable,	1
variable always has	1
variable through a	1
variable inside the	1
variable would be	1
variable unless the	1
variable members of	1
variable means that	2
variable storage are	1
variable storage Variables	1
variable global if	1
variable size. The	1
variable outside the	1
variable until the	1
variable names from	1
variable declaration to	1
variable pointed to	2
variable names. Remember	1
variable produces a	2
variable lengths that	1
variable Y //	1
variable Z }	1
variable having the	1
variable whose address	1
variable Day. Note	1
variable storage............................................................................. 26	1
variable __intel_cpu_feature_indicator where	1
variable __intel_cpu_feature_indicator_x. You	1
variable 85 ;	1
variable m. The	1
variable (eax) which	1
any of the	5
any of these	3
any function are	1
any function or	1
any code branch	1
any use of	1
any memory block	1
any other function	1
any other value	1
any other member	1
any other address	1
any other error	1
any other function.	1
any other module	1
any other number.	1
any other form	1
any other cleanup	1
any other factor.	1
any other modules.	2
any other module.	1
any other resource,	1
any other constructors.	1
any cache lines	1
any floating point	2
any size other	1
any pointer or	2
any library functions	1
any objects if	1
any objects declared	1
any performance penalty	1
any branch misprediction	1
any member functions	1
any elements in	1
any call to	1
any part of	1
any type of	1
any function. Global	1
any extra code	2
any extra code.	3
any extra time.	1
any processor that	1
any necessary destructors	1
any speed advantage	1
any specific calling	1
any specific recommendation	1
any specific model.	1
any exception so	1
any option that	1
any known hardware	1
any cost in	1
any public variables.	1
any higher instruction	1
any hot spots	1
any particularly slow	1
any algorithm with	1
any effect on	1
any time, then	1
any algebraic reductions	1
any situation where	1
any non-static data	2
any non-static access.	1
any brand of	1
any brand name	1
any compile-time constant	1
any loss of	1
any constructors are	1
any assumption about	1
any non-polymorphic member	1
any expression, but	1
any function) should	1
any answer. Beginners	1
any transition from	1
any non-vector library.	1
any event, the	1
any patch. 131	1
we are in	1
we are using	2
we are running	1
we are writing	1
we are adding	1
we are reading	1
we are waiting	1
we are converting	1
we are swapping	1
we are assuming	1
we are seeing	1
we are breaking	1
we are relying	1
we can use	1
we can do	1
we can access	1
we can avoid	1
we can calculate	1
we can store	1
we can handle	1
we can define	1
we can help	1
we can eliminate	1
we can see,	1
we can roughly	1
we can surely	1
we can learn	1
we may also	1
we may need	1
we may choose	1
we may save	1
we may write:	1
we have a	1
we have to	1
we have an	1
we have (set)	1
we have inserted	1
we use hexadecimal	1
we will not	1
we will have	1
we will calculate	1
we will consider	1
we used above	1
we should preferably	1
we do not	2
we do have	1
we need the	1
we need to	2
we need metaprogramming.	1
we want to	4
we want it	1
we must consider	1
we compile the	1
we get 0	1
we get rid	1
we would have	1
we add a	1
we don't have	3
we don't need	1
we don't get	1
we end up	1
we read from	1
we assume is	1
we assume that	1
we know that	1
we change the	1
we still want	1
we expect to	1
we modify example	1
we try to	1
we notice is	2
we roll out	1
we specify the	1
we prefer a	1
we forgot to	1
we loose the	1
we encounter another	1
we have: //	1
we reach element	1
some of the	7
some of these	1
some more vector	1
some other functions	1
some other variable	1
some compilers will	1
some compilers unroll	1
some very good	1
some very old	1
some long vector	1
some operating systems	1
some systems because	1
some cases the	2
some cases to	1
some cases and	1
some cases be	2
some cases it	4
some cases on	1
some cases you	1
some cases this	1
some cases take	1
some cases even	1
some cases ignore	1
some processors that	1
some extra complications.	1
some calculations at	1
some small low-power	1
some support for	1
some information for	1
some cases, the	2
some cases, for	1
some cases, it	1
some cases, but	1
some cases, there	3
some expression is	1
some development tools	1
some systems. If	1
some types of	1
some compilers. If	1
some processors. On	1
some microprocessors when	1
some microprocessors have.	1
some things very	1
some positive value,	1
some syntax checking	1
some cases. An	1
some cases. Multiple	1
some cases. Does	1
some programmers use	1
some help if	1
some typical sources	1
some heavy work	1
some disadvantages that	1
some changes for	1
some measurements to	1
some embedded systems.	1
some CPU-intensive applications	1
some tests with	1
some programs, more	1
some formula into	1
some experience to	1
some differences due	1
some funny things	1
some legacy software.	1
some tips on	1
some caveats. We	1
some situations, and	1
some links. 20	1
some indication of	1
some day be	1
some examples: strlen	1
some rare cases	1
so the compiler	1
so the floating	1
so the value	1
so the misprediction	1
so is a	1
so is also	1
so a cache	1
so in a	1
so that the	14
so that it	13
so that you	2
so that only	1
so that one	1
so that each	2
so that there	1
so that we	4
so that they	2
so that a+b	1
so it can	1
so as to	1
so you can	1
so you will	1
so you need	1
so this feature	1
so will cause	1
so there may	1
so many different	1
so many unknown	1
so we can	2
so we don't	2
so long that	1
so important and	1
so large that	1
so big that	2
so much stronger	1
so small that	2
so fast that	2
so unless you	1
so complicated that	1
so high that	3
so expensive that	1
so (i.e. if	1
so on. 7.31	1
so kludgy that	1
so 1.2 in	1
so complicated? Because	1
variables is so	1
variables is eight	1
variables is approximately	1
variables to be	2
variables to calculate	1
variables to zero	1
variables and objects	5
variables and therefore	1
variables and operators	3
variables and internal	1
variables and operators...............................................................................	1
variables in the	2
variables in a	4
variables in memory	1
variables in order	1
variables in 32-bit	2
variables in registers	1
variables The most	1
variables for the	1
variables for other	1
variables for floating	1
variables for float	1
variables for array	1
variables for calculating	1
variables that are	3
variables that may	2
variables that count	1
variables are stored	3
variables are often	1
variables are temporary	1
variables are stored.	1
variables are overdetermined	2
variables can be	2
variables can also	1
variables or hide	1
variables if possible,	1
variables by using	1
variables as long	1
variables as input	2
variables than if	1
variables may be	1
variables have one	1
variables use a	1
variables will be	1
variables because of	1
variables do not	1
variables into a	1
variables const double	1
variables called global	1
variables (see below).	1
variables An expression	1
variables declared with	1
variables Floating point	1
variables go through	1
variables global if	1
variables defined outside	1
variables might have	1
variables happen to	1
variables (i.e. variables	1
variables sum1 and	1
variables Compilers cannot	1
variables Y and	1
variables ......................... 142	1
return the result	1
return a -	2
return a pointer	2
return a +	5
return a *	1
return a >	1
return to its	1
return and parameter	1
return with an	1
return an error	1
return x *	4
return from the	1
return from functions	1
return from Func	1
return value depends	1
return any pointer	1
return address of	1
return 0; //	1
return 0; }	2
return operations with	1
return 0 if	1
return type of	1
return ; align	1
return addresses to	1
return addresses (i.e.	1
return y =	1
return c; }	1
return types The	1
return types ..............................................................................................	1
return x; }	1
return f; }	1
return y; }	1
return value. The	1
return 1.0; }	1
return a[i]; //	1
return _mm_loadu_si128((__m128i const*)p);	2
return _mm_loadu_si128((__m128i const*)p);}	1
return sum; }	1
return clock; }	1
return &CriticalFunction_386; }	1
return x^10 //	1
return &CriticalFunction_SSE2; }	1
return (*SelectAddMul_pointer)(aa, bb,	2
return Func1(x) *	1
return &CriticalFunction_AVX; }	1
return pow(x,10); }	1
return x10; }	1
return (2.5f *	1
return IntegerPower<10>(x); }	1
return powN<(N &	1
return x*x +	1
return n;} This	1
return ipow(x,10); //	1
return (*CriticalFunction)(parm1, parm2);	1
return powN<(N1&(N1-1))==0,N1>::p(x) *	1
return powN<true,N/2>::p(x) *	1
return _mm_load_si128((__m128i const*)p);	1
return square(x) +	1
return _mm_cvtss_si32(_mm_load_ss(&x));} static	1
return list[x]; }	1
return a+1;. The	1
return add_elements(s); //	1
return N; }	1
return _mm_cvtss_f32(s); }	1
return FactorialTable[n]; //	1
return prediction). 149	1
return route. This	1
return vector(x +	1
return statement: //	1
return _mm_cvtsd_si32(_mm_load_sd(&x));} The	1
return *(T*)0; }	1
2 is faster	1
2 to x	1
2 to each	2
2 and the	1
2 and 15	1
2 in example	2
2 in order	1
2 can be	1
2 // make	1
2 // Still	2
2 or not.	1
2 if the	4
2 if a	1
2 if possible	1
2 by using	1
2 by putting	1
2 - n.a.	1
2 int unsigned	1
2 when multiplying	1
2 then the	2
2 then N&(N-1)	1
2 double Intel	1
2 In 64-bit	1
2 * 5;	1
2 clock cycles	1
2 return (2.5f	1
2 return powN<(N	1
2 2 int	1
2 2 int,	1
2 64 MMX	1
2 template <int	1
2 32 8	1
2 does not	2
2 ; add	1
2 128 SSE2	2
2 : b	2
2 Integer division	1
2 > v.i	1
2 AVX2 _mm256_i64gather_pd	1
2 AVX2 _mm256_i64gather_epi32	1
2 #define FUNCNAME	1
2 unused bytes	1
2 == 0)	1
2 (See page	2
2 bytes. first	2
2 applies only	1
2 int64_t 128	1
2 (i.e. 2,	1
2 int, signed	1
2 Choosing the	2
2 63 .	1
2 uint64_t 128	1
2 0.12 0.18	1
2 23 ,	1
2 13.4 Test	1
2 GHz then	1
2 GHz CPU.	1
2 a+a+a+a=a*4 -(-a)=a	1
2 12.6 Transforming	1
2 52 ,	1
2 thenaandbcannot use	1
2 Gbytes. This	1
2 gigabytes of	1
2 Mbytes. There	1
2 0.77 0.89	1
2 (be aware	1
2 GB, but	1
2 GB. When	1
2 0.63 0.75	1
You can use	2
You can take	2
You can avoid	3
You can check	1
You can calculate	1
You can assume	2
You can improve	2
You can change	1
You can save	1
You can divide	1
You can generally	1
You can disable	2
You can force	1
You can bypass	1
You can subtract	1
You may have	1
You may use	5
You may make	2
You may need	1
You may even	1
You may avoid	2
You may add	2
You may write	1
You may replace	1
You may preferably	1
You may look	1
You may choose	5
You may save	1
You may insert	1
You may remove	1
You may declare	1
You may prefer	1
You may think	1
You may mirror	1
You may ignore	1
You may skip	1
You may deviate	1
You have to	6
You will not	1
You should be	1
You should use	2
You should avoid	1
You should therefore	2
You cannot be	1
You cannot use	1
You cannot avoid	1
You cannot replace	1
You cannot assume	1
You cannot rely	1
You cannot expect	3
You cannot swap	1
You need to	1
You can't have	1
You may, in	1
table is not	1
table is used	1
table is advantageous	1
table is initialized	1
table is cached.	1
table of const	1
table of pointers	3
table of constants	1
table of jump	1
table of coefficients	1
table of 1/n!	1
table to be	1
table to stack	1
table to see	1
table and possibly	1
table in the	2
table in static	1
table The following	1
table for even	1
table that is	1
table are core	1
table can give	1
table can improve	1
table // of	2
table or a	1
table if you	1
table by 16	1
table with two	1
table may be	1
table may go	1
table from static	1
table at runtime,	1
table has const	1
table should be	1
table takes extra	1
table before the	1
table element Instruction	1
table inside a	1
table values by	1
table lookup is	2
table lookup for	1
table lookup can	1
table lookup or	1
table lookup if	1
table lookup at	1
table lookup operations	1
table lookup Using	1
table lookup Lookup	1
table lookup mechanisms	1
table instead of	1
table shows that	1
table shows whether	1
table 19 in	1
table lists the	1
table 8.1 below.	1
table 9.3 shows,	1
table lookups are	1
table lookup. For	1
table lookup. These	1
table lookup. Lookup	1
table (PLT) and	1
table (PLT) in	1
table (PLT) that	1
table 9.1 show	1
table static. This	1
table lookup: //	2
table increases the	1
table 8.1. The	1
table (PLT). The	1
table (PLT). And	1
table 9.2. All	1
table (GOT). These	1
table (GOT) in	1
table summarizes the	1
table 9.2, such	1
performance is to	1
performance is not	1
performance is important	1
performance is limited	1
performance is obtained	3
performance is inferior	1
performance of the	3
performance of a	1
performance of this	1
performance of different	1
performance of two	1
performance of competing	1
performance and precision.	1
performance and studying	1
performance in some	1
performance for the	1
performance for vector	1
performance for many	1
performance for 32-bit	1
performance for background	1
performance that can	1
performance can be	1
performance can easily	1
performance if the	2
performance by unit-testing	1
performance by organizing	1
performance by 5-10%	1
performance on CPUs	1
performance on AMD	1
performance on non-Intel	3
performance then there	1
performance has high	1
performance because the	2
performance because they	1
performance should be	1
performance between the	1
performance between 32-bit	1
performance test that	1
performance test should	1
performance even matters,	1
performance cost to	1
performance costs to	1
performance counters inside	1
performance during the	1
performance monitor counter	2
performance monitor counters	7
performance monitor counters.	2
performance under the	1
performance penalty to	1
performance penalty for	2
performance penalty when	1
performance problems. The	1
performance problems. Avoid	1
performance over other	1
performance reasons. Use	1
performance options. I	1
performance measurement should	1
performance tests are	1
performance significantly simply	1
performance dramatically by	1
performance bottlenecks is	1
performance monitoring options.	1
performance somewhat. The	1
performance costs. The	1
very time consuming.	1
very different speeds.	1
very efficient because	1
very efficient way	1
very efficient solution	1
very long and	2
very long on	1
very long time	1
very often underestimate	1
very user friendly	1
very useful to	1
very useful for	2
very useful when	1
very useful way	1
very important to	2
very important for	1
very large or	1
very large data	1
very large number	1
very large shared	1
very large runtime	1
very large positive	1
very large libraries.	1
very big to	1
very big in	1
very big data	1
very big problem	1
very much on	1
very small or	1
very small loops	1
very good at	1
very good compilers	1
very good performance	1
very good choice	1
very few restrictions	1
very likely to	1
very likely that	1
very well spend	1
very fast if	1
very high resolution	1
very efficient. The	1
very difficult to	1
very old DOS	1
very inefficient if	1
very inefficient because	1
very inefficient way.	1
very inefficient solution.	1
very little overhead	1
very smart and	1
very well. This	1
very similar thanks	1
very low repeat	1
very inefficient. Linear	1
very time-consuming function	1
very time-consuming tasks	1
very time-consuming garbage	1
very fast. The	1
very fast. This	1
very fast. All	1
very fast. Simple	1
very expensive cache	1
very dramatic effect	1
very expensive. A	2
very time- consuming.	1
very limited. There	1
very big. In	1
very problematic because	1
very contrived example,	1
very obscure possibility	1
very common. Even	1
very kludgy. The	1
very old-fashioned. Development	1
very smart. They	1
very often, but	1
very helpful for	1
very stupid. Some	1
software is to	1
software is implemented	1
software to be	1
software to add	1
software in a	1
software in two	1
software in C++	1
software in C++:	1
software for speed	1
software that is	2
software that runs	1
software that dates	1
software be reinstalled	1
software are available	1
software can cause	1
software with network	1
software more clear	1
software because the	1
software should be	1
software into an	1
software performance should	1
software optimization is	1
software optimization issue.	1
software programming language	1
software programming language,	1
software uses CPU	1
software contains a	2
software was coded.	1
software was developed.	1
software programs automatically	1
software implementation is	2
software implementation if	1
software implementation rather	1
software development and	1
software development work	1
software development process	1
software development models	1
software development process.	1
software development kit	1
software applications use	1
software applications need	1
software framework that	1
software writing style	1
software optimization. Everything	1
software module for	1
software programmers to	1
software faster. It	1
software developers should	1
software developers who	1
software users as	1
software specifies the	1
software development, and	1
software package and	1
software package in	1
software package on	1
software package several	1
software project together	1
software project goes	1
software runs most	1
software layers and	1
software projects have	1
software packages and	1
software packages faster	1
software product is	1
software users. In	1
software develop- ment	1
software development. This	1
software companies often	1
software installed, a	1
software products fail	1
software development", Addison-	1
software engineering principles	1
software package, including	1
software teachers to	1
software design, it	1
software project, it	1
software developer may	1
order is usually	1
order is opposite).	1
order of the	5
order of functions	1
order of floating	1
order of Boolean	2
order of inheritance	1
order to make	11
order to take	1
order to test	1
order to access	2
order to avoid	3
order to get	4
order to calculate	1
order to optimize	1
order to improve	2
order to know	1
order to find	3
order to prevent	1
order to save	1
order to divide	3
order to predict	1
order to enable	1
order to align	1
order to implement	1
order to help	1
order to increase	1
order to identify	1
order to force	1
order to cover	1
order to utilize	1
order to determine	1
order to emulate	1
order to reserve	1
order to facilitate	1
order to minimize	1
order and it	1
order and there	1
order in which	7
order in order	1
order or do	1
order but are	1
order execution All	1
order execution .................................................................................................	1
order calculation capabilities.	1
order polynomial: //	1
order a[0], b[0],	1
long and very	1
long and difficult	1
long and irregular	1
long that the	1
long or int64_t	1
long or uint64_t	1
long on a	1
long as the	1
long as it	1
long as you	3
long as this	1
long as their	1
long int unsigned	1
long int 64	1
long int 32	1
long time to	3
long time in	1
long time it	1
long time when	1
long time unless	1
long time compared	1
long vector library	1
long vector libraries	1
long vector math	1
long vector library,	1
long because the	1
long double take	1
long double precision	2
long double precision.	1
long double 8,	1
long double format.	1
long double reflects	1
long long or	2
long long 64	4
long long ReadTSC()	1
long long clock;	1
long long time1;	1
long long timediff[NumberOfTests];	1
long before the	1
long 64 2	1
long 64 4	1
long 64 8	1
long 64 1	1
long time. It	1
long 32 0	1
long does not	1
long list of	1
long dependency chains	1
long dependency chain	1
long dependency chain.	2
long dependency chains.	3
long dependency chains,	1
long response times	3
long response times,	1
long time, such	1
long sequence of	1
long enough to	2
long ReadTSC() {	1
long clock; __cpuid(dummy,	1
long time1; long	1
long delay. See	1
long latencies. 8.5	1
long timediff[NumberOfTests]; for	1
long long, double.	1
between the different	2
between the two	2
between the number	1
between the operating	2
between the optimization	1
between the calls	1
between the Boolean	1
between the systems.	1
between the efficiency	1
between the latency	1
between a and	1
between a function	1
between a software	1
between function names	1
between x and	1
between different CPU	1
between different threads	1
between different parts	2
between different tasks	1
between different threads,	1
between different precisions	1
between CPU brands	1
between CPU cores.	1
between CPU brands,	1
between floating point	2
between each call,	1
between using signed	1
between multiple CPU	2
between multiple dynamic	1
between multiple threads	1
between multiple processes	1
between multiple threads,	2
between multiple processes.	1
between two or	1
between two pointers	1
between two simple	1
between two expressions	1
between two constants	1
between 2 and	1
between 32-bit and	1
between 32-bit Linux	1
between 8 bit	1
between these considerations.	1
between simple processors	1
between threads is	1
between threads becomes	1
between single and	1
between several execution	1
between integers and	3
between optimizing for	1
between signed and	2
between development time,	1
between 5 and	1
between rows in	1
between c2 and	1
between rounding and	2
between threads. The	1
between 9 and	1
between leaf functions	1
between platforms, it	1
between threads, such	1
between float, double	1
between RISC and	1
between PC's and	1
between efficiency, portability	1
between coarse-grained parallelism	1
between commas and	1
between recoverable and	1
32-bit and 64-bit	11
32-bit and 64-bit.	2
32-bit or 64-bit	1
32-bit integer has	1
32-bit integer multiplication	1
32-bit number (the	1
32-bit software because	1
32-bit software development",	1
32-bit operating systems	2
32-bit systems and	4
32-bit systems when	1
32-bit systems do	1
32-bit systems unless	1
32-bit systems gives	1
32-bit systems allow	1
32-bit Windows and	1
32-bit Windows in	1
32-bit Windows by	1
32-bit integers to	1
32-bit integers and	1
32-bit integers in	1
32-bit Linux is	1
32-bit Linux and	2
32-bit Linux with	1
32-bit mode so	1
32-bit mode 4	1
32-bit mode unless	1
32-bit programs if	1
32-bit Mac code	1
32-bit Mac Intel	1
32-bit Mac OS	3
32-bit systems. Virtual	1
32-bit Windows, including	1
32-bit Windows, Intel/MASM	1
32-bit Linux, Gnu/AT&T	1
32-bit mode. The	3
32-bit mode. If	1
32-bit mode. Storing	1
32-bit version. The	1
32-bit Windows. Gnu	1
32-bit Windows. Does	2
32-bit Windows. Integrates	1
32-bit systems, but	1
32-bit systems, especially	1
32-bit mode, and	1
32-bit mode, for	1
32-bit integer. Floating	1
32-bit case. The	1
32-bit absolute addresses.	1
32-bit integers, and	1
32-bit integers, then	1
32-bit integers, which	1
32-bit integers, depending	1
32-bit number. If	1
32-bit -fno-builtin Gnu	1
32-bit counterparts. In	1
32-bit (signed) address.	1
branch is executed.	1
branch is mispredicted	1
branch is poorly	1
branch is executed	1
branch is eliminated.	1
branch is fed	1
branch of the	1
branch of code	2
branch to use	1
branch and other	1
branch in example	1
branch for a	1
branch for test	1
branch that is	1
branch that can	1
branch that always	1
branch that goes	3
branch that follows	1
branch that chooses	2
branch can be	2
branch can also	1
branch // Loop	1
branch if the	1
branch if it	1
branch by a	3
branch will be	1
branch will go	1
branch only when	1
branch instruction takes	1
branch should be	1
branch into the	1
branch void SelectAddMul(short	1
branch must rely	1
branch inside the	4
branch depends on	2
branch (e.g. an	1
branch target buffer	3
branch target buffer.	1
branch target buffer,	1
branch prediction are	1
branch prediction into	1
branch prediction (see	1
branch prediction mechanism.	1
branch misprediction is	1
branch misprediction long	1
branch misprediction penalty.	1
branch prediction. A	2
branch prediction. If	1
branch prediction. Example:	1
branch prediction. Modern	1
branch mispredictions. The	1
branch mispredictions. Boolean	1
branch mispredictions. When	1
branch mispredictions. Test	1
branch pattern history,	1
branch tree or	1
branch mispredictions if	1
branch mispredictions by	1
branch ahead of	1
branch tree. On	1
branch mispredictions, floating	1
branch mispredictions, etc.	1
branch misprediction, or	1
branch predictions in	1
< b because	1
< 0 and	1
< 0 ||	1
< 100; i	2
< 100; i++)	9
< 100; x++)	2
< 2; i++)	1
< b) =	1
< 0) {	1
< size; i	1
< size; i++)	10
< n; i++)	1
< 256; i	5
< 256; i++)	1
< SIZE; r++)	4
< SIZE; c++)	2
< SIZE; r1	1
< 4) {	1
< 1000; i++)	1
< 5) {	1
< 5) {}	1
< r; c++)	2
< 100. It	1
< 100. pop	1
< r1; c1	1
< 2.0 This	1
< 20; i	1
< 20; i++)	1
< 0. The	1
< ARRAYSIZE &&	1
< r1+TILESIZE; r2++)	2
< rows; i++)	2
< NumberOfTests; i++)	2
< 10) {	1
< 223 to	1
< arraysize; i++)	1
< NUMROWS; row++)	1
< NUMCOLUMNS; column++)	1
< ArraySize; i++)	1
< c1+TILESIZE; c2++)	1
< &list[100]; temp++)	1
< arraysize) {	1
< 231 then	1
< r2; c2++)	1
< list.Size(); i++)	1
< 13) {	1
< columns; j++)	1
member the object	1
member is more	1
member is unchanged	1
member of the	5
member of a	3
member of its	1
member or after	1
member function is	6
member function to	1
member function or	1
member function has	1
member function because	3
member function which	1
member function pointer	1
member function such	1
member function cannot	2
member function called	1
member function means	1
member by 8.	1
member functions is	2
member functions of	3
member functions that	1
member functions are	1
member functions if	1
member functions have	1
member functions then	1
member functions because	1
member functions static	1
member functions faster	1
member functions counts	1
member functions Virtual	1
member functions ........................................................................................	1
member functions (methods)	1
member functions (methods).........................................................................	1
member pointer simply	1
member pointer refers	1
member variable with	1
member pointers and	1
member pointers are	1
member pointers if	1
member pointers less	1
member pointers /vms	1
member function. The	1
member function. See	1
member function. But	1
member function. Do	1
member function. 7.12	1
member functions. The	3
member functions. This	1
member functions. A	2
member functions. You	1
member function, provided	1
member pointer. This	1
member pointer. 7.9	1
member relative to	2
member functions, where	1
member functions) has	1
way the register	1
way the user	1
way the programming	1
way is to	3
way is predicted	1
way is mispredicted	2
way is equal	1
way a branch	1
way a profiler	1
way of example	1
way of making	3
way of doing	1
way of handling	1
way of setting	1
way of declaring	1
way of defining	1
way of keeping	1
way of removing	1
way of relieving	1
way of solving	1
way to use	1
way to make	3
way to set	1
way to test	1
way to work	1
way to avoid	1
way to check	2
way to control	1
way to prevent	2
way to tell	2
way to handle	2
way to keep	1
way to fully	1
way to increase	1
way to identify	1
way to roll	1
way to overcome	1
way to limit	1
way to solve	1
way and three	1
way in the	1
way in case	1
way that can	1
way that there	1
way that takes	1
way that avoids	1
way or the	1
way or another.	1
way or bypassing	1
way if the	1
way by wrapping	1
way as in	1
way as an	1
way as last	1
way than last	1
way has become	1
way most of	1
way two times	1
way member pointers	1
way three times.	1
way microprocessors are	1
way includes the	1
way m is	1
elements is small	1
elements is known	2
elements of a	2
elements of b	1
elements of type	1
elements of simple	1
elements to store	1
elements to zero.	1
elements and the	1
elements in the	2
elements in a	4
elements in an	1
elements in vector	1
elements in each	1
elements in table	1
elements in order	1
elements in list	1
elements in row	1
elements in aa:	4
elements in a[]	1
elements that come	1
elements are there	1
elements are stored	1
elements are accessed	4
elements are cumbersome	1
elements // align	1
elements with a	1
elements with column	1
elements have a	1
elements have no	1
elements have been	1
elements more complicated	1
elements will go	1
elements } }	1
elements then this	1
elements from row	1
elements from cc	3
elements from bb	3
elements at the	2
elements at a	2
elements inside sqaure:	1
elements }; vector()	1
elements were inserted,	1
elements per vector.	2
elements per row	1
elements Induction variables	1
elements are. For	1
elements consecutively in	1
elements Total size	2
elements matrix[r][c] below	1
elements Size of	1
elements c.load(cc+i); //	1
elements matrix[c][r] above	1
elements b.load(bb+i); //	1
faster the smaller	1
faster to use	2
faster to make	1
faster to first	1
faster to access	2
faster to calculate	1
faster to transfer	1
faster to compose	1
faster and that	1
faster and more	1
faster and makes	1
faster and smaller.	1
faster in a	1
faster in 64-bit	1
faster in 32-bit	1
faster // Still	2
faster if the	5
faster if a	1
faster if unsigned	4
faster by making	1
faster with signed	1
faster than the	7
faster than a	3
faster than in	1
faster than x	1
faster than when	1
faster than from	1
faster than other	2
faster than floating	1
faster than example	1
faster than double	1
faster than any	1
faster than 32-bit	1
faster than making	1
faster than signed	1
faster than division	2
faster than linked	1
faster than reading	1
faster than calculating	1
faster than multiplying	1
faster than random	1
faster than pow	1
faster than 15.1b,	1
faster when the	1
faster when columns	1
faster at the	1
faster because the	1
faster because we	1
faster because testing	1
faster way to	1
faster vectorized code.	1
faster either by	1
faster nor slower	1
faster despite the	1
const in order	1
const or typedef	1
const function that	1
const int size	12
const int x;	1
const int rows	3
const int declaration	1
const int SIZE	3
const int TILESIZE	1
const int ArraySize	1
const int ABC	1
const int NumberOfTests	1
const int min	1
const int ARRAYSIZE	1
const int FactorialTable[13]	2
const int NUMROWS	1
const int arraysize	1
const double A	2
const double log2	1
const double A2	1
const pointer or	1
const float OneOrTwo5[2]	1
const float coef[16]	1
const float lookup[2]	1
const * const	1
const * p)	4
const variable or	1
const variable means	1
const member function	1
const & a,	1
const & x)	6
const & b)	1
const & a)	1
const & source)	1
const x) {	3
const reference if	1
const reference makes	1
const reference cannot	1
const reference allows	1
const keyword tells	1
const keyword wherever	1
const twice because	1
const reference. A	1
const restriction on	1
const restriction from	1
const Greek[4] =	1
const definitions when	1
makes the code	7
makes the compiler	1
makes the use	1
makes the data	1
makes the program	1
makes the access	1
makes the assembly	1
makes the compiled	1
makes the microprocessor	1
makes the dispatcher	1
makes the entire	1
makes a critical	1
makes a runtime	1
makes a PLT	1
makes a distinction	1
makes a symbolic	1
makes it more	1
makes it point	1
makes it possible	4
makes it less	1
makes it necessary	1
makes it easier	2
makes function calls	2
makes code caching	1
makes an error	1
makes an extra	1
makes data caching	8
makes program development	1
makes no difference	2
makes floating point	3
makes code. For	1
makes sure the	2
makes sure that	7
makes operations with	1
makes intermediate object	1
makes dispatching on	1
makes caching more	1
makes caching less	1
makes various other	1
makes inlining more	1
makes testing and	1
makes sense to	1
makes detailed optimization	1
makes position- independent	1
makes dynamic_cast more	1
cannot be used	2
cannot be stored	2
cannot be called	1
cannot be sure	1
cannot be calculated	1
cannot be known	1
cannot be certain	1
cannot be predicted	1
cannot be loaded	1
cannot be vectorized	2
cannot be inlined	1
cannot be overloaded	1
cannot be changed	1
cannot be determined	1
cannot be mixed	1
cannot be executed	1
cannot be ruled	1
cannot be controlled.	2
cannot be shared.	1
cannot be avoided,	1
cannot be tolerated.	1
cannot be ignored	1
cannot use the	1
cannot use ~	1
cannot make floating	2
cannot make any	1
cannot make algebraic	1
cannot point to	2
cannot set a	1
cannot do the	1
cannot do must	1
cannot always rely	1
cannot access any	2
cannot avoid this	1
cannot avoid conversions	1
cannot inline the	1
cannot replace a	2
cannot assume that	2
cannot know for	1
cannot know that	1
cannot reduce the	1
cannot change its	1
cannot change what	1
cannot find the	1
cannot rely on	3
cannot expect the	1
cannot expect a	3
cannot swap the	3
cannot modify data	1
cannot multiply integers	1
cannot easily be	2
cannot do. All	1
cannot increase the	1
cannot prefetch more	1
cannot rule out	3
before the function	4
before the code	1
before the compiler	1
before the time	1
before the program	3
before the loop	2
before the cache	1
before the floating	1
before the pointer	1
before the performance	1
before the first	4
before the test	1
before the file	1
before the calculation	1
before the application	1
before the end	1
before the preceding	2
before the decimal	1
before and after	4
before it is	4
before it can	1
before it has	2
before it checks	1
before it occurs,	1
before you start	1
before all objects	1
before any floating	2
before any constructors	1
before any transition	1
before we need	1
before test //	1
before they are	1
before conversion to	1
before running a	1
before calling the	2
before your code	1
before p is	1
before adding the	1
before multiplying with	2
before multiplying them.	1
before converting to	1
before compilation. The	1
before leaving the	2
before leaving their	1
before terminating a	1
before dividing by	1
before MemberPointer is	1
before coordination with	1
before storing. The	1
before trying the	1
before you. Optimized	1
stored in the	3
stored in a	9
stored in an	1
stored in memory	1
stored in different	2
stored in one	1
stored in integer	1
stored in static	3
stored in registers	3
stored in stack	1
stored in memory.	2
stored in binary	1
stored in dynamically	1
stored in x,	1
stored in memory,	2
stored in ASCII	1
stored in y.	1
stored in edx.	1
stored are containers	1
stored can be	1
stored by the	1
stored with each	1
stored on the	6
stored as the	1
stored as a	3
stored as it	1
stored as 8-bit	1
stored at a	3
stored at an	2
stored at address	1
stored together in	2
stored together The	1
stored together if	1
stored together Cache	1
stored together ......................................	1
stored near each	4
stored (or if	1
stored sequentially in	1
stored consecutively in	1
stored contiguously in	1
stored together...................................... 88	1
called the branch	2
called the heap	1
called a frame	1
called a leaf	1
called a loop-carried	1
called and the	1
called and how	2
called and resources	1
called in the	1
called in a	2
called for the	1
called by the	2
called by F1	1
called with many	1
called with IsPowerOf2	1
called on an	1
called when the	2
called from the	3
called from a	1
called from only	1
called from many	1
called from any	1
called from programming	1
called from another	2
called from main,	1
called only from	3
called only first	1
called CPU dispatching.	1
called performance monitor	1
called faster than	1
called before the	3
called register renaming.	1
called stack unwinding	1
called stack unwinding.	1
called function. Example:	1
called function. But	1
called through a	1
called every time	1
called shared objects	2
called name mangling.	1
called core clock	1
called global variables.	1
called global offset	1
called whole program	1
called square blocking	1
called garbage collection.	1
called whenever an	1
called near each	1
called procedure linkage	1
called once or	1
called once. The	1
called CodeAnalyst. These	1
called before. This	1
called accumulators. Current	1
called Single-Instruction-Multiple-Data (SIMD)	1
called VTune; AMD's	1
called properties) are	1
called from), function	1
called "Gnu indirect	1
address is in	1
address is not	1
address is likely	1
address is predicted	1
address is taken,	1
address a =	1
address of the	13
address of a	1
address of it	1
address of an	2
address of x	1
address of each	2
address of array	1
address of element	1
address of list[i]	1
address of matrix[j][0]	1
address and shared	1
address and back	1
address and attempts	1
address in the	1
address in this	1
address that is	2
address can be	2
address by the	1
address by adding	1
address at which	1
address which is	1
address which can't	1
address so a	1
address cannot be	1
address calculations are	1
address calculations have	1
address through a	1
address calculation and	1
address calculation in	1
address calculation more	1
address calculation faster.	1
address space of	1
address divisible by	5
address range from	2
address below 2	1
address might clash	1
address again before	1
address is. ecx	1
address plus a	1
address 0x2710 and	1
address 0x2710 will	2
address 0x2700 to	1
address [ecx+eax*4]. This	1
address esp+8 and	1
4 and AMD	1
4 in the	1
4 = 32.	1
4 = 2048	1
4 or 8,	1
4 with different	1
4 - 8	1
4 - 16	1
4 int 128	1
4 double 8	1
4 pointer or	1
4 + esp	1
4 float a[100];	1
4 64-bit integer,	1
4 clock cycles	1
4 clock cycles.	1
4 2 Choosing	2
4 4 double	1
4 4 pointer	1
4 4 64-bit	1
4 4 bytes	2
4 unsigned int	1
4 unsigned short	1
4 unsigned 256	1
4 64 2	1
4 64 4	1
4 64 MMX	1
4 32 4	1
4 short int	1
4 ; mangled	1
4 bytes in	1
4 bytes =	6
4 bytes without	1
4 AVX _mm256_permutevar_ps	1
4 128 SSE2	1
4 128 SSE	1
4 Most of	1
4 256 AVX	1
4 256 AVX2	1
4 AVX2 Table	1
4 AVX2 _mm256_i32gather_epi32	1
4 AVX2 _mm_i32gather_ps	1
4 AVX2 _mm256_i32gather_ps	1
4 computer where	1
4 unused bytes	2
4 lines in	1
4 bytes. first	3
4 processors, and	1
4 processor. Extra	1
4 Performance and	2
4 computer. The	1
4 ways. This	1
4 floats A	1
4 floats exp	1
4 ways, with	1
4 PUBLIC ?Func@@YAXQAHAAH@Z	2
4 rows. Let's	1
4 ?Func2@@YAXQAHAAH@Z ENDP	1
4 (NetBurst) CPU	1
See the compiler	2
See the Intel	1
See the manual	2
See the end	1
See the examples	1
See the preceding	1
See the discussion	1
See the vectorclass	1
See page and	1
See page 16	1
See page 32	1
See page 128	1
See page 3	1
See page 130	2
See page 120	1
See page 87	1
See page 122	2
See page 80	1
See page 90	1
See page 107	1
See page 103	1
See page 51	1
See page 43	2
See page 88	1
See page 150	1
See page 26	1
See page 29	1
See page 31	1
See page 49	1
See page 93	1
See page 81	1
See page 89	2
See page 153	1
See page 145	1
See page 140	1
See page 141	1
See page 78	2
See page 131.	2
See page 52.	1
See page 73	1
See page 26.	1
See page 80.	1
See page 95	1
See page 78.	1
See page 141.	1
See page 34.	1
See page 54.	1
See page 90.	1
See page 53.	1
See page 45.	1
See page 140.	1
See page 61.	1
See page 73.	1
See Intel Technology	1
See manual 5:	1
See my blog	1
See chapter 10	1
See www.agner.org/optimize/cppexamples.zip for	1
See www.agner.org/optimize/cppexamples.zip. If	1
See ISO/IEC TR18015	1
See www.gnu.org/copyleft/fdl.html. 164	1
See www.agner.org/optimize and	1
See www.openmp.org and	1
critical function is	2
critical function a	1
critical function and	1
critical function may	1
critical function many	1
critical function through	1
critical function ten	1
critical code to	1
critical code in	2
critical code are	1
critical code so	1
critical time consumers.	1
critical when there	1
critical because they	1
critical functions and	1
critical functions take	1
critical functions inline	1
critical integer parameter	1
critical code. A	1
critical part of	16
critical part can	1
critical function. The	2
critical function. In	1
critical dependency chain	1
critical dependency chain,	1
critical applications because	1
critical parts of	5
critical piece of	1
critical innermost loop	3
critical innermost loop.	2
critical innermost loops.	1
critical modules with	1
critical resources. Modern	1
critical stride is	3
critical stride and	1
critical stride for	1
critical stride can	1
critical stride will	1
critical stride then	1
critical stride (see	1
critical stride causes	1
critical stride, as	1
critical stride. Variables	1
critical application- specific	1
call the function	1
call the library	2
call the version	1
call the function.	1
call the destructor	2
call the chosen	1
call the polymorphic	1
call the CPUID	1
call the ReadTSC	1
call the std::unexpected()	1
call is translated	1
call a function	1
call a virtual	1
call a polymorphic	2
call a non-virtual	1
call of the	1
call to the	4
call to a	5
call to count	1
call to square	1
call to CriticalFunction	1
call to memcpy	1
call to C1::f	1
call to _endthread()	1
call to Func1,	1
call to Object1.Hello(),	1
call and return	2
call // Header	1
call or any	1
call it will	1
call it from	1
call it points	1
call if it	1
call by the	1
call with a	1
call this distance	1
call from the	1
call all code	1
call any other	2
call so that	1
call makes the	1
call method using	1
call stack in	1
call inline void	1
call statement always	1
call statement occupies	1
call (e.g. GetProcessAffinityMask	1
call polymorphic child	1
call transpose function	1
call method. When	1
call _mm256_zeroupper() before	3
call C1::f directly	1
call WriteFile if	1
call p->f() goes	1
call (other than	1
call __intel_cpu_features_init_x(). In	1
0; for (i	1
0; for (int	1
0; for (i=0;	1
0; // return	1
0; // Initialize	1
0; int i;	2
0; int i,	1
0; x <	2
0; } The	2
0; } if	1
0; } else	1
0; i <	39
0; while (seconds	1
0; c <	4
0; r <	2
0; row <	1
0; j <	1
0; column <	1
0; c1 <	1
0; 14.6 Floating	1
0; list[i+1] =	1
0; r1 <	1
0; i--, x++)	1
0; 35 This	1
0; i--) *(p++)	1
8 and no	1
8 in order	1
8 = 64	1
8 = 80.	1
8 or 16	2
8 - 64	1
8 floating point).	1
8 most popular	1
8 pointer or	1
8 + esp	1
8 float 4	1
8 * 4	1
8 clock cycles.	1
8 long double	1
8 8 pointer	1
8 8 float	1
8 8 long	1
8 8 unsigned	1
8 8 64	1
8 8 char	1
8 bit and	1
8 unsigned short	1
8 unsigned char	1
8 64 4	2
8 64 MMX	1
8 rather than	2
8 16 unsigned	1
8 16 128	1
8 16 char	1
8 32 8	1
8 32 256	1
8 32 char	1
8 bits each,	1
8 0 255	1
8 short int	1
8 bytes of	1
8 bytes in	1
8 bytes =	4
8 bytes without	1
8 bytes smaller	1
8 bytes each.	1
8 128 SSE2	1
8 256 AVX	1
8 256 AVX2	1
8 below. This	1
8 char 64	1
8 AVX2 _mm_i64gather_pd	1
8 AVX2 _mm_i32gather_epi32	1
8 AVX2 _mm_i64gather_epi32	1
8 512 AVX512	2
8 #define FUNCNAME	1
8 columns unused.	1
8 bytes. first	2
8 edx, eax	1
8 ways. The	1
8 -128 127	1
8 2.5 Choice	1
8 kb =	1
8 kb size	1
8 Optimizations in	2
8 double's of	1
less be possible	1
less than the	4
less than a	1
less than in	1
less than 128	1
less than half	1
less than 2n	1
less than 231.	1
less than 1/50	1
less than 2-20,	1
less than ARRAYSIZE.	1
less than 1%	1
less memory and	1
less each time.	1
less efficient and	1
less efficient in	1
less efficient if	1
less efficient code	1
less efficient than	7
less efficient when	1
less efficient because	1
less efficient (see	1
less so that	1
less critical parts	1
less user friendly.	1
less useful in	1
less important on	1
less important than	1
less advantageous to	1
less likely to	1
less optimal code	1
less efficient. The	2
less efficient. In	2
less efficient. There	1
less efficient. You	1
less efficient. Most	1
less efficient. Dynamic	1
less efficient. Do	1
less efficient. Access	1
less efficient. Extra	1
less efficient. Splitting	1
less clear and	1
less efficiently if	1
less efficiently when	2
less popular at	1
less strict when	1
less computing resources	1
less expensive. Using	1
less optimized. Note	1
less compact. See	1
less intensive applications.	1
less safe. This	1
less favorable: Larger	1
less efficiently. This	1
less precise floating	1
less reliable. Event-based	1
less susceptible to	1
less well-known languages.	1
For this reason,	1
For more on	1
For example use	1
For Intel CPUs	1
For example, the	4
For example, a	11
For example, to	1
For example, in	5
For example, for	1
For example, it	2
For example, if	9
For example, x	2
For example, you	2
For example, use	1
For example, when	1
For example, only	1
For example, all	1
For example, one	1
For example, compilers	1
For example, many	1
For example, some	1
For example, #define	1
For example, let's	1
For example, b*2.0/3.0	1
For these reasons,	1
For example: //	12
For my own	1
For unused returns	1
For example,a *	1
For team projects,	1
For one-man projects,	1
example, the compiler	2
example, the size	1
example, the first	1
example, the template	1
example, the sign	1
example, the conversion	1
example, the latest	1
example, the Boost	1
example, the DelayFiveSeconds	1
example, a =	1
example, a compiler	1
example, a loop	1
example, a double	1
example, a library	1
example, a branch	1
example, a programmer	1
example, a 128-bit	1
example, a heavy	1
example, a Core	1
example, a FIFO	1
example, to test	1
example, to go	1
example, to convert	1
example, in the	2
example, in a	1
example, in Windows,	1
example, in interpreted	1
example, for (i=0;	1
example, that a	1
example, it may	2
example, if the	2
example, if a	3
example, if you	1
example, if each	1
example, if multiple	1
example, if we	1
example, x =	2
example, you can	1
example, you may	1
example, you should	1
example, you want	1
example, you get	1
example, this is	1
example, use AVX	1
example, when a	1
example, then all	1
example, only one	1
example, which calculates	1
example, all good	1
example, but the	1
example, one tread	1
example, compilers cannot	1
example, using Intel	1
example, using Agner	1
example, many programmers	1
example, we are	1
example, some programmers	1
example, a, b	1
example, #define ABC	1
example, vectorized with	1
example, let's look	1
example, f(x) or	1
example, b*2.0/3.0 will	1
bit is kept	1
bit of a	1
bit of x	2
bit of i	3
bit of f	2
bit of ebx.	1
bit of u.f	1
bit to zero	1
bit to compare	1
bit to zero:	1
bit and 32	1
bit in the	1
bit in Day	1
bit in nn	1
bit are zero.	1
bit can be	1
bit // u.d	1
bit code 64	1
bit code Static	1
bit at a	1
bit vector of	2
bit vector registers	1
bit vector containing	1
bit instruction set	1
bit which is	1
bit integer and	1
bit integer vectors	1
bit float and	1
bit float vectors	1
bit float vectors)	1
bit version for	1
bit so that	1
bit systems have	2
bit operations and	1
bit must be	1
bit Windows and	1
bit Linux The	1
bit Linux Shared	1
bit }; The	1
bit mode and	1
bit mode if	1
bit mode than	1
bit mode SSE	1
bit platform not	1
bit platform _WIN64	1
bit platform __GNUC__	1
bit x86 instruction	1
bit mode. The	1
bit mode. Some	1
bit mode, where	1
bit mode, we	1
bit scan instruction	3
bit scan instructions.	1
bit scan instruction.	1
bit systems: The	1
bit systems: Pointers,	1
bit manipulation tricks	1
bit -fno-builtin Gnu	1
bit offsets). Example:	1
bit indicates a	1
bit set). We	1
operating systems and	3
operating systems that	2
operating systems are	5
operating systems can	1
operating systems need	1
operating systems available	1
operating systems give	1
operating systems Windows,	1
operating systems DOS	1
operating systems lack	1
operating systems disappears	1
operating systems (but	1
operating system is	2
operating system to	3
operating system and	2
operating system for	1
operating system can	2
operating system or	1
operating system if	1
operating system may	3
operating system this	1
operating system has	1
operating system functions	1
operating system which	1
operating system rather	1
operating system (see	1
operating system thread	1
operating system All	1
operating system running	1
operating system API	1
operating system kernel	1
operating system standards.	1
operating systems. The	1
operating systems. Some	1
operating systems. 10	1
operating systems. 3	1
operating systems, and	1
operating systems, though	1
operating system. The	1
operating system. This	1
operating system. It	1
operating system. See	2
operating system. AVX	1
operating system, and	2
operating system, not	1
operating system, this	1
operating system, but	1
operating systems". The	1
operating systems". For	1
operating systems". 7.16	1
operating systems"). An	1
operating system......................................................................................... 6	1
operating systems" for	1
unsigned in order	1
unsigned The same	1
unsigned for fast	1
unsigned // Faster	2
unsigned if you	1
unsigned int in	1
unsigned int or	1
unsigned int one	1
unsigned int before	1
unsigned int 64	1
unsigned int 16	1
unsigned int i;	2
unsigned int 128	1
unsigned int sign	3
unsigned int exponent	3
unsigned int u;	3
unsigned int fraction	3
unsigned int n)	1
unsigned int N>	1
unsigned int dummy;	1
unsigned int absvalue,	1
unsigned int u[2]}	1
unsigned integer to	1
unsigned integer and	1
unsigned integer takes	1
unsigned integer type	1
unsigned variable produces	1
unsigned 2 2	1
unsigned You can	1
unsigned long int	1
unsigned long long	1
unsigned long 32	1
unsigned 4 4	1
unsigned 8 8	1
unsigned short int	3
unsigned integers is	2
unsigned integers to	2
unsigned integers in	1
unsigned integers -	1
unsigned integers int	1
unsigned integers In	1
unsigned integers (see	1
unsigned integers simply	1
unsigned 1 1	1
unsigned 256 int	1
unsigned 256 short	1
unsigned conversion //	1
unsigned char 8	1
unsigned char 64	1
unsigned char short	1
unsigned char 128	1
unsigned variables. A	1
unsigned integers. But	1
unsigned __int64 64-bit	1
unsigned Examples: //	1
first the runtime	1
first and foremost,	1
first in a	1
first in an	1
first // 4	2
first // 6	1
first time the	2
first time int	1
first time you	1
first time because	1
first time Func	1
first when you	1
first data member	1
first two integer	1
first two (three	1
first two suggested	1
first object to	1
first way is	1
first way and	1
first call to	1
first call //	1
first call it	2
first call method	1
first time. This	1
first processors that	2
first processors with	1
first result is	1
first compiled to	1
first element is	2
first element of	1
first 128 bytes	1
first 128 bytes.	1
first four parameters	1
first eight floating	1
first eight elements	1
first count is	1
first count and	1
first program. An	1
first application if	1
first byte of	2
first byte at	5
first look up	1
first algorithm that	1
first operand of	2
first operand determines	1
first convert the	1
first thing to	1
first thing we	1
first generation of	1
first generation class	1
first call. The	1
first six integer	1
first manual. The	1
first PC's had	1
first sum, then	1
first sub-vector. A	1
first dimension may	1
register the object	1
register is a	1
register is 128	1
register is volatile.	1
register to zero	1
register to temp	1
register to hold	1
register and prevents	1
register for the	1
register for more	1
register for computing	1
register for both,	1
register that appears	1
register can be	2
register if its	1
register because their	2
register which can	1
register size is	1
register size in	1
register size only	1
register size comes	1
register into the	1
register variable in	2
register variables is	2
register variables in	2
register variables are	1
register variables because	1
register less so	1
register rather than	1
register available for	1
register stack is	2
register stack also	1
register stack are:	1
register stack versus	1
register (see below)	1
register allocation and	1
register keyword is	1
register keyword can	1
register size. In	1
register size. Vectorized	1
register variables. This	1
register variables. Vector	1
register variables. 9.5	1
register temp in	1
register variable. The	2
register stack. These	1
register containing (2,2,2,2),	1
register sizes to	1
register temp; for	1
register except in	1
register storage. The	1
register storage. Live	1
register variables, but	1
register parameters. In	1
register renaming and	1
register use, as	1
register left for	1
register usage convention	1
register renaming. The	1
register keyword. The	1
register state. This	1
64 and IA-32	1
64 or 0x40	1
64 If you	1
64 2 32	1
64 2 128	2
64 2 int64_t	1
64 2 uint64_t	1
64 4 unsigned	1
64 4 64	1
64 4 32	1
64 4 256	2
64 8 512	2
64 bit code	1
64 bit instruction	1
64 bit systems	2
64 bit Windows	1
64 bit Linux	1
64 bit mode	2
64 bit platform	1
64 bit mode.	1
64 bit mode,	1
64 bit -fno-builtin	1
64 64 32	1
64 64 matrix	2
64 64 14.0	1
64 32 16.4	1
64 bits in	1
64 bits are	1
64 bits rather	1
64 bits total	1
64 bits wide,	1
64 bits each.	1
64 bits (MMX),	1
64 0 264-1	1
64 bytes on	1
64 matrix on	1
64 matrix size	1
64 1 64	1
64 1 int64_t	1
64 consecutive bytes	1
64 bytes. This	1
64 bytes. Each	1
64 bits. The	1
64 bits. This	1
64 MMX int	1
64 MMX long	1
64 MMX short	1
64 MMX char	1
64 bits, but	1
64 Kbytes and	1
64 Iu32vec2 64	1
64 -263 263-1	1
64 14.0 80.8	1
64 Iu8vec8 16	1
64 kbytes. This	1
64 Is32vec2 32	1
64 Is8vec8 8	1
64 Is16vec4 16	1
64 kb. This	1
64 Iu16vec4 32	1
64 I64vec1 8	1
take the same	2
take the integer	1
take the elements	1
take the absolute	1
take the hint,	1
take a long	2
take a lot	2
take a whole	1
take more than	3
take more time	4
take more resources	1
take memory space	1
take only one	2
take only 256	1
take only 5	1
take no more	1
take no extra	2
take most time.	1
take into account	2
take any extra	1
take branch prediction	1
take up to	1
take up cache	2
take extra precautions	1
take much more	1
take several seconds	1
take several years	1
take several minutes	1
take advantage of	8
take quite a	2
take longer time	1
take longer time.	3
take 10 clock	1
take installation time	1
take special precautions	1
take maximum advantage	1
take 3 -	1
take approximately 500	1
take care of	4
take 1000 *	1
take microseconds to	1
take precedence, not	1
often the case	1
often a part	1
often a lot	1
often a disadvantage	1
often be optimized	1
often be made	1
often be C	1
often be executed	1
often as a	1
often an obstacle	1
often have execution	1
often have exploited.	1
often use position-independent	1
often more efficient	1
often more reliable	1
often because the	1
often used for	1
often used by	1
often used as	1
often used data	1
often used functions	1
often used variables	1
often used members	1
often possible to	2
often takes no	1
often takes much	1
often faster to	1
often faster than	1
often take several	1
often useful to	1
often necessary to	2
often much more	1
often implemented as	1
often contains a	1
often contains writeable	1
often write expressions	1
often optimize the	1
often replace integer	1
often requires that	1
often gives more	1
often inlined automatically	1
often true last	1
often fail to	1
often easier to	1
often easier said	1
often happen that	1
often inefficient. Objects	1
often determined by	1
often waiting for	1
often belong to	1
often preferable to	1
often inserts built-in	1
often suffer from	1
often conflicting with	1
often reveal things	1
often mispredicted. A	1
often underestimate this	1
often reorganized in	1
often seen, is	1
often abusing the	1
often fluctuating and	1
often excessively so.	1
often unreliable. They	1
often disturb the	1
rather than the	8
rather than a	5
rather than in	3
rather than by	6
rather than on	5
rather than as	1
rather than at	2
rather than CPU	1
rather than each	2
rather than using	1
rather than double	1
rather than two	1
rather than pointers	1
rather than 32	1
rather than dynamic	1
rather than type	1
rather than making	1
rather than its	1
rather than processor	1
rather than Boolean	1
rather than references	1
rather than reading	1
rather than future	1
rather than seconds	1
rather than two.	1
rather than moving	1
rather than allocating	2
rather than "what	1
rather than generating	1
rather than rounding.	1
rather than loops,	1
rather than 1.23456.	1
rather than sequences	1
rather than 20.	1
rather than nine,	1
rather than 200.	1
rather than -156.	1
rather than isolating	1
rather than self-styled	1
rather unconventional manner	1
optimization is to	2
optimization is needed.	1
optimization is enabled.	1
optimization is requested.	1
optimization of C++	3
optimization of performance	1
optimization are discussed	1
optimization can sometimes	1
optimization or for	1
optimization it may	1
optimization by compiler	2
optimization by CPU	1
optimization by executing	1
optimization by CPU.............................................................................81	1
optimization than to	1
optimization more difficult.	1
optimization cannot be	1
optimization instructions at	1
optimization Some compilers	1
optimization option available.	1
optimization unless the	1
optimization Integer algebra	1
optimization automatically in	1
optimization methods and	1
optimization options and	1
optimization options that	1
optimization options are	1
optimization options All	1
optimization options turned	3
optimization options ...................................................................................	1
optimization features of	1
optimization features and	1
optimization manuals are	1
optimization capabilities for	1
optimization effort is	2
optimization effort on	1
optimization manuals. I	1
optimization MS compiler	2
optimization options. Supports	1
optimization are. Dynamic	1
optimization guide for	4
optimization Intel: "Intel	1
optimization explicitly. Divisions	1
optimization Whole program	1
optimization topics .........................................................................................	1
optimization topics 14.1	1
optimization report /Qopt-report	1
optimization issue. But	1
optimization efforts on	1
optimization /GL --combine	1
optimization hints as	1
optimization /Og Whole	1
optimization job. You	1
libraries is more	1
libraries of predefined	1
libraries and short	1
libraries and see	1
libraries and drivers	1
libraries and compiler-generated	1
libraries and frameworks,	1
libraries in this	1
libraries for many	3
libraries for special	1
libraries for computing	1
libraries that are	2
libraries that come	1
libraries are not	3
libraries are used	1
libraries are also	1
libraries are less	1
libraries are useful	1
libraries are available	1
libraries are loaded	2
libraries are discussed	1
libraries are highly	2
libraries can be	2
libraries or shared	1
libraries it is	1
libraries with internal	1
libraries have the	1
libraries have CPU	1
libraries have very	1
libraries have features	1
libraries use dynamic	1
libraries when running	1
libraries It is	1
libraries do not	2
libraries where only	1
libraries need to	1
libraries without the	1
libraries available use	1
libraries Some applications	1
libraries Function libraries	1
libraries support 32-bit	1
libraries available. The	1
libraries included with	1
libraries distributed as	1
libraries slower than	1
libraries Test Processor	1
libraries (*.dll or	1
libraries named MKL,	1
libraries (*.lib, *.a)	2
libraries contend for	1
libraries 113 Number	1
libraries (.dll or	1
libraries (.lib or	1
libraries published by	1
how the if	1
how the microprocessor	1
how the development	1
how a cache	1
how a piece	1
how to use	4
how to make	6
how to do	2
how to take	1
how to test	2
how to avoid	3
how to speed	1
how to check	1
how to store	1
how to align	2
how to implement	1
how to break	1
how to identify	1
how to overcome	3
how to recover	1
how you can	2
how this can	1
how this works	1
how this works,	1
how compilers and	1
how compilers work.	1
how efficient the	1
how many times	4
how variables are	1
how long time	1
how often a	1
how they are	1
how big a	1
how much time	3
how much memory	1
how advantageous vectorization	1
how well the	2
how well it	1
how metaprogramming can	1
how predictable the	1
how caches work	1
how tortuous and	1
code. The library	1
code. The best	1
code. The name	1
code. The reason	1
code. The second	1
code. The bigger	1
code. The main	1
code. The 128-bit	1
code. The third	1
code. The history	1
code. // Example	1
code. This is	1
code. This can	2
code. This framework	1
code. A test	1
code. It is	4
code. If the	2
code. If you	2
code. In this	1
code. In general,	1
code. There are	1
code. You can	1
code. See ISO/IEC	1
code. For example,	2
code. For my	1
code. Example: //	4
code. Some profilers	1
code. An interrupt	1
code. But many	1
code. These workaround	1
code. All addresses	1
code. However, we	1
code. Most implementations	1
code. Each compiler	1
code. Many of	1
code. Dynamic memory	1
code. Dynamic cast	1
code. #if is	1
code. Register ebx	1
code. Intrinsic functions	1
code. System code	1
code. Compilers and	1
code. Furthermore, most	1
code. Metaprogramming can	1
code. Let's look	1
code. Storing something	1
code. Sometimes the	1
code. C#, managed	1
code. Let me	1
code. 7.32 Preprocessing	1
code. Inserting your	1
code. Compiled languages	1
code. 147 14.12	1
code. (Compile without	1
time. The function	1
time. The code	2
time. The time	1
time. The program	1
time. The objects	1
time. The expression	1
time. The storage	1
time. The delay	1
time. // Example	1
time. This is	4
time. A code	1
time. A loop	1
time. A variable	1
time. A template	1
time. A user	1
time. A part	1
time. A simple	1
time. A for-loop	1
time. It is	3
time. It can	1
time. It simply	1
time. There are	2
time. You can	1
time. You may	1
time. 4 2	1
time. 4 Performance	1
time. For example,	1
time. For example:	1
time. Example: //	1
time. Some compilers	1
time. An experiment	1
time. But this	1
time. These conversions	1
time. Integer multiplication	1
time. Integer division	1
time. Therefore, both	1
time. Each code	1
time. Loop unrolling	1
time. No memory	1
time. No universal	1
time. Do not	1
time. Optimizing less	1
time. Another disadvantage	1
time. Other programs	1
time. Shared objects	1
time. Templates make	1
time. Dispatch on	1
time. Are objects	1
time. Text strings	1
time. Single precision	1
time. Interpreted languages	1
time. Four typical	1
time. (Of course	1
time. (Examples can	1
time. Uses debug	1
time. Newer processors	1
template is a	1
template is calling	1
template is similar	1
template to get	1
template for x	1
template function is	1
template function for	1
template with many	1
template has only	1
template because partial	1
template class is	2
template class can	1
template class which	1
template library (STL)	2
template rather than	1
template template <typename	1
template parameters are	3
template parameters then	1
template parameters differ	1
template parameter is	1
template parameter can	1
template parameter should	1
template parameter rather	1
template feature was	1
template function, m	1
template instance has	1
template metaprogramming is	1
template metaprogramming //	1
template metaprogramming so	1
template metaprogramming is.	1
template parameter. The	1
template parameter. It	1
template parameter. If	1
template parameter. In	1
template parameter. There	1
template parameter. No	1
template parameter. Templates	1
template parameters. A	1
template instances will	1
template method. 7.29	1
template specialization is	1
template specialization for	3
template parameters, as	1
template <int N>	2
template <int m>	1
template metaprogramming. Don't	1
template metaprogramming, but	1
template metaprogramming, loops	1
template <typename T,	1
template <typename T>	1
template <typename MyChild>	1
template parameter: //	1
template parameter: template	1
template specialization. This	1
template specialization, not	1
template <bool IsPowerOf2,	1
registers is a	1
registers is very	1
registers is doubled.	1
registers is extended	1
registers is limited.	1
registers to test	1
registers and correspondingly	1
registers in the	1
registers in 64-bit	2
registers The first	1
registers The 128-bit	1
registers for the	1
registers for floating	1
registers that have	1
registers are available	3
registers are accessed	1
registers are supported	1
registers are used.	5
registers are used,	2
registers are extended	1
registers can hold	1
registers can benefit	1
registers by default	1
registers by 64,	1
registers have long	1
registers when compiling	1
registers then the	1
registers has been	2
registers only in	1
registers rather than	5
registers available in	1
registers available for	1
registers (see page	2
registers used. Conversion	1
registers instead of	1
registers are: It	1
registers organized as	1
registers had in	1
registers eax, ecx	1
registers anyway. Pure	1
registers named YMM	1
registers ................................................................. 107	1
registers (6 integer	1
registers (8 float	1
registers .......................................................... 107	1
registers (XMM or	1
need the next	1
need the updates	1
need the 'this'	1
need the "override"	1
need a CPU	1
need a smart	1
need a 'this'	1
need a constructor.	1
need to be	7
need to use	2
need to do	1
need to call	1
need to take	2
need to test	1
need to check	1
need to store	1
need to load	1
need to link	1
need to divide	1
need to update	1
need to remove	1
need to break	1
need to split	1
need to lock	1
need to organize	1
need to deallocate	1
need for the	1
need for special	1
need for garbage	1
need not be	1
need an error	1
need only read	1
need any non-static	1
need any patch.	1
need extra overhead	1
need assembly code	1
need assembly language.	1
need separate storage.	1
need induction variables	1
need better support	1
need better backup	1
need conversions between	1
need it. In	1
need initialization. A	1
need modification to	1
need modification if	1
need updating in	1
need metaprogramming. The	1
need metaprogramming. None	1
need relocation. All	1
need relocation, but	1
need relocation at	1
pointers is to	1
pointers of different	2
pointers to the	2
pointers to data	2
pointers to different	1
pointers to all	1
pointers to its	2
pointers to zero	1
pointers to zero,	1
pointers to objects)	1
pointers and the	1
pointers and for	1
pointers and virtual	1
pointers and addresses	1
pointers and references	1
pointers and references.	2
pointers and references,	1
pointers and non-constant	1
pointers in one	1
pointers that are	1
pointers are used	1
pointers are auto_ptr	1
pointers are implemented.	1
pointers are type-casted	1
pointers can be	2
pointers or addresses	1
pointers or references	1
pointers or references.	1
pointers or references:	1
pointers if it	1
pointers if there	2
pointers may be	1
pointers may not	1
pointers A smart	1
pointers It is	1
pointers because in	1
pointers because it	1
pointers because this	1
pointers do not	1
pointers In simple	1
pointers so that	1
pointers makes it	1
pointers less efficient.	1
pointers rather than	1
pointers unless they	1
pointers requires a	1
pointers requires only	1
pointers are: The	1
pointers efficient, and	1
pointers ...................................................................................................... 37	1
pointers Calling a	1
pointers .......................................................................................................... 38	1
pointers /vms Fastcall	1
test the different	1
test the performance	1
test the sign	1
test the response	1
test a software	1
test and setting	1
test in the	1
test for the	1
test that measures	1
test // Time	1
test // Critical	1
test // (time	1
test // Repeat	1
test or manipulate	1
test on several	1
test this is	1
test when software	1
test data and	1
test data should	1
test data instead	1
test program is	1
test program that	2
test program itself	1
test because the	1
test all branches	1
test but also	1
test should be	1
test should preferably	1
test should include	1
test each function	1
test 16 bytes	1
test bits 0	1
test several different	1
test run with	1
test sign bit	1
test their functionality.	1
test data. The	1
test data. That	1
test feature into	1
test feature called	1
test loop. The	1
test purposes. The	1
test purposes. If	1
test situations to	1
test tool for	2
test tool can	2
test tool supports	1
test () {	3
test server. Use	1
test examples. The	1
test examples. You	1
test setup may	1
test setup but	1
test theory. Advice	1
test finishes in	1
new and return	1
new and better	1
new and delete	5
new and delete,	2
new or malloc	1
new or malloc.	1
new or malloc)	1
new compiler which	1
new memory block	2
new vector size	1
new instruction set	1
new cache line	1
new floating point	1
new object is	1
new object of	1
new version of	1
new version for	1
new version without	1
new version causes	1
new value of	2
new objects can	1
new software project,	1
new branch of	1
new branch only	1
new register size	2
new instructions to	1
new instructions can	1
new function. The	1
new versions of	1
new processor enters	1
new element in	1
new model comes	1
new addition before	1
new bigger memory	3
new relevant information.	1
new instance of	2
new generation of	1
new features to	1
new block. Any	1
new update or	1
new one. The	1
new one. I	1
new physical register	1
new features. User	1
new features. Take	1
new context. It	1
new today will	1
new insight can	1
systems and a	1
systems and in	1
systems and 8	1
systems and 64	1
systems and programs	1
systems and fourteen	2
systems and sixteen	2
systems that have	1
systems that do	1
systems that allows	1
systems are not	2
systems are most	1
systems are using	1
systems are common,	1
systems can also	1
systems can improve	1
systems or 64-bit	1
systems if the	1
systems by using	1
systems with only	1
systems with multiple	1
systems with big-endian	2
systems than it	1
systems may have	1
systems you have	1
systems have the	1
systems have a	1
systems have several	1
systems use position-independent	1
systems use segmentation	1
systems when the	1
systems will dominate	1
systems because of	1
systems should be	1
systems do not	1
systems also have	2
systems we can	1
systems often use	1
systems need better	1
systems available today.	1
systems unless the	1
systems give almost	1
systems Windows, Linux,	1
systems gives rise	1
systems allow you	1
systems allow up	1
systems allow lazy	1
systems normally use	1
systems DOS and	1
systems lack the	1
systems ............................................................................. 158	1
systems disappears when	1
systems Microcontrollers used	1
systems (but not	1
user is likely	1
user is far	1
user is waiting	1
user to turn	1
user to restart	1
user and a	1
user and prevent	1
user can see	1
user if such	1
user may not	1
user will be	1
user will have	1
user has a	1
user has to	2
user but only	1
user access rights.	1
user must install	1
user never uses	1
user data. A	1
user actually has	1
user interface is	2
user interface and	2
user interface can	1
user interface than	1
user interface library	3
user interface elements	1
user interface framework	2
user interface etc.,	1
user interface framework...........................................................................	1
user interface (OnIdle	1
user might experience	1
user input in	1
user input or	2
user input never	1
user who has	1
user gets the	1
user input. The	1
user input. Many	1
user input. (In	1
user interface. A	1
user interface. It	1
user interface. Applications	1
user interface. Otherwise	1
user interfaces and	1
user interfaces from	1
user feedback seriously.	1
user expects an	1
user expects immediate	1
user settings are	1
user friendly compiler	1
user interface, another	1
user friendly. It	1
these and handle	1
these are hardly	1
these are incompatible	1
these time consuming	1
these functions is	1
these functions are	1
these functions have	1
these instruction sets.	2
these cache lines	1
these integer operations	1
these example containers	1
these compilers that	1
these compilers can	1
these two functions	1
these two versions	1
these two values	1
these two gives	1
these also treat	1
these variables to	1
these table lookup	1
these elements with	1
these address calculations	1
these operating systems	1
these libraries have	1
these operations are	1
these instructions require	1
these eight elements	1
these addresses to	1
these problems is	1
these problems are	1
these methods to	1
these methods are	2
these methods then	1
these examples are	1
these examples we	1
these data. It	1
these types to	1
these directives are	1
these directives do	1
these languages have	1
these variables. The	1
these conditions is	1
these calculations. Division	1
these classes. Size	1
these purposes. This	1
these purposes. Unfortunately,	1
these instructions. Function	1
these problems. More	1
these disadvantages when	1
these manuals are	1
these manuals can	1
these guidelines by	1
these obstacles and	1
these methods. If	1
these reasons, the	1
these considerations. It	1
these categories: File	1
they are in	2
they are not	2
they are used	1
they are no	1
they are often	1
they are sure	2
they are integers	1
they are used.	3
they are members	1
they are never	1
they are declared	2
they are predicted	1
they are executed.	1
they are equally	1
they are resolved	1
they are available,	1
they are deallocated	1
they are needed,	1
they are running.	1
they are guaranteed	1
they are long.	1
they are disabled	1
they are uninitialized	1
they are created.	1
they are wrapped	1
they are unavoidable.	1
they are uninitialized,	1
they can be	1
they can block	1
they may be	1
they have put	1
they point to	2
they do not	1
they cannot be	2
they cannot use	1
they cannot make	1
they cannot do.	1
they always keep	1
they always evaluate	1
they must be	1
they don't need	1
they were able	1
they fail to	1
they come from	1
they waste a	1
they contain is	1
they appear in	2
they are. However,	1
they are. Declare	1
they otherwise would	1
without the static	1
without the register	1
without the need	3
without the SSE2	1
without the sign	1
without the risk	1
without the -fpic	1
without the Common	1
without the FMA4	1
without an operating	1
without an IDE.	1
without CPU dispatching.	1
without cache MOVNTQ	1
without cache MOVNTDQ	1
without cache MOVNTPD	1
without cache MOVNTPS	1
without cache MOVNTI	1
without using the	2
without using exceptions	1
without using exceptions.	1
without any of	1
without any option	1
without any cost	1
without SSE2 typically	1
without dynamic memory	1
without AVX using	1
without AVX support	1
without AVX support.	1
without information about	1
without problems if	1
without caching is	1
without position-independent code	1
without checking all	1
without adding any	1
without loading a	2
without help of	1
without -fpic is	1
without -fpic in	2
without -fpic because	1
without polymorphism or	1
without specifying the	1
without reducing the	1
without invoking the	1
without generating overflow.	1
without AVX, as	1
without worrying too	1
without restrictions. A	1
without effectively preventing	1
without jeopardizing safety,	1
without taking cache	1
without paying the	1
without returning. F1	1
without discriminating between	1
useful to make	2
useful to copy	1
useful to put	2
useful to know	1
useful to turn	1
useful to roll	1
useful to study	1
useful to isolate	1
useful in the	1
useful in some	1
useful in test	1
useful in compiled	1
useful in programs	1
useful in situations	3
useful in 32-	1
useful for the	1
useful for library	1
useful for many	1
useful for making	2
useful for large	1
useful for copy	1
useful for optimizing	1
useful for Boolean	1
useful for calling	1
useful for checking	1
useful for testing	1
useful for finding	3
useful for random	1
useful for supporting	1
useful for preventing	1
useful for assigning	1
useful for investigating	1
useful for vectorizing	1
useful for identifying	1
useful if the	2
useful on servers	1
useful when the	2
useful when doing	1
useful when testing	1
useful because it	1
useful performance monitor	1
useful way of	1
useful way to	1
useful methods for	1
useful mathematical functions.	1
useful source of	1
useful whenever a	1
useful discussions about	1
even the same	1
even the smallest	1
even a single	1
even a linear	1
even a thousand	1
even of functions	1
even in the	1
even for double	1
even for simple	1
even for arrays	1
even for programs	1
even be a	1
even be used	1
even if the	6
even if a	1
even if no	1
even if they	2
even if a,	1
even on such	1
even have a	1
even have an	1
even more important	1
even more powerful	1
even when the	1
even when it	3
even when accessed	1
even when shared	1
even when their	1
even when just	1
even integer is	1
even faster to	1
even faster way	1
even without the	1
even add dummy	1
even smaller by	1
even compatible with	1
even though the	4
even though it	2
even allocate more	1
even swapped to	1
even worse, it	1
even temporarily. This	1
even telling the	1
even matters, which	1
even worse kind	1
sure the code	1
sure the compiler	1
sure the object	1
sure the value	1
sure the variable	1
sure the file	1
sure the arrays	2
sure the result	1
sure the information	1
sure the startup	1
sure to be	1
sure to have	1
sure to make	1
sure to point	1
sure to work	1
sure to produce	1
sure to distinguish	1
sure that the	11
sure that a	2
sure that it	1
sure that functions	1
sure that all	2
sure that one	1
sure that no	3
sure that variables	1
sure that they	2
sure that overflow	1
sure that certain	1
sure that everything	1
sure it is	2
sure it works	1
sure not to	1
sure you are	1
sure you need	1
sure you know	1
sure its size	1
sure allocated resources	1
sure whether the	1
sure everything that	1
method is to	1
method is that	1
method is faster	2
method is useful	3
method is explained	1
method is advantageous	1
method is likely	1
method is described	2
method is fastest	1
method is inefficient,	1
method is illustrated	1
method is extremely	1
method is somewhat	1
method is safer.	1
method of doing	2
method of induction	1
method of bounds	1
method of storing	2
method to use	1
method in example	1
method in 32-bit	1
method for all	1
method for transferring	1
method that is	1
method that gives	1
method that delays	1
method can be	4
method if memory	1
method with multiple	1
method may be	2
method you use	1
method only for	1
method used in	1
method used here	1
method should be	1
method using InstructionSet():	1
method also involves	1
method doesn't work	1
method works with	1
method works only	1
method Function inlining	1
method requires that	1
method requires OS	1
method described above	1
method currently used	1
method unfavorable, unless	1
always the same.	1
always to tell	1
always to specify	1
always for application-specific	1
always be a	1
always as good	1
always use the	1
always use this	1
always use standardized	1
always has the	1
always possible to	1
always takes memory	1
always stored together	1
always 0 or	1
always available from	1
always work well	1
always calls the	1
always calculated with	1
always advantageous to	1
always run slower	1
always 1 if	1
always able to	1
always end with	1
always transferred as	1
always goes the	1
always points to	1
always #pragma vector	1
always rely on	1
always position-independent because	1
always inlined even	1
always true or	1
always keep up	1
always apply to	1
always fully optimized.	1
always resolved at	2
always evaluate both	1
always avoiding this.	1
always select the	1
always belong to	1
always enabled in	1
always true. The	1
always one, and	1
always chooses the	1
always work. Data	1
always behave according	1
always Optimize function	1
always accurate, however,	1
always comparable to	1
always true/false Loopunrolling	1
always sequential, and	1
always compete for	1
always false: //	1
always normalized, if	1
always optimal, though.	1
always happy to	1
access the data	1
access the system	1
access the file	1
access the saved	1
access is the	1
access is a	1
access is more	1
access is faster	1
access a floating	1
access a variable	1
access a file	1
access a public	1
access a multidimensional	1
access to the	4
access to a	1
access to all	1
access to array	1
access to hardware	1
access to individual	1
access to virus	1
access to low-level	1
access and you	1
access and memory	1
access and cache	1
access and network	1
access in a	1
access in separate	1
access are critical	1
access can be	1
access or cache	1
access it the	1
access by each	1
access an object	1
access an element	1
access x as	1
access may be	1
access any non-static	2
access rather than	1
access these instructions.	1
access part of	1
access times cannot	1
access Some application	1
access non-sequential which	1
access Reading or	1
access Accessing data	1
access internal variables	1
access ............................................................................................. 87	1
access ...................................................................................................... 21	1
access 9.1 Caching	1
access patterns containing	1
access rights. Software	1
access patterns. This	1
void test ()	3
void SomeFunction (int	1
void Func ()	1
void SelectAddMul(short int	6
void Disp() {	4
void StoreVector(void *	3
void Func1 (int	1
void CriticalFunction(); ...	1
void CriticalInnerFunction ()	1
void TransposeCopy(double a[SIZE][SIZE],	2
void transpose(double a[SIZE][SIZE])	2
void Plus2 (int	1
void FuncA (int	1
void F1() {	1
void F1() throw();	1
void f(); };	2
void Func(int a[],	2
void Func2() {	1
void Hello() {	2
void Disp(); void	1
void NotPolymorphic(); virtual	1
void NotPolymorphic(); };	1
void F3(bool y)	2
void FuncB (int	1
void g() {	1
void F0() {	1
void AddTwo(int *	1
void SelectAddMul_dispatch(short int	1
void F2(float x[]);	1
void StoreNTD(double *	1
void StoreVectorA(void *	1
void F1(int x[]);	1
void MathLoop() {	1
void FUNCNAME(short int	1
void FuncType(short int	1
void xplus2() {	1
void Func() {	1
void DelayFiveSeconds() {	1
16 is actually	1
16 is required.	1
16 to the	1
16 to fit	1
16 in column	1
16 for a	1
16 for SSE2,	1
16 or 32	1
16 will not	1
16 float Exp(float	1
16 clock cycles,	1
16 4 unsigned	1
16 4 64	1
16 4 short	1
16 8 or	1
16 8 unsigned	1
16 8 short	1
16 8 128	1
16 bit platform	1
16 unsigned char	1
16 16 32	1
16 16 256	2
16 32 8	1
16 bits of	2
16 bits each,	1
16 bits wide,	1
16 0 65535	1
16 (see below).	1
16 bytes by	1
16 bytes at	1
16 bytes should	1
16 bytes without	3
16 128 SSE2	1
16 1 byte	1
16 256 AVX2	1
16 256 Vec32uc	1
16 char 128	1
16 Table 7.2.	1
16 512 AVX512	2
16 lines in	1
16 bytes. Some	1
16 Testing speed	1
16 Testing speed..............................................................................................................	1
16 __declspec( align(16))	1
16 SSSE3 _mm_perm_epi8	1
16 3.2 Use	1
16 3.3 Program	1
16 3.1 How	1
16 -32768 32767	1
16 XOP, AMD	1
SSE2 is the	1
SSE2 is always	1
SSE2 is available:	1
SSE2 and later	1
SSE2 // SSE4.1	1
SSE2 or later	4
SSE2 or x64	1
SSE2 or later.	1
SSE2 not supported");	1
SSE2 int 32	1
SSE2 instruction set	18
SSE2 instruction sets	1
SSE2 instruction set,	4
SSE2 instruction set:	1
SSE2 float 32	1
SSE2 version of	1
SSE2 version int	2
SSE2 long long	1
SSE2 short int	1
SSE2 128 bit	1
SSE2 supported return	1
SSE2 supported CriticalFunction	1
SSE2 typically takes	1
SSE2 intrinsic functions	1
SSE2 #include <emmintrin.h>	1
SSE2 char 8	1
SSE2 Table 9.2.	1
SSE2 Store 8	1
SSE2 Store 16	1
SSE2 (or later)	1
SSE2 emmintrin.h SSE3	1
out the loop	5
out the calculation	1
out the sign	2
out the possibility	2
out the theoretical	1
out a loop	1
out a big	1
out of the	3
out of a	3
out of order	1
out of range	5
out of F1	1
out of order.	2
out of range";	2
out of range.	2
out of range");	1
out to be	2
out or if	1
out if exceptions	1
out by the	1
out by 4	1
out by 2.	1
out with all	1
out loop by	5
out which one	1
out multiple bits	1
out some typical	1
out whether it	1
out sign bit:	1
out results printf("\n%2i	1
out aliasing (see	1
out loop-invariant code	1
out independently of	1
following compiler versions	1
following example shows	11
following example illustrates	4
following example explains	1
following example transposes	1
following example converts	1
following table lists	1
following table summarizes	1
following example, which	1
following assembly code	2
following list points	1
following methods may	1
following methods could	1
following examples explain	1
following example: //	1
following algorithm is	1
following conditions are	2
following way. The	1
following way. If	1
following way. First	1
following explanation if	1
following sections describe	1
following table. Type	1
following disadvantages compared	1
following guidelines can	1
following considerations should	1
following techniques can	1
following reasons: The	2
following reasons: Each	1
following way: //	1
following way: There	1
following way: bool	1
following cases: If	1
following alternatives: Make	1
following steps to	1
following work-around can	1
following features: The	1
following sections. 3.3	1
following solutions, depending	1
system is often	1
system is likely	1
system is based	1
system to avoid	1
system to generate	1
system to swap	1
system and CPU	1
system and choose	1
system for support	1
system can be	2
system or libraries	1
system if the	1
system with only	1
system code is	2
system code or	1
system may not	1
system may have	1
system may store	1
system may supply	1
system this is	1
system has support	1
system functions (e.g.	1
system which redirects	1
system performance options.	1
system makes sure	1
system call (e.g.	1
system rather than	1
system code. In	1
system code. Dynamic	1
system code. System	1
system (see page	1
system calls (e.g.	1
system thread scheduler.	1
system All newer	1
system running in	1
system resources ..........................................................................................	1
system resources Writes	1
system instead of	1
system core and	1
system database in	1
system calls. These	1
system devices and	1
system programming, but	1
system modules. 3.12	1
system API and	1
system database, and	1
system kernel in	1
system color settings	1
system crash. Furthermore,	1
system forbids the	1
system standards. Such	1
system dependent and	1
system breakdown. Many	1
32 and the	1
32 and 64	1
32 for an	1
32 for AVX.	1
32 = 28.	1
32 with j	1
32 instruction set	1
32 2 2	1
32 2 64	1
32 4 int	1
32 4 unsigned	1
32 4 64	1
32 4 128	2
32 8 64	2
32 8 32	1
32 8 256	2
32 bit code	1
32 bit Linux	1
32 bit mode	2
32 bit platform	1
32 bit mode.	1
32 bit systems:	2
32 bit offsets).	1
32 64 Iu32vec2	1
32 16 512	2
32 bits of	4
32 bits in	2
32 bits at	1
32 bits while	1
32 bits each,	1
32 bits (rarely	1
32 0 232-1	1
32 1 byte	1
32 sets can	1
32 sets 4	1
32 256 AVX2	1
32 char 256	1
32 results when	1
32 bits. This	1
32 bits, so	1
32 7.4 Enums	1
32 AND-operations in	1
32 bytes). This	1
32 16.4 65	1
32 -231 231-1	1
file is faster	1
file is closed.	2
file of every	1
file to a	1
file and the	1
file and all	1
file and one	1
file and compiled	1
file and copies	1
file in a	1
file in simple	1
file in exclusive	1
file for the	1
file for a	1
file for each	1
file for InstructionSet()	2
file that has	1
file can be	1
file by calling	1
file on a	1
file than in	1
file when static	1
file will give	1
file will remain	1
file from the	1
file has been	1
file access is	1
file access and	1
file access in	1
file access or	1
file needs to	1
file until the	1
file containing numerical	1
file includes the	1
file input and	1
file MMX mmintrin.h	1
file tells the	1
file format. The	1
file format is	1
file format instead	1
file level, and	1
file input/output operations.	1
file stdint.h or	1
file formats should	1
file timingtest.h from	1
file dvec.h vectorclass.h	1
file mathimf.h that	1
file stub. If	1
file disassembler. Note	1
file http://www.agner.org/optimize/asmlib.zip contains	1
file level. My	1
file /Fm Generate	1
file formats. Comments	1
programming is so	1
programming are dominating.	1
programming can be	1
programming as a	1
programming will typically	1
programming without paying	1
programming error known	1
programming work automatically.	1
programming language is	3
programming language and	3
programming language that	1
programming language when	1
programming language defines	1
programming language Before	1
programming language ...............................................................................	1
programming are: Non-static	1
programming errors that	1
programming errors associated	1
programming languages and	1
programming languages that	1
programming languages are	1
programming languages can	1
programming languages as	1
programming languages use	1
programming style that	1
programming style if	1
programming style has	1
programming manuals from	1
programming principles in	1
programming .......................................................................................... 150	1
programming languages, but	1
programming languages, such	1
programming languages, operating	1
programming languages, profiling	1
programming languages. This	1
programming languages. www.yeppp.info	1
programming style. The	2
programming style. It	1
programming style. Some	1
programming error. The	1
programming language, e.g.	1
programming questions to	1
programming questions if	1
programming experience before	1
programming constructs are	1
programming textbooks recommend	2
programming nowadays stress	1
programming practice, of	1
programming Device drivers,	1
dynamic memory allocation	11
dynamic memory allocation.	8
dynamic library is	2
dynamic library can	4
dynamic library than	1
dynamic library requiring	1
dynamic array of	1
dynamic libraries are	2
dynamic libraries need	1
dynamic libraries without	1
dynamic libraries Function	1
dynamic libraries (*.dll	1
dynamic libraries contend	1
dynamic libraries (.dll	1
dynamic allocation and	1
dynamic linking is	1
dynamic linking makes	1
dynamic linking cannot	1
dynamic linking are:	2
dynamic link library	3
dynamic link libraries	1
dynamic link libraries,	2
dynamic libraries. The	1
dynamic allocation. The	1
dynamic versions. It	1
dynamic linker. The	1
dynamic linking. The	1
dynamic libraries............................................................................ 146	1
part of the	34
part of a	11
part of memory	2
part of it).	1
part of it)	1
part can run	1
part unsigned int	2
part takes. See	1
part 142 unsigned	1
bits is likely	1
bits of the	4
bits of a	3
bits of an	1
bits of its	1
bits of a[i]	1
bits to zero.	1
bits in a	3
bits in an	1
bits in 64-bit	1
bits in 32-bit	1
bits in x86	1
bits for Tuesday,	1
bits for holding	1
bits are less	1
bits with the	2
bits than a	1
bits when the	1
bits at a	1
bits rather than	1
bits 0 -	1
bits while a	1
bits total size,	1
bits except the	2
bits Vector class,	1
bits Instruction set	1
bits Number of	2
bits each, or	1
bits each, four	1
bits each, eight	1
bits represent a	1
bits differently. A	1
bits minimum value	1
bits wide, should	1
bits wide, while	1
bits each. The	1
bits (MMX), 128	1
bits (XMM), 256	1
bits (YMM), and	1
bits 32-62. This	1
bits (rarely 64).	1
bits (YMM) if	1
bits (ZMM). Vector	1
bits (XMM) if	1
operations is more	1
operations of modern	1
operations to finish.	1
operations and before	1
operations and choose	1
operations and shift	1
operations in the	1
operations in order	1
operations for manipulating	2
operations for incrementing	1
operations are not	1
operations are very	1
operations are faster	1
operations are useful	1
operations are available	1
operations are done	1
operations are therefore	1
operations are fast	1
operations are particularly	1
operations are generally	1
operations can be	2
operations with other	1
operations with Boolean	1
operations with pointers.	1
operations on all	2
operations on vectors	1
operations on contemporary	1
operations than to	1
operations use a	1
operations use different	1
operations when the	1
operations when alignment	1
operations do not	1
operations into two	1
operations such as	1
operations where there	1
operations so that	1
operations take only	1
operations without reducing	1
operations An integer	1
operations automatically in	1
operations require that	1
operations slow down	1
operations outside the	1
operations mentioned in	1
operations involves eight	2
operations (chapter 12)	1
operations in-between the	1
operations Today's microprocessors	1
operations (addition, multiplication,	1
0 is true,	1
0 a &	1
0 a ^	1
0 to 12.	1
0 to 15.	1
0 and the	1
0 and i	1
0 and generate	2
0 and 1.	2
0 in this	1
0 for positive	1
0 for false	1
0 that r	1
0 // This	1
0 // this	1
0 = a	2
0 = 0,	1
0 or 1	3
0 or 1.	4
0 or 1,	1
0 if out	1
0 - n.a.	6
0 - 2	1
0 - Divide	1
0 - 30	1
0 - a*1	1
0 - a+0	1
0 because this	1
0 rather than	1
0 || i	1
0 ? c	2
0 <= n	1
0 n! 117	1
0 a+0=a a*0=0	1
0 264-1 uint64_t	1
0 65535 uint16_t	1
0 255 uint8_t	1
0 232-1 uint32_t	1
type is more	1
type is most	1
type of a	1
type of an	1
type of data	1
type of CPU	1
type of object	1
type of objects	1
type of registers	1
type of parameters	1
type of storage	1
type of vector,	1
type of microprocessor.	1
type to avoid	1
type and size	1
type and its	1
type in the	1
type that is	1
type can be	1
type by type-casting	1
type with desired	1
type has advantages	1
type such as	1
type short int	1
type __m128i defines	1
type conversion //	1
type conversion A	1
type conversion takes	1
type conversion generates	1
type conversions is	1
type identification adds	1
type identification (RTTI)	4
type identification (RTTI).	1
type identification (RTTI),	1
type T is	1
type T //	1
type casting of	1
type casting //	2
type casting operator	1
type int. Therefore,	1
type holds a	1
type typedef void	1
type __m128 defines	1
type size_t is	1
type conversions: //	1
type casting. Linked	1
type casting, but	1
type __m128d defines	1
case the function	1
case the code	1
case the array	1
case the reading	1
case is a	2
case is to	1
case is faster	1
case a =	1
case of the	2
case of an	5
case of data	1
case of large	1
case of overflow	2
case of Boolean	1
case of overflow.	1
case of error.	1
case of mispredictions	1
case of underflow:	1
case and make	1
case in loops.	1
case that the	2
case it may	1
case it will	1
case it doesn't	1
case if alternative	1
case with programs	1
case x can	1
case you have	1
case then the	1
case memory re-allocation	1
case there is	1
case where you	1
case we may	1
case we need	1
case so we	1
case situation is	1
case situation of	1
case 3: printf("Delta");	1
case 2: printf("Gamma");	1
case conditions. For	1
case 1: printf("Beta");	1
case labels follow	1
case F2 actually	1
case 0: printf("Alpha");	1
cases the compiler	1
cases the SSE2	1
cases the microprocessor	1
cases of program	1
cases of floating	1
cases of stack	2
cases to use	1
cases and it	1
cases for different	1
cases be advantageous	1
cases be linked	1
cases be determined	1
cases are usually	1
cases it is	4
cases it can	2
cases it might	1
cases on Windows	1
cases you can	1
cases you may	1
cases this multiplication	1
cases when the	1
cases should definitely	1
cases such as	1
cases In most	1
cases where the	8
cases where a	1
cases where it	4
cases where we	1
cases where they	1
cases where dynamic	1
cases cannot be	1
cases take memory	1
cases they are	1
cases even the	1
cases like these,	1
cases described in	1
cases ignore a	1
short in duration	1
short or common	1
short int is	1
short int in	3
short int int	1
short int 64	2
short int 16	3
short int 128	2
short int instead	1
short int a;	2
short int bb[],	9
short int cc[])	8
short int a[100];	1
short int s;	2
short int (16	1
short int bb[size]	1
short int cc[size]	1
short int aa[size]	1
short int 832	1
short int cc[]);	1
short time then	1
short vector method	1
short vector math	2
short vector libraries.	1
short vector library,	1
short int, signed	1
short int, float.	1
short int) are	1
& a =	1
& b if	1
& 0 =	1
& a, T	1
& b; will	1
& b; d	1
& 1 is	1
& unless you	1
& operator is	1
& operator forces	1
& operator (bitwise	1
& x) {	6
& later __svml_expf4	1
& b) {	1
& operation will	1
& -1 =	2
& ~a =	2
& enum Weekdays	1
& r) {	3
& r) {return	1
& earlier vmlsExp4	1
& a) {	1
& operator; and	1
& (Tuesday |	1
& 3) <<	1
& 3) <<6	1
& obj1; p->f();	1
& 0x7FFFFFFF) {	2
& operation, which	1
& N-1)==0 if	1
& source) {	1
& operator[] (unsigned	1
& 1) y	1
& (N-1)) return	1
& 15] +=	1
& 0x7FFFFF) |	1
& 0= 0	1
& 0x0F) |	1
& a= a	1
& N-1)==0,N>::p(x); }	1
& 1]; Here,	1
simple to develop.	1
simple in most	1
simple function with	1
simple function because	1
simple integer with	1
simple integer calculations	1
simple integer counter.	1
simple class containing	1
simple pointer or	1
simple array is	1
simple array can	1
simple variables into	1
simple way of	1
simple test setup	1
simple type casting,	1
simple cases where	1
simple processors and	1
simple solution to	1
simple standard operations.	1
simple cases, the	1
simple cases, a	1
simple types because	1
simple types such	1
simple constructor may	1
simple function, the	1
simple function, m	1
simple things like	1
simple reductions on	1
simple cases. The	1
simple cases. 7.28	1
simple cases. Database	1
simple algorithm can	1
simple tasks like	1
simple variable. Most	1
simple variable. Using	1
simple algebraic expressions	1
simple algebraic reductions	1
simple alternative is	1
simple expressions. Operations	1
simple variables, loop	1
simple variables, arrays	1
simple method. //	1
simple regular pattern,	1
simple index. A	1
simple tasks. Sometimes	1
simple periodic pattern	3
simple type, a	1
simple solution, but	1
simple actions like	1
instructions to the	1
instructions in the	1
instructions for the	1
instructions for integer	1
instructions for address	1
instructions for fast	1
instructions for mathematical	1
instructions for high	1
instructions for converting	1
instructions that are	1
instructions that can	1
instructions that may	1
instructions that use	1
instructions that make	1
instructions that take	1
instructions that allow	1
instructions are not	2
instructions are one	1
instructions are less	1
instructions are summarized	1
instructions are fetched	1
instructions are accessible	1
instructions can make	1
instructions or small	1
instructions than the	1
instructions have very	1
instructions at specific	1
instructions which can	1
instructions where the	1
instructions cannot multiply	1
instructions rather than	1
instructions without help	1
instructions out of	2
instructions (see page	1
instructions AVX 256	1
instructions add ebx,	1
instructions write directly	1
instructions becomes noticeable.	1
instructions were splitting	1
instructions require that	1
instructions mov ebx,eax	1
instructions during this	1
instructions SSE4.1 some	1
instructions sets. The	1
instructions listed in	1
instructions SSE4.2 string	1
instructions MOVNTPS, MOVNTPD	1
instructions (MOVNT) are	1
instructions executed, cache	1
processors is not	1
processors is called	1
processors is better.	1
processors and the	1
processors and on	1
processors and vector	1
processors and instruction	1
processors and FPGA	1
processors and earlier	1
processors that have	1
processors that support	3
processors that supported	2
processors that were	3
processors are not	1
processors are used	1
processors are sure	1
processors are sometimes	1
processors are preferred	1
processors are becoming	1
processors are covered	1
processors can be	1
processors can have	1
processors can calculate	1
processors with the	1
processors with a	1
processors with this	1
processors with low	1
processors with CISC	1
processors on the	1
processors on a	1
processors on which	1
processors have to	1
processors will support	1
processors because this	1
processors but eight	1
processors rather than	1
processors without the	1
processors available in	1
processors available can	1
processors (see page	1
processors requires a	1
processors usually share	1
processors prefetch data	1
processors (0, 2,	1
processors (when vector	1
processors properly. Many	1
available to the	1
available to fit	1
available in the	4
available in different	1
available in all	1
available in 64-bit	1
available in 32-bit	1
available in both	1
available in newer	1
available in 2015	1
available for the	1
available for other	1
available for 64-bit	1
available for many	2
available for Linux	1
available for doing	1
available for general	1
available for free	1
available for free.	1
available can be	1
available if the	1
available if supported	1
available with vector	1
available as an	1
available use excessive	1
available then it	1
available then each	1
available from the	1
available from a	2
available from www.intel.com.	2
available from www.agner.org/optimize.	1
available from Intel.	1
available from www.agner.org/optimize/testp.zip.	1
available at compile	1
available vector classes.	1
available because the	1
available instruction set.	2
available which are	1
available register size.	1
available registers is	1
available options for	1
available information. They	1
available today. You	1
constant is a	1
constant is faster	6
constant a value	1
constant to the	2
constant and then	1
constant and known	1
constant that is	1
constant can be	2
constant = shift	1
constant = multiply	3
constant with a	2
constant with its	1
constant data //	1
constant data from	1
constant vector (1,2,3,4),	1
constant should be	1
constant const int	1
constant 8 rather	1
constant always takes	1
constant (see page	1
constant single precision	1
constant known at	1
constant needs to	1
constant reference instead:	1
constant references accept	1
constant plus an	1
constant propagation is	1
constant propagation and	2
constant propagation An	1
constant 5. But	1
constant divisor that	1
constant n, then	1
constant N1 could	1
constant 3.5 will	1
constant (2n /	1
constant subexpression. A	1
constant propagation, and	1
constant propagation, etc.	1
constant 2.5, which	1
up the function	1
up the data	1
up the CPU	1
up the loop	1
up the performance	1
up the address	2
up the calculation	1
up the stack.	1
up the factors	1
up the queue	1
up a function	2
up a stack	1
up a program.	1
up to some	1
up to 4	1
up to cause	1
up to count	1
up to 5	1
up to five	1
up to fourteen	3
up to date.	2
up to date):	1
up and calling	1
up and enable	1
up and down.	1
up in a	1
up in case	2
up if the	1
up with the	3
up more space	1
up then it	1
up because it	1
up one register.	1
up cache space	1
up cache space.	1
up into multiple	1
up 64-bit shared	1
up everything in	1
up significantly just	1
up multiplications and	1
up spaces that	1
up include: Memory	1
error is to	1
error is not	1
error is easy	1
error is lower	1
error and compare	1
error in the	1
error for each	1
error that hackers	1
error can return	1
error // Return	1
error if the	1
error by avoiding	1
error code if	1
error code may	1
error code which	1
error then there	1
error has occurred	1
error return a[i];	1
error code. If	1
error without using	1
error doesn't occur,	1
error known as	2
error simply by	1
error handling in	1
error handling system	1
error handling Exception	1
error handling ................................................................................	1
error conditions in	1
error message is	1
error message and	2
error message in	2
error message if	1
error message when	1
error message function.	1
error condition terminates	1
error handling. You	1
error handler calls	1
error condition. Replacing	1
error condition. Things	1
error prone. The	1
error prone. A	1
error prone. All	1
error messages to	1
error message. It	1
error reporting here:	1
error reporting. For	1
I have used	2
I have no	2
I have done	1
I have implemented	1
I have made	1
I have tested	5
I have described	1
I have added	1
I have provided	1
I have seen	1
I have AND'ed	1
I have ever	1
I have supplied	1
I have developed	1
I have studied	1
I have confirmed	1
I have tested.	1
I have tried.	1
I will make	1
I will call	1
I will conclude	1
I want to	1
I must warn	1
I simply don't	1
I write that	2
I don't know	1
I don't think	1
I consider it	1
I once made	1
I am not	2
I am using	2
I am always	1
I am giving	1
I think that	1
I believe that	2
I die. See	1
I tried to	1
I guess, that	1
I disagree with	1
making the code	1
making the data	1
making the most	1
making the number	1
making the constant	1
making the arrays	1
making the container	1
making the structure	1
making the dispatch	1
making the full	1
making the entire	1
making a and	1
making a new	1
making a common	1
making a shared	1
making a separate	1
making a pointer.	1
making a debug	1
making a non-inlined	1
making it count	1
making an induction	1
making an unused	1
making an additional	1
making an explicit	1
making data more	1
making floating point	2
making i an	1
making multiple versions	1
making two threads	1
making objects inside	1
making any pointer	1
making any specific	1
making software in	1
making software more	1
making critical functions	1
making sure that	3
making another function	1
making programs that	1
making branches that	1
making longer time	1
making optimizations that	1
making optimizations across	1
making them static	1
making clear and	1
making highly optimized	1
making plug-ins that	1
times the function	1
times the other	2
times the first	1
times to test	1
times to simple	1
times to keyboard	1
times and the	2
times and that	1
times and make	1
times and calls	1
times and cause	1
times and stores	1
times in the	1
times in a	1
times in order	2
times for user	1
times for simple	1
times for network	1
times // Time	1
times with a	1
times with four	1
times as long	1
times an interrupt	1
times may be	1
times when a	1
times then the	1
times then we	1
times because the	1
times because of	1
times because it	1
times one way,	1
times each function	2
times each part	1
times faster than	2
times faster either	1
times cannot be	1
times before the	1
times less than	1
times rather than	1
times per matrix	1
times CriticalFunction is	1
times faster. The	1
times 24 dramatically	1
times lower; and	1
stack is the	1
stack is a	2
stack is used.	1
stack is organized.	1
stack and are	1
stack and reading	1
stack in the	1
stack in 32-bit	2
stack for all	1
stack can be	1
stack when CriticalInnerFunction	1
stack memory at	1
stack memory which	1
stack memory outside	1
stack at address	1
stack also has	1
stack before the	1
stack before it	1
stack rather than	1
stack registers are	3
stack always belong	1
stack ; return	1
stack ; ecx	1
stack (see above,	1
stack memory. Copying	1
stack are: All	1
stack pointer. Likewise,	1
stack frame is	1
stack frame makes	1
stack frame unless	1
stack frame /Oy	1
stack Variables and	1
stack unwinding The	1
stack unwinding that	1
stack unwinding information	1
stack unwinding mechanism	2
stack unwinding ..............................................................................	1
stack versus XMM	1
stack (three parameters	1
stack frame, saving	1
stack frame" or	1
stack entries use	1
stack unwinding. All	1
want the function	1
want the code	1
want the program	1
want the CPU	1
want the executable	1
want a number	1
want to be	1
want to use	1
want to make	5
want to call	1
want to avoid	1
want to compile	1
want to get	2
want to check	1
want to calculate	1
want to optimize	2
want to see	1
want to read	1
want to improve	1
want to know	1
want to generate	1
want to go	1
want to find	2
want to prevent	1
want to keep	1
want to vectorize	1
want to measure	1
want to roll	1
want to compare	1
want to 155	1
want to flip	1
want to thank	1
want to optimize,	1
want it to	1
want it to.	1
want as static	1
want this to	1
want this initialization,	1
want when the	1
want vectorization then	1
want them to	1
Example: // Example	48
Gnu and PathScale	2
Gnu and Clang	1
Gnu or Intel	1
Gnu function libraries	1
Gnu This is	1
Gnu compiler is	1
Gnu compiler and	1
Gnu compiler in	1
Gnu compiler for	2
Gnu compiler can	2
Gnu compiler //	1
Gnu compiler on	1
Gnu compiler A	1
Gnu compiler will	2
Gnu compiler often	1
Gnu compiler Linux	3
Gnu compiler allows	1
Gnu compiler mechanism	1
Gnu compiler reduced	1
Gnu compiler manual.	1
Gnu compiler .........................................................................	1
Gnu compilers are	1
Gnu compilers without	1
Gnu Intel Borland	1
Gnu C++ compiler	1
Gnu C++ v.	1
Gnu 32-bit Mac	1
Gnu 32-bit -fno-builtin	1
Gnu 64 bit	1
Gnu libraries support	1
Gnu manual currently	1
Gnu mechanism stores	1
Gnu compilers. //	1
Gnu compilers. See	1
Gnu directives work	1
Gnu compiler. Not	1
Gnu C function	1
Gnu C library.	1
Gnu compiler, the	1
Gnu compiler, etc.	1
Gnu Comes with	1
Gnu utilities in	1
Some of the	1
Some functions are	1
Some other compilers	1
Some compilers are	1
Some compilers can	1
Some compilers have	8
Some compilers will	4
Some compilers make	1
Some compilers offer	1
Some 64-bit compilers	1
Some software development	1
Some systems have	1
Some systems also	2
Some systems allow	1
Some programming languages,	1
Some programming textbooks	1
Some instructions are	1
Some important obstacles	1
Some CPUs have	1
Some versions of	1
Some common function	1
Some common compilers	1
Some common problems	1
Some copy protection	1
Some programs search	1
Some application programs	1
Some applications require	1
Some applications (e.g.	1
Some applications spend	1
Some modules may	1
Some STL templates,	1
Some implementations of	1
Some implementations use	1
Some developers feel	1
Some profilers require	1
Some guidelines are	1
Some early implementations	1
its time in	1
its time on	1
its time waiting	1
its data members	1
its size is	1
its pointer set	1
its b member	1
its many optimization	1
its possible exception	1
its value is	1
its value at	1
its variables called	1
its return value	1
its address is	1
its parameters replaced	1
its members are	1
its name at	1
its own memory	1
its own data	1
its own CPU	1
its own set	1
its own address	1
its own allocated	1
its own block	1
its own stack.	1
its own IDE.	1
its own caller,	1
its binary representation	1
its functions, called	1
its final destination,	1
its child class	2
its child class.	1
its address. The	1
its 'this' pointer	1
its value. However,	1
its family and	1
its parameters. This	1
its body is	1
its mirror position	1
its limit, etc.	1
its brand, family	1
its arguments. This	1
its out-of- order	1
its reputation. The	1
its simplicity. But	1
its address: //	1
its API. In	1
about the function	1
about the only	1
about the class	2
about the performance	1
about the sign	1
about the costs	1
about the destructor	1
about the possibility	1
about the chain	1
about the third	1
about the dimensions	1
about a variable,	1
about in my	1
about function names	1
about code optimization.	1
about an unknown	1
about this condition.	1
about memory caching.	1
about data storage	1
about functions in	1
about instruction latencies	1
about which software	1
about which implementation	1
about which platforms	1
about no pointer	1
about pointer alignment	1
about branch prediction.	1
about register use,	1
about how the	1
about how to	1
about how caches	1
about its child	1
about overflow and	1
about Linux also	1
about supported instruction	1
about whether the	1
about mathematical functions.	1
about name mangling	1
about it. Possible	1
about loss of	1
about increment operators	1
about them. You	1
about Func1 when	1
about rounding. Pointer	1
about division). The	1
about bugs, compatibility	1
about investigation of	1
important to the	1
important to have	1
important to make	1
important to do	2
important to optimize	1
important to consider	1
important to economize	4
important to understand	1
important to distinguish	1
important to study	1
important to focus	1
important to decide	1
important to note	1
important to weigh	1
important to remember	1
important to realize	1
important to ignore,	1
important and generally	1
important for the	1
important for tasks	1
important that the	2
important that all	1
important or critical	1
important it is	1
important if you	1
important on most	1
important on small	1
important than it	1
important than optimizing	1
important than speed.	1
important functions are	1
important new update	1
important method that	1
important part of	1
important disadvantage of	2
important addition to	1
important thing is	1
important usability problems	1
important obstacles to	1
important work. The	1
important distinction between	1
important remedy is	1
accessed in the	1
accessed in a	7
accessed in more	1
accessed in sequential	1
accessed in non-	1
accessed by any	2
accessed by several	1
accessed with the	1
accessed with a	1
accessed with an	1
accessed on a	2
accessed from the	1
accessed from any	1
accessed from main	1
accessed from within	1
accessed most efficiently	1
accessed very fast.	1
accessed much faster.	1
accessed through the	1
accessed through a	2
accessed through pointers	4
accessed through pointers,	1
accessed quite fast.	1
accessed after it	1
accessed approximately two	1
accessed equally fast.	1
accessed backwards and	1
accessed sequentially in	1
accessed consecutively and	1
accessed sequentially. The	1
accessed sequentially. It	1
accessed recently than	1
accessed non-sequentially because	1
accessed column-wise. Assume	1
accessed row-wise, then	1
CPUs is not	1
CPUs is increasing	1
CPUs to verify	1
CPUs and operating	2
CPUs in a	2
CPUs for executing	1
CPUs that are	1
CPUs that support	1
CPUs are so	1
CPUs are actually	1
CPUs are capable	1
CPUs can be	1
CPUs can do	1
CPUs can change	1
CPUs can execute	1
CPUs or a	1
CPUs or CPU	1
CPUs or multi-core	1
CPUs if the	1
CPUs if you	1
CPUs with a	1
CPUs with only	1
CPUs with execution	2
CPUs with slow	1
CPUs with full-size	1
CPUs have a	1
CPUs have only	1
CPUs have two	1
CPUs have particularly	1
CPUs have family	1
CPUs use Intel	1
CPUs use AMD	1
CPUs which may	1
CPUs such as	1
CPUs cannot be	1
CPUs without the	1
CPUs was more	1
CPUs unless you	2
CPUs (See manual	1
CPUs increased the	1
CPUs (Intel Atom).	1
CPUs optimally. The	1
CPUs unequally can	1
function. The function	1
function. The }	1
function. The static	1
function. The following	1
function. The stack	1
function. The assembly	1
function. The automatic	1
function. The string	1
function. The overhead	2
function. The PLT	1
function. The initialization	1
function. The branching	1
function. This is	1
function. This will	1
function. This has	2
function. This fragmentation	1
function. A leaf	2
function. If the	1
function. In the	1
function. In some	1
function. There are	1
function. See page	1
function. Example: //	2
function. But in	1
function. But there	1
function. Function inlining	1
function. However, the	1
function. Using an	1
function. Do not	1
function. When the	1
function. Avoid the	1
function. 12.2 AVX-512	1
function. Global variables	1
function. Copying the	1
function. 7.12 Branches	1
function. Compile once	1
function. Provoke branch	1
function. Switch between	1
function. Sometimes, functions	1
function. __attribute__((const)) (Linux	1
function. typeof(CriticalFunction) *	1
function. Leaf functions	1
function. 154 //	1
extra function calls	1
extra code to	1
extra code and	1
extra code for	1
extra code at	2
extra time if	1
extra time as	1
extra time may	1
extra time when	1
extra cache for	1
extra software layers	1
extra register to	1
extra register available	1
extra code. It	1
extra code. Example:	1
extra code. Dynamic	1
extra time. The	1
extra time. This	1
extra time. It	1
extra time. There	1
extra time. These	1
extra operations outside	1
extra instructions for	2
extra work needed	1
extra element zero.	1
extra check on	1
extra information to	1
extra cost is	1
extra cost to	1
extra cost whenever	1
extra framework can	1
extra overhead of	1
extra overhead to	1
extra overhead in	1
extra overhead which	1
extra resources. Each	1
extra time, of	1
extra iteration that	1
extra level of	1
extra jump through	1
extra bits. The	1
extra precautions to	1
extra dummy element	1
extra complications. A	1
extra layer of	1
does the same	5
does the necessary	1
does not have	2
does not use	1
does not make	1
does not need	3
does not always	1
does not work	1
does not check	2
does not cost	1
does not give	1
does not require	1
does not produce	2
does not fit	1
does not allow	1
does not apply	2
does not spend	1
does not necessarily	1
does not alias	2
does not cover	1
does not solve	1
does not occur.	1
does not throw	1
does have some	1
does this by	1
does It can	1
does floating point	2
does some things	1
does some funny	1
does so in	1
does quite ingenious	1
does what you	1
does not, and	1
does ............................................................................. 84	1
does incredibly stupid	1
assembly or easy	1
assembly on all	1
assembly code to	2
assembly code for	2
assembly code or	1
assembly code from	2
assembly instruction for	1
assembly code. Register	1
assembly code. Let	1
assembly instructions or	1
assembly language is	1
assembly language and	2
assembly language for	1
assembly language has	1
assembly language because	1
assembly language Use	1
assembly language modules	1
assembly language programming,	1
assembly language output.	1
assembly language output,	1
assembly syntax in	1
assembly output of	1
assembly output more	1
assembly output option	2
assembly output listing	1
assembly output (/FAs	1
assembly programmers and	1
assembly language. It	1
assembly language. C++	1
assembly language. In	1
assembly language. See	1
assembly language. Here	1
assembly names. The	1
assembly listing reveals	1
assembly listing /FA	1
assembly output. The	1
assembly language". The	1
assembly language". While	1
assembly listing. Use	1
assembly language", section	1
assembly language: An	1
large to handle	2
large for the	1
large that we	1
large or if	1
large or constant.	1
large then it	1
large memory model	2
large memory blocks,	1
large data files	1
large data sets	1
large data structures	2
large data sets.	2
large data bases,	1
large because the	1
large number of	1
large static arrays	1
large array can	1
large objects and	1
large libraries where	1
large part of	1
large arrays and	1
large arrays if	1
large shared object	1
large block containing	1
large cost to	1
large runtime framework	2
large expressions when	1
large graphics frameworks,	1
large positive number	2
large overhead of	1
large overhead cost	1
large libraries. The	1
large delay due	1
large fraction of	1
large arrays. Array	1
large applications. The	1
large object, unless	1
large arrays, it	1
large amounts of	1
large delays. The	1
must be a	1
must be called	2
must be done	1
must be inside	1
must be read	1
must be aligned	1
must be declared	1
must be divisible	1
must be loaded	1
must be dynamically	1
must be saved	1
must be found	1
must be multiplied	1
must be placed	1
must be careful	1
must be added.	1
must be adjusted	1
must be emphasized	1
must be followed	1
must be reversed	1
must have a	2
must have extern	1
must use a	1
must use thread-safe	1
must then check	1
must make sure	1
must make your	1
must do the	1
must return to	1
must always end	1
must check if	1
must calculate its	1
must go through	1
must rely on	1
must convert it	1
must consider that	1
must consider if	1
must wait until	1
must install a	1
must clean up	1
must begin at	1
must compute (FuncRow(i)*columns	1
must warn against	1
must bear in	1
while the program	2
while the type	1
while the Gnu	1
while the speed	1
while the multiplication	1
while the expression	2
while the runtime	1
while the Borland	1
while a function	1
while a double	1
while in the	1
while it is	1
while if is	1
while an int	1
while you can	1
while data that	1
while other functions	1
while other compilers	2
while loop is	1
while loop in	1
while loop because	1
while all newer	1
while most of	1
while multiple statements	1
while many reductions	1
while less than	1
while pointers and	1
while dynamic linking	1
while execution speed,	1
while another thread	1
while (i <	1
while Pentium 4	1
while seconds count	1
while waiting for	1
while (n !=	1
while simultaneously prefetching	1
while high-level languages	1
while loop, the	1
while loops, then	1
while (*p !=	1
while (seconds <	1
while (0 <	1
while he or	1
; a ;	1
; Example 8.26a	1
; Example 8.26b	1
; point to	1
; double Func2(double	1
; i +	1
; i <	1
; return from	1
; return ;	1
; add what	1
; store result	1
; parameter 2:	1
; parameter 1:	2
; parameter $B1$1:	1
; r ;	1
; a[i] =	1
; start of	1
; unused label	4
; shift right	1
; shift down	1
; save ebx	1
; repeat loop	1
; align by	1
; align ;	1
; eax =	1
; ecx =	2
; jump to	1
; edx =	2
; compare with	1
; top of	2
; compute i/2	1
; a[i+1] =	1
; Induction++; ;	1
; i++ ;checkifi<100	1
; mangled function	2
; restore ebx	1
; mark end	1
; mark_end; This	1
arrays is fast	1
arrays of different	1
arrays of variable	1
arrays of structure	1
arrays and other	1
arrays and where	1
arrays and want	1
arrays and big	1
arrays and objects.	1
arrays and structures.	1
arrays in the	1
arrays in C	1
arrays that are	1
arrays that you	1
arrays are faster	1
arrays are accessed	3
arrays are aligned	2
arrays are sufficiently	2
arrays are properly	1
arrays are aligned,	1
arrays can be	1
arrays // Define	1
arrays or structures	1
arrays if it	1
arrays by the	1
arrays by well-tested	1
arrays with vector	1
arrays with bounds	1
arrays with alloca.	1
arrays as required,	1
arrays It may	1
arrays should be	2
arrays very big	1
arrays even if	1
arrays inside the	1
arrays automatically but	1
arrays bigger than	1
arrays require a	1
arrays Alignd (	1
arrays forwards, not	1
work the same	1
work to do	1
work to take	1
work in example	1
work in both	1
work for class	1
work for very	1
work that the	1
work that needs	1
work can be	1
work // Re-do	1
work it has	1
work with any	1
work with member	1
work with both	1
work on the	2
work on a	1
work on all	2
work on compilers	1
work on non-Intel	1
work as a	1
work as possible.	1
work int i	1
work when Intel	1
work only on	1
work into each	1
work into multiple	2
work cannot be	1
work best on	1
work well on	2
work needed for	1
work load is	2
work around this	1
work efficiently on	1
work automatically. The	1
work better. If	1
work better. Remember	1
work load. The	1
work correctly. The	1
work evenly between	1
(see page 130	1
(see page 134	1
(see page 107).	2
(see page 16)	1
(see page 71).	1
(see page 73).	2
(see page 78).	2
(see page 137).	1
(see page 43).	1
(see page 87).	1
(see page 105).	2
(see page 140).	2
(see page 51).	1
(see page 27).	1
(see page 103)	1
(see page 107),	1
(see page 122)	1
(see page 53).	1
(see page 93).	1
(see page 96).	1
(see page 103),	1
(see page 142).	1
(see page 84).	1
(see page 134)	1
(see page 135).	1
(see page 38).	1
(see page 72).	1
(see page 73)	1
(see page 70).	1
(see p. 43).	1
(see p. 87).	1
(see p. 104).	1
(see p. 22).	1
(see p. 57).	1
(see above, page	1
(see above, p.	1
(see below) then	1
(see below) 16.1	1
(see below). The	1
(see below). A	1
Windows and the	1
Windows and to	1
Windows and C++	1
Windows and 32-bit	2
Windows and Linux	1
Windows and Mac	1
Windows and Linux,	1
Windows and Linux.	2
Windows and Mac.	1
Windows in this	1
Windows are fully	1
Windows if functions	1
Windows by transferring	1
Windows compiler to	1
Windows may be	1
Windows you can	1
Windows program that	1
Windows Intel compiler	2
Windows version is	1
Windows operating system,	1
Windows Gnu compiler	3
Windows Linux __INTEL_COMPILER	1
Windows allows a	1
Windows allows only	1
Windows platform _WIN32	1
Windows platforms. The	2
Windows platforms. This	1
Windows syntax or	1
Windows (See page	1
Windows Library (OWL).	1
Windows system. Note	1
Windows applications. The	1
Windows Template Library	2
Windows 7 and	1
Windows DLLs use	1
Windows 3.x. These	1
Windows Server 2008	1
Windows MFC). This	1
calls the function	1
calls the same	1
calls the critical	2
calls the dispatcher	1
calls is the	1
calls a function	1
calls a device	1
calls to the	1
calls to a	1
calls to check	1
calls to frame	2
calls to memset	1
calls to CriticalFunction.	1
calls to log,	1
calls and it	2
calls and branches	1
calls and branches.	1
calls in the	4
calls are saved	1
calls can be	1
calls may run	1
calls may slow	1
calls more efficient.	1
calls at least	1
calls because the	1
calls other functions	1
calls faster and	1
calls faster in	1
calls rather than	1
calls another function	2
calls another function,	1
calls another dispatched	1
calls it. A	1
calls (e.g. IsProcessorFeaturePresent	1
calls directly to	1
calls exit. Calling	1
calls exit(), abort(),	1
calls alternately FuncA	1
calculations of loop	1
calculations of (2n	1
calculations to save	1
calculations and the	1
calculations in a	1
calculations in floating	1
calculations in parallel	1
calculations in parallel.	1
calculations are available	1
calculations are done	3
calculations are just	1
calculations can cause	1
calculations or turn	1
calculations with memory	1
calculations on the	3
calculations on large	1
calculations on vectors	1
calculations as long	1
calculations may take	1
calculations have to	1
calculations will typically	1
calculations then you	1
calculations at compile	1
calculations should therefore	1
calculations into a	1
calculations so that	1
calculations take no	1
calculations without the	1
calculations while another	1
calculations while simultaneously	1
calculations inside the	3
calculations unless the	1
calculations piece by	1
calculations usually take	1
calculations go outside	1
calculations including linear	1
calculations whenever they	1
calculations simultaneously or	1
calculations forms a	1
versions of the	11
versions of a	3
versions of an	1
versions of memory	1
versions of Intel	1
versions of these	1
versions of common	1
versions of Linux	1
versions of their	1
versions of CriticalFunction	1
versions and turn	1
versions for different	6
versions are available	1
versions are produced	2
versions with and	1
versions have to	1
versions should be	2
versions without an	1
versions even of	1
versions work correctly.	1
versions #include "instrset_detect.cpp"	1
versions were tested:	1
versions tested (not	1
versions 7 through	1
versions alternatingly several	1
versions instead. The	1
execution is no	1
execution of everything	2
execution of CriticalFunction.	1
execution to the	1
execution and advanced	1
execution by causing	1
execution may be	1
execution time on	1
execution time when	1
execution time because	2
execution then it	1
execution time. 4	1
execution time. Loop	1
execution time. No	1
execution times per	1
execution speed to	2
execution speed and	1
execution speed in	1
execution speed or	1
execution All modern	1
execution mechanism can	1
execution mechanism works	1
execution core of	1
execution units. The	2
execution units. If	1
execution units. For	1
execution units. Each	1
execution units. Any	1
execution units. Typically,	1
execution units and	1
execution units in	1
execution units same	1
execution units rather	1
execution units smaller	1
execution units, memory	1
execution (chapter 11)	1
execution ................................................................................................. 103	1
execution unit. For	1
execution speed, memory	2
execution considerably. Another	1
avoid the loop	1
avoid the large	1
avoid the calls	1
avoid the problem	1
avoid the multiplication	1
avoid the overhead	1
avoid the conversions	1
avoid the inefficient	1
avoid the time-	1
avoid the burdensome	1
avoid that the	1
avoid that some	1
avoid an excessive	1
avoid this in	1
avoid this by	1
avoid this method	1
avoid this error	1
avoid this problem	1
avoid this wasteful	1
avoid multiple threads	1
avoid multiple inheritance	1
avoid any use	1
avoid long dependency	2
avoid these and	1
avoid these problems.	1
avoid dynamic memory	3
avoid making any	1
avoid virtual functions	1
avoid running the	1
avoid running two	1
avoid global variables	1
avoid conversions from	2
avoid it. Global	1
avoid powers of	1
avoid this. See	1
avoid this. (In	1
avoid them. Some	1
avoid macros with	1
avoid modulo operations:	1
avoid hyperthreading by	1
avoid hard-to-find errors,	1
result is the	1
result is that	1
result is stored	2
result is known	2
result is valid.	1
result of the	7
result of other	1
result of each	1
result of macro	1
result of full	1
result of comparing	1
result to see	1
result in a	2
result in array	1
result in x.	1
result in a[i].	1
result can be	1
result // Update	1
result = b	2
result if we	1
result by using	1
result will be	3
result then we	1
result vector in	4
result because the	1
result 100 rather	1
result ebx is	1
result back to	1
result -56 rather	1
result (b+c) can	1
processor the user	1
processor is not	2
processor is an	1
processor is much	1
processor is compatible	1
processor to give	1
processor and the	2
processor and a	1
processor for calculating	1
processor that you	1
processor can do	1
processor with four	1
processor may be	2
processor may have	1
processor will have	1
processor has a	1
processor has four	1
processor has hyperthreading.	1
processor makes the	1
processor model is	1
processor model will	1
processor model numbers	1
processor model N	1
processor core on	1
processor models to	2
processor models on	2
processor models rather	1
processor core. Unfortunately,	1
processor core. Two	1
processor core. Try	1
processor cores. Each	1
processor performs better	1
processor appears on	1
processor features. The	1
processor model. You	1
processor X" is	1
processor enters the	1
processor X?" rather	1
processor activates critical	1
compiled to an	1
compiled to binary	1
compiled to assembly:	2
compiled and distributed	1
compiled in multiple	1
compiled for the	4
compiled for a	1
compiled for 64-bit	1
compiled for AVX	1
compiled for old	1
compiled with the	1
compiled with and	1
compiled with different	2
compiled with AVX	2
compiled with -fpic	1
compiled on a	1
compiled code and	1
compiled code may	1
compiled code big	1
compiled as a	1
compiled as position-independent	1
compiled when it	1
compiled into an	1
compiled C++ or	1
compiled version is	1
compiled code. In	1
compiled code. Compiled	1
compiled code. (Compile	1
compiled without any	1
compiled without AVX	1
compiled without -fpic	2
compiled without AVX,	1
compiled programming languages	1
compiled versions #include	1
compiled three times,	1
compiled languages such	1
compiled C++. This	1
An integer is	1
An integer may	1
An integer overflow	1
An example is	1
An object of	2
An object cannot	1
An efficient solution	1
An array is	1
An array can	1
An array using	1
An array overflow	1
An array initialized	1
An optimization guide	4
An even more	1
An even worse	1
An error message	1
An important disadvantage	1
An allocated array	1
An overflow of	1
An inline function	1
An optimizing compiler	4
An application with	1
An expression that	1
An expression or	1
An expression with	1
An implementation of	1
An overloaded operator	1
An alternative is	1
An alternative solution	1
An interrupt service	1
An OR combination	1
An enum is	1
An appendix to	1
An uncached write	1
An inferior version	1
An experiment where	1
An uncaught overflow	1
Use the call	1
Use the option	2
Use the latest	1
Use the "generate	1
Use a compiler	1
Use a reference	1
Use a profiler	2
Use a "move	1
Use function libraries	1
Use an old	1
Use an antivirus	1
Use different executables.	1
Use 64-bit mode	2
Use template to	1
Use these example	1
Use simple method.	1
Use Gnu or	1
Use CPUs with	1
Use assembly language	1
Use large data	1
Use another function	1
Use inline functions	1
Use intrinsic functions	1
Use signed when	1
Use automatic parallelization.	1
Use lookup tables	2
Use appropriate compiler	1
Use whole program	1
Use macro as	1
Use square blocking:	1
Use bitwise operators	2
Use OpenMP directives.	1
Use 12 option	1
Use rounding instead	1
Use macros instead	1
Use mask to	1
Use ReadTSC() from	1
Use fastcall functions	1
Use predefined vector	1
bytes is slightly	1
bytes of memory.	1
bytes of storage	1
bytes of code).	1
bytes to find	1
bytes in the	1
bytes in a	1
bytes in 64-bit	1
bytes in 32-bit	1
bytes can be	1
bytes // 8	1
bytes = int	2
bytes = double	2
bytes = float	4
bytes = 4	1
bytes = int64_t	2
bytes or more	1
bytes by adding	1
bytes on contemporary	1
bytes then put	1
bytes from address	1
bytes at a	1
bytes should be	1
bytes Intel Core	1
bytes between a	1
bytes without cache	5
bytes AMD Opteron	1
bytes byte at	1
bytes smaller and	1
bytes S1 ArrayOfStructures[100];	1
bytes bool 1	1
bytes smaller. Structure	1
bytes each. The	1
bytes alignment, bytes	1
big a structure	1
big to cover	1
big and is	1
big and uses	1
big in order	1
big for the	1
big that overflow	1
big that caching	1
big memory block	1
big memory blocks	1
big data structures	1
big data structures.	2
big program when	1
big loop then	1
big floating point	1
big objects that	1
big objects come	1
big software companies	1
big before multiplying	1
big file containing	1
big arrays and	2
big matrix happen	1
big problem if	1
big program. Frequent	1
big block of	1
big difference in	1
big runtime frameworks,	1
big structures by	1
big problem. Whenever	1
big enough to	1
big enough for	2
big waste of	1
big blocks is	1
big blocks rather	1
big endian systems	1
big endian storage	1
big endian storage.	1
big arrays, then	1
big mainframe computer.	1
big mainframe computers.	1
big registration database	1
doesn't have the	2
doesn't have to	3
doesn't have an	1
doesn't have information	1
doesn't make such	1
doesn't call any	2
doesn't take any	1
doesn't need the	1
doesn't need a	2
doesn't need induction	1
doesn't need initialization.	1
doesn't work for	1
doesn't work //	1
doesn't work with	1
doesn't work int	1
doesn't work well	1
doesn't cause overflow	1
doesn't cause overflow.	1
doesn't works (gcc	1
doesn't add or	1
doesn't automatically check	1
doesn't give the	1
doesn't know the	1
doesn't know in	1
doesn't know what	1
doesn't generate any	1
doesn't prevent two	1
doesn't handle current	1
doesn't occur has	1
doesn't delay the	1
doesn't matter and	1
doesn't matter if	1
doesn't depend on	1
doesn't compromise safety	1
doesn't mean atomic.	1
doesn't occur. In	1
doesn't occur, but	1
doesn't support, and	1
doesn't provide the	1
threads is discussed	1
threads is minimized.	1
threads and put	1
threads in the	2
threads in a	1
threads in each	1
threads that run	1
threads that jump	1
threads are often	1
threads are doing	1
threads are competing	1
threads are sharing	1
threads are areas	1
threads can share	1
threads can add,	1
threads with the	2
threads with different	1
threads with low	1
threads with lower	1
threads with widely	1
threads on a	1
threads have each	1
threads have access	1
threads have finished	1
threads use different	1
threads will invalidate	1
threads from attempting	1
threads should rely	1
threads where one	1
threads so that	1
threads need separate	1
threads must be	1
threads write to	1
threads running in	1
threads becomes faster	1
threads writing to	2
threads share the	1
threads simultaneously. This	1
threads simultaneously. If	1
threads Parallelization by	1
best and most	1
best for all	1
best function libraries	1
best if the	1
best on the	1
best on a	1
best on processors	1
best on processor	1
best on future	1
best compiler and	1
best when the	1
best at doing	1
best compilers use	1
best into the	2
best possible instruction	1
best possible version	1
best possible branch	1
best possible version.	1
best performance is	3
best way to	5
best optimization it	1
best optimized function	1
best optimized math	1
best solution is	1
best optimizing compilers	1
best implementation for	1
best cases. It	1
best algorithm than	1
best performance. The	1
best under this	1
best Java machines	1
best Java implementations.	1
best job optimizing	1
best suited for	1
best optimizer. Borland/CodeGear/Embarcadero	1
best algorithm. The	1
necessary to have	1
necessary to use	2
necessary to do	4
necessary to first	1
necessary to test	1
necessary to check	1
necessary to optimize	1
necessary to replace	1
necessary to look	1
necessary to load	1
necessary to unroll	1
necessary to convert	1
necessary to modify	1
necessary to allocate	1
necessary to compromise	1
necessary to reload	1
necessary to query	1
necessary to adhere	1
necessary in the	1
necessary for your	1
necessary for verifying	1
necessary if the	1
necessary if you	1
necessary when no	1
necessary then it	1
necessary because the	1
necessary functions for	1
necessary instruction set.	1
necessary library files	1
necessary (see page	1
necessary calculations of	1
necessary information about	2
necessary here to	1
necessary destructors after	1
necessary communication between	1
necessary cleanup jobs	1
necessary initialization. The	1
necessary support. Hardware	1
element is stored	1
element is accessed,	1
element is stored?	1
element of the	1
element to list	1
element to x?"	1
element in the	2
element in a	2
element in an	1
element in vector	4
element in b	2
element in order	1
element in list,	1
element for a	1
element if the	1
element } An	1
element then use	1
element Example 9.6a	1
element Example 9.6b	1
element has to	1
element number 16	1
element number i.	1
element 0 in	1
element addresses for	1
element __m128i a	1
element a[i] is	1
element outside the	1
element level 9.	1
element level 108	1
element Instruction set	1
element zero. It	1
element 63 63	1
element matrix[r][c] is	1
element matrix[r][c] below	1
element matrix[c][r] at	1
element (approximately): if	1
element matrix[c][r]. //	1
language is a	1
language is that	1
language is best	1
language is chosen	1
language is provided	1
language is portable	1
language is implemented.	1
language is inherently	1
language and the	1
language and a	1
language and development	1
language and automatic	1
language and interface	1
language in the	1
language for CPU-intensive	1
language that can	1
language that allows	1
language that requires	1
language with a	1
language as a	1
language when the	1
language will often	1
language has full	1
language because a	1
language also includes	1
language elements in	1
language need only	1
language Use intrinsic	1
language allows compile-time	1
language runtime of	1
language based on	1
language modules when	1
language defines an	1
language defines hardware	1
language programming, compiler	1
language 11 programming,	1
language While C++	1
language output. On	1
language Before starting	1
language relates to	1
language ............................................................................... 8	1
language gained remarkably	1
language output, which	1
But the compiler	1
But the same	1
But the C++	1
But the software	1
But the &	1
But the cost	1
But a solution	1
But a highly	1
But a sorted	1
But in the	1
But in more	1
But it is	3
But it can	1
But it may	1
But if the	3
But if a	1
But if all	1
But if I	1
But not if	1
But an optimizing	1
But this language	1
But this solution	1
But when the	1
But program loading	1
But each member	1
But most of	1
But there is	1
But there are	2
But many programs	1
But we will	1
But we do	1
But these eight	1
But what if	1
But lazy binding	1
But implementing a	1
But beware of	1
But beware that	2
speed is many	1
speed is relevant	1
speed is particularly	1
speed is critical.	1
speed is important.	3
speed of a	1
speed of functions	1
speed of each	1
speed of CPUs	1
speed of modern	1
speed of RAM	1
speed of addition,	1
speed to using	2
speed and for	1
speed in any	1
speed for certain	1
speed or not	1
speed or program	1
speed or size.	1
speed or full	1
speed or not.	1
speed if the	1
speed by using	3
speed on non-Intel	1
speed will be	1
speed because of	1
speed between using	1
speed between single	1
speed between rounding	1
speed test should	1
speed without jeopardizing	1
speed up the	1
speed up multiplications	1
speed advantage in	1
speed here is	1
speed Testing the	1
speed exceeding that	1
speed /O2 or	1
specific to Microsoft	1
specific functions have	1
specific CPU model	1
specific CPU feature	1
specific CPU core	2
specific CPU models	1
specific CPU brands	1
specific CPU models.	1
specific instruction set.	1
specific instruction set,	1
specific size is	1
specific pointer does	1
specific version of	1
specific order but	1
specific optimization instructions	1
specific instructions that	1
specific processor models	1
specific advantage to	1
specific parts of	1
specific optimizations in	1
specific graphics framework	1
specific load address.	1
specific calling conventions	1
specific advantages that	1
specific size. Integer	1
specific models then	1
specific purpose in	1
specific places in	1
specific profiler. For	1
specific event it	1
specific recommendation of	1
specific recommendation about	1
specific bottleneck or	1
specific purpose. It	1
specific needs. 9.8	1
specific literature for	1
specific model. Instead,	1
specific purpose, you	1
specific preferences for	1
specific purpose: Contain	1
specific option) better:	1
specific interval. A	1
c is added	1
c and d	1
c are integers,	1
c can share	1
c = a	4
c = b	2
c = 0;	1
c = 1;	1
c = temp	1
c = d	1
c = 100,	1
c = LoadVector(cc	3
c = (a+1)	1
c = 1.23456,	1
c loop in	1
c + b	1
c + 2	2
c + d;	2
c + 2,	2
c + two,	1
c < SIZE;	2
c < r;	2
c < 0.	1
c __m128i c2	2
c __m128i bc	2
c > b)	1
c (a&&b) ||	1
c first. b+c	1
c x-xx----- 75	1
much is a	2
much of the	1
much on the	1
much as possible	1
much you gain	1
much time is	1
much time it	2
much time each	1
much more by	1
much more than	1
much more time	2
much more efficient	2
much more complicated	1
much more resources	2
much more dramatic	1
much memory a	1
much data for	1
much data as	1
much faster to	1
much faster than	1
much less memory	1
much less efficiently	1
much about the	1
much about overflow	1
much space in	1
much longer time	3
much higher than	1
much higher resolution	1
much faster. In	1
much faster. There	1
much faster. Division	1
much slower than	1
much simpler in	1
much stronger for	1
much faster, except	1
single and double	3
single or double	1
single function or	1
single function by	1
single function from	1
single object file.	2
single branch if	1
single call to	2
single bit which	1
single register the	1
single & operation,	1
single instructions that	1
single constant with	1
single function. Switch	1
single assembly instructions	1
single precision to	1
single precision or	2
single precision if	1
single precision than	1
single precision variables	2
single operation using	1
single task that	1
single precision. These	1
single precision. Using	1
single precision. When	1
single precision. And	1
single executable file	1
single element. The	1
single step rather	1
single result. An	1
single operation. Example:	1
single instruction. The	1
single container, preferably	1
single comparison: //	1
single result, true	1
single session. But	1
i; for (i	6
i; if ((unsigned	1
i; int Induction	1
i; } }	1
i; } x;	1
i; } Here,	1
i; } u;	5
i; } u,	2
i; float x;	1
i; float f;	1
i; float a[size],	2
i; float list[size];	1
i; float i2;	1
i; return f;	1
i; long long	1
i; const int	1
i; short int	2
i; ... for	2
i; ... if	1
i; ... list[i	1
i; Here, the	1
i; p =	1
i; for(i=0; i<300;	3
i; for(i=0; i<100;	1
i; for(i=0; i<301;	1
i; 45 for	1
i; 84 for	1
These are of	1
These are available	1
These function libraries	2
These may be	1
These different methods	1
These functions are	2
These two functions	1
These two books	1
These table lookups	1
These registers have	1
These new instructions	1
These systems use	1
These cases are	1
These instructions are	2
These instructions write	1
These virtual processors	1
These operators and	1
These addresses all	1
These problems should	1
These complicated cases	1
These methods are	1
These methods also	1
These directives are	1
These conversions are	1
These conversions can	1
These conversions do	1
These conversions take	1
These lines are	1
These costs are	1
These costs can	1
These containers should	1
These counters can	1
These algorithms are	1
These factors are	1
These profilers are	1
These units are	1
These requirements are	1
These suffixes are	1
These workaround methods	1
virtual function is	2
virtual function will	1
virtual function }	1
virtual function call	1
virtual function calls	1
virtual function dispatch	2
virtual function tables.	1
virtual functions are	1
virtual functions or	1
virtual functions if	1
virtual functions then	1
virtual functions class	1
virtual table is	1
virtual table to	1
virtual table before	1
virtual table lookup	1
virtual member the	1
virtual member function	1
virtual member functions	2
virtual member function.	1
virtual member functions.	1
virtual void Disp()	2
virtual void f();	2
virtual void Disp();	1
virtual processors can	1
virtual processors on	1
virtual function. If	1
virtual processor may	2
virtual functions. The	1
virtual functions. This	1
virtual functions, and	1
virtual destructor is	1
virtual table. Unfortunately,	1
virtual machine are	1
virtual 53 function	1
virtual machine. The	1
several different functions	1
several different C++	1
several different CPUs	1
several different ways	2
several different CPUs.	1
several different purposes.	1
several different algorithms	1
several different profiling	1
several functions that	1
several other less	1
several clock cycles	1
several clock cycles.	1
several variables happen	1
several times in	2
several large arrays	1
several versions for	1
several execution units.	1
several standard PC's	1
several files when	1
several branches is	1
several applications use	1
several examples of	1
several advantages over	1
several ways to	1
several seconds to	1
several seconds because	1
several iterations of	1
several iterations ahead.	1
several factors that	2
several hundred clock	1
several reasons. C++	1
several years before	1
several layers of	1
several drivers, configuration	1
several minutes to	2
several meanings depending	1
several stages before	1
several flaws: The	1
through the following	1
through the calculations	1
through the PLT	1
through the implicit	1
through the Internet	1
through the symbolic	1
through a function	3
through a pointer	7
through a template	2
through a linked	1
through a second	1
through a pointer.	1
through a smart	1
through a linear	1
through a series	1
through a self-relative	1
through a hidden	1
through function pointer	1
through function calls.	1
through an import	1
through an imported	1
through this address.	1
through multiple function	1
through multiple layers	1
through array cout	1
through pointers in	1
through pointers or	2
through pointers so	1
through rows for	1
through rows //	1
through pointers, e.g.:	1
through 14, with	1
common to make	2
common to exchange	1
common for software	1
common function libraries	1
common memory and	1
common compilers are	1
common way of	1
common programming error	1
common programming errors	1
common programming error.	1
common error that	1
common language runtime	1
common cause of	2
common programs use	1
common problems with	1
common mathematical functions	1
common mathematical calculations	1
common source of	1
common string functions	1
common platforms with	1
common math functions	1
common subexpression elimination	1
common subexpression elimination,	2
common situation where	1
common implementations of	2
common purposes (www.boost.org).	1
common names. Use	1
common pitfalls of	1
common obstacles to	1
common entry point	1
common time-consumers are	1
common excuse that	1
common subexpressions, and	1
common denominator can	1
common denominator: //	1
common subexpressions that	1
common practice to	1
common sub-expressions. Why	1
a, a &	1
a, a |	2
a, a ||	1
a, int x[])	1
a, but they	1
a, b and	1
a, float b)	1
a, b; a	8
a, b; //	2
a, b; double	1
a, b; b	1
a, b, c	1
a, b, c;	7
a, b, c,	8
a, bool b)	4
a, T const	1
a, sizeof(b)); 47	1
thread is used	1
thread is waiting	1
thread is terminated.	1
thread to a	2
thread in which	1
thread in systems	1
thread that runs	1
thread that shares	1
thread are smaller.	1
thread can then	1
thread can do	2
thread can take	1
thread can possibly	1
thread function so	1
thread if the	1
thread if it	1
thread if there	1
thread with lower	1
thread as very	1
thread than to	1
thread than another.	1
thread may run	1
thread have a	1
thread will always	1
thread will get	1
thread will run	1
thread has its	1
thread should then	1
thread void DelayFiveSeconds()	1
thread its own	1
thread does not	1
thread running in	1
thread safe if	1
thread priority before	1
thread jumps between	1
thread environment block.	1
thread steals resources	1
thread affinity mask.	1
thread scheduler. This	1
thread increments seconds.	1
etc. is still	1
etc. is considerable.	1
etc. of only	1
etc. and the	1
etc. in vectors.	1
etc. The C++	1
etc. The problem	1
etc. The efficiency	1
etc. The worst	1
etc. for Windows,	1
etc. for Linux)	1
etc. are implemented	1
etc. are defined	1
etc. // Returns	1
etc. This means	1
etc. may have	1
etc. then there	1
etc. It is	1
etc. at compile	1
etc. should be	1
etc. In most	1
etc. In cases	1
etc. In large	1
etc. There are	1
etc. For example:	1
etc. Use an	1
etc. But program	1
etc. But beware	1
etc. These counters	1
etc. #define Alignd(X)	1
etc. Optimizing database	1
etc. scattered around	1
etc. And it	1
etc. Whether you	1
etc. (Intel CPU	1
etc. SSSE3 a	1
etc. -msse3 -mssse3	1
etc. Event-based sampling	1
etc. Locked mutexes.	1
etc. Accessibility guidelines	1
etc. Overriding the	1
AMD and Intel	1
AMD and VIA	15
AMD and VIA.	1
AMD or VIA	1
AMD only _mm_permutevar_ps	1
AMD processors and	1
AMD processors are	1
AMD CPUs use	1
AMD CPUs (See	1
AMD AMD Math	1
AMD CPUs. The	1
AMD CPUs. New	1
AMD math core	1
AMD processors, but	1
AMD Math core	1
AMD Core Math	1
AMD CodeAnalyst. There	1
AMD CodeAnalyst. Unfortunately,	1
AMD Opteron K8	3
AMD LIBM library.	1
AMD LIBM Library	1
AMD FMA4 fma4intrin.h	1
AMD SSE4A ammintrin.h	1
AMD XOP ammintrin.h	1
AMD Family 15h	1
compile the program	2
compile the shared	1
compile the output	1
compile a shared	1
compile for different	1
compile with the	2
compile with -mcmodel=large,	1
compile time to	1
compile time and	1
compile time or	2
compile time then	1
compile time because	1
compile time which	1
compile time so	1
compile time rather	2
compile time while	1
compile time here.	1
compile time. The	2
compile time. //	1
compile time. A	2
compile time. For	2
compile time. Some	1
compile time. Integer	1
compile time. No	1
compile time. Templates	1
compile time. Are	1
compile time. Text	1
compile time. Four	1
compile time. (Of	1
compile time. (Examples	1
compile them separately	1
compile time, but	1
compile for. The	1
compile time? If	1
exception is costly	1
exception is caught	1
exception in case	2
exception for floating	1
exception or other	1
exception then F1	1
exception so that	1
exception without using	1
exception handling is	2
exception handling and	1
exception handling in	1
exception handling for	2
exception handling can	1
exception handling then	1
exception handling takes	1
exception handling even	1
exception handling system	1
exception handling option	1
exception handling support	1
exception handling unless	1
exception handling information.	1
exception handling Exception	1
exception handling /EHs-	1
exception safe if	1
exception occurs in	1
exception occurs somewhere	1
exception handling. It	1
exception handling. See	1
exception handling. 8.6	1
exception handling. Omitting	1
exception ever happens.	1
exception handler to	1
exception handler in	1
exception handler needs	1
exception safe. In	1
exception handler, even	1
exception handlers for	1
allocated is also	2
allocated to each	1
allocated and the	1
allocated and deallocated	2
allocated in sequence	1
allocated for an	1
allocated with new	2
allocated with alloca,	1
allocated memory is	1
allocated memory may	1
allocated memory into	1
allocated memory block.	1
allocated memory Memory	1
allocated array may	1
allocated array into	1
allocated objects and	1
allocated objects are	2
allocated objects with	1
allocated memory. It	1
allocated memory. 9.6	1
allocated resources that	1
allocated resources are	1
allocated dynamically with	1
allocated dynamically when	2
allocated dynamically (with	1
allocated resources. The	1
allocated block. Walking	1
allocated object, and	1
allocated memory, using	1
allocated memory, windows,	1
allocated resource. The	1
allocated separately. The	1
allocated dynamically. The	1
allocated dynamically. Arrays	1
allocated memory................................................................. 120	1
small to cause	1
small and always	1
small and fixed	1
small and changing	1
small in the	1
small that a	1
small that it	1
small or if	3
small or too	1
small code size	1
small as possible	1
small x //	2
small then a	1
small bit at	1
small test program	1
small part of	1
small bits in	1
small block for	1
small piece of	1
small piece at	1
small dynamically allocated	1
small loops (less	1
small fraction of	1
small gain in	1
small enough to	1
small devices if	1
small devices with	1
small embedded systems.	1
small embedded applications	1
small pieces of	2
small devices, as	1
small devices, but	1
small sequences of	1
small microcontrollers: Smaller	1
small subtasks, but	1
small low-power CPUs	1
overflow is another	1
overflow is needed:	1
overflow is "undefined".	1
overflow of the	2
overflow of a	1
overflow of an	1
overflow and works	1
overflow and give	1
overflow and negative	1
overflow and loss	1
overflow and underflow	2
overflow and underflow.	1
overflow and redo	1
overflow in the	1
overflow can cause	1
overflow can occur	1
overflow can occur,	1
overflow or another	1
overflow or assume	1
overflow or loss	1
overflow by checking	1
overflow with the	1
overflow on the	1
overflow on input	1
overflow will make	1
overflow has occurred.	1
overflow but no	1
overflow before it	1
overflow doesn't occur	1
overflow Integer to	1
overflow never occurs,	1
overflow outside the	1
overflow condition will	1
overflow condition inside	1
overflow checks where	2
overflow behavior well-defined	1
overflow check. There	1
+= i /	1
+= b; In	1
+= n <<	1
+= x; This	1
+= x; Here,	1
+= 2; Common	1
+= 2) {	3
+= xn /	1
+= 4) {	1
+= a[i]; The	1
+= a[i]; s1	1
+= a[i]; Converting	1
+= 8) {	4
+= 1.0f; This	1
+= 1.0f; }	2
+= i_div_3; }	1
+= i_div_3; list[i+1]	1
+= i_div_3; list[i+2]	1
+= xxn *	1
+= 16) {	1
+= TILESIZE) {	2
+= 2;} //	1
+= list[i]; This	1
+= list[i]; sum2	1
+= A2; //	1
+= a[i+1]; s2	1
+= x^n/n! xxn	1
+= Z; Z	1
+= a[i+2]; s3	1
+= list[i+1];} sum1	1
+= a[i+3]; }	1
+= sum2; If	1
+= 9; }	1
integers is ambiguous	1
integers is costless.	1
integers of the	1
integers of any	1
integers of 8	1
integers of 64	1
integers of 16	1
integers of 32	1
integers to floating	2
integers to signed	1
integers to alias	1
integers and other	1
integers and floating	3
integers and 64-bit	1
integers in 32-bit	1
integers in case	1
integers in 16-bit	1
integers in comparisons,	1
integers are equally	1
integers or floating	1
integers or four	1
integers if the	1
integers with the	1
integers with a	1
integers with hardly	1
integers as Boolean	1
integers - they	1
integers int a,	1
integers use truncation	1
integers from 0	1
integers which range	1
integers In most	1
integers before conversion	1
integers (see page	1
integers simply makes	1
integers Conversion from	1
integers ................................... 141	1
option is also	1
option is less	1
option in the	2
option for the	1
option for all	1
option for assembly	1
option for source	1
option for whole	1
option for assuming	1
option for "assume	1
option for RTTI	1
option for "standard	1
option for "function	1
option that allows	1
option that gives	1
option that limits	1
option if you	1
option then use	1
option only in	1
option makes the	2
option available. Some	1
option -fpic according	1
option -fno-pic and	1
option -fno-pic when	1
option -fno-pic apparently	1
option -fno-builtin to	1
option -fpie because	1
option -fpie instead	1
option "assume no	1
option /MT). In	1
option -mveclibabi=acml. Agner's	1
option -ftrapv, but	1
option /QaxAVX or	1
option (Windows: /Gy,	1
option -fwrapv or	1
option -read_only_relocs suppress.	1
option -mveclibabi=svml. This	1
option -Wstrict-overflow=2, or	1
good to have	1
good to do	1
good for the	2
good for making	1
good for optimizing	1
good if you	1
good code performance	1
good as the	2
good as possible.	1
good as expected.	1
good compiler can	2
good compiler will	2
good at optimizing	1
good compilers and	1
good compilers will	1
good performance and	1
good performance for	1
good way of	1
good way to	1
good optimization options.	1
good optimizing compiler	1
good implementation of	1
good implementation uses	1
good development tools,	1
good choice for	4
good idea to	3
good deal of	2
good investment. A	1
good performance). Aligned	1
good knowledge of	1
power of the	2
power of 2	22
power of 10	2
power of 2.	5
power of 2,	1
power of N	1
power of 2:	1
power of two.	1
power function when	1
power than PCs.	1
power using loop	1
power using template	1
power consumption are	1
matrix is the	1
matrix is a	3
matrix is so	1
matrix is bigger	1
matrix a in	1
matrix a power	1
matrix and stores	1
matrix in my	1
matrix in STL	1
matrix for use	1
matrix // function	2
matrix // call	1
matrix // define	1
matrix or multidimensional	2
matrix on a	1
matrix when the	1
matrix when contentions	1
matrix using example	1
matrix size causes	2
matrix into smaller	1
matrix void TransposeCopy(double	2
matrix line size.	1
matrix line (in	1
matrix longer than	1
matrix 512 520	1
matrix sizes were	1
matrix happen to	1
matrix element. The	1
matrix line. The	1
matrix 96 void	1
matrix sizes. The	1
matrix cell for	1
matrix a: //	1
Linux is that	1
Linux is more	1
Linux and 32-bit	1
Linux and Windows	2
Linux and supported	1
Linux and Mac	3
Linux and BSD	1
Linux and BSD,	1
Linux and perhaps	1
Linux and Mac.	1
Linux and BSD.	2
Linux in almost	1
Linux The procedure	1
Linux with Microsoft,	1
Linux as well	1
Linux than in	3
Linux have an	1
Linux Intel compiler	3
Linux also applies	1
Linux operating systems	1
Linux systems. The	1
Linux platform n.a.	1
Linux syntax 90	1
Linux platforms if	1
Linux compiler, or	1
Linux Shared objects	1
Linux platforms, and	1
Linux __INTEL_COMPILER __INTEL_COMPILER	1
Linux kernel version	1
Linux Align by	1
Linux Optimize for	1
been a power	1
been stored in	1
been called before.	1
been accessed recently	1
been allocated is	1
been replaced by	1
been tested in	1
been tested only	1
been given a	1
been reduced from	1
been initialized to	1
been copied to	1
been defined in	1
been added and	1
been increased from	1
been updated since	1
been updated lately.	1
been doubled. Thin	1
been loaded. This	1
been translated to	1
been deallocated. The	1
been deallocated. Failure	1
been added? If	2
been incremented to	1
been lost at	1
been incremented, while	1
been reordered, inlined,	1
been alleviated in	1
been identified, then	1
been found, then	1
been unsatisfied with	1
been calculated. Therefore,	1
been introduced in	1
been criticized for	1
been brutally interrupted.	1
been identified. My	1
been wasted. The	1
been allocated. If	1
cause the memory	1
cause the cache	1
cause the software	1
cause the heap	1
cause the creation	1
cause the resource-hungry	1
cause a cache	1
cause a lot	1
cause a waste	1
cause a loss	1
cause of errors	1
cause of reduced	1
cause of unacceptably	1
cause other variables	1
cause all kinds	1
cause cache contentions	1
cause cache contentions.	1
cause branch mispredictions	1
cause large delays.	1
cause overflow in	1
cause overflow or	1
cause problems if	1
cause problems when	1
cause caching problems	1
cause contentions in	3
cause errors if	1
cause overflow. For	1
cause overflow. Example:	1
cause seven memory	1
cause overflow, this	1
cause unpredictable errors	1
cause delays in	1
cause complications with	1
cause slight imprecision	1
cause severe delays	1
cause fatal errors	1
cause holes of	1
AVX is supported	2
AVX and later	1
AVX or later	2
AVX code to	2
AVX int 32	1
AVX only when	1
AVX instruction set	7
AVX instruction set.	1
AVX instruction set,	1
AVX using CPU	1
AVX double 64	1
AVX version int	1
AVX version 127	1
AVX 32 instruction	1
AVX instructions have	1
AVX support and	1
AVX support then	1
AVX support calls	1
AVX supported return	1
AVX supported CriticalFunction	1
AVX 256 bit	1
AVX instructions. The	1
AVX instructions. A	1
AVX support. There	1
AVX part. If	2
AVX instr. set	1
AVX support, then	1
AVX _mm256_permutevar_ps 4	1
AVX immintrin.h AMD	1
classes is just	1
classes and using	1
classes and member	1
classes and overloaded	1
classes and templates	1
classes in the	3
classes that use	1
classes are given	1
classes are generally	1
classes are currently	1
classes can also	1
classes // Function	1
classes or modify	1
classes or structures.	1
classes with destructors	1
classes on page	1
classes than by	1
classes use dynamic	2
classes void SelectAddMul(short	1
classes like string,	1
classes #include "vectorclass.h"	1
classes defined in	2
classes allocate a	1
classes implement the	1
classes contain the	1
classes Agner's vector	1
classes Fortunately, it	1
classes ............................................................................................. 113	1
classes Whenever dynamic	1
classes ..................................................................................................... 93	1
classes looks like	1
classes Programming in	1
classes (Intel) #include	1
classes 114 #include	1
classes Nowadays, programming	1
done the job	1
done a good	1
done to choose	1
done in a	2
done in big	1
done in connection	1
done by the	3
done by copying	1
done by multiplying	1
done by declaring	1
done by me	1
done by controlling	1
done by fetching,	1
done with the	3
done with a	2
done with an	1
done with long	1
done with single	1
done with just	1
done on the	1
done as a	1
done at the	1
done at compile	1
done at every	1
done at runtime	1
done only once.	1
done only once,	1
done every time	1
done simply by	1
done outside the	1
done under the	1
done manually by	1
done implicitly when	1
therefore the system	1
therefore a good	1
therefore be a	1
therefore be used	1
therefore be advantageous	2
therefore be aware	1
therefore it is	1
therefore as efficient	1
therefore as fast	1
therefore not be	1
therefore not possible	1
therefore not advantageous	1
therefore not recommended	1
therefore more error	1
therefore more safe	1
therefore possible for	1
therefore cannot do	1
therefore need modification	1
therefore important to	1
therefore necessary to	3
therefore likely to	1
therefore certain to	1
therefore count as	1
therefore recommended to	1
therefore recommended that	1
therefore preferably be	2
therefore preferably have	1
therefore difficult to	1
therefore fail to	2
therefore equal to	1
therefore becoming more	1
therefore safer to	1
therefore suffer from	1
therefore conclude that	1
precision is not	1
precision is good	1
precision is used.	1
precision of approximately	1
precision to double	1
precision in all	1
precision in 32-bit	1
precision in programs	1
precision for reasons	1
precision or by	1
precision or double	1
precision or four	1
precision or eight	1
precision if you	1
precision by default,	1
precision on most	1
precision as the	1
precision than for	1
precision when the	2
precision takes only	1
precision variables in	2
precision before multiplying	1
precision without worrying	1
precision constant and	1
precision (see page	1
precision calculations are	1
precision calculations take	1
precision conversion instructions	1
precision conversion Conversions	1
precision requires only	1
precision require precision	1
precision math allow	1
precision constant. It	1
precision math. Memory	1
precision math. Libraries	1
precision division, square	1
precision (80 bits).	1
line is implicitly	1
line to be	1
line in both	1
line that we	1
line that was	1
line that covered	1
line can hold	1
line or a	1
line or an	1
line if you	1
line by any	1
line by line	1
line with all	1
line when it	1
line will be	1
line then the	1
line at a	2
line has to	1
line size is	1
line size of	2
line size in	1
line size //	1
line size may	1
line size (typically	1
line number information.	1
line doesn't work	1
line would be	1
line options relevant	1
line size. I	1
line containing the	1
line size, which	1
line separately through	1
line (in bytes)	1
line covers 64	1
line provokes an	1
line 29. Each	1
line written. This	1
works is of	1
works and suggests	1
works in the	2
works for any	1
works by compiling	1
works with all	1
works on all	1
works on Intel	1
works more efficiently	1
works then you	1
works only for	4
works only if	2
works only with	1
works only on	1
works most efficiently	3
works less efficiently	1
works even if	1
works best if	1
works best on	4
works well on	2
works particularly bad	1
works automatically. However,	1
works best. Some	1
works differently. The	1
works correctly. A	1
works somewhat less	1
works (gcc v.	1
optimized is to	1
optimized and fine-tuned	1
optimized for the	1
optimized for is	1
optimized for a	1
optimized for SSE2	1
optimized for large	1
optimized for execution	1
optimized for accessing	1
optimized for 16-bit	1
optimized function libraries	1
optimized function libraries.	1
optimized if a	1
optimized by using	1
optimized code with	1
optimized code will	1
optimized code because	1
optimized code looks	1
optimized code (release	1
optimized as good	1
optimized program is	1
optimized Intel function	1
optimized version of	1
optimized version because	1
optimized software design,	1
optimized part of	1
optimized versions of	1
optimized mathematical functions.	1
optimized function, but	1
optimized math function	1
optimized to: //	1
optimized away and	1
optimized well, others	1
optimized programs. The	1
optimized away. It	1
optimized away. Note	1
optimized further. The	1
optimized yet. Supports	1
inside the function	3
inside the CPU	2
inside the loop	6
inside the class	1
inside the critical	1
inside the function.	1
inside the innermost	1
inside the loop.	3
inside the class.	1
inside the derived	1
inside the pow	1
inside the loop,	1
inside the template.	1
inside a function	3
inside a loop	1
inside a class	3
inside can be	1
inside one function,	1
inside another loop	1
inside your program	1
inside containers should	1
inside {} brackets.	1
inside sqaure: for	1
inside square: //	1
manual is for	1
manual is number	1
manual is also	1
manual is based	2
manual for your	1
manual for my	1
manual for reasons	1
manual for details.	2
manual or in	1
manual on usability,	1
manual will soon	1
manual at www.agner.org/optimize/cppexamples.zip	2
manual at www.agner.org/optimize/cppexamples.zip.	1
manual does not	1
manual 3: "The	7
manual 2: "Optimizing	3
manual 5: calling	1
manual 5: "Calling	5
manual currently doesn't	1
manual discusses how	1
manual 4: "Instruction	2
/ b as	1
/ 2 (be	1
/ 4 =	1
/ 8 =	1
/ unsigned conversion	1
/ c; a	1
/ means integer	1
/ b) is	1
/ b) etc.	1
/ b) >>	1
/ 3; }	1
/ 10; a	2
/ 10; //	1
/ CodeGear /	1
/ 16; a	1
/ 16; //	1
/ b2; This	1
/ (number of	1
/ 64) %	1
/ sar ebx,1	1
/ jl $B1$2	1
/ c) 139	1
/ (line size)	1
/ x64 (Visual	1
/ shr ebx,31	1
/ 4; The	1
/ 4; Register	1
/ (b1*b2); The	1
/ nfac; xn	1
/ 1.2345; Change	1
/ b1; y2	1
/ 1.2345); The	1
/ (b1 *	1
/ 0x40) %	1
/ 3.0; The	1
/ Embarcadero Comes	1
explained in the	5
explained in example	1
explained in manual	1
explained in chapter	1
explained in detail	1
explained on page	18
explained at page	1
explained below. The	1
explained below. There	1
explained below. Shared	2
explained below on	1
explained above, the	1
explained above, so	1
explained above. A	1
explained above. Examples	1
calculated the first	1
calculated the fastest	1
calculated in advance	2
calculated in advance.	1
calculated by the	1
calculated by a	1
calculated by an	2
calculated by n	1
calculated by adding	1
calculated with the	1
calculated with two	1
calculated as follows:	1
calculated as (critical	1
calculated as (b*2.0)/3.0	1
calculated as ((a+b)+c)+d.	1
calculated more efficiently	1
calculated from the	3
calculated from a	1
calculated at compile	2
calculated using multiplications	1
calculated faster than	1
calculated much faster	1
calculated fast if	1
calculated value. The	1
calculated result. Example:	1
calculated twice because	1
calculated first, then	1
calculated once, rather	1
calculated internally as	1
calculated independently. The	1
calculated asa <<	1
calculated as(a <<	1
calculation is more	1
calculation of the	5
calculation of this	1
calculation of A	3
calculation of one	2
calculation of expressions	1
calculation of graphics	1
calculation of B	1
calculation of self-relative	1
calculation of c+b	1
calculation of B.	1
calculation of (a+b).	1
calculation and table	1
calculation in a	2
calculation in 64	1
calculation may be	1
calculation time is	2
calculation time of	1
calculation more efficient:	1
calculation time. A	1
calculation implemented with	1
calculation becomes easier	1
calculation requires n-1	1
calculation here gives	1
calculation depends on	2
calculation faster. The	1
calculation capabilities. Here	1
}; The values	1
}; The offset	1
}; // The	1
}; // constant	1
}; // Function	1
}; // Make	1
}; // Any	1
}; // Index	1
}; // Full	2
}; // Called	1
}; // Partial	1
}; if ((unsigned	1
}; if (y)	1
}; int order(int	1
}; int Sum2(S3	1
}; class C1	1
}; class CChild2	1
}; class C2	1
}; void test	2
}; void F1()	1
}; void g()	1
}; void Func()	1
}; char abc;	1
}; S1 ArrayOfStructures[100];	1
}; struct Sdouble	1
}; struct Slongdouble	1
}; Bitfield x;	2
}; Weekdays Day;	2
}; Replace with:	1
}; 7.23 Constructors	1
}; 52 or	1
}; vector() {}	1
128 function cannot	1
128 because the	1
128 double 128	1
128 float 256	1
128 bit vector	3
128 bit integer	1
128 bit float	1
128 SSE2 int	1
128 SSE2 float	1
128 SSE2 long	1
128 SSE2 short	1
128 SSE2 char	1
128 bits (XMM),	1
128 bits (XMM)	1
128 bytes or	1
128 bytes then	1
128 bytes Intel	1
128 bytes AMD	1
128 128 128	1
128 128 17.4	1
128 below. Dispatch	1
128 == 0)	1
128 bytes. 7.19	1
128 SSE double	1
128 Is16vec8 Vec8s	1
128 13.7 CPU	1
128 Is8vec16 Vec16c	1
128 Iu32vec4 Vec4ui	1
128 17.4 129	1
128 Is32vec4 Vec4i	1
128 I64vec2 Vec2q	1
128 Vec2uq 8	1
128 Iu8vec16 Vec16uc	1
128 Iu16vec8 Vec8us	1
uses the cache	1
uses the new	1
uses the dispatch	1
uses a different	1
uses a lot	2
uses a lookup	1
uses a newer	1
uses a procedure	1
uses a GOT.	1
uses of a	1
uses of dynamic	1
uses by looking	1
uses an unfortunate	1
uses an ordinary	1
uses more than	1
uses more cache	1
uses more clock	1
uses more bits	1
uses CPU dispatching:	1
uses most of	1
uses many small	1
uses 32-bit absolute	1
uses 64 bits.	1
uses pointers because	1
uses new and	1
uses 32 bits	1
uses much more	1
uses few resources.	1
uses XMM registers	1
uses position-independent code	1
uses ebx as	1
uses logarithms in	1
uses 90% of	1
uses SSE3. //	1
uses (live ranges)	1
four function parameters	1
four cache lines	3
four double precision	1
four float additions	1
four elements of	1
four single precision	1
four integers of	1
four parameters to	1
four parameters are	1
four numbers of	1
four numbers at	1
four results in	1
four consecutive terms	1
four kinds of	1
four cores can	1
four (or eight)	1
four additions in	1
four parameters. There	1
four B value	1
four places back.	1
four physical processors	1
four objects. STL	1
four floats F32vec4	1
four bits, and	1
four numbers, then	1
four multiplications. How	1
four float. The	1
four x^n }	1
four G values	1
four R value	1
four float's when	1
four float's fits	1
four sums }	1
four floats. The	1
functions. The code	1
functions. The compiler	1
functions. The floating	1
functions. The template	1
functions. The following	1
functions. The difference	1
functions. The second	2
functions. The 'this'	1
functions. The CPU-	1
functions. This is	1
functions. This so-called	1
functions. This applies	1
functions. A static	2
functions. A lot	1
functions. A frame	1
functions. A metaprogramming	1
functions. A thread-safe	1
functions. It is	2
functions. It also	1
functions. There is	1
functions. You can	1
functions. See page	1
functions. I disagree	1
functions. Many function	1
functions. Avoid virtual	1
functions. Alternatively, you	1
functions. 80 Unfortunately,	1
functions. While an	1
functions. 7.4 Enums	1
functions. 7.27 Overloaded	1
functions. 9.4 Variables	1
functions. Sum1 has	1
functions. Time- consuming	1
another function and	1
another function with	1
another function which	1
another function library	1
another function F2	1
another by assignment.	1
another memory access.	1
another vector register	1
another loop that	1
another C++ program	1
another version for	1
another way than	1
another dynamic library	1
another part of	1
another error has	1
another thread is	1
another thread can	1
another thread will	1
another thread void	1
another source file.	1
another addition to	1
another function, etc.,	1
another compiler. 2.6	1
another class. It	1
another thread. This	1
another thread. If	1
another problem. The	1
another array. The	1
another dispatched function	1
another security problem.	1
another computer. The	1
another exception. 64	1
another module. The	2
another module. This	1
another platform. 14.8	1
parameters a and	1
parameters of the	1
parameters to a	1
parameters to be	4
parameters and the	1
parameters that are	1
parameters are not	1
parameters are stored	1
parameters are always	1
parameters are transferred	9
parameters are replaced	1
parameters are exactly	1
parameters are evaluated	1
parameters on the	1
parameters on CodeGear	1
parameters then the	1
parameters then make	1
parameters because of	1
parameters Function parameters	1
parameters would be	1
parameters replaced by	1
parameters ............................................................................................... 50	1
parameters typedef int	1
parameters Vec4f polynomial	1
parameters differ then	1
get the same	1
get the value	2
get the generic	1
get the exact	1
get a compiler	1
get a good	2
get a lot	1
get a better	1
get a misprediction	1
get a realistic	1
get a reply	1
get as much	1
get an integral	1
get x to	1
get time slices	1
get more reproducible	1
get used to	1
get one instance	1
get no warning	1
get library versions	1
get any answer.	1
get very expensive	1
get access to	1
get 0 rather	1
get its own	1
get four float	1
get next each	1
get reliable results	1
get reproducible results.	1
get ReadTSC as	1
get rid of	3
get answers to	1
b; a =	10
b; a +=	1
b; for (i	1
b; // 4	1
b; // 8	1
b; // everything	1
b; // Critical	1
b; if (b)	2
b; This is	1
b; int c;	1
b; int d;	1
b; int c;};	1
b; int Sum1()	1
b; A branch	1
b; will make	1
b; } A	1
b; } else	1
b; double c;	1
b; b =	2
b; static const	1
b; In this	1
b; c =	1
b; Here, I	1
b; d =	2
check the code	1
check the order	1
check the final	1
check is bypassed	1
check for the	2
check for CPU	1
check for all	1
check for integer	1
check for array	1
check for overflow	6
check for buffer	1
check for overflow.	2
check for exceptions	1
check that the	1
check that thrown	1
check if the	2
check if a	1
check if it	1
check if an	1
check if your	1
check if XMM	1
check if nonzero	1
check on b	1
check on n	1
check makes dynamic_cast	1
check before the	1
check whether an	1
check after the	1
advantageous the smaller	1
advantageous to use	8
advantageous to make	1
advantageous to do	2
advantageous to replace	1
advantageous to put	2
advantageous to mix	2
advantageous to keep	1
advantageous to roll	1
advantageous to split	1
advantageous in most	1
advantageous in cases	1
advantageous for applications	1
advantageous or not.	1
advantageous if the	4
advantageous if a	1
advantageous by itself.	1
advantageous as replacements	1
advantageous when a	1
advantageous then it	1
advantageous because registers	1
advantageous vectorization is.	1
advantageous if, and	1
implemented a separate	1
implemented a collection	1
implemented in the	2
implemented in a	3
implemented in different	1
implemented in compiled	2
implemented in hardware	1
implemented in various	1
implemented in PC	1
implemented by the	1
implemented by (partial)	1
implemented with an	1
implemented with template	1
implemented with intrinsic	1
implemented with interpretation.	1
implemented on a	1
implemented on other	1
implemented as a	6
implemented as vector	1
implemented as three	1
implemented as follows	1
implemented as recursive	1
implemented simply by	1
implemented like this	1
implemented either as	2
implemented internally as	1
problem is to	4
problem is that	1
problem is likely	1
problem is too	1
problem of the	1
problem and make	1
problem and assume	1
problem in interactive	1
problem that the	1
problem that were	1
problem are the	1
problem can be	2
problem if the	2
problem by increasing	1
problem by defining	1
problem by bypassing	1
problem with the	1
problem with this	1
problem with vector	1
problem with accessing	1
problem with macros	1
problem when the	1
problem when mixing	1
problem then it	1
problem has been	1
problem only occurs	1
problem cannot easily	1
problem void AddTwo(int	1
problem here is	1
problem since we	1
known to the	1
known to be	4
known in 36	1
known with certainty	1
known as memory	2
known then it	1
known from a	1
known at this	1
known at compile	15
known at compile-time	1
known CPU model	1
known which version	1
known before the	2
known hardware CPU.	1
known processors. Other	1
known type, but	1
(i = 0;	26
(i = 2;	1
(i = StringLength;	1
(i = (int)n	1
(i < 0	1
(i < ARRAYSIZE	1
(i < arraysize)	1
(i >= min	1
(i >= N)	1
(i % 2	1
solution is the	1
solution is a	1
solution is to	6
solution is more	1
solution is using	1
solution is best	1
solution is optimal	1
solution is too	1
solution is clearly	1
solution a =	1
solution of making	2
solution to this	2
solution to make	1
solution to these	1
solution in this	1
solution in such	1
solution in some	1
solution for the	1
solution that doesn't	1
solution can still	1
solution can incur	1
solution on future	1
solution may be	1
solution you prefer	1
solution because the	1
solution because of	1
solution where a	1
solution would be	1
container is to	1
container is too	1
container for a	1
container for each	1
container for exclusive	1
container that contains	1
container that allows	1
container be recycled?	1
container are allowed	1
container or memory	1
container than to	1
container may move	1
container class that	2
container class libraries	1
container class must	1
container class templates	1
container class templates,	1
container elements are	1
container rather than	1
container without dynamic	1
container classes and	1
container classes in	2
container classes that	1
container classes are	1
container classes or	1
container classes on	1
container classes use	1
container class. The	1
container classes. The	1
container classes. An	1
container classes. Unfortunately,	1
container classes. Text	1
container expandable, but	1
advantage of the	3
advantage of a	1
advantage of this	4
advantage of vector	1
advantage of using	5
advantage of static	1
advantage of 64-bit	2
advantage of these	1
advantage of bigger	1
advantage of out-of-order	2
advantage of sharing	1
advantage to using	2
advantage to unroll	1
advantage to obtain,	1
advantage in the	1
advantage in using	1
advantage in applications	1
advantage in interpreted	1
advantage that the	1
advantage that it	1
advantage if the	1
advantage because integer	1
advantage comes automatically.	1
Function to store	4
Function to load	4
Function with vector	1
Function pointer initially	1
Function pointer serves	1
Function return types	2
Function libraries can	2
Function template for	1
Function pointers ......................................................................................................	1
Function pointers Calling	1
Function calls may	1
Function parameters that	1
Function parameters are	4
Function parameters Function	1
Function parameters ...............................................................................................	1
Function addresses are	1
Function inlining The	1
Function inlining can	1
Function inlining has	1
Function inlining x-xxxx--x	1
Function names are	1
Function level linking	1
Function prototype CriticalFunctionType	1
Function Assembly name	1
support the necessary	1
support the SSE	1
support the ADX	1
support a new	1
support of the	1
support and is	1
support and another	1
support in the	1
support for the	2
support for 64-bit	1
support for exception	1
support for inline	1
support for intrinsic	2
support for runtime	1
support for XMM	1
support for relative	1
support for whole	1
support for calculating	1
support for hard	1
support for multiplying	1
support this instruction	1
support then call	1
support from both	1
support different CPUs.	1
support which is	1
support static linking.	1
support 32-bit and	1
support calls a	1
support processor X"	1
support intrinsic functions.	1
support it. There	1
support anyway. The	1
support SSE. Several	1
supported in the	1
supported in such	1
supported in Windows	1
supported by the	8
supported by all	1
supported by most	1
supported by some	1
supported by both	1
supported by Microsoft,	1
supported on all	2
supported on AMD	1
supported at all.	1
supported instruction set	2
supported instruction sets	1
supported instruction set.	1
supported instruction set,	2
supported instruction sets,	1
supported return &CriticalFunction_SSE2;	1
supported return &CriticalFunction_AVX;	1
supported 128-bit vector	1
supported CriticalFunction =	2
supported 256-bit instructions	1
supported fprintf(stderr, "\nError:	1
eight to fit	4
eight in 32-bit	1
eight or sixteen	1
eight different cache	1
eight floating point	3
eight elements in	1
eight elements will	1
eight elements at	2
eight times because	1
eight threads simultaneously.	1
eight single precision	1
eight integers of	1
eight numbers of	1
eight consecutive elements	12
eight 16-bit integers	1
eight 16-bit integers.	1
eight logical processors.	1
operators is more	1
operators and functions	1
operators The pre-increment	1
operators for things	1
operators for checking	2
operators that have	2
operators that produce	1
operators are single	1
operators are calculated	1
operators are inlined	1
operators on integer	1
operators will cause	1
operators because they	1
operators using integers	1
operators also applies	1
operators new and	1
operators An overloaded	1
operators Integer operations	1
operators Integer sizes	1
operators && and	1
operators produce a	1
operators produce 32	1
operators (e.g. '>')	1
operators Modern microprocessors	1
operators ............................................................................................. 56	1
operators &, |,	3
operators ...................................................................... 32	1
operators &&, ||,	1
operators (& and	1
operators (&& and	1
few of the	1
few or no	1
few more integer	1
few functions that	1
few compilers are	1
few clock cycles	6
few clock cycles,	1
few cases where	2
few instructions that	1
few times may	1
few extra instructions	1
few arrays of	1
few programs do.	1
few cases, however,	1
few branches as	1
few unused points	1
few lines should	1
few resources. On	1
few parameters. Or	1
few machine instructions.	1
few files, preferably	1
few pitfalls here.	1
few lines. A	1
few restrictions on	1
few kilobytes at	1
few comments about	1
few decades ago,	1
few places. Constant	1
contains the address	4
contains a function	1
contains a lot	1
contains a negative	1
contains a positive	1
contains only a	1
contains only simple	1
contains only six	1
contains integer division:	1
contains no calls	1
contains no absolute	1
contains floating point	1
contains many functions	2
contains many variables	1
contains many useful	1
contains any member	1
contains any non-polymorphic	1
contains calls to	1
contains several branches	1
contains optimized mathematical	1
contains various functions	1
contains automatic CPU	1
contains examples of	1
contains similar functions,	1
contains debug information	1
contains well-tested libraries	1
contains natural parallelism.	1
contains complete code	1
contains i/2+r. The	1
contains writeable data.	1
whether the code	1
whether the compiler	1
whether the different	1
whether the object	1
whether the call	1
whether the arrays	2
whether the processor	1
whether the second	1
whether the positive	1
whether the largest	1
whether the original	1
whether a particular	1
whether to use	1
whether to store	1
whether to repeat	1
whether to base	1
whether it is	6
whether an integer	1
whether you are	1
whether you use	1
whether there is	1
whether they are	1
whether they were	1
whether r is	1
whether p is	1
whether vectorization will	1
whether CriticalFunction is	1
whether others have	1
i++) is the	1
i++) for (j	1
i++) { //	4
i++) { if	1
i++) { ...	1
i++) { a[i]	7
i++) { temp	1
i++) { j	2
i++) { b[i]	1
i++) { aa[i]	2
i++) { list[i].a	1
i++) { time1	1
i++) { ab[i].b	1
i++) { 92	1
i++) a[i] =	2
i++) sum +=	3
i++) f *=	1
i++) b[i] =	1
i++) List[i]++; Here,	1
i++) matrix[FuncRow(i)][FuncCol(i)] +=	1
list is the	1
list is a	1
list is less	1
list is large	1
list is almost	1
list of which	3
list of some	1
list of short	1
list of processors	1
list of processor	2
list of data.	1
list of numbers:	1
list of titles.	1
list and make	1
list in example	1
list can be	1
list or a	1
list or with	1
list with a	1
list from static	1
list has its	1
list should preferably	1
list float a[100];	1
list takes more	1
list does not	1
list (see page	1
list every time	1
list needs to	1
list points out	1
list causes all	1
list plus i*sizeof(S1).	1
would of course	1
would be to	1
would be an	1
would be 8	1
would be even	1
would be while	1
would be able	1
would be needed	1
would be transferred	1
would be predicted	1
would be invalid	2
would be obvious	1
would be straightforward.	1
would be evicted.	1
would be re-calculated	1
would not only	1
would have to	1
would have spent	1
would make the	2
would only read	1
would all be	1
would double the	1
would take longer	1
would cause overflow	1
would like to	1
would give annoyingly	1
would assume that	1
would know that	1
would require two	1
would still be	1
would otherwise go	1
likely is a	1
likely to be	13
likely to use	1
likely to work	1
likely to cause	1
likely to run	1
likely to inline	1
likely to generate	1
likely to require	1
likely to go	1
likely to execute	1
likely to fail	1
likely to consume	1
likely to lead	1
likely to experience.	1
likely in a	1
likely that the	1
likely that code	1
likely that memory	1
likely be called,	1
likely case that	1
structure is a	1
structure is simply	1
structure is created.	1
structure of the	1
structure of a	1
structure of four	1
structure to make	1
structure and then	1
structure and class	1
structure and clarity	1
structure in example	1
structure in some	1
structure that can	1
structure are stored	1
structure or class	7
structure or each	1
structure or union	1
structure or class.	2
structure then you	1
structure has one	1
structure object takes	1
structure where data	1
structure 8 bytes	1
structure }; 52	1
structure y into	1
structure needed? A	1
doing the same	3
doing the optimizations	1
doing the heavy	1
doing the division.	1
doing the spell	1
doing a sequence	1
doing an addition	1
doing different kinds	1
doing floating point	2
doing multiple calculations	3
doing multiple logically	1
doing two or	1
doing two iterations	1
doing some calculations	1
doing type conversions:	1
doing calculations on	1
doing mathematical calculations.	1
doing optimizations on	1
doing things only	1
doing whole program	1
doing out-of-order execution,	1
doing parallel calculations	1
doing something on	1
doing arithmetic operations.	1
doing exactly the	1
doing equivalent reductions	1
doing calculations, and	1
doing divisions. It	1
run the program	1
run the most	1
run the optimized	1
run the advanced	1
run a little	1
run a speed-critical	1
run in the	1
run in a	1
run in an	1
run in both	1
run in parallel.	1
run with a	1
run with reduced	1
run on a	1
run on its	1
run on Mac	1
run an inferior	1
run at more	1
run at less	1
run only if	1
run most of	1
run two threads	2
run many processes	1
run any code	1
run faster than	1
run faster at	1
run faster because	1
run time. Therefore,	1
run eight threads	1
run slightly faster	1
run slower than	1
run optimally on	1
calculate the function	1
calculate the time	1
calculate the same	1
calculate the most	1
calculate the value	2
calculate the table	4
calculate the address	2
calculate the addresses	1
calculate the absolute	1
calculate a vector	1
calculate that the	1
calculate it at	1
calculate it only	1
calculate than the	1
calculate when long	1
calculate which set	1
calculate each value	1
calculate each address	1
calculate how much	1
calculate its address.	1
calculate element addresses	1
calculate xn as	1
calculate self-relative addresses	1
calculate *p+2 a	1
calculate *p+2 and	1
calculate (c+d) before	1
calculate (1./1.2345) at	1
calculate pow(x,10) with	1
inline the function	2
inline the function,	1
inline a function	1
inline and optimize	1
inline or static	1
inline function is	1
inline function instead	1
inline function #define	1
inline int lrint	2
inline int lrintf	1
inline this function	1
inline functions An	1
inline double IntegerPower	1
inline float add_elements(__m128	1
inline void SelectAddMul(short	1
inline void StoreVector(void	3
inline void StoreNTD(double	1
inline void StoreVectorA(void	1
inline assembly or	1
inline assembly on	1
inline assembly code	1
inline assembly instruction	1
inline assembly syntax	1
inline __m128i LoadVector(void	3
inline __m128i LoadVectorA(void	1
inline keyword is	1
inline T max(T	1
every function that	1
every function or	1
every code line.	1
every time the	6
every time a	5
every time it	1
every time an	1
every time they	1
every time Func	1
every clock cycle.	2
every call of	1
every call method.	1
every element in	1
every four objects.	1
every intermediate version.	1
every three clock	1
every second by	1
every iteration of	1
every access. The	1
every version. For	1
every call. A	1
every millisecond. The	1
standard is used	1
standard for specifying	1
standard function library	1
standard function libraries.	1
standard library functions	1
standard libraries for	1
standard libraries are	1
standard template library	2
standard user interface	1
standard stack frame	2
standard solution to	1
standard container classes	1
standard calling conventions.	1
standard operations. All	1
standard tasks are	1
standard tasks such	1
standard header file	1
standard PC processors	3
standard PC platform	1
standard specifies that	1
standard specifies truncation	1
standard C, specifying	2
standard API calls	1
standard PC's in	1
standard PCs. The	1
standard says that	1
standard 754 (1985).	1
hardware is updated.	1
hardware in the	1
hardware for raising	1
hardware can be	1
hardware often requires	1
hardware functions. The	1
hardware support for	3
hardware implementation of	1
hardware implementation in	2
hardware platform and	1
hardware platform The	1
hardware platform for	1
hardware platform has	1
hardware platform .......................................................................................	1
hardware access. Available	1
hardware CPU. These	1
hardware definition code	1
hardware definition language	4
hardware definition language.	1
hardware definition language,	1
hardware conditions. A	1
hardware interfaces and	1
hardware exceptions. The	1
hardware circuits consisting	1
hardware design. The	1
hardware identification. Such	1
1 is certain	1
1 is changed	1
1 to 127	1
1 and that	1
1 for the	1
1 for negative	1
1 for true.	1
1 if nonzero	1
1 by XOR'ing	1
1 - 5.	1
1 from -128	1
1 b =	1
1 64 MMX	1
1 short int,	1
1 (see page	1
1 1 short	1
1 1 char,	1
1 : 0]	1
1 cache. This	1
1 byte =	2
1 byte at	1
1 fraction 2	2
1 ebx, DWORD	1
1 eax, 8	1
1 eax, 100	1
1 int64_t 64	1
1 char, signed	1
1 Introduction This	1
1 Introduction .......................................................................................................................	1
1 0.5ns. 2GHz	1
: b *	2
: c (a&&b)	1
: c x-xx-----	1
: b; }	1
: 1; //	2
: public CHello	2
: public C0	1
: public CParent<CChild1>	2
: public CGrandParent	1
: public B1	1
: public CParent<CChild2>	1
: public B1,	1
: b) y	1
: 8; //	1
: (bb[i] *	1
: 23; //	1
: 0] in	1
: "memory" );	1
: "=m"(n) :	1
: x(0) {};	1
: EXCEPTION_CONTINUE_SEARCH) {	1
: 52; //	1
: 63; //	1
: "m"(x) :	1
: 2.6f; The	1
: 15; //	1
: 2.5f; If	1
: 11; //	1
add the static	1
add the constant	1
add the four	1
add the keyword	1
add the last	1
add a to	1
add a few	1
add to the	1
add or remove	1
add an extra	1
add b and	1
add i to	1
add 2 to	1
add elements };	1
add new features	1
add extra code	1
add add cmp	1
add counter variables	1
add what r	1
add n to	1
add unused columns	1
add mov add	1
add statements like	1
add ebx, DWORD	1
add ebx, eax	1
add functionality to	1
add cmp jl	1
add cmp ja	1
add Divide by	1
add sar add	1
add dummy elements	1
add eax,1 is	1
mode is used	1
mode and some	1
mode and back	2
mode and mostly	1
mode or when	3
mode or enable	1
mode if the	1
mode if SSE2	1
mode than in	2
mode program is	2
mode program are	1
mode has to	1
mode because the	3
mode where the	1
mode so that	1
mode 4 4	1
mode 8 8	1
mode rather than	1
mode program. The	1
mode unless the	1
mode unless you	1
mode SSE 128	1
mode (SSE2): #include	1
mode (SSE): #include	1
mode Parameter transfer	1
store the floating	1
store the table	1
store the result	1
store the four	1
store the values	1
store the information	1
store the shared	1
store the intermediate	1
store the reciprocal	1
store is known	1
store it in	1
store x in	1
store data because	1
store all strings	2
store each object	1
store many objects	1
store objects of	1
store result in	1
store An uncached	1
store intermediate data	1
store intermediate results	1
store aligned integer	1
store operation doesn't	1
store strings in	1
store unaligned integer	3
store help files	1
store application-specific information	1
store forwarding delay	2
values is closest	1
values of a	2
values of all	1
values of its	1
values of nonzero	1
values of A,	1
values in the	2
values in a	1
values are then	1
values are simply	1
values are confined	1
values or if	1
values if they	1
values by hand	1
values than 0	4
values have to	1
values then the	1
values at once	1
values at once...................................	1
values because a	1
values before the	1
values before it	1
values before compilation.	1
values per point.	1
values far from	1
values first, then	1
All the code	1
All the reductions	1
All of these	2
All in all,	1
All code that	1
All you have	1
All functions have	1
All C++ compilers	1
All software should	1
All pointers and	1
All these libraries	1
All these instructions	1
All these problems	1
All these examples	1
All dynamic memory	1
All calculations are	1
All common implementations	1
All optimizing compilers	1
All addresses in	1
All intermediate results	1
All source files	1
All public functions	1
All x86 platforms	1
All global variables	1
All modern x86	1
All identical constants	1
All newer microprocessors	1
All non-static variables	1
All accesses to	1
All disturbing influences	1
sign is stored	1
sign of a	2
sign and rounding	1
sign bit of	8
sign bit to	3
sign bit in	1
sign bit are	1
sign bit //	1
sign bit so	1
sign bit };	1
sign bit set).	1
sign must be	1
sign : 1;	1
sign bit: //	2
sign bit: absvalue	1
sign bit. The	1
sign bit. We	1
sign :1;//signbit };	2
sign bit, the	1
copy the table	1
copy the entire	1
copy the contents	1
copy is dead	1
copy a to	2
copy of the	3
copy of an	1
copy of every	1
copy that the	1
copy matrix void	2
copy Function inlining	1
copy constructor is	1
copy constructor and	2
copy constructor can	1
copy constructor may	1
copy constructor must	1
copy constructor specifying	1
copy protection schemes	3
copy protection scheme	1
copy constructors and	3
copy constructor, if	1
copy constructors, and	1
optimizing the software	1
optimizing the first	1
optimizing a particular	1
optimizing for size	1
optimizing for speed.	1
optimizing // Time	1
optimizing compiler can	4
optimizing compiler may	1
optimizing compiler will	2
optimizing compiler should	1
optimizing compiler would	1
optimizing compiler might	1
optimizing CPU use	1
optimizing compilers can	1
optimizing compilers will	1
optimizing compilers available,	1
optimizing library functions	1
optimizing execution speed	1
optimizing code, as	1
optimizing database access.	1
optimizing away p	1
optimizing away cpuid	1
optimizing features, and	1
optimizing application-specific code.	1
optimizing ............................................................................................... 4	1
optimizing multithreaded applications:	1
optimizing University courses	1
memory. The functions	1
memory. The static	1
memory. The renaming	1
memory. This is	1
memory. This can	1
memory. This may	1
memory. This makes	1
memory. This prevents	1
memory. A register	1
memory. It is	2
memory. It will	1
memory. If the	1
memory. If you	1
memory. If several	1
memory. See the	1
memory. See page	1
memory. Example: //	2
memory. These methods	1
memory. Function parameters	2
memory. Most compilers	1
memory. No information	1
memory. Variables and	1
memory. They may	1
memory. One kilobyte	1
memory. Big arrays	1
memory. Copying constant	1
memory. 9.6 Dynamic	1
memory. Efficient caching	1
well the compiler	1
well the microprocessor	1
well in tests	1
well it optimizes	1
well if the	1
well if it	1
well with non-Intel	1
well on all	1
well on AMD	1
well on non-Intel	2
well as the	1
well as in	1
well as efficient	1
well as pointers	1
well as important	1
well as writing	1
well as directly	1
well as Intel-based	1
well use a	1
well only on	2
well before the	1
well optimized Intel	1
well optimized software	1
well spend more	1
well specify the	1
well developed as	1
well tested, and	1
well documented. The	1
well thought-through approach	1
information is contained	1
information is utilized	1
information to all	1
information to optimize	1
information in the	1
information in a	1
information in order	1
information for the	1
information for function	1
information that we	1
information can be	1
information stored by	1
information about the	8
information about a	1
information about function	1
information about functions	1
information about which	1
information about pointer	1
information about its	1
information about supported	1
information about mathematical	1
information about Func1	1
information about bugs,	1
information elsewhere and	1
simply the address	1
simply a matter	5
simply to increment	1
simply by using	1
simply by copying	1
simply by setting	1
simply by storing	1
simply by comparing	1
simply by performing	1
simply by removing	1
simply by ignoring	1
simply by inverting	1
simply not appropriate	1
simply an integer	1
simply no difference	1
simply makes the	1
simply optimized away	1
simply don't have	1
simply put there	1
simply put 80	1
simply predicted to	1
simply stores the	2
simply zero. Execution	1
simply treated as	1
simply identical. For	1
simply prints an	1
able to do	7
able to avoid	1
able to run	1
able to calculate	1
able to inline	2
able to optimize	1
able to automatically	1
able to see	1
able to generate	1
able to reduce	1
able to find	1
able to mix	1
able to predict	3
able to define	1
able to evaluate	1
able to completely	1
able to recover	2
able to overlap	1
able to reorder	1
able to do,	1
able do function	1
certain to be	3
certain to have	1
certain to become	1
certain to truly	1
certain that the	1
certain that a	2
certain that this	1
certain that u	1
certain Intel CPUs,	1
certain operating system	1
certain programming principles	1
certain instructions that	1
certain calculations are	1
certain parts of	1
certain options are	1
certain conditions are	1
certain tasks on	1
certain kinds of	1
certain optimizations. Do	1
certain rules about	1
certain limit to	1
certain restrictions on	2
certain modification is	1
certain events, for	1
certain events, such	1
certain tolerance. The	1
certain interval: //	1
cycles to do	1
cycles to read	1
cycles to fetch	1
cycles in the	1
cycles for 32-bit	1
cycles that we	1
cycles if it	2
cycles on most	1
cycles on Pentium	1
cycles than other	1
cycles more than	2
cycles then it	1
cycles at the	1
cycles before the	1
cycles rather than	1
cycles even if	1
cycles counter is	1
cycles after the	2
cycles later and	1
cycles per array	1
cycles per element	1
cycles per byte	1
cycles per element.	2
cycles whenever it	1
cycles spent on	1
cycles (depending on	1
... a =	1
... for (i	4
... for (int	2
... can be	1
... // Use	1
... // Call	2
... if (i	2
... int i,	1
... } }	3
... } If	1
... } void	1
... } Here,	1
... then you	1
... There is	1
... return 0;	2
... Here, you	1
... Here you	1
... Conversions between	1
... x.a =	1
... ~C1(); };	1
... list[i &	1
addresses is much	1
addresses is reused	1
addresses of library	1
addresses of array	2
addresses of dynamically	1
addresses to be	1
addresses to function	1
addresses in the	3
addresses in order	1
addresses in 32-bit	1
addresses for one	1
addresses for everything,	1
addresses that need	2
addresses are often	1
addresses are accessed	1
addresses are spaced	1
addresses are obscured	1
addresses with different	1
addresses at each	1
addresses all belong	1
addresses divisible by	4
addresses (i.e. where	1
addresses 0x2F00, 0x3700,	1
counter is a	1
counter is an	1
counter is used	1
counter is very	1
counter is counting	1
counter and using	1
counter and go	1
counter in the	1
counter in Intel	1
counter that measures	1
counter can be	4
counter // For	1
counter // Calculate	1
counter by a	1
counter with its	1
counter when the	1
counter then make	1
counter should preferably	1
counter i is	1
counter variables that	1
counter before and	1
counter (see below)	1
counter inside the	1
counter becomes invalid	1
counter outside both	1
counter ahead of	1
counter //=2*A //=A*x*x+B*x+C	1
shared object is	2
shared object can	1
shared object has	1
shared object which	1
shared object where	1
shared object without	2
shared object compiled	1
shared object made	1
shared objects in	2
shared objects are	1
shared objects without	1
shared objects (*.dll,	2
shared variable inside	1
shared between multiple	5
shared resources are	1
shared object. This	1
shared object. It	1
shared object. Obviously,	1
shared object. Likewise,	1
shared object, then	2
shared objects), resource	1
count is not	1
count is large	1
count is small	2
count is too	1
count is divisible	2
count is usually	1
count is near	1
count is mispredicted	1
count is odd	1
count to 5	1
count and the	2
count and no	1
count and always	1
count that can	2
count on it.	1
count as true,	1
count may be	1
count has been	1
count should preferably	1
count before and	1
count how many	2
count up to	1
count certain events,	1
count down to	1
count (ArraySize) is	1
program. The time	1
program. The use	1
program. The CPU	1
program. The number	1
program. The advantage	1
program. The map	1
program. The inputs	1
program. The profilers	1
program. This is	1
program. This has	1
program. This makes	1
program. This requires	1
program. This requires,	1
program. In some	1
program. See page	1
program. An optimizing	1
program. All in	1
program. Many programmers	1
program. Avoid unnecessary	1
program. 3 Finding	1
program. 6 Development	1
program. Add to	1
program. Reading or	1
program. 16.2 The	1
program. Small functions	1
program. Whole program	1
program. Weighing the	1
program. During the	1
program. Frequent context	1
program. Application programmers	1
quite a long	2
quite a good	1
quite as versatile.	1
quite efficient thanks	1
quite often as	1
quite often because	1
quite simple in	1
quite likely is	1
quite well if	1
quite certain that	1
quite fast on	1
quite difficult to	1
quite inefficient in	1
quite inefficient if	1
quite inefficient. The	1
quite time-consuming (see	1
quite fast. The	1
quite expensive -	1
quite costly because	1
quite efficient, but	1
quite powerful and	1
quite inefficient, and	1
quite dramatic consequences.	1
quite tedious and	1
quite tedious indeed.	1
quite substantial. This	1
quite convenient. It	1
quite often. This	1
quite ingenious things	1
used. a and	1
used. The operating	1
used. The method	1
used. The advantages	2
used. A computer	1
used. A smart	1
used. A newer	1
used. It is	4
used. It takes	1
used. If the	1
used. You may	1
used. See page	2
used. For example,	1
used. Example: //	1
used. An optimizing	1
used. However, this	1
used. We can	1
used. Such variables	1
used. Dynamic linking	1
used. No program	1
used. Do not	1
used. Conversion of	1
used. Conversions of	1
used. Whenever a	1
used. Web systems	1
files to be	1
files and other	1
files and system	1
files and network	1
files and databases	1
files and executables.	1
files and databases.	1
files for the	1
files for intrinsic	1
files that need	1
files are as	1
files are then	1
files are also	1
files are first	1
files or accessing	1
files on access.	2
files when the	1
files from different	1
files from disk.	1
files into a	2
files into one	1
files For example,	1
files need to	1
files while less	1
files etc. scattered	1
files generated by	1
files smaller. It	1
files (*.ini files).	1
recommended to use	9
recommended to make	2
recommended to set	1
recommended to return	1
recommended to calculate	1
recommended to put	2
recommended to turn	3
recommended to enable	2
recommended to modify	1
recommended to try	1
recommended to declare	1
recommended to specify	1
recommended to wrap	1
recommended to place	1
recommended for critical	1
recommended that big	1
recommended if portability	1
intermediate code is	4
intermediate code and	2
intermediate code for	1
intermediate code by	1
intermediate code cannot	1
intermediate code like	1
intermediate code (byte	1
intermediate data and	1
intermediate object for	1
intermediate code. The	1
intermediate code. This	1
intermediate file format	2
intermediate calculations can	1
intermediate result of	1
intermediate result (b+c)	1
intermediate files are	1
intermediate expression b	1
intermediate results in	1
intermediate results are	1
intermediate results as	1
intermediate results should	1
intermediate code, which	1
intermediate code, interpreters,	1
intermediate version. For	1
intermediate results, which	1
fast and easy	1
fast and efficient,	1
fast in a	1
fast in most	1
fast that the	1
fast that what	1
fast if the	1
fast if it	1
fast on a	1
fast on such	1
fast on newer	1
fast as a	1
fast as integer	1
fast as single	1
fast as calling	1
fast as accessing	1
fast as additions.	1
fast floating point	1
fast 32-bit software	1
fast access to	1
fast whether p	1
fast division c	1
fast ways of	1
fast math and	1
fast anyway and	1
fast approximate reciprocal	1
fast approximate reciprocal,	1
fast enough. A	1
fast enough. For	1
allocation is done	1
allocation is particularly	1
allocation is used,	1
allocation is negligible	1
allocation is unnecessarily	1
allocation of memory	2
allocation and function	1
allocation and parameter	1
allocation and deallocation	2
allocation and de-allocation	1
allocation in an	1
allocation for all	1
allocation can be	1
allocation can therefore	1
allocation with new	1
allocation may be	1
allocation when the	1
allocation using new/delete	1
allocation also tends	1
allocation process because	1
allocation are: The	1
allocation are: int	1
allocation Dynamic memory	1
allocation Any array	1
allocation Objects and	1
allocation ...................................................................................... 90	1
allocation (new and	1
(int i =	13
(int * p)	2
(int & r)	1
(int a, int	1
(int a, bool	4
(int x) {	2
(int n =	1
(int x, int	1
(int n) {	3
(int a[], int	1
write the same	1
write the variable	1
write the file	1
write the members	1
write is more	1
write a +	1
write a 64-bit	1
write to the	1
write that something	2
write it in	1
write it with	1
write instruction prevents	1
write less than	1
write instructions are	2
write instructions becomes	1
write instructions (MOVNT)	1
write expressions that	1
write expressions like	1
write your own	1
write #pragma vector	1
write causes an	1
write directly to	1
write configuration files	1
write FatalAppExitA(0,"Array index	1
write 2.0/3.0 than	1
write _mm_add_epi16(a,b). Two	1
write if(!a &&	1
optimize the code	2
optimize the parts	1
optimize a piece	1
optimize for several	1
optimize code that	1
optimize as good	1
optimize this with	1
optimize this loop	1
optimize this loop?	1
optimize example 8.26a	1
optimize performance for	1
optimize register allocation	1
optimize both functions	1
optimize well. Open	1
optimize away the	2
optimize away a	1
optimize away an	1
optimize Modern compilers	1
optimize across the	1
optimize across function	1
optimize across modules	1
optimize anything else	1
optimize access, as	1
optimize caching. Smaller	1
optimize ............................................................................................ 66	1
optimize anything, you	1
optimize specifically for	1
above the diagonal	2
above the diagonal.	2
above for the	1
above can still	1
above code is	1
above code in	1
above code can	1
above code will	2
above example with	2
above example may	1
above example sets	1
above example, the	3
above example, then	1
above template class	1
above doesn't work	1
above line doesn't	1
above methods if	1
above examples will	1
above examples all	1
above advantages of	1
above sections are	1
above table. If	1
above security advices	1
However, the code	1
However, the Intel	1
However, the const	1
However, the short	1
However, the STL	1
However, the out-of-order	1
However, the CISC	1
However, the pipeline	1
However, a software	1
However, in most	1
However, it is	1
However, if F1	1
However, with a	1
However, you must	1
However, this is	1
However, this does	1
However, this involves	1
However, this did	1
However, most compilers	1
However, there are	4
However, there may	1
However, C++ is	1
However, such applications	1
However, we must	1
However, we still	1
However, these languages	1
was the opposite:	1
was it possible	1
was not declared	1
was an odd	1
was more than	1
was used by	1
was called from),	1
was less popular	1
was done by	1
was certain to	1
was never designed	1
was zero or	1
was too slow.	1
was called. There	1
was unknown at	1
was executed. It	1
was executed. If	1
was down to	1
was hardly any	1
was saved in	1
was split into	1
was programmed. But	1
was programmed. Therefore,	1
was manipulated to	1
was started. The	1
was assigned previously	1
was coded. If	1
was developed. A	1
was originally designed	1
both the CPU	2
both the pointers	1
both the level-1	1
both the executable	1
both are negative	1
both can be	1
both have addresses	1
both functions and	1
both static and	2
both 32-bit and	1
both Windows and	2
both AMD and	1
both get the	1
both Intel, AMD	1
both positive and	1
both positive }	1
both cases. This	1
both during installation	1
both loops //	1
both compiler, operating	1
both compiler, linker	1
both parent and	1
both operands. Nevertheless,	1
both cheaper and	1
both positive. It	1
both 16-bit, 32-bit	1
programs to run	1
programs and also	1
programs that are	1
programs that have	2
programs can be	1
programs if there	1
programs with many	1
programs use time	1
programs use more	1
programs use internet	1
programs use inappropriate	1
programs when the	1
programs because the	1
programs but rarely	1
programs should be	1
programs where security	1
programs they are	1
programs must use	1
programs compiled for	2
programs implemented in	1
programs automatically download	1
programs search for	1
programs spend most	1
programs do. Hence,	1
programs written in	1
programs installed can	1
problems is quite	1
problems of the	1
problems of overflow	1
problems and they	1
problems and system	2
problems and necessary	1
problems and desired	1
problems and compatibility	1
problems and planned	1
problems for integer	1
problems that the	1
problems that software	1
problems that cause	1
problems that relate	1
problems are usability	1
problems or performance	1
problems if the	2
problems with profilers	1
problems you must	1
problems when the	1
problems because static	1
problems should be	1
problems into account	1
problems mentioned above.	1
problems associated with	1
problems separating the	1
unless the function	2
unless the code	1
unless the loop	1
unless the size	1
unless the value	1
unless the address	1
unless the SSE2	4
unless the SSE4.1	1
unless the length	1
unless the strictness	1
unless the Pentium-II	1
unless you are	3
unless you have	2
unless you put	1
unless you expect	1
unless you specify	1
unless there is	3
unless they are	1
unless your program	1
optimal to use	2
optimal to do	1
optimal to inline	1
optimal to mirror	1
optimal in most	1
optimal in special	1
optimal for each	1
optimal on the	1
optimal code for	1
optimal code because	1
optimal from a	1
optimal because it	2
optimal only on	1
optimal number of	1
optimal version of	1
optimal branch can	1
optimal solution is	1
optimal solution because	1
optimal platform ...........................................................................................	1
optimal platform 2.1	1
optimal choice for	1
optimal algorithm The	1
optimal algorithm before	1
optimal algorithm .......................................................................................	1
optimal order. Some	1
optimal decomposition of	1
space is used	1
space is automatically	1
space is freed	1
space is occupied	1
space of the	1
space to store	1
space to become	1
space and are	1
space in the	4
space for the	1
space can be	1
space or make	1
space by joining	1
space by allowing	1
space on the	1
space than needed.	1
space has become	1
space used for	1
space where a	1
space never becomes	1
space becomes more	1
space becomes fragmented	1
space were scarce	1
space explicitly when	1
space 91 step	1
cases, the compiler	2
cases, the Intel	1
cases, the optimal	1
cases, the fastest	1
cases, the log	1
cases, a data	1
cases, for example	1
cases, it is	2
cases, an optimizing	1
cases, you can	2
cases, but it	1
cases, but not	1
cases, but its	1
cases, double precision	1
cases, there is	3
cases, there are	1
cases, even for	1
cases, while many	1
cases, however, there	1
cases, however, where	2
cases, composite objects	1
cases, regardless of	1
else if else	2
else if (level	1
else on a	1
else than finding	1
else { a	5
else { //	3
else { float	1
else { return	2
else { y	2
else { list[i]	2
else { (iset	1
else { F2(b);	1
else { goto	2
else { FuncB(i);	1
else { CFALSE:	1
else { DTRUE:	1
else being initialized.	1
lot of code	1
lot of time	2
lot of data	2
lot of CPU	1
lot of cache	2
lot of optimization	1
lot of time.	1
lot of extra	2
lot of branches	1
lot of runtime	1
lot of advanced	1
lot of added	1
lot of background	1
lot of computing	1
lot of resources,	1
lot of modifications	1
lot of bookkeeping	1
lot of jumping	1
lot of irrelevant	1
lot of CPU-time	1
lot to gain	3
lot in performance.	1
Integer to float	2
Integer size conversion	1
Integer variables can	1
Integer operations are	2
Integer constant const	1
Integer overflow is	1
Integer power using	1
Integer operators Integer	1
Integer multiplication takes	2
Integer multiplication Integer	1
Integer multiplication .............................................................................................	1
Integer division is	1
Integer division by	4
Integer division takes	2
Integer division Integer	1
Integer expressions are	1
Integer XMM (vector)	1
Integer constants are	1
Integer sizes Integers	1
Integer algebra reductions:	1
Integer division...................................................................................................... 137	1
dispatching to make	1
dispatching to C1::Disp()	1
dispatching and is	1
dispatching and run	1
dispatching and discovered	1
dispatching in the	1
dispatching in Intel	2
dispatching in Gnu	3
dispatching can be	1
dispatching or memory-intensive	1
dispatching with vector	1
dispatching on first	1
dispatching on every	1
dispatching then call	1
dispatching only to	1
dispatching only for	1
dispatching should be	1
dispatching There may	1
dispatching works only	1
dispatching #include "vectorclass.h"	1
dispatching mechanism can	1
dispatching are: Optimizing	1
dispatching explicitly as	1
dispatching .................................................................................... 124	1
dispatching 125 for	1
particular code implementation	1
particular code version.	1
particular compiler to	1
particular memory address	2
particular CPU or	1
particular CPU model	1
particular instruction set	1
particular instruction set,	1
particular integer size	1
particular set of	1
particular branch of	1
particular programming language	1
particular part of	1
particular processor model.	1
particular advantageous as	1
particular application uses	1
particular piece of	1
particular brand is	1
particular application. The	1
particular application. If	1
particular reduction would	1
particular part. It	1
particular purpose. The	1
particular weakness or	1
particular meaning, then	1
particular subtask before	1
particular situation, but	1
microprocessor is doing	1
microprocessor is able	1
microprocessor and the	1
microprocessor and therefore	1
microprocessor in an	1
microprocessor The benchmark	1
microprocessor that supports	1
microprocessor can predict	1
microprocessor can execute	1
microprocessor can begin	1
microprocessor it is	1
microprocessor with out-of-order	2
microprocessor has the	1
microprocessor has hardware	1
microprocessor has made	1
microprocessor has hyperthreading,	1
microprocessor because the	1
microprocessor doesn't know	1
microprocessor hardware for	1
microprocessor hardware design.	1
microprocessor core and	1
microprocessor jump to	1
microprocessor ........................................................................................... 6	1
microprocessor handles this	1
microprocessor microarchitecture. A	1
microprocessor wastes several	1
replace the code	1
replace the CPU	2
replace the branch	1
replace the call	1
replace the Gnu	1
replace a function	1
replace a branch	1
replace a &&	1
replace a ||	1
replace a database	1
replace a poorly	1
replace it by	1
replace it with	1
replace an integer	1
replace this by	5
replace this line	1
replace all occurrences	1
replace integer multiplication	1
replace such loops	1
replace arrays by	1
replace j *	1
replace u[1] by	1
next time the	1
next time a	1
next instruction mov	1
next each bit	1
next example shows	1
next two instructions	1
next new model	1
next function. However,	1
next processor model	1
next line provokes	1
next four x^n	1
next model work	1
next higher instruction	1
next section (page	1
next instance of	1
next generation of	2
next chapter describes	1
next block. A	1
next element. I	1
next vector, and	1
next step in	1
next step. With	1
next calculation. However,	1
next paragraph. The	1
next year. Ignoring	1
next section. 12.5	1
branches is not	1
branches to feed	1
branches and the	1
branches and function	2
branches and switch	1
branches in a	1
branches The code	1
branches for correctness.	1
branches that are	1
branches that can	1
branches that take	1
branches that select	1
branches are scattered	1
branches are poorly	1
branches can be	1
branches or function	1
branches as possible,	1
branches may take	1
branches at the	1
branches such as	1
branches works correctly.	1
branches inside can	1
branches every time	1
branches separately and	1
branches Eliminate jumps	1
branches Remove branch	1
typically in a	1
typically have more	1
typically have variable	1
typically have much	1
typically use integer	1
typically use pointers	1
typically used on	1
typically takes a	1
typically takes one	1
typically takes 40	1
typically between 5	1
typically stored in	1
typically 64 bytes	1
typically 64 bytes.	1
typically take much	1
typically 0 -	1
typically small pieces	1
typically uses much	1
typically get the	1
typically implemented by	1
typically aligned by	1
typically look like	1
typically loaded at	1
typically happens if	1
typically specified on	1
typically 30 ms	1
typically thinks "what	1
operator is as	1
operator is used	3
operator is also	1
operator is exactly	1
operator is equivalent	1
operator that specifies	1
operator that transfers	1
operator // add	1
operator will detect	1
operator } };	1
operator which otherwise	1
operator + (vector	1
operator does the	1
operator These different	1
operator here is	2
operator i++ are	1
operator forces the	1
operator (bitwise and)	1
operator less. Fortunately,	1
operator (|) works	1
operator ++i and	1
operator %. Conversion	1
operator (&) and	1
operator (^) may	1
preferably in the	1
preferably be a	5
preferably be an	1
preferably be stored	1
preferably be done	2
preferably be put	1
preferably be declared	2
preferably be avoided	1
preferably be static,	1
preferably be kept	2
preferably be responded	1
preferably with contiguous	1
preferably have a	1
preferably have no	1
preferably using powers	1
preferably 32 for	1
preferably avoid global	1
preferably implemented on	1
preferably aligned by	1
preferably isolated into	1
1; for (i	2
1; // always	1
1; // sign	1
1; } The	1
1; } This	2
1; } }	3
1; } return	1
1; } };	2
1; } else	3
1; } module2.cpp	1
1; return c;	1
1; You cannot	1
1; n <=	1
1; r <	2
1; list[i+2] =	2
1; x[1] =	1
1; a[1] =	1
1; 69 }	1
Therefore, the code	1
Therefore, the data	2
Therefore, the number	1
Therefore, the dispatcher	1
Therefore, the __fastcall	1
Therefore, it is	7
Therefore, it can	1
Therefore, it will	1
Therefore, it has	1
Therefore, it cannot	1
Therefore, you only	1
Therefore, you should	4
Therefore, you don't	1
Therefore, make sure	1
Therefore, 64-bit Linux	1
Therefore, both the	1
Therefore, micro- processors	1
Mac The libraries	1
Mac code uses	1
Mac Intel CodeGear	1
Mac operating system	1
Mac systems often	1
Mac systems normally	1
Mac programs but	1
Mac systems. 14	1
Mac platforms. 2.	1
Mac Windows, Linux,	1
Mac platforms By	1
Mac OS and	1
Mac OS X	6
Mac OS X,	2
Mac OS X.	1
Mac allow up	1
Mac systems, this	1
Mac platform. Intel	1
Mac OS, etc.)	1
Mac OS. See	1
Mac platform, but	1
multiplication is done	1
multiplication is exact.	1
multiplication of xxn	1
multiplication and an	1
multiplication are permissible	1
multiplication can be	1
multiplication or division.	1
multiplication by a	1
multiplication by 2	1
multiplication by columns	1
multiplication by changing	1
multiplication may be	1
multiplication will be	1
multiplication } //	1
multiplication at the	1
multiplication but only	1
multiplication takes longer	1
multiplication takes 11	1
multiplication would take	1
multiplication Integer multiplication	1
multiplication units. This	1
multiplication here: a[i]	1
multiplication ............................................................................................. 136	1
multiplication b[i]*c[i], though	1
multiplication (27 -	1
multiplication (20 -	1
multiplication prior to	1
application is preferably	1
application is generally	1
application to a	1
application to calculate	1
application that uses	1
application can make	1
application if dynamic	1
application with many	1
application then you	1
application program will	1
application program without	1
application program loads	1
application has a	1
application software is	1
application code. An	1
application uses a	1
application uses most	1
application program. The	1
application program. All	1
application program. Add	1
application programs use	1
application programmer gets	1
application depends on	1
application software. Such	1
application itself and	1
application integration, mixed	1
application programmer. There	1
x) { //	4
x) { double	1
x) { float	1
x) { static	1
x) { return	14
x) { __declspec(align(16))	1
x) { _mm_storeu_si128((__m128i	3
x) { __m128	1
x) { _mm_store_si128((__m128i	1
automatically and vectorize	1
automatically in cases	1
automatically in simple	2
automatically in vectorized	1
automatically or does	1
automatically if this	1
automatically by the	1
automatically when the	2
automatically then it	1
automatically but you	1
automatically but only	1
automatically check for	1
automatically replace a	1
automatically replace such	1
automatically generate multiple	1
automatically choose the	1
automatically come into	1
automatically detect which	1
automatically detect opportunities	1
automatically prefetch data	1
automatically deallocated when	1
automatically thanks to	1
automatically reduces example	1
automatically download updates	1
see the result	1
see the excessive	1
see the compiler-generated	1
see the delay.	1
see in the	1
see that the	2
see that p	1
see if the	1
see if a	1
see if it	1
see if our	1
see which one	1
see which part	1
see which solution	1
see page 105.	1
see page 122.	1
see how well	1
see whether the	1
see whether they	1
see below. Installing	1
see my free	1
see this. It	1
see shortly. The	1
see http://www.agner.org/optimize/ -	1
see emulated processors	1
caching is a	1
caching is therefore	1
caching is advantageous	1
caching is critical.	2
caching is poor	1
caching and data	1
caching for the	1
caching more efficient	2
caching more efficient.	1
caching will be	1
caching very efficient.	1
caching less efficient.	6
caching problems for	1
caching problems because	1
caching becomes a	1
caching becomes inefficient.	1
caching conditions are	1
caching inefficient. An	1
caching inefficient. Dynamic	1
allows the function	1
allows the compiler	3
allows the CPU	1
allows the linker	1
allows a maximum	1
allows it to	1
allows you to	3
allows only four	1
allows multiple pointers	1
allows less precise	1
allows common subexpression	1
allows bigger segments	1
allows parallel calculations.	1
allows 256-bit integer	1
allows compile-time if	1
allows larger floating	1
allows overriding of	1
allows it, it	1
allows us to	2
allows direct access	1
allows "__attribute__((visibility("hidden")))". Use	1
sets the CPU	1
sets the variable	2
sets the sign	1
sets is as	1
sets is provided	1
sets a function	2
sets and other	1
sets and cache	1
sets are mutually	2
sets can be	2
sets have certain	1
sets have got	1
sets A more	1
sets from the	1
sets all other	1
sets all elements	1
sets where the	1
sets 4 ways.	1
sets rather than	1
sets enable the	1
sets include a	1
sets Microprocessor producers	1
expression is optimized	1
expression is calculated	1
expression is used,	1
expression a =	2
expression a &&	1
expression to generate	1
expression that is	4
expression that it	1
expression that should	2
expression or an	1
expression or subexpression	1
expression with multiple	1
expression b *	1
expression b &&	1
expression contains a	1
expression y =	1
expression better explains	1
expression list[i] is	1
expression -(-a) to	1
expression (Tuesday |	1
expression -a >	1
implementation is faster	2
implementation is optimal	1
implementation is needed.	1
implementation is best.	1
implementation of the	4
implementation of member	1
implementation of these	1
implementation in most	2
implementation for a	1
implementation can be	1
implementation if the	1
implementation if possible,	1
implementation may look	1
implementation when b	1
implementation rather than	1
implementation works particularly	1
implementation uses a	1
implementation uses XMM	1
implementation would only	1
implementation dependent. The	1
implementation analogous to	1
Most of the	3
Most compiler packages	1
Most compilers can	3
Most compilers have	1
Most compilers will	5
Most compilers include	1
Most compilers offer	1
Most C++ compilers	2
Most performance tests	1
Most copy protection	1
Most reductions involving	1
Most modern CPUs	1
Most implementations of	1
Most programmers have	1
Most caches are	1
Most IDE's (Integrated	1
Most importantly, it	1
complicated to make	1
complicated and time	1
complicated and clumsy,	1
complicated and error-prone.	1
complicated in a	1
complicated that I	1
complicated if the	1
complicated code that	1
complicated because various	1
complicated functions like	1
complicated address calculation	1
complicated template method.	1
complicated cases should	1
complicated cases cannot	1
complicated solution is	1
complicated implementation is	1
complicated implementation of	2
complicated mathematical tasks.	1
complicated process which	1
complicated algorithm if	1
complicated algebraic expressions.	1
complicated algorithms is	1
complicated techniques like	1
complicated reductions. Algebraic	1
complicated criteria or	1
handling is not	2
handling is intended	1
handling is negligible	1
handling a full	1
handling and you	1
handling in the	1
handling in this	1
handling for the	1
handling for a	1
handling can be	1
handling then you	1
handling takes no	1
handling even in	1
handling system makes	1
handling system instead	1
handling option in	1
handling support anyway.	1
handling unless the	1
handling errors without	1
handling cleanup jobs	1
handling information. Each	1
handling Exception handling	2
handling ................................................................................ 61	1
handling /EHs- No	1
like the one	1
like a pointer.	1
like a macro	1
like a key	1
like a mouse	1
like a parameter,	1
like to put	1
like and how	1
like an array	1
like this in	1
like example 12.4a	1
like adding vectors.	1
like square blocking	1
like this: //	6
like -(-a) very	1
like pressing a	1
like throw(A,B,C) to	1
like string, wstring	1
like sin. Pointer	1
like sqrt, pow	1
like these, it	1
dependency chains is	1
dependency chains in	1
dependency chains can	2
dependency chains with	1
dependency chains then	1
dependency chains (see	1
dependency chain is	1
dependency chain in	1
dependency chain may	1
dependency chain has	1
dependency chain which	1
dependency chain where	1
dependency chain would	1
dependency chain. A	1
dependency chain. If	1
dependency chain. We	1
dependency chain. Such	1
dependency chain. 3.16	1
dependency chain. Nothing	1
dependency chains. A	1
dependency chains. In	1
dependency chains. Another	1
dependency chains, especially	1
dependency chains, namely	1
dependency chain, especially	1
members is added	1
members of the	3
members of a	4
members of both	1
members of mixed	1
members to round	1
members in the	1
members that are	1
members are then	1
members can be	1
members or member	1
members or non-static	1
members with a	1
members may cause	1
members come first.	1
members within the	1
members share the	1
members (properties) The	1
members (properties) ............................................................................	1
members last: //	1
members individually. Example:	1
their time waiting	1
their CPU dispatchers	1
their clock frequency	1
their software faster.	1
their 32-bit counterparts.	1
their address and	1
their execution time	1
their uses (live	1
their values before	1
their own graphical	1
their own initiative	1
their CPUs. Intel's	1
their index or	1
their stack. This	1
their smart pointer	1
their implementations reveal	1
their live ranges	4
their actual values	1
their 23 software.	1
their functionality. This	1
their live-ranges do	1
their workplace and	1
their superior performance/price	1
__m128i a =	2
__m128i b =	2
__m128i two =	2
__m128i const &	4
__m128i c =	2
__m128i zero =	2
__m128i c2 =	2
__m128i defines a	1
__m128i bc =	2
__m128i mask =	2
__m128i LoadVector(void const	3
__m128i LoadVectorA(void const	1
Using the vector	1
Using the SSE2	1
Using the methods	1
Using the out-of-order	1
Using the nontemporal	1
Using a union	1
Using an overloaded	1
Using vector operations	1
Using vector classes	2
Using vector operations...............................................................................................	1
Using integer operations	2
Using double precision	1
Using multiple CPUs	1
Using performance monitor	2
Using pointers makes	1
Using complicated techniques	1
Using intrinsic functions	3
Using templates for	1
Using unaligned reads	1
Using hexadecimal numbers,	1
Boolean vector operations	1
Boolean vector operations.	1
Boolean variables are	3
Boolean variables as	2
Boolean operations can	1
Boolean operators because	1
Boolean operators &&	1
Boolean operators produce	1
Boolean operators &&,	1
Boolean operators (&&	1
Boolean XMM (vector)	1
Boolean operands The	1
Boolean operands because	1
Boolean vector. For	1
Boolean expressions. There	1
Boolean expressions. Whether	1
Boolean algebra reductions:	1
Boolean operands. You	1
Boolean output. The	1
Boolean vectors, and	1
Boolean algebra, it	1
Boolean NOT on	1
cache. The different	1
cache. The same	1
cache. The cache	1
cache. The operating	1
cache. The register	1
cache. The problem	1
cache. The advantage	1
cache. The level-2	1
cache. The subsequent	1
cache. The Core2	1
cache. This has	2
cache. If the	2
cache. These instructions	1
cache. Most compilers	1
cache. Using the	1
cache. We can	1
cache. When we	1
cache. Compilers will	1
cache. 2.2 Choice	1
cache. Single precision	1
cache. Files on	1
cache. Bit-fields of	1
cache. Multithreaded programs	1
don't have the	1
don't have to	6
don't need the	1
don't need a	1
don't need an	1
don't need any	1
don't need conversions	1
don't even have	1
don't want this	1
don't get rid	1
don't support processor	1
don't count on	1
don't know if	1
don't modify the	1
don't vectorize the	1
don't care to	1
don't depend on	1
don't understand it.	1
don't think that	1
don't send your	1
256 int int64_t	1
256 double 256	1
256 float 128	1
256 clock cycles.	1
256 bit integer	1
256 bit float	1
256 unsigned 256	1
256 16 16	1
256 bits (YMM),	1
256 bits (YMM)	1
256 short int	1
256 times and	1
256 AVX int	1
256 AVX double	1
256 && SIZE	1
256 AVX2 int	1
256 AVX2 float	1
256 AVX2 long	1
256 AVX2 short	1
256 F32vec4 F64vec2	1
256 bytes) on	1
256 uint64_t 256	1
256 Kbytes to	1
256 Vec32c unsigned	1
256 Vec32uc Vec16s	1
intrinsic function call	1
intrinsic function _mm256_zeroupper()	1
intrinsic vector functions	1
intrinsic functions and	1
intrinsic functions for	1
intrinsic functions can	1
intrinsic functions //	2
intrinsic functions or	2
intrinsic functions It	1
intrinsic functions You	1
intrinsic functions Use	1
intrinsic functions (i.e.	1
intrinsic functions ........................................................................................	1
intrinsic instructions for	1
intrinsic function. Provoke	1
intrinsic functions. This	1
intrinsic functions. It	1
intrinsic functions. Alternatively,	1
intrinsic hardware functions.	1
intrinsic vectors requires	1
intrinsic functions, but	2
intrinsic functions, inline	1
methods of rounding,	1
methods to improve	1
methods and algebraic	1
methods in the	1
methods for communication	1
methods for avoiding	1
methods for dealing	1
methods for exploiting	1
methods are time	1
methods are based	1
methods are further	1
methods are discussed	1
methods are incremental	1
methods or require	1
methods if the	1
methods with little	1
methods may be	1
methods have exactly	1
methods then the	1
methods only if	1
methods also work	1
methods described on	1
methods could possibly	1
methods mentioned above.	1
methods depend on	1
signed and unsigned	5
signed or unsigned	4
signed or unsigned.	1
signed with unsigned	1
signed than with	1
signed when you	1
signed when converting	1
signed integer to	1
signed integer if	1
signed integer doesn't	1
signed integer overflow	1
signed variable produces	1
signed before converting	1
signed integers in	1
signed integers before	1
signed integers. It	1
signed number. If	1
signed number, or	1
model the best	1
model is likely	1
model is hardly	1
model is going	1
model is over.	1
model and then	1
model that was	1
model with a	1
model will work	1
model has its	1
model used here.	1
model number to	1
model where the	1
model work better.	1
model numbers are	1
model numbers form	1
model comes on	1
model N supports	1
model number. The	1
model number. I	1
model number. Failure	1
model numbers, but	1
model N+1 supports	1
model N-1 is	1
model fast=2 Simple	1
development of a	1
development of user	1
development and the	1
development are more	1
development time and	1
development time for	1
development more expensive	1
development time. Interpreted	1
development work as	1
development methods are	1
development process and	1
development process can	1
development time, usability,	1
development models have	1
development tool is	2
development tools. The	1
development tools. A	1
development tools. One	1
development process. These	1
development tools for	1
development tools have	1
development environment (IDE)	1
development kit (SDK	1
development tools, rather	1
mathematical functions that	1
mathematical functions are	2
mathematical functions such	4
mathematical functions take	1
mathematical code. There	1
mathematical operations on	1
mathematical calculations with	1
mathematical calculations including	1
mathematical functions. A	1
mathematical functions. It	1
mathematical functions. 7.4	1
mathematical applications with	1
mathematical calculations. It	1
mathematical calculations. In	2
mathematical iterations such	1
mathematical tasks. Before	1
mathematical calculations, should	1
mathematical purity. In	1
mathematical purity. For	1
mathematical notion of	1
never be sure	1
never be negative	1
never be negative.	1
never use static	1
never used at	2
never takes memory	1
never return any	1
never stored in	1
never uses the	1
never used. A	1
never used. Whenever	1
never becomes fragmented	1
never called. The	1
never called. This	1
never called. Unfortunately,	1
never designed for	1
never interrupt the	1
never spend time	1
never modified by	1
never occurs, even	1
never throw any	1
never changed. This	1
never exceeds an	1
never respond to	1
separate for each	1
separate function library	1
separate function library.	1
separate from seldom	1
separate version for	1
separate file than	1
separate dynamic link	2
separate function. Sometimes,	1
separate threads with	1
separate threads so	1
separate thread in	1
separate thread if	3
separate thread with	1
separate modules if	1
separate C or	1
separate containers for	1
separate module then	1
separate storage. No	1
separate layers of	1
separate subroutine if	1
separate executables for	1
separate module, and	1
block the execution	2
block is allocated	1
block is re-allocated	1
block of memory	1
block of 16	1
block of data.	1
block to copy	1
block and a	1
block and copy	1
block for each	1
block for every	1
block that the	1
block that has	1
block or function	1
block than to	1
block then become	1
block from one	1
block should have	1
block size grows	1
block into the	1
block every time	2
block containing many	1
block turns out	1
name is not	1
name of this	1
name of Func	1
name and the	1
name and model	1
name in the	1
name for the	1
name for each	1
name for local	1
name that the	1
name as a	2
name as template	1
name at the	1
name cannot be	1
name ; start	1
name depending on	1
name Instruction set	1
name Intrinsic function	1
name ?Func@@YAXQAHAAH@Z is	1
name mangling are	1
name mangling. The	1
name "position-independent code"	1
name _alloca) for	1
name ;startofFunc ;	1
systems. The Intel	1
systems. The 64	1
systems. The user	1
systems. The appropriate	1
systems. The smaller	1
systems. The latter	1
systems. The Intel-based	1
systems. A software	1
systems. A look	1
systems. It is	1
systems. If the	1
systems. If you	1
systems. There is	1
systems. Some compilers	2
systems. All of	1
systems. Mac systems	1
systems. Floating point	1
systems. 10 Gnu	1
systems. 3 The	1
systems. Virtual member	1
systems. 14 Specific	1
systems. Applications that	1
systems. Today (2013)	1
systems. 67 The	1
put the different	1
put the most	2
put the desired	1
put the whole	1
put the operand	2
put the task-specific	1
put a test	1
put a task	1
put a parenthesis	2
put a tag	1
put an equal	1
put into the	1
put there when	1
put file access	2
put something in	1
put away in	1
put time-consuming tasks	1
put 80 into	1
put seldom used	1
put measurement instruments	1
put time- consuming	1
needs the result	1
needs a floating	1
needs a little	1
needs of position-	1
needs to be	5
needs to code	1
needs to make	1
needs to call	1
needs to look	1
needs to load	1
needs to switch	1
needs to evaluate	2
needs to follow	1
needs an extra	1
needs only calculate	1
needs all information	1
needs one instance	2
needs them. Pure	1
needs careful optimization.	1
y = a	4
y = c	1
y = d	1
y = (a	1
y = 1.0;	1
y = b;}	1
y = cos(x);	2
y = sin(x);	2
y = a1/b1	1
y = pow(x,n)	1
y = (a1*b2	1
y = MAX(f(x),	1
y will get	1
y into a	1
y + 1.;	3
y + a.y);}	1
y && z	1
y *= x;	1
conversion is costly	1
conversion is valid.	1
conversion of i	1
conversion to floating	1
conversion to signed	1
conversion and shuffling	1
conversion // Example	2
conversion // C-style	1
conversion time is	1
conversion A pointer	1
conversion from floating	1
conversion from example	1
conversion from float	1
conversion takes more	1
conversion takes no	1
conversion takes zero	1
conversion takes 50	1
conversion between signed	1
conversion often takes	1
conversion instructions which	1
conversion Conversion of	2
conversion Conversions between	1
conversion generates no	1
c; a =	5
c; The calculation	1
c; for (r	2
c; // Define	1
c; // Roll	1
c; int UnusedFiller;	1
c; } In	1
c; } Can	1
c; double temp;	2
c; b =	2
c; }; Replace	1
c; }; 7.23	1
c; ... //	2
c; y =	1
c; Here, y	1
c; Is16vec8 a	1
c; x[0] =	1
#include directives and	1
#include directives. This	1
#include <stdio.h> //	1
#include <stdio.h> #include	1
#include <dvec.h> //	2
#include "vectorclass.h" //	2
#include <emmintrin.h> //	1
#include <emmintrin.h> static	1
#include "asmlib.h" //	2
#include <xmmintrin.h> _mm_setcsr(_mm_getcsr()	1
#include <xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);	1
#include <ia32intrin.h> etc.	1
#include <excpt.h> #include	1
#include "xmmintrin.h" //	1
#include <float.h> #include	1
#include <pmmintrin.h> //	1
#include <malloc.h> void	1
#include <intrin.h> long	1
#include "instrset_detect.cpp" //	1
#include <asmlib.h> void	1
#include <math.h> #define	1
various function libraries	1
various functions for	1
various other optimizations	1
various instruction sets	1
various efficient container	1
various optimization methods	1
various optimization options	1
various programming languages.	1
various methods for	1
various options to	1
various ways of	1
various ways to	5
various ways around	1
various ways depending	1
various things you	1
various discussion forums	1
various algebraic expressions	1
various profilers available	1
various alternatives to	1
various corrections for	1
disadvantage is that	5
disadvantage of the	1
disadvantage of a	1
disadvantage of function	1
disadvantage of using	3
disadvantage of 64-bit	1
disadvantage of C++	1
disadvantage of intermediate	1
disadvantage of complicated	1
disadvantage of binary	1
disadvantage of compiling	1
disadvantage for the	1
disadvantage that the	3
disadvantage if the	1
disadvantage if other	1
disadvantage when the	1
high and decreased	1
high for programs	1
high that it	3
high then the	1
high speed of	1
high power of	2
high precision math	1
high precision math.	1
high overhead cost	1
high repeat count	1
high processing power	1
high priority of	1
high level framework	2
high level framework.	1
high priority. The	1
high priority. Other	1
high resolution if	1
high degree of	1
high complexity of	1
high price, and	1
zero is sometimes	1
zero and to	2
zero and then	1
zero in the	1
zero for (i	1
zero that is	1
zero // Return	1
zero = _mm_set1_epi16(0);	2
zero or one	1
zero or infinity	1
zero if all	1
zero by using	1
zero by testing	1
zero than making	1
zero } We	1
zero at the	1
zero We can	1
zero whenever the	1
zero within a	1
zero flag and	1
zero flags on	1
zero memset(a, 0,	1
Microsoft and Intel	1
Microsoft and PathScale	1
Microsoft or Gnu	1
Microsoft compiler for	1
Microsoft compiler does	1
Microsoft compiler #define	1
Microsoft compiler supports	1
Microsoft C++ compilers	1
Microsoft C++ Compiler	1
Microsoft Table 2.1.	1
Microsoft compilers. //	1
Microsoft directives work	1
Microsoft Intel, Microsoft,	1
Microsoft platform software	1
Microsoft compiler. Some	1
Microsoft compiler. Supports	1
Microsoft Visual Studio	3
Microsoft Visual Studio.	1
Microsoft Visual studio	1
Microsoft Constant propagation	1
Microsoft Comes with	1
Microsoft Foundation Classes	1
what the compiler	3
what the assembly	1
what the preprocessor	1
what is most	1
what is brand	1
what is happening.	1
what a function	1
what a pointer	1
what it can	1
what it points	1
what if an	1
what you are	1
what you want	2
what instruction sets	1
what class of	1
what they are.	1
what r points	1
what kind of	1
what fits best	2
what happens inside	1
parameter is that	1
parameter is always	1
parameter is part	1
parameter is bigger	1
parameter is copied	1
parameter is wrong,	1
parameter of composite	1
parameter to the	2
parameter and a	1
parameter can also	1
parameter has a	1
parameter should be	1
parameter rather than	1
parameter comes first	1
parameter transfer is	2
parameter transfer for	1
parameter transfer are	1
parameter transfer across	1
parameter 2: 12	1
parameter 1: 4	1
parameter 1: 8	1
parameter $B1$1: mov	1
division is faster	1
division is inexact	1
division to be	1
division and relational	1
division in vectors,	1
division by a	7
division by making	1
division with truncation,	1
division takes much	2
division takes 40	1
division take longer	1
division c =	1
division Integer division	1
division Floating point	1
division prevents the	1
division faster. Of	1
division ........................................................................................... 139	1
reference is the	1
reference is valid	1
reference to the	3
reference to a	4
reference to such	1
reference to a[i]	1
reference to it.	1
reference to anything	1
reference to provoke	1
reference can be	1
reference or a	1
reference or pointer	1
reference if the	1
reference may be	1
reference makes sure	1
reference cannot change	1
reference allows the	1
reference instead: //	1
reference parameters). The	1
source is an	1
source of such	1
source of error	1
source of information	1
source of errors	1
source and destination	1
source code is	1
source code more	1
source compiler for	1
source so that	1
source code. The	1
source code. It	1
source code. #if	1
source file and	1
source files for	1
source files are	1
source files into	1
source code, as	1
source library. Supports	1
source file. If	1
source file. Keep	1
source files. 13.2	1
source annotation in	1
source annotation option	1
cost is seen	1
cost is minimized	1
cost of this	1
cost of dynamic	1
cost of exception	1
cost of longer	1
cost of task	1
cost of heap	1
cost of keeping	1
cost of starting	1
cost of fine-tuning,	1
cost of verifying,	1
cost of synchronizing	1
cost to memory	1
cost to using	2
cost to accessing	1
cost to creating	1
cost in performance.	1
cost in terms	2
cost because it	1
cost whenever a	1
cost anything here	1
running the advanced	1
running the services	1
running a program	1
running and before	1
running in the	3
running in other	1
running in 64-bit	1
running in 32-bit	1
running in parallel.	1
running on the	2
running on an	2
running on non-Intel	1
running this code	1
running when it	1
running multiple threads	1
running two threads	1
running on, while	1
running simultaneously can	1
running on. Replace	1
running at, rather	1
automatic CPU dispatching	2
automatic CPU dispatching.	3
automatic check for	1
automatic dispatching can	1
automatic vectorization (see	2
automatic vectorization works	1
automatic vectorization leads	1
automatic updates to	1
automatic vectorization. The	2
automatic vectorization. It	1
automatic vectorization. Optimizes	2
automatic prefetching so	1
automatic parallelization. The	1
automatic parallelization. Supports	1
automatic parallelization of	1
automatic vectorization, such	1
automatic CPU-dispatching (see	1
automatic updates, remote	1
resources of the	1
resources and servers	1
resources for other	1
resources that need	1
resources are not	1
resources are most	1
resources are cleaned	1
resources are sufficient,	1
resources are limiting	1
resources than the	3
resources than a	1
resources than doing	1
resources than standard	1
resources than C	1
resources than non-virtual	1
resources from a	1
resources should be	1
resources cannot be	1
resources .......................................................................................... 21	1
resources Writes to	1
resources cleaned up.	1
resources locally or	1
induction variable for	1
induction variable can	1
induction variable as	1
induction variable because	1
induction variable method	1
induction variable would	1
induction variable unless	1
induction variable Y	1
induction variable Z	1
induction variable (eax)	1
induction variables to	1
induction variables for	3
induction variables can	1
induction variables const	1
induction variables (see	1
induction variables Compilers	1
induction variables Y	1
induction variables. It	1
induction variable. The	1
induction variable. (This	1
induction variables: //	1
reason is that	4
reason to use	3
reason to add	1
reason to unroll	1
reason for this	2
reason for using	1
reason for updating.	1
reason that they	1
reason why the	1
reason why it	1
reason why this	1
reason why all	1
reason why compilers	1
reason why there	1
reason why such	1
reason why exception	1
reason is, I	1
dispatcher to know	1
dispatcher in the	1
dispatcher in only	1
dispatcher that doesn't	1
dispatcher function is	1
dispatcher function and	1
dispatcher function will	1
dispatcher function decides	1
dispatcher then sets	1
dispatcher should not	1
dispatcher should have	1
dispatcher should give	1
dispatcher function. This	1
dispatcher function. When	1
dispatcher function. typeof(CriticalFunction)	1
dispatcher does not	1
dispatcher 128 function	1
dispatcher based on	1
dispatcher checks whether	1
dispatcher changes the	1
dispatcher signal an	1
dispatcher treats non-Intel	1
dispatcher updated. It	1
n is the	1
n is a	1
n is an	1
n is known	1
n to the	1
n to exponent	1
n and reorganize	1
n = 1;	1
n = 4,	1
n with a	1
n from the	1
n < 223	1
n bits of	1
n 0 n!	1
n << 23;	1
n here because	1
n factorial }	1
n additions and	1
n <= 16;	1
n places back,	1
n being out	1
n >>= 1;	1
n floats: float	1
string is created	2
string is already	1
string is checked	1
string of bytes	1
string to lower	1
string and then	1
string or CString.	1
string as code.	1
string functions and	1
string functions as	1
string functions have	1
string classes use	1
string classes allocate	1
string functions. A	1
string instructions. The	1
string length function	1
string search instructions	1
string searching and	1
string constants, and	1
string constants, array	1
string manipulation Mathematical	1
string classes, such	1
programmer to be	1
programmer to make	7
programmer to know	2
programmer in a	1
programmer that pointers	1
programmer can use	1
programmer can do	1
programmer may prefer	1
programmer has defined	1
programmer does not	1
programmer typically thinks	1
programmer gets the	1
programmer choosing the	1
programmer forgets that	1
programmer can. It	1
programmer hasn't thought	1
three to seven	1
three or four,	1
three different object	1
three functions Sum1,	1
three clock cycles.	1
three times the	1
three times faster.	1
three versions should	1
three functions. Sum1	1
three values per	1
three aligned arrays	1
three ways to	2
three things that	1
three conditions which	1
three times. Then	1
three branches. They	1
three times, one	1
three clauses are	1
three clauses: initialization,	1
three parts: one	1
three advantages: The	1
three levels of	1
better to do	1
better to join	1
better and better	1
better on very	1
better than the	1
better than its	1
better than RISC	1
better use of	1
better at vectorization.	1
better at reducing	1
better because the	1
better version of	1
better result by	1
better processor appears	1
better solution to	1
better support for	1
better metaprogramming tools	1
better solution. It	1
better backup features,	1
better explains the	1
better understanding of	1
better performing software	1
better standardization of	1
keyword is not	1
keyword is only	1
keyword is used	1
keyword to all	1
keyword can be	1
keyword has a	1
keyword has several	1
keyword static to	2
keyword also makes	1
keyword makes sure	1
keyword __restrict or	1
keyword volatile is	1
keyword far (arrays	1
keyword static, when	4
keyword __fastcall changes	1
keyword specifies that	1
keyword tells that	1
keyword __thread or	1
keyword wherever appropriate	1
efficient. The size	2
efficient. The performance	1
efficient. The SSE2	1
efficient. The following	1
efficient. This instruction	1
efficient. If the	1
efficient. If you	1
efficient. 64-bit Windows	1
efficient. In 64-bit	1
efficient. In many	1
efficient. There are	1
efficient. You can	1
efficient. You may	1
efficient. 64 bit	1
efficient. Most C++	1
efficient. Dynamic libraries	1
efficient. Do not	1
efficient. Variables that	1
efficient. Access to	1
efficient. Extra memory	1
efficient. Simple function	1
efficient. Splitting up	1
lookup is to	1
lookup is often	1
lookup in a	1
lookup for a	1
lookup can be	1
lookup or require	1
lookup if the	1
lookup } else	1
lookup at the	1
lookup table is	1
lookup table if	1
lookup table instead	1
lookup cannot be	1
lookup operations slow	1
lookup Using intrinsic	1
lookup process is	1
lookup tables if	1
lookup tables Reading	1
lookup tables .................................................................................................	1
lookup Lookup tables	1
lookup table: //	2
lookup mechanisms explained	1
end of the	2
end of a	2
end of an	1
end of this	1
end of array	1
end of procedure	1
end in order	1
end with a	1
end when all	1
end user is	1
end user will	1
end user who	1
end user gets	1
end up with	1
end user. The	1
end user. There	1
end user. Dynamic	1
end user. Installation	1
end user. Menus,	1
end users have.	1
end user's computers.	1
applications to perform	1
applications and the	1
applications that can	2
applications are highly	1
applications can be	1
applications it is	1
applications with many	1
applications with large	1
applications have less	1
applications use the	1
applications use a	1
applications because the	1
applications such as	1
applications need better	1
applications without an	1
applications even on	1
applications run faster	1
applications running simultaneously	1
applications require that	1
applications (e.g. in	1
applications spend most	1
applications force the	1
below. The function	1
below. The time	1
below. The program	1
below. The stack	1
below. The disadvantage	1
below. This manual	1
below. There are	1
below. You may	1
below. Microsoft Visual	1
below. Make calls	1
below. Many libraries	1
below. Shared objects	2
below. Intrinsic function	1
below. Position-independent code	1
below. Dispatch at	1
below. 126 Make	1
below. Signed /	1
below. Devirtualization An	1
below. 3.7 File	1
below. Installing a	1
below. Cannot optimize	1
below. Those who	1
&& is false,	1
&& a =	1
&& a needs	1
&& to &	1
&& and ||	1
&& b with	1
&& b needs	1
&& i <=	1
&& b; d	1
&& expression to	1
&& true =	1
&& list[i] >	1
&& false =	1
&& SIZE %	1
&& z !=	1
&& !a =	1
&& expression, or	1
&& a<c) =	1
&& !b) rather	1
&& !b =	1
&& b<c &&	1
&& WriteFile(handle, ...))	1
&& b<c) Multiply	1
| a =	1
| b if	1
| operations than	1
| 0 =	2
| b; Here,	1
| operator which	1
| -1 =	2
| Wednesday |	2
| operator; you	1
| (~a&c) |	1
| (~a&c) a&b&c&d	1
| Friday) in	1
| (b&c) =	1
| ((C &	1
| ((B &	1
| Friday)) {	1
| 0x3F800000; //	1
| (C <<	1
| (B <<	1
| 0x8040); See	1
Make the function	4
Make the dispatcher	1
Make a vector	6
Make a C++	1
Make a member	1
Make functions local	1
Make all instances	1
Make pointer at	1
Make two or	1
Make array of	1
Make sure the	1
Make sure to	1
Make dynamic array	1
Make calls directly	1
Make three aligned	1
We can make	2
We can only	2
We can take	2
We can therefore	1
We can check	1
We can calculate	1
We can never	1
We can change	1
We can shift	1
We can tell	1
We can convert	1
We can multiply	1
We may decide	1
We cannot change	1
We take the	1
We want the	1
We want to	1
We must bear	1
We might check	1
We took advantage	1
examples of how	3
examples of arrays	1
examples of container	1
examples of suitable	1
examples of poor	1
examples of bad	1
examples in the	1
examples in this	1
examples in these	1
examples for these	1
examples are optimized	1
examples are intended	1
examples on page	1
examples have been	1
examples will therefore	1
examples all use	1
examples where the	1
examples we are	1
examples I have	1
examples explain how	1
examples exist. Therefore	1
char a =	3
char const *	1
char 8 8	1
char 8 16	1
char 8 32	1
char 8 0	1
char 8 -128	1
char 64 Iu8vec8	1
char 64 Is8vec8	1
char 16 SSSE3	1
char 16 XOP,	1
char short int	1
char 128 Is8vec16	1
char 128 Iu8vec16	1
char 256 Vec32c	1
char (or int)	1
char pointers. 144	1
char string[100], *p	2
char pointers). An	1
char abc; };	1
difference is simply	2
difference in performance	2
difference in speed	3
difference in performance.	1
difference in efficiency.	1
difference for the	1
difference for each	1
difference between the	3
difference between a	2
difference between two	1
difference between 32-bit	1
difference between rounding	1
difference between commas	1
difference less than	1
difference whether you	1
difference lies in	1
addition is finished.	1
addition of integers	1
addition to the	2
addition to sum1	1
addition to sum2	1
addition and multiplication	1
addition and subtraction	1
addition with floating	1
addition with another	1
addition on a	1
addition then you	1
addition has to	1
addition takes 5	1
addition takes 3	1
addition before the	1
addition every clock	2
addition every three	1
addition depends on	1
addition units, and	1
addition unit, but	1
addition to) the	1
data. The code	1
data. The data	1
data. The need	1
data. The test	1
data. The speed	1
data. The disadvantage	1
data. The effect	1
data. The similarity	1
data. This is	2
data. This makes	1
data. A database	1
data. A hash	1
data. A missing	1
data. A complete	1
data. It is	1
data. Use an	1
data. Use OpenMP	1
data. Therefore, the	1
data. Extra data	1
data. 148 It	1
data. That being	1
data. Multidimensional arrays	1
too many branches.	1
too long time	1
too important to	1
too large for	1
too big for	1
too big before	1
too much data	1
too much about	1
too much space	1
too small to	1
too small or	1
too little data	1
too long. If	1
too slow. Today,	1
too fragmented. This	1
too big. 7.14	1
too small. Are	1
too fine then	1
too high. It	1
too late. You	1
too worried about	1
too much. Excessive	1
too small, then	1
mechanism is also	2
mechanism is rarely	1
mechanism of static	1
mechanism to advertise	1
mechanism in the	2
mechanism in Intel	1
mechanism that treats	1
mechanism can be	2
mechanism can prefetch	1
mechanism may be	1
mechanism because it	1
mechanism should never	1
mechanism called stack	1
mechanism even when	1
mechanism works only	1
mechanism works automatically.	1
mechanism allows the	1
mechanism stores a	1
mechanism relies on	1
mechanism executes a	1
Table of factorials:	2
Table // Loop	2
Table lookup }	1
Table lookup cannot	1
Table 8.1 (page	1
Table 12.5. Vector	1
Table 8.1. Comparison	1
Table 9.2. Cache	1
Table 18.2. Compiler	1
Table 12.4. Vector	1
Table 7.2. Alignment	1
Table 9.1. Time	1
Table 9.3. Time	1
Table 13.1. Instruction	1
Table 12.1. Vector	1
Table 12.3. Intrinsic	1
Table 7.1. Sizes	1
Table 18.1. Command	1
Table 2.1. Comparing	1
Table 18.3. Predefined	1
Table 12.2. Header	1
runtime of the	1
runtime if all	1
runtime from the	1
runtime address calculations	1
runtime libraries and	1
runtime type identification	4
runtime check that	1
runtime framework for	1
runtime framework that	1
runtime framework may	1
runtime dispatch to	1
runtime here if	1
runtime DLL or	1
runtime DLL takes	1
runtime polymorphism that	1
runtime frameworks are	1
runtime frameworks, intermediate	1
runtime frameworks. The	1
runtime polymorphism: //	1
runtime DLL's (dynamically	1
needed a few	1
needed in this	1
needed in 64-bit	2
needed in order	1
needed in advance	1
needed for the	1
needed for other	1
needed for calculating	1
needed for setting	1
needed for communication	1
needed if the	2
needed by the	1
needed from the	1
needed because the	1
needed only if	1
needed before all	1
needed before adding	1
needed even when	1
needed after all	1
needed anyway. You	1
needed _mm_shuffle_epi8 16	1
means of making	1
means of #include	2
means to make	1
means that the	2
means that a	2
means that it	5
means that if	2
means that different	1
means that all	1
means that source	1
means are among	1
means not a	1
means integer division	1
means avoid powers	1
means modulo. For	1
last the second	1
last in a	1
last in an	1
last time the	1
last time it	1
last all the	1
last cache level,	1
last 8 columns	1
last time. Newer	1
last element outside	1
last line is	1
last byte at	8
last index changes	1
last index changing	1
last vector. Organize	1
last member. This	1
byte of data	1
byte of zero	1
byte of zero.	1
byte = char	2
byte at 1	1
byte at 0,	3
byte at 8,	2
byte at 19	1
byte at 15	1
byte at 7	1
byte at 16,	1
byte at 13	1
byte at 11	1
byte at 12,	1
byte at 403	1
byte at 400,	1
byte at 399	1
byte longer in	1
parts of the	20
parts of a	1
parts only. Critical	1
|| is true,	1
|| are evaluated	1
|| b with	1
|| i >=	1
|| b; This	1
|| b) a	1
|| true =	1
|| false =	1
|| !a =	1
|| expression. Assume,	1
|| Day ==	2
|| (a&&c) =	1
|| (a&&c) ||	1
|| (a&&b&&c) =	2
|| (!a&&c) =	1
|| (!a&&c) ||	1
|| b)) even	1
|| defined(__GNUC__) //	1
|| (b&&c) =	1
|| (!a&&b) =	1
> and >=	1
> b /	1
> b ?	2
> 0; i--)	1
> 0 is	1
> 0 ?	2
> 256 &&	1
> y &&	1
> 0, c	2
> b) But	1
> 0) {	1
> 0) ?	1
> v.f if	1
> largest_abs) {	1
> abs(v.f) }	1
> -b to	1
> 1.0) {	1
> v.i *	1
> v.i) {	1
types of a	1
types of floating	3
types of elements	1
types of expressions	1
types of graphics	1
types of variables.	1
types of expressions,	1
types to integers	1
types The return	1
types or strings	1
types or sizes?	1
types with the	1
types because the	1
types such as	1
types cannot point	2
types Unfortunately, the	1
types (See Sutter:	1
types available. declaration	1
types .............................................................................................. 50	1
expressions and other	1
expressions and operators.	1
expressions for every	1
expressions that can	1
expressions are less	1
expressions or more	1
expressions on seven	1
expressions as arguments	1
expressions than on	1
expressions than floating	1
expressions may have	1
expressions may occur	1
expressions when not	1
expressions using the	1
expressions also occur	1
expressions where operands	1
expressions rather than	1
expressions (see page	1
expressions like -(-a)	1
expressions Automatic vectorization	1
expressions Induction variables	1
expressions (except for	1
difficult to get	1
difficult to find	2
difficult to predict	2
difficult to implement	2
difficult to measure	1
difficult to debug	1
difficult to maintain.	3
difficult to understand	1
difficult to use,	1
difficult to read.	2
difficult to diagnose.	1
difficult for the	4
difficult cases like	1
set. The most	1
set. The following	1
set. The examples	1
set. The main	1
set. The newer	1
set. The preprocessing	1
set. This instruction	1
set. A CPU	1
set. It is	1
set. If the	2
set. If you	1
set. These new	1
set. Therefore, you	1
set. Make two	1
set. Do not	1
set. 120 However,	1
set. Aligning data	1
set. 13.6 CPU	1
set. More complicated	1
set. Neither can	1
set. High precision	1
instead of the	3
instead of a	2
instead of functions	1
instead of using	1
instead of user	1
instead of virtual	1
instead of main	1
instead of bool	1
instead of copying	1
instead of calculating	1
instead of (or	1
instead of j	1
instead of truncation	1
instead of pointers,	1
instead of int.	1
instead of truncation.	1
instead of double,	1
instead of if.	1
instead of -fpic.	1
compilers. The code	1
compilers. The advantage	1
compilers. The results	1
compilers. // It	1
compilers. // Example	1
compilers. This function	1
compilers. This includes	1
compilers. If exception	1
compilers. Intel C++	1
compilers. See www.openmp.org	1
compilers. Some compilers	1
compilers. Use automatic	1
compilers. #include <excpt.h>	1
compilers. We want	1
compilers. Several other	1
compilers. Dispatch at	1
compilers. Fastcall is	1
compilers. 2.5 Choice	1
compilers. 8.3 Obstacles	1
compilers. Wikipedia article	1
compilers. (The PGI	1
compilers. Mixing object	1
transferred to the	1
transferred in registers	8
transferred in registers.	1
transferred in registers,	3
transferred by value	1
transferred on the	2
transferred as an	1
transferred as pointers	1
transferred as machine	1
transferred from one	2
transferred at runtime	1
longer in 64	1
longer than a	2
longer than needed	1
longer time to	1
longer time in	1
longer time than	5
longer time slices.	1
longer used and	1
longer size by	1
longer time. It	3
longer time. Integer	1
longer used. A	1
longer used. It	1
longer response times	1
longer loop- carried	1
after the program	1
after the loop	1
after the pointer	1
after the 64-bit	1
after the value	1
after the test	1
after the last	1
after the piece	1
after it has	2
after this statement	1
after all objects	2
after all elements	1
after each of	1
after each time	1
after they have	1
after debugging if	1
after executing the	1
after executing a	1
after jumping out	1
after exceptions: while	1
read the time	1
read the value	2
read the performance	1
read and write	1
read and understand	1
read and written	1
read or write	2
read this first	1
read from the	1
read from a	1
read from memory	1
read from different	1
read from 0x4700.	1
read because the	1
read one or	1
read into one	1
read before p	1
read operations into	1
read about in	1
read four elements	1
give the compiler	1
give the variable	1
give the execution	1
give the result	2
give the full	1
give the 124	1
give a CPU	1
give a considerable	1
give it a	1
give you access	1
give each thread	1
give some indication	1
give overflow and	1
give higher priority	1
give almost identical	1
give inconsistent results	1
give annoyingly long	1
give misleading results	1
give -2.0 55	1
give infinity. A	1
Each of the	1
Each function call	1
Each code version	2
Each compiler does	1
Each time a	1
Each cache line	2
Each object is	1
Each type has	1
Each element in	1
Each element matrix[r][c]	1
Each thread can	1
Each thread will	1
Each thread has	1
Each thread should	1
Each line covers	1
Each dependency chain	1
Each graphics operation	1
Each instance of	1
Each 128-bit operation	1
becomes the same	1
becomes a little	1
becomes a problem.	1
becomes more efficient	1
becomes more fragmented	1
becomes more readable	1
becomes faster and	1
becomes bigger if	1
becomes smaller if	1
becomes easier if	1
becomes invalid if	1
becomes invalid as	1
becomes inefficient. There	1
becomes fragmented when	1
becomes fragmented thanks	1
becomes simpler because	1
becomes inconsistent and	1
becomes full. This	1
becomes noticeable. The	1
becomes contiguous. The	1
becomes bulky and	1
aligned to an	1
aligned // Structure	1
aligned or the	1
aligned or not.	2
aligned by the	1
aligned by at	1
aligned by 8	1
aligned by 32	1
aligned by 16,	2
aligned at round	1
aligned integer vector	2
aligned arrays with	1
aligned arrays Alignd	1
aligned operands Intel	1
aligned operands AMD	1
aligned #pragma vector	2
aligned Assume pointer	1
directives and declare	1
directives and keywords	1
directives for parallel	1
directives for multi-core	1
directives that select	1
directives are useful	1
directives are supported	1
directives are equivalent	1
directives are compiler-specific.	1
directives when used	1
directives which are	1
directives do not	1
directives 32 bit	1
directives Some compilers	1
directives work on	2
directives around it	1
directives .............................................................................................. 82	1
directives ......................................................................................... 65	1
directives Preprocessing directives	1
directives (everything that	1
requires the loading	1
requires a compiler	1
requires a big	1
requires a CPU-	1
requires a division,	1
requires that the	1
requires that you	2
requires that all	1
requires an extra	1
requires only an	1
requires only SSE).	1
requires no modification	1
requires static linking	1
requires several layers	1
requires support from	1
requires alignment to	1
requires OS support	1
requires log on	1
requires compilation or	1
requires n-1 multiplications,	1
optimizations is that	1
optimizations of the	1
optimizations of a	1
optimizations in different	1
optimizations in some	1
optimizations in precompiled	1
optimizations that it	1
optimizations that we	1
optimizations that rely	1
optimizations with option	1
optimizations on the	1
optimizations on that	1
optimizations you can	1
optimizations you have	1
optimizations when interprocedural	1
optimizations such as	2
optimizations possible because	1
optimizations across function	1
optimizations across modules	1
optimizations automatically, but	1
graphics function is	1
graphics function that	1
graphics function libraries	1
graphics on the	1
graphics library or	1
graphics objects in	1
graphics application is	1
graphics framework is	1
graphics framework between	1
graphics processors. 5	1
graphics operation in	1
graphics calculations. In	1
graphics processing unit	1
graphics processing unit.	1
graphics processing unit,	1
graphics frameworks, interpreters,	1
graphics card or	1
graphics accelerator card	1
graphics accelerator card.	1
graphics coprocessor or	1
graphics cards, etc.	1
public and static	1
public data can	1
public data object:	1
public functions and	2
public variable in	1
public variable where	1
public variables in	1
public variables go	1
public variables. All	1
public CHello {	2
public C0 {	1
public CParent<CChild1> {	2
public CGrandParent {	1
public B2 {	1
public B1 {	1
public CParent<CChild2> {	1
public B1, public	1
public symbols, but	1
public: int c;	1
public: int a;	1
public: int a[100];	1
public: float x,	1
public: static double	4
public: void Disp()	2
public: void Hello()	1
public: void NotPolymorphic();	2
public: virtual void	4
public: ... ~C1();	1
public: B2 b2;	1
public: c1() :	1
public: SafeArray() {	1
framework is used.	1
framework and the	1
framework and compile	1
framework in its	1
framework for interpreting	1
framework that must	1
framework that uses	1
framework are based	1
framework can consume	1
framework as well	1
framework may use	1
framework should definitely	1
framework between the	1
framework must be	1
framework typically uses	1
framework Most of	1
framework based on	1
framework sometimes have	1
framework still consumes	1
framework itself, during	1
framework requiring many	1
look in my	1
look at the	7
look at to	1
look at CPU	1
look at what	1
look different in	1
look up the	3
look up in	1
look like and	1
look like this:	3
look clumsy and	1
linking is that	1
linking is used.	2
linking is used,	1
linking is preferable	1
linking to assembly	1
linking and by	1
linking and position-independent	2
linking for any	1
linking makes the	1
linking makes it	1
linking cannot be	1
linking rather than	1
linking works differently.	1
linking are: Static	1
linking are: 146	1
linking (e.g. option	1
linking includes only	1
linking (remove unreferen-	1
linking (multithreaded) /arch:AVX	1
Many of the	1
Many of these	1
Many function libraries	1
Many CPU dispatchers	1
Many compilers have	1
Many Intel library	1
Many software programs	1
Many software applications	2
Many 32-bit systems	1
Many optimization options	1
Many libraries for	1
Many processors can	1
Many CPUs have	1
Many copy protection	1
Many programs spend	1
Many containers use	1
Many algebraic reductions	1
Many programmers have	1
Many advices on	1
Many services that	1
processors. The cache	1
processors. The performance	1
processors. The following	1
processors. The application	1
processors. A non-Intel	1
processors. It is	1
processors. In a	1
processors. There is	1
processors. There are	1
processors. See page	1
processors. AMD processors	1
processors. Many processors	1
processors. 5 Programmable	1
processors. Supports all	1
processors. On many	1
processors. Other brands	1
processors. Explicit CPU	1
processors. Consider the	1
processors. Hyperthreading is	1
processors. Henry S.	1
processors. Details about	1
actually be better	1
actually more than	1
actually has to	1
actually called in	1
actually making a	1
actually doing something	1
actually add extra	1
actually able to	1
actually quite powerful	1
actually quite convenient.	1
actually used. No	1
actually needed by	1
actually reduce speed	1
actually points to	1
actually is. This	1
actually increase the	1
actually reducing example	1
actually adds 16	1
actually hidden behind	1
actually implies more	1
actually throws an	1
Intel, even if	1
Intel, Gnu and	3
Intel, AMD and	12
Intel, AMD or	1
Intel, Microsoft and	1
Intel, Microsoft Intel,	1
Intel, PathScale and	1
Intel, Microsoft, Gnu,	1
linked function is	1
linked from static	1
linked into the	1
linked into projects	1
linked library functions.	1
linked libraries or	1
linked list is	2
linked list or	1
linked list has	1
linked list takes	1
linked list (see	1
linked together in	1
linked together with	1
linked either as	1
linked lists in	1
linked list. Each	1
linked list. Do	1
linked list. 94	1
linked together. The	1
linked lists. A	1
x; for (i	2
x; for (x	1
x; // x^2	1
x; This can	1
x; This makes	1
x; int A,	2
x; x *=	1
x; } };	1
x; float sum	1
x; const double	1
x; ... }	1
x; n >>=	1
x; public: c1()	1
x; Here, the	1
x; Note the	1
x; __asm fistp	1
x; nfac *=	1
x; *(int*)&x |=	1
x; x.f =	1
microprocessors is obtained	1
microprocessors is split	1
microprocessors is lost.	1
microprocessors and operating	1
microprocessors in the	2
microprocessors that do	1
microprocessors are not	1
microprocessors are using	1
microprocessors are very	1
microprocessors are able	2
microprocessors are constructed.	1
microprocessors can do	1
microprocessors have vector	1
microprocessors have no	1
microprocessors when an	1
microprocessors from Intel,	1
microprocessors without any	1
microprocessors work. The	1
microprocessors have. In	1
load the dynamic	1
load the structure	1
load the framework	1
load the entire	1
load is high	1
load is low	1
load a program	1
load a new	1
load time can	1
load more than	1
load all the	1
load into memory	1
load time. The	1
load time. Shared	1
load several files	1
load aligned integer	1
load unaligned integer	3
load address. If	1
load address. Relocation	1
control the way	1
control the addresses	1
control it compares	1
control no yes	1
control branch is	2
control branch depends	2
control branch ahead	1
control instructions than	1
control statement several	1
control condition is	1
control condition The	1
control instructions. There	1
control branch. There	1
control branch. See	1
control .............................................................................................. 99	1
control Microprocessors with	1
control condition: //	1
control tool. 7	1
assume the worst	1
assume is optimized.	1
assume that the	5
assume that it	1
assume that an	1
assume that floating	1
assume that b	1
assume that there	2
assume that these	1
assume that model	2
assume that seconds	1
assume that F1	1
assume that *p+2	1
assume no pointer	1
100; // Array	1
100; int i;	1
100; int matrix[NUMROWS][NUMCOLUMNS];	1
100; i +=	2
100; float list[size],	2
100; float list[ARRAYSIZE];	1
100; i++) {	7
100; i++) sum	1
100; i++) matrix[FuncRow(i)][FuncCol(i)]	1
100; S1 list[size];	1
100; x++) {	2
numbers is less	1
numbers is inefficient.	1
numbers of type	2
numbers to integers	1
numbers and integers	2
numbers in case	1
numbers in b[i]	1
numbers in question	1
numbers are not	1
numbers are stored	1
numbers are powers	1
numbers can be	1
numbers as a	1
numbers at a	1
numbers because all	1
numbers simply by	1
numbers form a	1
numbers mean good	1
platform is likely	1
platform is obviously	1
platform and operating	1
platform The choice	1
platform for a	1
platform with a	1
platform with an	1
platform not _WIN64	1
platform has become	1
platform n.a. __unix__	1
platform software development	1
platform _WIN64 _LP64	1
platform ....................................................................................... 5	1
platform _M_IX86 and	1
platform _M_IX86 _M_IX86	1
platform _WIN32 _WIN32	1
platform ........................................................................................... 5	1
platform 2.1 Choice	1
platform __GNUC__ and	1
platform independence, and	1
later and the	1
later in the	1
later // Header	1
later with code	1
later instruction set	5
later instruction set.	1
later instruction sets.	3
later Intel processors.	1
later reads from	1
later deleted by	1
later ported to	1
later maintenance. However,	1
later discovers that	1
later __svml_expf4 __svml_exp2	1
together and tested	1
together in the	1
together in an	2
together in one	1
together in order	1
together The code	1
together are also	1
together are stored	1
together if they	1
together with C	1
together on the	1
together should be	4
together into a	1
together near each	1
together Cache misses	1
together ...................................... 88	1
dispatch is made	1
dispatch to virtual	1
dispatch by CPU	1
dispatch on first	1
dispatch on every	1
dispatch branch of	1
dispatch branches are	1
dispatch mechanism is	1
dispatch mechanism in	2
dispatch mechanism that	1
dispatch mechanism can	1
dispatch mechanism even	1
dispatch Automatic vectorization	1
dispatch process. This	1
dispatch methods. The	1
dispatch strategies........................................................................................ 122	1
dispatch strategies It	1
dispatch decision at	1
dispatch mechanisms, and	1
calling the function	2
calling the library	1
calling the intrinsic	1
calling a simple	1
calling function can	1
calling function must	1
calling more efficient	1
calling from other	1
calling program is	1
calling any necessary	1
calling method in	1
calling conventions for	1
calling conventions are	1
calling itself in	1
calling conventions. The	1
calling conventions. Optimizes	1
calling conventions. FreeBSD	1
calling vector::reserve with	1
calling WritePrivateProfileString, which	1
your code is	2
your compiler for	1
your program to	1
your program before	1
your program exception	1
your program relies	1
your optimization effort	2
your programming questions	2
your application then	1
your own error	2
your own container	1
your own profiling	1
your own error-handling	1
your program, you	1
your software. A	1
your modifications actually	1
own function library	1
own memory block	1
own data structure	1
own CPU core.	1
own set of	1
own address through	1
own error handling	1
own error message	1
own allocated memory	1
own container classes	1
own block of	1
own stack. Alternatively,	1
own graphical user	1
own profiling instruments	1
own IDE. It	1
own research, not	1
own research, I	1
own initiative whenever	1
own error-handling function	1
own caller, and	1
declared in the	2
declared in a	2
declared or created	1
declared by specifying	1
declared with the	1
declared with #define	1
declared as constant	1
declared const in	1
declared inside the	2
declared inside a	4
declared outside of	1
declared whenever an	1
declared volatile then	1
declared volatile. This	1
XMM and 256-bit	1
XMM vector registers	1
XMM register can	1
XMM registers to	1
XMM registers for	1
XMM registers are	6
XMM registers can	1
XMM registers (see	1
XMM vectors must	1
XMM registers. Example:	1
XMM register. In	1
XMM (vector) reductions:	3
XMM registers; see	1
second by another	1
second way is	1
second result is	1
second application that	1
second induction variable	1
second operand is	4
second thing we	1
second generation of	1
second generation class	2
second step of	1
second step where	1
second step. The	1
second sum, then	1
second source, and	1
second operand. Likewise,	1
second sub-vector before	1
shows the same	1
shows the principle	1
shows a code	1
shows a way	1
shows that a	1
shows that it	1
shows an example	1
shows this calculation	1
shows which reductions	1
shows first the	1
shows how to	6
shows how you	1
shows how this	1
shows whether the	1
shows what the	1
interface is not	1
interface is obtained	1
interface to the	2
interface and use	1
interface and other	1
interface can use	1
interface than on	1
interface library for	1
interface library can	1
interface library may	1
interface elements that	1
interface framework must	1
interface framework Most	1
interface calls. The	1
interface frameworks are	1
interface etc., can	1
interface frameworks. This	1
interface framework........................................................................... 14	1
interface (OnIdle in	1
improve the performance	6
improve the code.	1
improve the execution	1
improve the speed	1
improve the performance,	1
improve the possibilities	1
improve this by	1
improve cache efficiency,	1
improve performance in	1
improve speed without	1
improve optimizations in	1
improve efficiency by	1
improve performance. It	1
improve search times	1
improve efficiency. These	1
higher for single	1
higher for shared_ptr	1
higher than the	1
higher than normal.	1
higher instruction set	2
higher instruction set.	2
higher instruction set,	1
higher number is	1
higher clock frequency	1
higher address which	1
higher priority to	1
higher priority than	1
higher level of	1
higher risk that	1
higher bits. There	1
higher speed. In	1
higher due to	1
higher resolution can	1
bigger and more	1
bigger if there	1
bigger than the	6
bigger than it	1
bigger than 2	1
bigger than 16	1
bigger than 127	1
bigger memory block	2
bigger memory block.	1
bigger vector registers.	1
bigger software packages	1
bigger systems. The	1
bigger vectors do	1
bigger segments (32-bit	1
vectors of two	1
vectors of 64	1
vectors of four	1
vectors of eight	1
vectors of inte-	1
vectors and matrixes.	1
vectors are preferably	1
vectors if the	1
vectors then you	1
vectors do not	1
vectors into C++	1
vectors There are	1
vectors SSE2 128	1
vectors must be	1
vectors requires alignment	1
vectors AVX2 256	1
vectors SSE3 horizontal	1
vectors RGB image	1
vectors ....................................................... 120	1
vectors FMA3 floating	1
Floating point variables	4
Floating point operations	1
Floating point calculations	1
Floating point overflow	1
Floating point precision	1
Floating point parameters	1
Floating point division	4
Floating point induction	1
Floating point addition	1
Floating point numbers	1
Floating point XMM	1
Floating point algebra	1
Floating point comparisons	2
AVX2 is supported	1
AVX2 and all	1
AVX2 // specific	1
AVX2 int 32	1
AVX2 instruction set	2
AVX2 float 32	1
AVX2 long long	1
AVX2 short int	1
AVX2 256 bit	1
AVX2 Table 12.3.	1
AVX2 Mathematical vector	1
AVX2 _mm256_i64gather_pd unlimited	1
AVX2 _mm_i64gather_pd unlimited	1
AVX2 _mm256_i32gather_epi32 unlimited	1
AVX2 _mm_i32gather_ps unlimited	1
AVX2 _mm256_i64gather_epi32 unlimited	1
AVX2 _mm_i32gather_epi32 unlimited	1
AVX2 _mm_i64gather_epi32 unlimited	1
AVX2 _mm256_i32gather_ps unlimited	1
piece of code	10
piece of memory	1
piece of program	1
piece of software	1
piece of code.	2
piece of memory.	1
piece of CPU-intensive	1
piece in a	1
piece by piece	1
piece at a	1
divisible by the	10
divisible by vector	1
divisible by 8	1
divisible by 16	1
divisible by 16.	4
divisible by 8.	2
divisible by TILESIZE	1
<< and |	1
<< 1; }	2
<< 2; }	2
<< list[i] <<	1
<< 4, anda	1
<< 4) +	1
<< 4) |	2
<< "Hello ";	2
<< 5. If	1
<< "Error: Index	2
<< 23; //	1
<< 6); Or,	1
<< x.f; //	1
<< endl; //	1
Here, the code	1
Here, the compiler	2
Here, the value	1
Here, the address	1
Here, the constant	1
Here, the Gnu	1
Here, it is	1
Here, you can	1
Here, you should	1
Here, you cannot	1
Here, each value	1
Here, there are	1
Here, we have	1
Here, I have	2
Here, / means	1
Here, y will	1
Here, log(2.0) is	1
x86 and x86-64	2
x86 and ARM	1
x86 instruction set	3
x86 processors are	1
x86 CPUs can	1
x86 platform _M_IX86	1
x86 CPUs. However,	1
x86 platforms. This	1
x86 platforms. Microsoft,	1
x86 platforms. 3.	1
x86 platforms. Works	1
x86 platforms (Windows,	1
x86 family of	1
x86 family can	1
x86 family have	1
x86 systems). 42	1
process is used	2
process is known	1
process of dynamic	1
process to take	1
process and software	1
process can proceed	1
process can influence	1
process or by	1
process or thread	1
process may take	1
process when compiled	1
process because the	1
process which is	1
process should always	1
process should run	1
process There is	1
process where the	1
process running when	1
binary code and	1
binary data storage	1
binary value of	1
binary executable code.	1
binary search for	1
binary integer, and	1
binary representation is	1
binary representation of	1
binary representation according	1
binary form than	1
binary tree or	2
binary tree may	1
binary code). Supports	1
binary search, or	1
binary tree. Is	1
binary decimals of	1
binary digits. The	1
binary trees, hash	1
know the value	1
know in advance	1
know for sure	1
know that a	2
know that double	1
know that processor	1
know that standard	1
know that u.f	1
know if this	1
know how a	1
know how to	2
know how this	1
know whether the	1
know what the	1
know what you	1
know what class	1
know about. Function	1
512 bits when	1
512 bits (ZMM).	1
512 matrix in	1
512 matrix size	1
512 512 matrix	2
512 512 2048	1
512 512 matrix.	1
512 512 378.7	1
512 AVX512 double	1
512 AVX512 float	1
512 AVX512 long	1
512 AVX512 Table	1
512 kb /	1
512 2048 230.7	1
512 matrix. My	1
512 378.7 168.5	1
512 520 and	1
512 kb, 8	1
generate the value	1
generate a new	1
generate a store	1
generate a piece	1
generate a bit-mask:	2
generate an error	1
generate an assembly	1
generate an overflow	1
generate an underflow	1
generate an interrupt,	1
generate floating point	1
generate multiple versions	1
generate many branch	1
generate any extra	1
generate relative addresses	1
generate relocations in	1
generate interrupts at	1
generate -128, and	1
advantages of function	1
advantages of each	1
advantages of using	5
advantages of object	1
advantages of C++	1
advantages of dynamic	2
advantages of alloca	1
advantages and drawbacks	1
advantages and disadvantages.	1
advantages that can	1
advantages that may	1
advantages when it	1
advantages over the	1
advantages over 32	1
r is the	1
r is a	1
r is re-loaded	1
r in Sum2	1
r are transferred	1
r = r	1
r = 28.	1
r + 2;	1
r + i/2;	1
r < SIZE;	4
r ; unused	1
r points to	1
r points to.	2
r ebx, eax	1
r places back	1
usually the order	1
usually not able	1
usually faster to	1
usually stored in	1
usually called in	1
usually called before	1
usually take the	1
usually much faster	1
usually done in	1
usually requires log	1
usually higher than	1
usually predicted well	1
usually inlined if	1
usually unroll a	1
usually share the	1
usually included as	1
usually divided into	1
usually 32. In	1
usually dealt with	1
results of the	1
results of my	1
results in table	1
results in another	1
results in RAM	1
results in a.	1
results in meaningless	1
results for branch	1
results are always	1
results are listed	1
results are combined	1
results are summarized	1
results or fail	1
results if the	1
results as floating	1
results when applied	1
results should be	1
results were as	1
results printf("\n%2i %10I64i",	1
b, and the	1
b, c and	1
b, c; a	2
b, c; //	2
b, c; b	1
b, c; ...	2
b, c; x[0]	1
b, temp; temp	1
b, c, d;	4
b, c, temp;	1
b, c, d,	3
storage is that	1
storage is inefficient	1
storage is determined	1
storage of static	1
storage of text	1
storage and page	1
storage are explained	1
storage on the	1
storage A limited	1
storage should be	1
storage order is	1
storage Most compilers	1
storage methods mentioned	1
storage Variables and	1
storage Variables that	1
storage (e.g. PowerPC).	1
storage space. It	1
storage p. 28)	1
storage principles are	1
old memory block	1
old data file	1
old version of	1
old operating systems	2
old processors without	1
old CPUs is	1
old block then	1
old microprocessors that	1
old microprocessors without	1
old CPUs. The	1
old computer with	1
old Pentium 4,	1
old Pentium 4.	1
old version. Updating	1
old C-style method	1
old DOS compilers).	1
old fashioned C	2
reduce the integer	1
reduce the number	1
reduce the performance	1
reduce the problem	1
reduce a to	1
reduce int x	1
reduce this problem.	1
reduce this to:	2
reduce other types	1
reduce example 12.1b	1
reduce any expression,	1
reduce some types	1
reduce simple algebraic	1
reduce speed if	1
reduce complicated algebraic	1
reduce various algebraic	1
reduce them all.	1
reduce (a*b*c)+(c*b*a) to	1
goes the same	1
goes the other	1
goes to the	2
goes to cache	1
goes to actually	1
goes to C0::f	1
goes in the	1
goes from the	1
goes one way	1
goes into sleep	1
goes many times	1
goes faster if	1
goes up and	1
goes through the	1
goes through an	1
goes another way	1
goes automatically when	1
goes randomly one	1
union is a	1
union is not	2
union can be	1
union can use	1
union can also	1
union { double	1
union { float	8
union { 89	1
union Bitfield {	1
union {double d;	1
union forces the	1
0, b =	1
0, c +	2
0, b; b	1
0, last byte	3
0, c, d;	1
0, _EM_OVERFLOW); //	2
0, sum2 =	1
0, s3 =	1
0, s2 =	1
0, sum; for	1
0, (a&b) |	1
0, s1 =	1
0, sizeof(a)); //	1
0, sizeof(a)); }	1
0, sizeof(list)); A	1
called. The compiler	1
called. The program	1
called. The values	1
called. The disadvantage	1
called. The safe	1
called. This is	1
called. This has	1
called. This method	1
called. A considerable	1
called. It is	1
called. If virtual	1
called. There is	1
called. You may	1
called. I have	1
called. Example: //	1
called. Therefore, the	1
called. Unfortunately, the	1
called. Lazy binding	1
called. 118 12.7	1
10 is an	1
10 - 20	2
10 page 101	1
10 double xpow10(double	2
10 * 8	1
10 clock cycles	2
10 clock cycles,	1
10 elements were	1
10 times rather	1
10 Gnu This	1
10 means that	1
10 μs today,	1
10 ms for	1
10 2.6 Choice	1
10 Multithreading The	1
10 Multithreading.............................................................................................................. 101	1
based on the	4
based on an	1
based on which	1
based on its	1
based on big	1
based on hardware	1
based on intermediate	2
based on complicated	1
based on what	1
based on compilers.	1
based on my	1
based on just-in-time	1
based on BSD,	1
based on hacks	1
based mainly on	1
choose the compilers	1
choose the most	1
choose the variables	1
choose the method	1
choose the type	1
choose the optimal	1
choose the appropriate	1
choose a software	1
choose a newer	1
choose to use	1
choose to make	1
choose to align	1
choose an up-to-date	1
choose this method	1
choose other programming	1
choose one of	1
choose between c2	1
choose either C	1
choose between. It	1
options to control	1
options to enable	1
options and the	1
options in the	1
options for the	1
options for fast	1
options that you	1
options are set	1
options are incompatible	1
options at the	1
options All C++	1
options Table 18.1.	1
options relevant to	1
options prevent optimization.	1
options turned on,	2
options turned on.	1
options -S or	1
options ................................................................................... 81	1
feature is used	1
feature is intended	1
feature is rarely	2
feature is seldom	1
feature for making	1
feature for reserving	1
feature that the	1
feature that there	1
feature that allows	1
feature on Intel	1
feature will become	1
feature into the	1
feature called performance	1
feature called whole	1
feature called "Gnu	1
feature uses an	1
feature was never	1
feature information, such	1
ways of doing	3
ways of handling	1
ways of copying	1
ways of multiplying	1
ways of reducing	1
ways of organizing	1
ways to make	1
ways to do	2
ways to avoid	3
ways to get	1
ways to divide	1
ways than by	1
ways around this	1
ways depending on	1
were in the	1
were as follows:	1
were not divided	1
were not present	1
were float instead	1
were able to	2
were unknown at	5
were measured on	1
were scarce resources.	1
were splitting 256-bit	1
were carried out	1
were tested: Microsoft	1
were observed between	1
were inserted, one	1
link to the	1
link to a	1
link with the	1
link with external	1
link pointer can	1
link pointer has	1
link library because	1
link library (*.dll	2
link library (DLL)	1
link order is	1
link libraries slower	1
link libraries (*.lib,	2
link pointers and	1
link libraries. These	1
link map or	1
link libraries, also	2
made the structure	1
made the right	1
made a Windows	1
made a series	1
made to the	1
made to recover	1
made for all	1
made for demonstration	1
made with option	1
made with Microsoft	1
made more compact	1
made very big	1
made available to	1
made about whether	1
made much more	1
made container class	1
made smaller by	1
made containers is	1
made local. This	1
appropriate to give	1
appropriate for the	1
appropriate function version	1
appropriate compiler options	1
appropriate instruction set	1
appropriate version of	5
appropriate version (May	2
appropriate type of	1
appropriate error message	1
appropriate error messages	1
appropriate header file	2
appropriate here. It	1
i, a, b;	1
i, sum =	1
i, f =	1
i, a[100]; for	1
i, i_div_3; for(i=i_div_3=0;	1
i, a); }	3
i, j; int	1
i, j; float	1
i, j; ...	1
i, a[100], b;	1
i, a[100], b,	1
i, a[100], temp;	1
i, StringLength; for	1
i, a[2]; for	1
i, largest_index =	1
i, timediff[i]); }	1
constructor is not	2
constructor is implemented	1
constructor and the	1
constructor and no	1
constructor for the	1
constructor that does	1
constructor can be	1
constructor // constructor	1
constructor // sum	1
constructor or overloaded	1
constructor may be	2
constructor must be	1
constructor sets all	1
constructor specifying otherwise.	1
constructor itself. Constructors	1
constructor initializes x	1
CPUs. The performance	1
CPUs. The SSE2	1
CPUs. The Gnu	1
CPUs. The Pentium	1
CPUs. The sequence	1
CPUs. This is	1
CPUs. This method	1
CPUs. It uses	1
CPUs. These costs	1
CPUs. However, a	1
CPUs. On the	1
CPUs. (See page	1
CPUs. Intel's profiler	1
CPUs. 5. Calling	1
CPUs. New versions	2
CPUs. Includes many	1
CPUs. Half size	1
2; // Find	1
2; } The	1
2; } A	1
2; } }	2
2; } void	1
2; } These	1
2; } };	2
2; } else	2
2; } list[300]	1
2; i <=	1
2; return a	2
2; i++) a[i]	1
2; Unfortunately, some	1
2; Common subexpression	1
just a single	1
just a few	1
just a matter	1
just by turning	1
just as a	1
just as fast	3
just an arbitrary	1
just because it	1
just one or	1
just one clock	1
just two additions	1
just two branches:	1
just long enough	1
just want the	1
just easier to	1
just happened to	1
a[i] is ecx+eax*4.	1
a[i] and shift	1
a[i] = b	1
a[i] = i	1
a[i] = r	1
a[i] = temp;	2
a[i] = *p	1
a[i] = log	1
a[i] = b[i]	1
a[i] = Induction;	2
a[i] = log(b[i])	2
a[i] = i+1;	1
a[i] = 0.0;	1
a[i] + b[i];	1
a[i] More examples	1
function, the compiler	1
function, and the	2
function, and it	1
function, if possible.	1
function, then the	1
function, but it	2
function, but unfortunately	1
function, one that	1
function, each optimized	1
function, while a	1
function, means that	1
function, though not	1
function, provided that	1
function, m is	2
function, etc., and	1
operands of the	1
operands and add	1
operands in case	1
operands The operands	1
operands are integer	1
operands are variables	1
operands are comparisons,	1
operands if the	1
operands have other	1
operands have no	1
operands have mixed	1
operands has side	1
operands because the	1
operands because you	1
operands Intel Core	1
operands cannot be	1
operands AMD Opteron	1
operands means that	1
innermost loop is	1
innermost loop of	2
innermost loop and	1
innermost loop that	1
innermost loop by	1
innermost loop A	1
innermost loop should	1
innermost loop doing	1
innermost loop bigger	1
innermost function, then	1
innermost loop. The	1
innermost loop. This	2
innermost loop. Another	1
innermost loop. log	1
innermost loop: for	1
innermost loops. 13.1	1
require a very	1
require a few	1
require a lot	1
require a multiplication	1
require a variable.	1
require that the	4
require that a	1
require that data	1
require more resources,	1
require other access	1
require two floating	1
require precision conversion	1
require runtime type	1
require cleanup before	1
require modifications in	1
compiler. The compilers	1
compiler. This library	1
compiler. This method	1
compiler. It is	1
compiler. You can	1
compiler. Some functions	1
compiler. Some compilers	2
compiler. Use CPUs	1
compiler. We can	1
compiler. Many algebraic	1
compiler. Supports only	1
compiler. Loop invariant	1
compiler. On the	1
compiler. Object files	1
compiler. Not optimized	1
compiler. 2.6 Choice	1
compiler. Remember, therefore,	1
advanced and complicated	1
advanced code version	1
advanced data structures	1
advanced C++ programming,	1
advanced version on	1
advanced version on,	1
advanced system performance	1
advanced programming constructs	1
advanced optimizing features,	1
advanced development tools.	1
advanced mathematical functions	1
advanced programmers and	1
advanced features rarely	1
advanced prediction mechanisms.	1
advanced algorithms to	1
advanced principles of	1
advanced facilities of	1
advanced high-level language	1
#define is certain	1
#define makes no	1
#define directives are	1
#define directives when	1
#define directive never	1
#define N1 (N	1
#define pure_function #endif	1
#define pure_function __attribute__((const))	1
#define FUNCNAME SelectAddMul_SSE41	1
#define FUNCNAME SelectAddMul_SSE2	1
#define FUNCNAME SelectAddMul_AVX2	1
#define swapd(x,y) {temp=x;	2
#define EXCEPTION_FLT_OVERFLOW 0xC0000091L	1
#define ABC 123	1
#define Alignd(X) X	1
#define Alignd(X) __declspec(align(16))	1
#define MAX(a,b) (a	1
points is not	1
points to the	3
points to is	1
points to a	1
points to and	1
points to an	2
points to ;	1
points to (see	1
points in the	1
points with the	1
points out some	1
points to. A	2
points to. Therefore,	1
points to. Now	1
switch is a	1
switch to protected	1
switch in your	1
switch between different	1
switch statement if	1
switch statement with	2
switch statement jump	1
switch statement leads	1
switch statements is	1
switch statements The	1
switch statements because	1
switch statements should	1
switch statements often	1
switch occurs during	1
switch statements, as	1
switch (n) {	1
switch statements............................................................................. 43	1
range is possibly	1
range of a	1
range of code	1
range of an	1
range of memory	1
range of floating	1
range and we	1
range } }	1
range then the	1
range then a	2
range from -128	1
range from 0x2700	2
range (see page	1
range analysis The	1
range analysis Join	1
range printf(Greek[n]); }	1
start the calculation	1
start the next	1
start a new	2
start of the	2
start of Func	1
start to calculate	1
start to program.	1
start to optimize	1
start to code,	1
start and stop	1
start at an	1
start at unpredictable	1
start so that	1
start calculations on	1
start garbage collection	1
start up, which	1
modules of a	1
modules and header	1
modules The compiler	1
modules that use	1
modules that make	1
modules are linked	1
modules or resource	1
modules if necessary,	1
modules with a	2
modules than the	1
modules may be	1
modules when the	1
modules into one	1
modules call the	1
modules (See page	1
modules contiguous in	1
modules appear in	1
smaller the data	1
smaller the integer	1
smaller the system,	1
smaller and the	1
smaller and more	1
smaller and closer	1
smaller in a	1
smaller if there	1
smaller by declaring	1
smaller by reordering	1
smaller as well.	1
smaller than the	1
smaller memory footprint.	1
smaller because relative	1
smaller functions only	1
smaller size is	1
smaller sizes (char,	1
smaller squares and	1
here is the	1
here is a	2
here is to	1
here is that	2
here is likely	1
here to draw	1
here in a	1
here // Virtual	1
here if the	1
here may apply	1
here because the	1
here because we	1
here about Linux	1
here about increment	1
here means that	1
here gives a+b=0,	1
core is running	1
core of modern	1
core and an	1
core and high-priority	1
core by setting	1
core with another	1
core on multi-core	1
core will always	1
core then it	1
core library contains	2
core clock cycles	2
core clock cycles.	1
core clock cycle	2
core during time	1
relevant to software	1
relevant to optimization	2
relevant to test	1
relevant to small	1
relevant to optimization.	1
relevant for the	1
relevant when the	1
relevant when CPU	1
relevant when testing	1
relevant optimization options	4
relevant options. Many	1
relevant information. 1.1	1
relevant books and	1
are: The process	1
are: The overhead	1
are: The syntax	1
are: int BigArray[1024]	1
are: It is	1
are: There is	1
are: All calculations	1
are: No loop-carried	1
are: When you	1
are: Avoid the	1
are: Variables that	1
are: Optimizing for	1
are: Static linking	1
are: 146 Multiple	1
are: Long double	1
are: Non-static member	1
are: Coarse time	1
around the constant	1
around the hot	1
around and less	1
around in the	1
around in memory	2
around in program	1
around in memory.	1
around it so	1
around on the	1
around on overflow	1
around this problem.	1
around this limitation	1
around at different	2
around such a	1
around 1980 where	1
5 and 20	1
5 and 9.	1
5 by another	1
5 } }	1
5 * 0.5	1
5 clock cycles	1
5 clock cycles,	2
5 times faster	1
5 / 2	1
5 #define FUNCNAME	1
5 Choosing the	2
5 μs on	1
5 2.2 Choice	1
5 2.1 Choice	1
5 Programmable logic	1
replaced by the	2
replaced by a	4
replaced by //	1
replaced by more	1
replaced by its	1
replaced by their	2
replaced by storage	1
replaced by my	1
replaced by x<<3,	1
replaced i by	1
replaced with: //	2
a; // 2	1
a; int b;	5
a; int b;};	1
a; double b;	2
a; double b;};	2
a; b =	1
a; float x,	1
a; y =	1
a; bool b;	1
a; Plus2 (&a);	1
a; 72 This	1
things to make	1
things to test	1
things in parallel.	1
things in parallel:	1
things that the	1
things that can	2
things with the	1
things with pointers	1
things you can	2
things at the	1
things only after	1
things very smart	1
things very stupid.	1
things like a	1
things like adding	1
negative or if	1
negative or -0	1
negative by AND'ing	1
negative integer will	1
negative value of	1
negative so that	1
negative list of	3
negative effect on	1
negative inputs give	1
negative result. An	1
negative numbers. The	1
negative effects of	2
negative list, on	1
negative impacts on	1
section is not	1
section is always	1
section and read-only	1
section for some	1
section can be	1
section if you	1
section by summing	1
section may contain	1
section will be	1
section so that	1
section contains no	1
section needs one	2
section (page 131)	1
section discusses how	1
section position-independent, makes	1
section 17.9: "Moving	1
reductions the compilers	1
reductions in my	1
reductions that the	1
reductions are not	1
reductions on integer	2
reductions on floating	2
reductions as 0/a	1
reductions at their	1
reductions such as	1
reductions they cannot	1
reductions Most compilers	1
reductions explicitly in	1
reductions manually. I	1
reductions involving integer	1
reductions involving division	1
go the same	1
go to the	1
go to dispatched	1
go more than	1
go one way	1
go into eight	1
go through the	1
go through a	1
go through multiple	1
go based on	1
go here //	1
go outside the	1
go back into	1
go away in	1
go undetected. The	1
go undetected. Converting	1
go deeper into	1
depends on the	10
depends on how	1
depends on calculations	1
depends on whether	1
depends on what	1
depends only on	2
depends very much	1
example: // Example	15
example: Use a	1
example: 38 //	1
tested the strlen	1
tested the capability	1
tested and investigated	1
tested in different	1
tested in Mac	1
tested can convert	1
tested with a	1
tested on a	1
tested on different	1
tested only on	1
tested library modules	1
tested were able	1
tested it. The	1
tested under worst-case	1
tested implement OneOrTwo5[b!=0]	1
tested seem to	1
tested (not up	1
contentions is that	2
contentions and the	1
contentions in the	3
contentions in large	2
contentions can be	1
contentions if the	2
contentions than for	1
contentions will occur:	1
contentions do not	1
contentions occur in	2
contentions expected. Use	1
predicted to go	1
predicted or if	1
predicted if the	1
predicted by the	1
predicted most of	1
predicted well if	1
predicted well only	2
predicted quite well	1
predicted depends on	1
predicted well. A	2
predicted well. Even	1
predicted well, of	1
predicted perfectly on	1
predicted perfectly varies	1
predicted perfectly. As	1
main will be	1
main will take	1
main memory and	1
main memory in	1
main has the	1
main through an	1
main advantage of	1
main memory. A	1
main program. See	1
main reason why	1
main executable to	1
main executable has	1
main executable because	1
main reasons why	1
main principles here:	1
main feedback comes	1
main focus is	1
references to data	1
references to relocate,	1
references in the	1
references in 32-bit	1
references in 64	1
references in 32	1
references are equally	1
references then tell	1
references do not	1
references rather than	1
references instead of	1
references require a	1
references are: When	1
references Pointers and	1
references Pointers versus	1
references ............................................................................................ 36	1
references accept expressions	1
loaded or at	1
loaded from memory	1
loaded at a	1
loaded at an	2
loaded at round	1
loaded only when	1
loaded into an	1
loaded into memory	1
loaded into memory.	1
loaded into ecx	1
loaded cannot be	1
loaded rather than	1
loaded type casting	1
loaded every time	1
loaded until the	1
loaded anyway. If	1
positive and 1	1
positive and negative	1
positive or the	1
positive } Example	1
positive integer constant.	1
positive floating point	1
positive number when	2
positive overflow of	1
positive list of	2
positive list needs	1
positive result. The	1
positive effects are:	1
positive n. You	1
positive integer: //	1
positive value, n.	1
loop. The time	1
loop. The loop	1
loop. The following	1
loop. The effect	1
loop. The loop-branch	1
loop. This is	1
loop. This reflects	1
loop. It is	1
loop. Example 12.4b	1
loop. Example 8.21	1
loop. If each	1
loop. In general,	1
loop. Example: //	1
loop. Some implementations	1
loop. Most compilers	1
loop. Another possibility	1
loop. log is	1
computer is not	1
computer is restarted	1
computer is reset	1
computer is rebooted.	1
computer for security	1
computer with a	1
computer with multiple	1
computer with many	1
computer has only	1
computer where the	1
computer while he	1
computer during the	1
computer users and	1
computer starts up,	1
computer game or	1
computer games and	1
computer games. Such	1
overhead of the	2
overhead of call	1
overhead of parameter	3
overhead of transferring	1
overhead of semaphores,	1
overhead of switching	1
overhead of managing	1
overhead to the	1
overhead to prevent	1
overhead in the	1
overhead which consumes	1
overhead while other	1
overhead cost of	1
overhead cost to	1
VIA processors because	1
VIA processor and	1
VIA processors. It	1
VIA processors. See	1
VIA processors. Explicit	1
VIA CPUs. 5.	1
VIA including the	1
VIA processors, and	1
VIA CPUs"). This	2
VIA CPUs"). Const	1
VIA CPUs" for	2
VIA CPUs" gives	1
VIA CPUs: An	1
VIA CPUs". A	1
VIA CPUs". 9.3	1
pointer. The pointer	1
pointer. The copy	1
pointer. This is	1
pointer. This can	1
pointer. A variable	1
pointer. It is	2
pointer. It may	1
pointer. It has	2
pointer. If a	1
pointer. You may	1
pointer. But there	1
pointer. These conversions	1
pointer. Likewise, all	1
pointer. Accessing an	1
pointer. 7.9 Smart	1
supports the corresponding	1
supports a particular	1
supports this option	1
supports this kind	1
supports then you	1
supports at least	1
supports vector intrinsics,	1
supports CPU dispatching	1
supports multiple programming	1
supports 32-bit and	1
supports Linux and	1
supports both Intel,	1
supports intrinsic functions,	1
supports automatic vectorization,	1
supports self-relative addressing	1
supports self-relative addressing.	1
supports this). Use	1
C and C++	1
C are too	1
C = 3.3;	2
C or C++	3
C or C++.	1
C function library	1
C if you	1
C functions such	1
C language as	1
C standard says	1
C library. It	1
C style with	1
C style as	1
C style string	1
compatible with the	1
compatible with a	1
compatible with that	1
compatible with different	1
compatible with other	1
compatible with all	1
compatible with CPUs	1
compatible with old	2
compatible with 16-bit	1
compatible with structured	1
compatible with Gnu.	1
compatible with these.	1
compatible on the	1
compatible instruction sets	1
compatible way is	1
compatible across compilers.	1
change the code	1
change the value	1
change the order	1
change the sign	1
change the expression	1
change the value.	1
change the behavior	1
change of a	1
change in the	1
change this to:	1
change its possible	1
change their clock	1
change what a	1
change what it	1
change && to	1
change during the	1
change pre-increment to	1
global and one	1
global and static	1
global if it	1
global if you	1
global variable in	2
global variable means	1
global variables or	1
global variables by	1
global variables (i.e.	1
global const variable	1
global arrays require	1
global variables. (See	1
global variables. They	1
global offset table	2
global object. The	1
my vector class	1
my optimization manuals	1
my optimization manuals.	1
my test tool	1
my test examples.	1
my manual will	1
my own research,	2
my free E-book	1
my study of	1
my experiment are	1
my blog. Here,	1
my experiments. Contentions	1
my crystal ball	1
my blog for	1
my comments, in	1
my tests, the	1
conversions is discussed	1
conversions and make	1
conversions in the	1
conversions The C++	1
conversions are not	1
conversions can be	1
conversions can sometimes	1
conversions by using	1
conversions from integer	1
conversions from floating	1
conversions from float	1
conversions do not	1
conversions between integers	2
conversions take a	1
conversions out of	1
statement and all	1
statement in the	1
statement in this	1
statement that calls	1
statement can be	1
statement can improve	1
statement if it	1
statement with many	1
statement with sequential	1
statement so that	1
statement always calls	1
statement several iterations	1
statement was executed.	1
statement jump tables,	1
statement leads to	1
statement occupies a	1
errors is to	1
errors in C++	2
errors in case	1
errors in cases	1
errors in programs	1
errors that would	1
errors that seldom	1
errors can happen	2
errors if the	1
errors if they	1
errors without using	1
errors must be	1
errors elsewhere in	1
errors associated with	1
off the loop	1
off the exception	1
off the binary	1
off the computer	2
off the position-independent	1
off the reading	1
off and use	1
off or until	1
off or log	1
off by default	1
off all optimizations	1
off support for	2
off debugging and	1
off requirements for	1
unused bytes in	2
unused bytes can	1
unused bytes //	1
unused bytes between	1
unused bytes byte	1
unused bytes S1	1
unused copy of	1
unused points in	1
unused columns to	1
unused label ;	3
unused label ;eax=addressofa	1
unused returns //	1
unused fourth value	1
relative to the	6
relative addresses in	2
relative addresses are	1
relative reference to	1
relative difference less	1
relative references in	1
relative references do	1
relative efficiency of	1
relative addresses. Therefore,	1
relative addressing of	1
columns is a	1
columns a power	1
columns to a	1
columns in a	3
columns in this	1
columns in matrix	2
columns = 8;	1
columns = 32;	1
columns = 50;	1
columns below diagonal	2
columns had not	1
columns unused. This	1
p is a	2
p is not	1
p is therefore	1
p is identical	1
p is incremented.	1
p and r	1
p and inlining	1
p = &	1
p = p	1
p = &Object1;	1
p = &Object2;	1
p has been	1
p + i;	1
p always points	1
p points to	1
platforms. The Microsoft	1
platforms. The Clang	1
platforms. This library	2
platforms. See the	1
platforms. AMD AMD	1
platforms. However, C++	1
platforms. 2. Optimizing	1
platforms. PathScale C++	1
platforms. Microsoft, Intel,	1
platforms. Clang The	1
platforms. Graphics accelerators	1
platforms. 3. The	1
platforms. Comparison of	1
platforms. Works well	1
platforms. Pascal has	1
languages and their	1
languages in Microsoft's	1
languages that do	2
languages are out	1
languages are good	2
languages are implemented	1
languages can be	1
languages as well.	1
languages have the	1
languages use an	1
languages such as	2
languages where everything	1
languages include C,	1
installation of the	2
installation of downloaded	1
installation and uninstallation	1
installation The time	1
installation time and	1
installation program makes	1
installation time. Each	1
installation process to	1
installation process can	1
installation process or	1
installation process should	1
installation options at	1
installation tools. It	1
installation tools. Automatic	1
installation .................................................................................................. 18	1
depending on the	12
depending on instruction	1
depending on how	2
depending on what	1
syntax is so	1
syntax is very	1
syntax is fully	1
syntax is simpler	1
syntax in example	2
syntax in both	1
syntax or See	1
syntax may seem	1
syntax has several	1
syntax described in	1
syntax checking and	1
syntax 90 Gives	1
syntax check. It	1
syntax checks. These	1
syntax restriction, but	1
cases. The most	1
cases. The so-called	1
cases. The equivalent	1
cases. The explicit	1
cases. This is	1
cases. This means	1
cases. It is	1
cases. See manual	1
cases. For example:	1
cases. An even	1
cases. Integer expressions	1
cases. Don't change	1
cases. Multiple threads?	1
cases. Does not	1
cases. 7.28 Templates	1
cases. Database queries	1
Supports the OpenMP	1
Supports vector intrinsics	1
Supports only 32-bit	2
Supports all x86	3
Supports 32-bit and	2
Supports both AMD	1
Supports three different	1
Supports x86 and	1
Supports parallel processing,	2
Supports OpenMP and	1
Supports 32- and	1
choice of compiler	1
choice of which	1
choice of user	1
choice of programming	2
choice of hardware	2
choice of platform	1
choice of algorithm	1
choice of n.	1
choice for code	1
choice for all	2
choice for Linux	1
choice for future	1
choice between optimizing	1
1. The reason	1
1. The AND	1
1. This makes	1
1. This ends	1
1. This '1'	1
1. See page	1
1. Use a	1
1. / (b1	1
1. Note that	1
1. Optimizing software	2
1. Add the	1
1. Number 18	1
1. How much	1
1. Writing a	1
1. Relocation. All	1
STL is not	1
STL is designed	1
STL for accessing	1
STL are universal,	1
STL as a	1
STL has been	1
STL vector stores	1
STL vector turned	1
STL also costs	1
STL container are	1
STL containers is	1
STL containers do	1
STL templates, such	1
STL containers. See	1
STL (Standard Template	1
STL deque (doubly	1
intended to be	1
intended to work	1
intended to mimic	1
intended for CPU	1
intended for array	1
intended for variables	1
intended for 32-bit	1
intended for system	1
intended for calculating	1
intended for finding	1
intended for detecting	1
intended as a	1
intended because of	1
intended (see page	1
intended for. In	1
intended for. Some	1
dynamically and that	1
dynamically with new	1
dynamically when the	2
dynamically allocated memory	1
dynamically allocated objects	2
dynamically allocated memory.	2
dynamically allocated memory,	2
dynamically allocated memory.................................................................	1
dynamically linked library	1
dynamically depending on	1
dynamically created by	1
dynamically (with new	1
consecutive elements in	4
consecutive elements from	6
consecutive elements c.load(cc+i);	1
consecutive elements b.load(bb+i);	1
consecutive bytes of	1
consecutive variables. Example:	1
consecutive terms in	1
consecutive indices or	1
profiler is most	1
profiler is called	2
profiler to find	2
profiler that can	1
profiler may sample	1
profiler which determines	1
profiler works then	1
profiler counts how	1
profiler tells the	2
profiler itself. Function	1
profiler inserts temporary	1
profiler measures not	1
profiler identifies any	1
become a serious	2
become more powerful.	1
become very big.	1
become less important	1
become available in	1
become too fragmented.	1
become bigger and	1
become fragmented and	1
become fragmented when	1
become fragmented. This	1
become fragmented. An	1
become invalid. The	1
become invalid, and	1
become imprecise or	1
become obsolete within	1
Windows, the first	1
Windows, you can	1
Windows, you may	1
Windows, while most	1
Windows, Linux and	3
Windows, including an	1
Windows, Linux, Mac	1
Windows, Linux, BSD	2
Windows, Linux, Mac,	1
Windows, allow variables	1
Windows, SetThreadAffinityMask, in	1
Windows, -msse2, -mavx,	1
Windows, Intel/MASM syntax:	1
index is not	1
index is out	3
index of memory	1
index or key	1
index by 8.	1
index than when	1
index then the	1
index then it	1
index out of	1
index must be	1
index operator }	1
index changes fastest:	1
index changing in	1
index multiplied by	1
modern C++ compilers.	1
modern programming languages	1
modern processors prefetch	1
modern CPUs can	1
modern CPUs have	1
modern microprocessors is	2
modern microprocessors and	1
modern microprocessors are	1
modern x86 CPUs	1
modern CPUs. The	1
modern CPU. But	1
modern CPUs, as	2
modern computers have	1
modern software, it	1
gives the value	1
gives the advantage	1
gives the simplest	2
gives the chosen	1
gives the worst	1
gives a measure	1
gives an advantage	1
gives an 9	1
gives more details	1
gives more reliable	2
gives access to	1
gives zero. An	1
gives a+b=0, and	1
gives rise to	1
Loop to make	1
Loop to print	1
Loop with branch	2
Loop through array	1
Loop counter //	1
Loop counter //=2*A	1
Loop unrolling should	2
Loop unrolling also	1
Loop unrolling In	1
Loop unrolling Some	1
Loop r1 and	1
Loop r2 and	1
Loop invariant code	2
avoided in 64-bit	1
avoided for these	1
avoided by using	1
avoided by making	2
avoided by calling	1
avoided by inlining	1
avoided by copying	1
avoided by joining	1
avoided by rolling	1
avoided by replacing	1
avoided on processors	1
avoided when speed	1
avoided because of	1
avoided because they	1
avoided unless you	1
turn it off	1
turn on and	1
turn on this	2
turn on all	1
turn on correction	1
turn calls another	1
turn off the	3
turn off or	1
turn off support	2
turn off debugging	1
turn off requirements	1
turn them off	1
inlining the call	1
inlining the frame	1
inlining the latter	1
inlining is that	1
inlining is done	1
inlining a function	1
inlining and constant	1
inlining The compiler	1
inlining can open	1
inlining more efficient	1
inlining has the	1
inlining all the	2
inlining are: The	1
inlining causes technical	1
inlining x-xxxx--x Constantfolding	1
size. The alternative	1
size. This is	1
size. If this	1
size. In other	1
size. In fact,	1
size. There is	1
size. I tried	1
size. However, it	1
size. Integer operations	1
size. When the	1
size. Alternatively, you	1
size. Vectorized code	1
size. Integers of	1
size. Today, it	1
size. Unpredictable branches	1
size. Later models	1
network is overloaded	1
network is unstable	1
network and other	1
network or database	1
network with heavy	1
network may be	1
network access to	1
network access in	1
network access may	1
network resources and	1
network resources are	1
network resources cannot	1
network resources. This	1
network resources, databases,	1
network connections. Temporary	1
slow and fragmented	1
slow // Division	1
slow // Modulo	1
slow or completely	1
slow instruction that	1
slow bit scan	2
slow unless the	2
slow implementations of	1
slow GOT lookup	1
slow down the	2
slow down a	1
slow CPU, an	1
b) is calculated	1
b) a &&	1
b) = (a	1
b) - n.a.	1
b) { if	4
b) { return	1
b) + (c	1
b) But beware	1
b) etc. at	1
b) y =	1
b) >> n	1
b) {x =	1
>= size can	1
>= 0; i--,	1
>= b) -	1
>= (unsigned int)size)	1
>= 2) SelectAddMul_pointer	1
>= 4) {	2
>= 8) SelectAddMul_pointer	1
>= size) {	1
>= 5) SelectAddMul_pointer	1
>= 11) {	2
>= min &&	1
>= operators). The	1
>= N) {	1
desired function version	1
desired program structure.	1
desired instruction set	1
desired instruction set.	1
desired version of	1
desired version in	1
desired new features.	1
desired function. The	1
desired parameters typedef	1
desired values before	1
desired version. Note	1
desired polymorphism effect	1
desired functionality without	1
desired measurement instruments	1
desired interval is	1
Such a branch	1
Such a processor	1
Such a list	1
Such a soft	1
Such a coprocessor	1
Such an extra	1
Such variables and	1
Such variables have	1
Such dependency chains	1
Such units can	1
Such schemes are	1
Such schemes cause	1
Such frameworks are	1
Such events as	1
Such hybrid solutions	1
#pragma vector always	3
#pragma vector aligned	3
#pragma vector nontemporal	3
#pragma ivdep Assume	1
#pragma ivdep __restrict	1
#pragma optimize("a",on). Specifies	1
#pragma optimize(...) Fastcall	1
#pragma optimize("a", on)	1
#pragma novector to	1
Dynamic memory allocation	9
Dynamic libraries are	1
Dynamic linking and	2
Dynamic linking makes	1
Dynamic linking works	1
Dynamic cast The	1
functions, and other	1
functions, and put	1
functions, or if	1
functions, but the	1
functions, but in	1
functions, but less	1
functions, but unfortunately	1
functions, where static	1
functions, called procedure	1
functions, etc. in	1
functions, etc. are	1
functions, inline assembly	1
functions, trigonometric functions,	2
functions, classes, templates	1
whole program by	1
whole program optimization	2
whole program optimization.	2
whole program execution,	1
whole program optimization,	1
whole program 81	1
whole loop will	1
whole software project	1
whole software package,	1
whole structure of	1
whole program. During	1
whole polygon or	1
whole workday or	1
inefficient to use	2
inefficient in large	1
inefficient if the	1
inefficient if a	1
inefficient when the	1
inefficient because the	2
inefficient because of	1
inefficient because it	1
inefficient virtual function	1
inefficient way. The	1
inefficient way. See	1
inefficient solution. Many	1
inefficient code-based methods	1
level-2 cache is	2
level-2 cache of	1
level-2 cache and	1
level-2 cache are	1
level-2 cache as	1
level-2 cache from	1
level-2 cache because	1
level-2 cache cannot	1
level-2 cache contentions	2
level-2 cache miss	1
level-2 cache. The	1
level-2 cache. This	1
level-2 cache. Using	1
response is delayed	1
response to pressing	1
response time is	2
response time to	2
response time under	1
response from a	1
response times to	2
response times for	3
response times. It	1
response times, even	1
described a mechanism	1
described in the	4
described in this	1
described in more	1
described in chapter	2
described in detail	1
described on page	1
described some of	1
described above can	1
described below. The	1
described below. Make	1
2. The compiler	1
2. The instruction	1
2. The following	1
2. The result	1
2. Example: //	2
2. Use the	1
2. Using hexadecimal	1
2. (See page	1
2. Optimizing subroutines	1
2. Position-independent code.	1
2. Objects bigger	1
2. Contentions in	1
2. Check that	1
2. Put the	1
variables. The negative	1
variables. This includes	1
variables. A positive	1
variables. It is	1
variables. In these	1
variables. See chapter	1
variables. Example: //	1
variables. All global	1
variables. (See thread-local	1
variables. Vector operations	1
variables. Obviously, this	1
variables. They can	1
variables. 9.5 Alignment	1
variables. 31 7.3	1
variables. Move the	1
lines is 8*1024/64	1
lines to use	1
lines and sets.	1
lines in the	1
lines in a	1
lines in set	1
lines in each	1
lines in column	1
lines for matrix	1
lines are organized	1
lines from set	1
lines should be	1
lines we used	1
lines follow the	1
lines belong to	1
hot spots and	1
hot spots in	2
hot spots have	1
hot spots Before	1
hot spots ..................................................................................	1
hot spot and	1
hot spot that	1
hot spot has	1
hot spot but	1
hot spot. Use	1
hot spot. Sometimes,	1
hot spot. Repeating	1
hot spots, but	1
hot spots. The	1
Unfortunately, the compiler	1
Unfortunately, the CPU	1
Unfortunately, the way	1
Unfortunately, the standard	1
Unfortunately, the syntax	2
Unfortunately, the cross-platform	1
Unfortunately, this method	1
Unfortunately, many standard	1
Unfortunately, some compilers	1
Unfortunately, table lookup	1
Unfortunately, these functions	1
Unfortunately, few compilers	1
Unfortunately, profilers are	1
Unfortunately, contemporary operating	1
v. 8.42n, 2004.	1
v. 11.1 for	1
v. 10.1.020. Functions	1
v. 3.1, 2007.	1
v. 4.5.2, July	1
v. 9.0 CodeGear	1
v. 1.4, 2005.	1
v. 7.2). This	1
v. 5.5 Mac:	1
v. 2.00. Intel	1
v. 2.1.7, 2004.	1
v. 14.00 for	1
v. 4.1.0, 2006	1
v. 2.7, 2.8.	1
v. 7.1-4, 2008.	1
operation is performed	2
operation in the	1
operation that crashes	1
operation can often	1
operation on such	1
operation will be	1
operation will then	1
operation which is	1
operation using the	1
operation takes 5	1
operation rather than	1
operation doesn't delay	1
operation was split	1
operation isolates the	1
code, as the	1
code, as explained	1
code, as described	1
code, you may	1
code, then you	1
code, which is	1
code, which supposedly	1
code, but this	1
code, but there	1
code, cache misses	1
code, so you	1
code, specific preferences	1
code, see below.	1
code, including user	1
code, interpreters, just-in-time	1
instance of the	5
instance of a	1
instance of S1	1
instance in main	1
instance for each	5
instance then you	1
instance has its	1
comes to optimization,	1
comes to mind.	1
comes with the	1
comes with most	2
comes with some	1
comes on the	1
comes when a	1
comes from a	1
comes from testing.	1
comes at a	1
comes only in	1
comes before the	1
comes first when	1
comes automatically. There	1
fact that the	4
fact that n	1
fact be less	1
fact it does	1
fact by replacing	1
fact an integer	1
fact only 64-bit	1
fact using each	1
fact accessed through	1
fact doing the	1
fact represented as	1
fact addressed relative	1
find the one	1
find the address	1
find the first	1
find the best	1
find the optimal	1
find the right	1
find the GOT	1
find the answers	1
find and resolve	1
find more examples	1
find out which	1
find out whether	1
find hot spots	2
find elsewhere. Faster	1
rely on the	4
rely on is	1
rely on a	1
rely on compiler	1
rely on only	1
rely on static	1
rely on instructions	1
rely on automatic	2
rely on anything	1
rely on longjmp	1
rely heavily on	1
No function or	1
No time is	1
No memory will	1
No program should	1
No cache contentions.	1
No error return	1
No stack frame	1
No exception handling	1
No information about	1
No runtime type	1
No link pointer	1
No general statement	1
No loop-carried dependency	1
No differences were	1
No universal solution	1
produce the same	2
produce the optimal	1
produce a single	1
produce no other	1
produce any extra	3
produce less optimal	1
produce 32 results	1
produce Boolean output.	1
produce binary code).	1
produce tables of	1
produce undesired results.	1
produce streaming audio	1
position-independent code is	1
position-independent code and	3
position-independent code by	1
position-independent code when	1
position-independent code Function	1
position-independent code flag	1
position-independent code .......................................................	1
position-independent code everywhere	1
position-independent code (option	1
position-independent has the	1
position-independent because this	1
position-independent code. These	1
position-independent code. 147	1
vectorization will be	1
vectorization then follow	1
vectorization const int	1
vectorization less favorable:	1
vectorization (see page	2
vectorization works best	1
vectorization Automatic paralleli-	1
vectorization is. Factors	1
vectorization ......................................................................................... 107	1
vectorization leads to	1
vectorization Not all	1
vectorization Devirtualization ---x-----	1
vectorization favorable: Small	1
vectorization Good compilers	1
including the library	1
including the 64-bit	1
including the while	1
including the profiler	1
including the terminating	2
including the ability	1
including a header	1
including an IDE.	1
including all runtime	1
including 32-bit and	1
including user interface	1
including local data	1
including linear algebra	1
including relaxed floating	1
checking is explained	1
checking is included	1
checking and is	1
checking and various	1
checking for array	1
checking for overflow,	1
checking if b[i]	1
checking all the	1
checking multiple values	2
checking In C++,	1
checking how well	1
checking template <typename	1
checking (see page	1
checking .................................................................................................. 134	1
out-of-order execution and	1
out-of-order execution mechanism	2
out-of-order mechanism allows	1
out-of-order capabilities of	1
out-of-order capabilities are	1
out-of-order capabilities can	1
out-of-order capabilities (see	1
out-of-order execution. The	1
out-of-order execution. This	1
out-of-order execution. It	1
out-of-order execution. There	1
out-of-order execution, as	1
out-of-order execution, you	1
platforms and the	1
platforms and other	1
platforms and operating	1
platforms and various	1
platforms that use	1
platforms or multiple	1
platforms if the	1
platforms with Windows,	1
platforms with big-endian	1
platforms as well,	1
platforms as shown	1
platforms because it	1
platforms By Agner	1
platforms (Windows, Linux,	1
particularly time consuming.	1
particularly critical because	1
particularly useful performance	1
particularly important on	1
particularly fast on	1
particularly slow instruction	1
particularly slow implementations	1
particularly critical. A	1
particularly critical. 129	1
particularly bad on	1
particularly problematic because	1
particularly interesting because	1
particularly risky because	1
particularly tricky. I	1
given a false	1
given a name.	1
given in the	1
given in example	1
given in manual	1
given in www.agner.org/optimize/cppexamples.zip.	1
given in advance.	1
given on page	1
given as a	1
given instruction set.	1
given below. The	1
given here may	1
given task is	1
given above. 7.	1
output of the	1
output of a	1
output are unacceptable.	1
output can often	1
output can produce	1
output more readable	1
output should be	1
output option is	1
output option then	1
output after the	1
output goes to	1
output file. A	1
output listing to	1
output (/FAs or	1
level-1 and the	1
level-1 data cache	3
level-1 data cache,	1
level-1 cache is	1
level-1 cache are	1
level-1 cache may	1
level-1 cache from	1
level-1 cache contentions	1
level-1 cache size.	1
level-1 cache. The	2
level-1 cache. We	1
resources. The system	1
resources. This time	1
resources. In this	1
resources. There are	1
resources. For example,	1
resources. For these	1
resources. But it	1
resources. However, the	1
resources. Most of	1
resources. Each graphics	1
resources. On the	1
resources. Modern CPUs	1
resources. Typically, a	1
resources. Consider running	1
outside the loop	3
outside the critical	1
outside the innermost	2
outside the loop.	2
outside the bounds	1
outside the loop:	1
outside of any	1
outside this interval,	1
outside any function)	1
outside both loops	1
task is often	1
task is divided	1
task of the	1
task in question.	1
task that takes	1
task that consumes	1
task or thread	1
task when the	1
task into a	1
task must have	1
task switch occurs	1
task switches and	1
task switching. This	1
task switches; so	1
limited is to	1
limited to well-tested	1
limited and there	1
limited in scope.	1
limited by the	2
limited by physical	1
limited number of	2
limited range then	1
limited resources. Most	1
limited resource. The	1
limited "express" edition	1
limited audience for	1
vectorized if the	1
vectorized if you	1
vectorized with the	1
vectorized with SSE4.1	1
vectorized code or	1
vectorized code when	1
vectorized code should	1
vectorized as intended	1
vectorized as follows	1
vectorized table lookup	1
vectorized table lookup.	1
vectorized code. Storing	1
vectorized #include <dvec.h>	1
vectorized automatically. For	1
sometimes be replaced	1
sometimes be avoided	1
sometimes be obtained	1
sometimes be eliminated	1
sometimes it does	1
sometimes have unacceptably	1
sometimes more efficient	2
sometimes possible to	1
sometimes take more	1
sometimes uses 32-bit	1
sometimes able to	1
sometimes give misleading	1
sometimes unacceptably long.	1
local A function	1
local data that	1
local object is	1
local object static	1
local objects are	1
local variables and	1
local variables in	1
local const variable	1
local name for	1
local variable. This	1
local references. If	1
local references. Shared	1
local variables, and	1
local non-member functions.	1
costs of this	1
costs of software	1
costs of dynamic	1
costs of optimizing	2
costs of position-independent	1
costs to other	1
costs to such	1
costs to multithreading	1
costs in terms	2
costs are higher	1
costs can be	1
costs if it	1
S1 in the	1
S1 { int	1
S1 { double	1
S1 { float	1
S1 { short	1
S1 aligned //	1
S1 x, y;	1
S1 list[100]; int	1
S1 {double a;	2
S1 ArrayOfStructures[100]; This	1
S1 ArrayOfStructures[100]; Here,	1
S1 list[size]; int	1
S1 list[100], *temp;	1
math is required	1
math and the	1
math function library	1
math function libraries	1
math functions should	1
math functions such	1
math library (SVML).	1
math library (VML,	1
math core library	1
math libraries. The	1
math allow addition	1
math libraries: Intel	2
math libraries: long	1
temp a register	1
temp in one	1
temp in memory.	1
temp = b	1
temp = a[i]	1
temp = 3;	1
temp = a+1;	1
temp * temp;	2
temp < &list[100];	1
temp before it	1
temp even though	1
temp += 9;	1
temp / 4;	1
inlined for improved	1
inlined or cannot	1
inlined function and	1
inlined function for	1
inlined if the	1
inlined by declaring	1
inlined - no	1
inlined functions may	1
inlined so that	1
inlined even when	1
inlined function. The	1
inlined function. Function	1
inlined automatically by	1
inlined 15.1b and	1
still the same	1
still the fastest	1
still be in	1
still be used	1
still be vectorized,	1
still have a	1
still take 10	1
still want to	1
still uses a	1
still run on	1
still needs careful	1
still give a	1
still consumes a	1
still frustrated by	1
class. The static	1
class. The container	1
class. The child	1
class. The transfer	1
class. This is	1
class. This makes	1
class. This check	1
class. It makes	1
class. Make the	1
class. Data members	1
class. Calling a	1
class. Storing variables	1
class. Which solution	1
class. Members of	1
database is heavily	1
database in the	1
database in Windows.	1
database for storing	1
database can consume	1
database by a	1
database It can	1
database access. 3.10	1
database ...................................................................................................... 20	1
database anyway if	1
database connections. Open	1
database integration, web	1
database queries is	1
database connections, etc.	1
constants is very	1
constants and floating	1
constants in the	1
constants that are	1
constants are double	1
constants are stored	1
constants are usually	1
constants are defined	1
constants are identical	1
constants can be	1
constants will be	1
constants because it	1
constants we can	1
constants Sunday, Monday,	1
bool is used	1
bool in order	1
bool a, b;	1
bool a, b,	2
bool b; a	1
bool b; if	2
bool 1 1	1
bool a; float	1
bool b) {	4
Do not use	6
Do not make	2
Do not read	1
Do not turn	1
Do not mix	1
Do not swap	1
Do objects have	2
frame is used	1
frame function is	1
frame function can	1
frame function or	1
frame function because	1
frame function into	1
frame functions for	1
frame functions then	1
frame makes function	1
frame functions. A	1
frame functions. While	1
frame unless your	1
frame function, while	1
frame /Oy -fomit-	1
== 2 //	1
== 2 #define	1
== 2 12.6	1
== 8 #define	1
== 5 #define	1
== 0) {	4
== 0) ?	1
== Wednesday ||	1
== EXCEPTION_FLT_OVERFLOW ?	1
== Friday) {	1
== Tuesday ||	1
d; a =	1
d; // 2	1
d; // makes	1
d; // 4	1
d; if (a	1
d; This expression	1
d; int i[2];	1
d; unsigned int	1
d; c =	2
d; }; void	1
d; d =	3
special vector registers.	1
special loop predictor.	1
special cache called	1
special cases such	1
special cases where	1
special versions of	1
special feature that	1
special position-independent code	1
special reasons to	1
special purposes are	1
special purpose libraries	1
special trick which	1
special precautions for	1
special mathe- matical	1
prevent the compiler	2
prevent the CPU	1
prevent it from	1
prevent this kind	1
prevent memory leaks	1
prevent cache contention.	1
prevent two threads	1
prevent such errors	2
prevent such errors.	1
prevent optimizing //	1
prevent optimization. The	1
prevent legitimate backup	1
shift and add	1
shift in software	1
shift out the	2
shift out sign	1
shift operations take	1
shift Floating point	1
shift operation which	1
shift right =	1
shift operations. Multiplying	1
shift down sign	1
shift operation. For	1
shift operation. x*8	1
shift operation, which	1
destructor the object	1
destructor is as	2
destructor is called	1
destructor of x.	1
destructor to make	1
destructor to call	1
destructor for the	1
destructor that makes	1
destructor that needs	1
destructor that destroys	1
destructor if it	1
destructor by constructing	1
destructor causes another	1
save a lot	1
save by avoiding	1
save time for	1
save one unit	1
save cache space	1
save some information	1
save time. The	1
save several clock	1
save exception handling	1
save temp in	1
save RAM space,	1
save ebx on	1
save power. There	1
save recovery information	1
prevents the compiler	5
prevents the use	1
prevents the CPU	2
prevents the level-2	1
prevents a faster	1
prevents it from	1
prevents all optimizations	1
prevents certain optimizations.	1
prevents out-of-order execution.	1
preceding one is	1
preceding one (see	1
preceding value of	1
preceding example, this	1
preceding branches and	1
preceding addition is	1
preceding addition then	1
preceding iteration is	1
preceding label plus	1
preceding one. This	1
preceding one. You	1
preceding paragraph and	1
preceding paragraph described	1
preceding row. The	1
safe to use	1
safe to make	1
safe to do	1
safe and flexible,	1
safe if it	1
safe if multiple	1
safe if there	2
safe than the	1
safe way to	1
safe way in	1
safe programming practice,	1
safe unless the	1
safe formula a[i]	1
d in assembly	1
d = a	2
d = 0;	1
d = 1;	1
d = u;	1
d = x-	1
d = ((a*x+b)*x+c)*x+d	1
d = (double)(signed	2
d = 1.6;	1
d + 3.5;	1
d + e	1
d would all	1
Choice of function	2
Choice of compiler	2
Choice of operating	2
Choice of user	2
Choice of programming	2
Choice of hardware	2
Choice of microprocessor	2
tell the compiler	9
tell a hyperthreading	1
tell it this	1
tell how many	1
tell these compilers	1
tell explicitly what	1
Pentium 4 and	1
Pentium 4 with	1
Pentium 4 computer	1
Pentium 4 processors,	1
Pentium 4 processor.	1
Pentium 4 computer.	1
Pentium 4 (NetBurst)	1
Pentium CPUs which	1
Pentium 4, while	1
Pentium 4. The	2
Pentium 4. Even	1
Pentium M processor	1
Pentium Pro instruction	1
further if the	1
further by using	1
further explained in	1
further tested and	1
further described in	1
further discussion of	4
further optimizations. Loops	1
further explanation. The	1
further discussion. Integer	1
further expansions of	1
further extension of	1
Assume that the	1
Assume that a	3
Assume that you	1
Assume function is	1
Assume function called	1
Assume function does	1
Assume no pointer	2
Assume pointer is	1
Assume pointer not	1
Assume member function	1
Assume now that	1
efficiency is obtained	1
efficiency is important.	1
efficiency is reflected,	1
efficiency of the	2
efficiency of a	1
efficiency of different	3
efficiency of 32-bit	1
efficiency and code	1
efficiency by using	1
efficiency then it	1
efficiency lies in	1
repeat the above	1
repeat or to	1
repeat loop if	1
repeat count is	6
repeat count and	3
repeat count may	1
repeat count has	1
unroll the loop	2
unroll a loop	3
unroll a loop.	1
unroll by two	1
unroll option in	1
unroll too much.	1
unroll loops if	1
unroll factor. A	1
unroll factor. If	1
unroll factor. For	1
unroll factor. Loop	1
calls. The Gnu	1
calls. The best	1
calls. The calculation	1
calls. The usability	1
calls. The principle	1
calls. The consequence	1
calls. It is	1
calls. If the	1
calls. There are	1
calls. Example: //	1
calls. These are	1
calls. Unfortunately, the	1
calls. 48 Use	1
calls. Internal references	1
algorithm is used	1
algorithm is very	1
algorithm of sequential	1
algorithm in question.	1
algorithm in question:	1
algorithm The first	1
algorithm that comes	1
algorithm can do	1
algorithm if a	1
algorithm with template	1
algorithm than by	1
algorithm before you	1
algorithm (e.g. Quine–McCluskey	1
algorithm ....................................................................................... 24	1
sum of a	1
sum of 100	1
sum = 0;	3
sum = 1.f;	1
sum = (s0+s1)+(s2+s3);	1
sum += xn	1
sum += a[i];	2
sum += list[i];	1
sum operator //	1
sum depends on	1
sum for(inti=0;i<16;i+=4){ //Loopby4	1
strings is the	1
strings of different	1
strings and similar	1
strings in the	1
strings in a	2
strings in one	1
strings in classes	1
strings in character	1
strings are particularly	1
strings typically have	1
strings including the	2
On the other	4
On the smallest	1
On the contrary,	3
On other processors,	1
On most compilers	1
On many processors,	1
On big endian	1
On older processors,	1
exponent is a	1
exponent is an	1
exponent is stored	1
exponent is always	1
exponent is biased	1
exponent if there	1
exponent } Example	1
exponent + 0x3FF	1
exponent + 0x3FFF	1
exponent + 0x7F	1
exponent : 8;	1
exponent : 15;	1
exponent : 11;	1
Linux, the first	1
Linux, 32-bit and	1
Linux, Mac Windows,	1
Linux, BSD and	4
Linux, BSD or	1
Linux, BSD, Windows	1
Linux, BSD, Intel-based	1
Linux, sched_setaffinity). The	1
Linux, Mac, BSD	1
Linux, Gnu/AT&T syntax:	1
possibility is to	2
possibility of using	1
possibility of compiling	1
possibility of algebraic	1
possibility of overflow.	1
possibility for other	1
possibility for further	1
possibility for significant	1
possibility that the	2
possibility that a	1
possibility that such	1
discussion of the	3
discussion of this	2
discussion of different	1
discussion of efficient	1
discussion of system	1
discussion of container	1
discussion of aligning	1
discussion of profiling.	1
discussion that the	1
discussion forums on	1
conditions is not	1
conditions in a	2
conditions in order	1
conditions that make	1
conditions are listed	1
conditions are optimal.	1
conditions are met:	1
conditions are satisfied.	1
conditions are satisfied:	1
conditions which are	1
conditions using &	1
conditions enum Weekdays	1
non-Intel processors can	1
non-Intel processors (see	1
non-Intel CPUs in	2
non-Intel CPUs was	1
non-Intel CPUs unless	2
non-Intel processor makes	1
non-Intel CPUs. Includes	1
non-Intel CPU. If	1
non-Intel processors, as	1
non-Intel machines? Possible	1
non-Intel processors). It	1
it. The load	1
it. The insight	1
it. This is	1
it. A dynamic	1
it. In C++	1
it. There are	1
it. I am	2
it. Therefore, you	1
it. Global variables	1
it. Possible solutions	1
it. Instead of	1
it. Complicated code	1
(See page 130	1
(See page 49	1
(See page 137	1
(See page 71).	1
(See page 137).	1
(See page 81).	1
(See also page	1
(See manual 3:	4
(See thread-local storage	1
(See Sutter: A	1
registers. The vector	1
registers. The first	1
registers. The maximum	1
registers. This problem	1
registers. A class	1
registers. It may	1
registers. 64-bit Unix	1
registers. There are	1
registers. You need	1
registers. Example: //	1
registers. Disadvantages are:	1
registers. Except for	1
registers. Typical candidates	1
maximum of four	1
maximum loop count	2
maximum size of	1
maximum number of	3
maximum possible memory	1
maximum value in	1
maximum advantage of	1
maximum repeat count	2
maximum value. There	1
mode. The first	1
mode. The next	1
mode. The latter	1
mode. The 32-	1
mode. A conversion	1
mode. If there	1
mode. See the	1
mode. Some 64-bit	1
mode. Therefore, the	1
mode. Make functions	1
mode. 16-bit mode	1
mode. Storing the	1
mode. Much of	1
per array element.	1
per element for	1
per element Example	2
per element 63	1
per matrix cell	1
per byte of	1
per vector. The	1
per vector. You	1
per row is	1
per element. The	1
per element. 100	1
per point. This	1
testing is useful	1
testing a condition	1
testing and maintenance	2
testing and analyzing	1
testing which version	1
testing all bits	1
testing multiple conditions	1
testing single assembly	1
testing contains debug	1
testing Most performance	1
testing worst-case performance:	1
testing ................................................................................................ 157	1
alignment is not	1
alignment of arrays	1
alignment of structure	1
alignment to addresses	1
alignment and the	1
alignment and aliasing.	1
alignment can cause	1
alignment by 16	1
alignment problem void	1
alignment problems. It	1
alignment explicitly by	1
alignment automatically. The	1
alignment requirements are	1
right in order	1
right = divide	1
right function for	1
right from the	1
right data into	1
right vector elements.	1
right version of	3
right prediction. The	1
right format and	1
right formula in	1
right positions in	1
offset of the	2
offset of a	1
offset of b	1
offset that is	1
offset can be	1
offset as a	1
offset at all.	1
offset has to	1
offset table (GOT).	1
offset table (GOT)	1
offset bigger than	1
offset relative to	1
compatibility is not	1
compatibility with a	1
compatibility with some	1
compatibility with old	1
compatibility with older	1
compatibility with existing	1
compatibility with legacy	1
compatibility problems and	3
compatibility problems into	1
compatibility problems. Software	1
compatibility problems, usability	1
macro is referencing	1
macro to swap	2
macro in the	1
macro for aligning	1
macro by template	1
macro as inline	1
macro will interfere	1
macro so that	1
macro parameters are	1
macro declared with	1
macro INSTRSET is	1
macro expansions. Programmers	1
bytes. The time	1
bytes. This makes	1
bytes. first //	3
bytes. first byte	5
bytes. Some CPUs	1
bytes. Each line	1
bytes. 7.19 Class	1
object. The compiler	1
object. The allocation	1
object. The calling	1
object. This so-called	1
object. A little-known	1
object. It is	1
object. If the	1
object. There is	1
object. Make the	1
object. Any copy	1
object. Obviously, all	1
object. Likewise, when	1
object. 7.17 Structures	1
100 and jumps	1
100 in the	1
100 floating point	1
100 * 5	1
100 clock cycles.	1
100 so that	1
100 rather than	1
100 / jl	1
100 As table	1
100 floats for	1
100 numbers: //	1
100 $B1$2 ebx	1
100 doubles: union	1
Note the difference	2
Note that the	6
Note that there	1
Note that these	2
Note that volatile	1
Note how efficient	1
them to apply	1
them for the	1
them as integers:	1
them into the	2
them into a	1
them into one	1
them static if	1
them off or	1
them again takes	1
them separately with	1
them all. In	1
them enabled (there	1
writing a variable	1
writing a file	1
writing a small	1
writing to the	2
writing to a	1
writing to uncached	1
writing from the	1
writing data files	1
writing big blocks	1
writing small bits	1
writing data. Multidimensional	1
writing style are	1
library. The application	1
library. The radical	1
library. This method	1
library. A runtime	1
library. It requires	1
library. If the	1
library. If you	1
library. Supports x86	1
library. Open source.	1
library. Add to	1
library. Only available	1
library. 119 The	1
library. 78 Therefore,	1
struct { int	1
struct S1 {	4
struct S1 {double	2
struct abc {int	1
struct Bitfield {	1
struct Sab {int	1
struct Sdouble {	1
struct Slongdouble {	1
struct Sfloat {	1
calculations. The code	1
calculations. The time	1
calculations. The program	1
calculations. The loop	1
calculations. This should	1
calculations. It is	2
calculations. In other	1
calculations. In such	1
calculations. In some	1
calculations. Even with	1
calculations. Division of	1
calculations. Examples are	1
operand is not	2
operand is more	1
operand is faster	1
operand is evaluated	1
operand is infinity	1
operand is valid.	1
operand of &&	1
operand of ||	1
operand that is	2
operand first. If	1
operand determines whether	1
reduced to 2	1
reduced to always	1
reduced from 20	1
reduced number of	1
reduced performance on	3
reduced speed or	1
reduced performance. 25	1
reduced to: //	1
reduced 15.1b to	1
reduced 15.1a to	2
cycles. The reason	1
cycles. The core	1
cycles. The rules	1
cycles. It may	1
cycles. If you	1
cycles. In most	1
cycles. You can	1
cycles. You cannot	1
cycles. But if	1
cycles. Floating point	1
cycles. Obviously, the	1
cycles. Division takes	1
cycles. Calculations in	1
final program and	1
final size cannot	1
final size needed	1
final array size	1
final version of	1
final value of	1
final result to	1
final result will	1
final program. This	1
final application depends	1
final program, it	1
final product. It	1
final destination, but	1
sake of the	1
sake of compatibility	2
sake of optimization.	1
sake of parallel	1
sake of fastest	1
sake of portability	1
sake of backwards	1
sake of efficiency.	1
sake of security.	1
sake of cross-platform	1
sake of modularity.	1
sake of security,	1
operations. The most	1
operations. The total	1
operations. This can	1
operations. A complex	1
operations. It can	1
operations. You may	1
operations. You should	1
operations. All you	1
operations. When an	1
operations. Algorithms that	1
operations. 7.6 Pointers	1
operations. 105 The	1
operations. Multiplying by	1
When the function	1
When the program	1
When the floating	1
When the most	1
When the critical	1
When a hot	1
When an integer	1
When you look	1
When used simply	1
When we add	1
When we reach	1
When accessing a	1
When considering whether	1
tasks in a	1
tasks that are	1
tasks are available	1
tasks on current	1
tasks because this	1
tasks into multiple	1
tasks into separate	1
tasks such as	4
tasks like pressing	1
tasks were not	1
Avoid the function	1
Avoid the use	1
Avoid the conversions	1
Avoid an excessive	1
Avoid multiple inheritance,	1
Avoid table lookup	1
Avoid long dependency	1
Avoid virtual functions	1
Avoid branches at	1
Avoid global and	1
Avoid conversions between	1
Avoid unnecessary functions	1
Avoid nested function	1
effect is so	1
effect is much	1
effect is simply	1
effect of the	2
effect of dependency	1
effect of nontemporal	1
effect can be	1
effect with templates	1
effect on the	2
effect on performance.	1
effect on older	1
amount of code	1
amount of memory	4
amount of cache	1
amount of time.	2
amount of work	1
amount of necessary	1
amount of space	1
amount of RAM	1
amount of RAM,	1
variable. The compiler	1
variable. The different	1
variable. The register	1
variable. The union	1
variable. This is	1
variable. This can	1
variable. For example,	1
variable. Example: //	1
variable. Most compilers	1
variable. Using pointers	1
variable. Make sure	1
variable. (This eliminates	1
variable. Efficiency Accessing	1
time, of course,	1
time, it also	1
time, then the	2
time, but the	1
time, but not	1
time, but also	1
time, but expensive	1
time, such as	1
time, any processor	1
time, RAM and	1
time, except for	1
time, usability, program	1
Variables and objects	3
Variables that are	6
Variables stored on	1
Variables declared inside	2
Variables whose distance	1
copying the code	1
copying the return	1
copying the entire	1
copying a large	1
copying of memory	1
copying it Use	1
copying an array	1
copying different size	1
copying all data	1
copying without effectively	1
copying them into	1
copying blocks of	1
copying process, and	1
optimization. The debugger	1
optimization. This works	2
optimization. A mixed	1
optimization. It is	1
optimization. See www.agner.org/optimize	1
optimization. For example,	1
optimization. 14 Portability	1
optimization. 2.4 Choice	1
optimization. Everything that	1
optimization. 8.2 Comparison	1
optimization. Prefetching data	1
optimization. en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC	1
accessing the same	1
accessing a data	1
accessing a variable	1
accessing a member	1
accessing a simple	1
accessing it directly.	1
accessing an object	2
accessing 32 bits	1
accessing arrays forwards,	1
accessing container elements	1
accessing databases, network	1
accessing list[i].a and	1
until the function	1
until the program	1
until the value	1
until the first	1
until the next	1
until the computer	2
until the previous	1
until the residual	1
until a few	1
until you turn	1
until 10 -	1
until seconds has	1
performance. The Windows	1
performance. The positive	1
performance. A good	1
performance. A copy	1
performance. It is	1
performance. There are	1
performance. I have	1
performance. Integer size	1
performance. We must	1
performance. 14.4 Integer	1
performance. 25 Since	1
performance. 7.18 Class	1
performance. Stefan Goedecker	1
adding the first	1
adding the length	1
adding a constant	2
adding an integer	1
adding one more	1
adding any extra	1
adding new instructions	1
adding n to	1
adding throw() to	1
adding vectors. The	1
adding bounds-checking to	1
adding -100 to	1
Define function type	1
Define function name	1
Define vector objects	1
Define vector classes	3
Define size of	1
Define multiple threads	1
Define SSE2 intrinsic	1
Define vectors of	1
Define macro to	1
Define macro for	1
Define biggest possible	1
causes the memory	1
causes the heap	1
causes a long	1
causes of compatibility	1
causes an entire	1
causes all writes	1
causes all subsequent	1
causes floating point	1
causes another exception.	1
causes problem that	1
causes misses in	2
causes technical problems	1
processing the data	1
processing and image	1
processing in C++	1
processing speed exceeding	1
processing power of	1
processing unit for	1
processing unit intended	1
processing Memory and	1
processing capabilities still	1
processing instructions, multiple	1
processing power. Connecting	1
processing unit. Various	1
processing unit, either	1
divide the data	1
divide the work	3
divide the matrix	1
divide the job	1
divide the workload	1
divide it into	1
divide by 2	1
divide by 2n	1
divide an integer	1
divide i by	2
so-called time stamp	1
so-called objects are	1
so-called virtual table	1
so-called intrinsic functions.	1
so-called nontemporal write	1
so-called Java virtual	1
so-called soft processor.	1
so-called position- independent	1
so-called symbol interposition	1
so-called partial flags	1
so-called commpage. These	1
so-called iterators that	1
so-called CPU-dispatcher that	1
clear to the	1
clear and more	1
clear and well-structured	1
clear and intelligible	1
clear and modular.	1
clear that static	1
clear that p	1
clear or mask	1
clear from this	1
clear program structure	1
clear whether r	1
clear unless the	1
clear correspondence between	1
total size of	1
total number of	3
total time. Optimizing	1
total execution time	1
total execution time.	1
total calculation time.	1
total offset bigger	1
total amount of	1
total waste of	1
total size, because	1
total computation time.	1
mix the two	1
mix of additions	1
mix different kinds	1
mix integer and	1
mix floating point	1
mix float and	2
mix simple integer	1
mix single and	1
mix signed and	1
mix mathematical calculations	1
mix nontemporal writes	1
16-bit systems or	1
16-bit integers or	1
16-bit mode is	1
16-bit mode and	1
16-bit Windows, allow	1
16-bit integers. The	1
16-bit systems: int	1
16-bit systems: long	1
16-bit systems: unsigned	2
16-bit programs. It	1
16-bit programs, except	1
child are typically	1
child class is	1
child class are	1
child class by	1
child class through	1
child class name	2
child class members.	1
child classes implement	1
child class. This	1
child class. Members	1
child function: (static_cast<MyChild*>(this))->Disp();	1
containers is the	1
containers is that	1
containers is 95	1
containers in the	1
containers in cases	1
containers for each	1
containers use linked	1
containers should be	1
containers should definitely	1
containers class templates	1
containers do not	1
containers 93 themselves.	1
fit the size	1
fit the biggest	1
fit the actual	1
fit the eight-element	4
fit into the	1
fit into a	1
fit specific needs.	1
fit their CPUs.	1
fit nicely into	1
predict the loop	1
predict the target	1
predict a switch	1
predict that the	1
predict with certainty	1
predict which compiler	1
predict which variables	1
predict which way	1
predict which resources	1
predict where the	1
predict whether the	1
predict correctly whether	1
priority is no	1
priority of program	1
priority of structured	1
priority to one	1
priority in the	1
priority than the	2
priority than code	1
priority before the	1
priority back to	1
priority level, typically	1
priority thread, and	1
disk or other	1
disk or network.	1
disk if the	1
disk because of	1
disk often takes	1
disk operations to	1
disk space were	1
disk cache. Files	1
disk space. It	1
disk files. See	1
disk copying. Security.	1
disk caching, but	1
frequency is 2	1
frequency is limited	1
frequency is increased	1
frequency is doubled.	1
frequency of the	1
frequency that the	1
frequency than other	1
frequency may be	1
frequency may vary	1
frequency goes up	1
frequency dynamically depending	1
frequency (in Windows:	1
unknown at the	6
unknown CPU based	1
unknown processors that	1
unknown processors properly.	1
unknown brand or	1
unknown factors in	1
unknown sources. The	1
obtained in a	1
obtained if the	1
obtained by the	1
obtained by using	1
obtained by choosing	1
obtained by dropping	1
obtained with the	3
obtained with a	1
obtained with virtual	1
obtained when the	1
libraries. The memory	1
libraries. The dynamic	1
libraries. The Gnu	1
libraries. A shared	1
libraries. C++ is	1
libraries. Use Gnu	1
libraries. These factors	1
libraries. Supports 32-	1
libraries. Several special	1
libraries. To explain	1
libraries. Numbers in	1
libraries. www.agner.org/optimize/#vectorclass All	1
iteration is a	1
iteration is finished.	1
iteration is repeated	1
iteration of the	2
iteration to the	1
iteration that has	1
iteration it decides	1
iteration should depend	1
iteration before the	1
iteration needs the	1
iteration (except for	1
counters in all	1
counters in each	1
counters are CPU-specific	1
counters can be	1
counters when you	1
counters when they	1
counters will stay	1
counters before running	1
counters inside your	1
counters instead of	1
counters Many CPUs	1
counters .................................................................... 155	1
Optimizing for size	1
Optimizing for speed	1
Optimizing for present	1
Optimizing memory access	2
Optimizing compilers will	1
Optimizing software in	2
Optimizing less critical	1
Optimizing file access	1
Optimizing database queries	1
Optimizing subroutines in	1
128-bit vector so	1
128-bit vector registers	1
128-bit vector register,	1
128-bit execution units	1
128-bit XMM and	1
128-bit XMM register	1
128-bit XMM registers	1
128-bit XMM vectors	1
128-bit XMM register.	1
128-bit operation was	1
128-bit vectors. The	1
128-bit reads. The	1
possibly in a	1
possibly be more	1
possibly be compiled	1
possibly be relevant	1
possibly be obtained	1
possibly not with	1
possibly more serious	1
possibly also a	1
possibly block the	1
possibly improve the	1
possibly save exception	1
possibly throw an	1
x, and last	1
x, int m)	1
x, unsigned int	1
x, while other	1
x, y; //	1
x, y; x	1
x, y; ...	1
x, y; bool	1
x, n, factorial	2
x, y, z;	2
stack. The memory	1
stack. This can	2
stack. This makes	1
stack. This behaviour	1
stack. A static	1
stack. These registers	1
stack. Each thread	1
stack. Alternatively, you	1
stack. Is the	1
stack. Deallocation has	1
stack. String constants	1
2, x =	1
2, b *	2
2, so the	1
2, 4 or	1
2, etc. This	1
2, 4, 8,	1
2, 4, etc.).	1
2, 6, 24,	2
2, 3, 4,	1
2, Tuesday =	1
full use rather	1
full size vector.	1
full 64-bit addresses	1
full advantage of	1
full information about	1
full optimization. It	1
full 128-bit execution	1
full declaration of	1
full metaprogramming features,	1
full debugging support	1
full speed. A	1
full generality and	1
Another function __intel_cpu_features_init_x()	1
Another problem with	1
Another disadvantage is	1
Another disadvantage of	2
Another example: //	1
Another possibility is	2
Another thing that	1
Another alternative worth	1
Another serious burden	1
Another open source	1
overloaded or the	1
overloaded or limited	1
overloaded function are	1
overloaded functions. 7.27	1
overloaded operators for	1
overloaded operators will	1
overloaded operator is	3
overloaded operators. Function	1
overloaded operators. Vectorized	1
overloaded assignment operator,	1
possible. The first	1
possible. The AVX	1
possible. This also	1
possible. A compiler	1
possible. See page	1
possible. SSE2 is	1
possible. Use inline	1
possible. However, there	1
possible. Don't rely	1
possible. Template meta-	1
possible. Smaller microprocessors	1
possible. Typically it	1
efficiently if the	1
efficiently if it	1
efficiently if functions	1
efficiently if pieces	1
efficiently by better	1
efficiently with coarse-grained	1
efficiently on all	1
efficiently than static	1
efficiently when the	1
efficiently when data	2
efficiently from the	1
models of the	1
models to avoid	1
models to run	1
models that were	2
models if the	1
models on which	2
models have a	1
models then you	1
models rather than	1
models had the	1
OS and Itanium	1
OS support and	1
OS independent and	1
OS X The	1
OS X make	1
OS X operating	2
OS X Compilers	1
OS X (Darwin)	1
OS X, 32-bit	1
OS X, unless	1
OS X. 14.13	1
needed. The C++	1
needed. The bitwise	1
needed. This makes	1
needed. You may	1
needed. Example: //	1
needed. These complicated	1
needed. All the	1
needed. Obviously, the	1
needed. Even better,	1
needed. Objects inside	1
needed. 11 Out	1
needed. Predictable branches	1
classes. The object	1
classes. The standard	1
classes. The splitting	1
classes. You may	1
classes. An appendix	1
classes. Each instance	1
classes. Unfortunately, many	1
classes. Text strings	1
classes. 7.2 Integers	1
classes. Size of	1
classes. Security The	1
classes. Including the	1
changed to the	1
changed to a	1
changed to c	1
changed to truncation	1
changed by another	1
changed then the	1
changed so that	1
changed without the	1
changed to: //	2
changed five times.	1
changed freely. The	1
true a &&	2
true that some	1
true = a,	1
true = true	1
true or always	1
true ; unused	1
true last in	1
true anyway. It	1
true 50% of	1
true (1) or	1
true 10% of	1
thread. The cost	1
thread. This method	1
thread. This structure	1
thread. This prevents	1
thread. A variable	1
thread. It is	1
thread. If you	1
thread. If seconds	1
thread. You cannot	1
thread. However, in	1
thread. Pointers to	1
thread. Thread-local storage	1
names of the	1
names of inlined	1
names and code	1
names and variable	2
names and model	1
names in the	1
names that begin	1
names are not	1
names are undocumented.	1
names with suffixes	1
names from string	1
though the logical	1
though the latter	1
though the rules	1
though the 61	1
though the CPU-type	1
though it is	1
though it could	1
though not all	1
though this only	1
though less user	1
though these operating	1
though future compilers	1
execute the loop	1
execute the program,	1
execute a code	1
execute then the	1
execute then measurements	1
execute faster than	1
execute instructions out	1
execute it. The	1
execute CriticalFunction when	1
execute faster. The	1
execute slower than	1
execute _mm_empty() after	1
% 2 ==	1
% 32 =	1
% 128 ==	1
% c; a	1
% means modulo.	1
% 3; }	1
% 10; a	2
% 16; a	1
% 16; //	1
% (number of	1
% 0x20 =	1
mov add cmp	1
mov mov mov	1
mov mov 2:8+esp	1
mov mov lea	1
mov DWORD PTR	1
mov xor mov	1
mov shr add	1
mov eax,0. The	1
mov ebx,eax /	1
mov $B1$2: mov	1
mov 2:8+esp eax,	1
mov lea $B2$2:	1
N is a	3
N is not	1
N a power	1
N = 0	1
N = 1.	1
N with the	1
N into the	1
N elements of	1
N template <int	1
N supports a	1
kinds of code	2
kinds of vector	1
kinds of variable	3
kinds of operations	1
kinds of costs	1
kinds of storage.	1
kinds of optimizations.	1
kinds of jobs.	1
kinds of strange	1
details of instruction	1
details of cache	1
details in both	1
details that make	1
details are given	1
details on when	1
details on branch	1
details about how	1
details about name	1
details about rounding.	1
details depend on	1
details (www.agner.org/optimize/testp.zip). A	1
RAM and disk	1
RAM than there	1
RAM than end	1
RAM memory and	1
RAM memory can	1
RAM memory if	1
RAM memory may	1
RAM size is	1
RAM memory. This	1
RAM memory. Big	1
RAM memory. Efficient	1
RAM space, if	1
rows and columns	2
rows in the	1
rows in a	1
rows for (c	1
rows are accessed	2
rows are indexed	1
rows // loop	1
rows = 20,	2
rows = 10,	1
square by the	1
square x //	1
square at a	1
square (float a)	1
square blocking for	1
square blocking or	1
square brackets mean	1
square brackets index,	1
square root and	2
square blocking: int	1
square root, RGB	1
fail to see	1
fail to start	1
fail to keep	1
fail to eliminate	1
fail to distinguish	1
fail to recognize	1
fail in the	1
fail if the	2
fail if an	1
fail if both	1
fail completely because	1
purposes. The use	1
purposes. The most	1
purposes. The const	1
purposes. This is	1
purposes. This memory	1
purposes. If the	1
purposes. All these	1
purposes. All dynamic	1
purposes. However, the	1
purposes. Floating point	1
purposes. Unfortunately, the	1
purposes. Available from	1
(e.g. in linear	1
(e.g. with _finite())	1
(e.g. an if-else	1
(e.g. option /MT).	1
(e.g. GetLogicalProcessorInformation in	1
(e.g. PowerPC). We	1
(e.g. DEC, JNZ).	1
(e.g. GetProcessAffinityMask in	1
(e.g. IsProcessorFeaturePresent in	1
(e.g. '>') are	1
(e.g. Quine–McCluskey or	1
(e.g. Sandy Bridge)	1
compiling the intermediate	1
compiling the module	1
compiling in two	1
compiling for the	1
compiling for a	1
compiling for 32-bit	1
compiling for Windows	1
compiling for Linux.	1
compiling for AVX2,	1
compiling multiple .cpp	1
compiling without -fpic	1
compiling module2.cpp. The	1
convert the unsigned	1
convert the result	1
convert it to	2
convert an integer	1
convert example 15.1b	1
convert example 15.1a	1
convert example 12.8a	1
convert b from	1
convert float to	1
convert unsigned integers	1
convert these types	1
thing is to	1
thing to do	1
thing to do.	1
thing and the	1
thing and if	1
thing and they	1
thing that can	1
thing that you	1
thing as p	1
thing at the	1
thing we notice	2
least the same	1
least the cache	1
least a large	1
least in some	1
least in simple	1
least at the	1
least one other	1
least one virtual	1
least significant bit	1
least significant n	1
least recently 4	1
least temporarily. Using	1
containing the functions	1
containing the address	1
containing the members	1
containing only constants	1
containing multiple streams	1
containing many objects	1
containing container classes	1
containing integers. It	1
containing pure function	1
containing thread-specific data	1
containing (2,2,2,2), and	1
containing numerical data	1
0) { //	3
0) { if	3
0) { c	1
0) { d	1
0) { FuncA(i);	1
0) ? 1.0f	1
0) ? (cc[i]	1
0) *(p++) |=	1
precision. The compilers	1
precision. The following	1
precision. The speed	1
precision. You may	1
precision. But the	1
precision. These conversions	1
precision. Using double	1
precision. When the	1
precision. Conversions between	1
precision. And who	1
precision. Let's repeat	1
precision. Long double	1
algebraic expressions on	1
algebraic expressions using	1
algebraic reductions in	1
algebraic reductions are	1
algebraic reductions on	2
algebraic reductions such	1
algebraic reductions explicitly	1
algebraic expressions. For	1
algebraic manipulations of	1
algebraic manipulations on	1
algebraic reduction. For	1
structures to addresses	1
structures and classes.	1
structures in the	1
structures for standard	1
structures that typically	1
structures are accessed	1
structures by 16	1
structures with non-sequential	1
structures with First-In-First-Out	1
structures It is	1
structures ............................................................. 96	1
structures (without member	1
little or no	2
little more complicated	1
little more syntax	1
little data for	1
little faster than	1
little work as	1
little space in	1
little overhead to	1
little math is	1
little explanation. The	1
little odd here.	1
Any function that	1
Any code that	1
Any other allocated	1
Any floating point	1
Any array or	1
Any pointers to	1
Any language that	1
Any specific bottleneck	1
Any copy constructor	1
Any expression that	1
Any task that	1
Any writable data	1
logical register that	1
logical processors available	2
logical processors usually	1
logical processors (0,	1
logical processor is	1
logical structure and	1
logical processors. There	1
logical processors. Hyperthreading	1
logical register. This	1
logical architecture of	1
logical sequence. If	1
level of optimization	2
level of abstraction	1
level = InstructionSet();	2
level framework based	1
level framework still	1
level linking (remove	1
level framework. The	1
level 9. Avoid	1
level 108 You	1
level linking" if	1
access. The code	1
access. The compiler	1
access. The execution	1
access. Assume that	1
access. 12 Using	1
access. Reading or	1
access. Available protocols	1
access. 7.20 Virtual	1
access. 3.10 Graphics	1
access. 12.9 Aligning	1
access. Sequential forward	1
access. Run multiple	1
bitwise operators is	1
bitwise operators for	2
bitwise operators are	2
bitwise operators using	1
bitwise operators produce	1
bitwise operators &,	2
bitwise operators (&	1
bitwise AND operation	1
bitwise OR operator,	1
handle the strings	2
handle is invalid.	1
handle an unrecoverable	1
handle only known	1
handle one square	1
handle its own	1
handle eight elements	1
handle strings is	1
handle unknown processors	1
handle current CPUs	1
handle text strings	1
heap is reserved	1
heap to be	1
heap can easily	1
heap has become	1
heap space to	1
heap space has	1
heap space becomes	1
heap manager for	1
heap manager can	1
heap manager will	1
heap manager has	1
heap management and	1
DWORD PTR [edx]	3
DWORD PTR [esp+8]	2
DWORD PTR [eax+400]	1
DWORD PTR [eax+4],	1
DWORD PTR [esp+4]	1
DWORD PTR [ecx+eax*4],ebx	1
DWORD PTR [esp+12]	1
DWORD PTR [eax],	1
DWORD PTR[ecx+eax*4],ebx eax,	1
Other compilers need	1
Other compilers offer	1
Other system resources	2
Other cases of	2
Other programs use	1
Other tasks such	1
Other brands or	1
Other manuals by	1
Other databases Many	1
Other databases .......................................................................................................	1
during the development	1
during the loop.	1
during the installation	1
during the update	1
during this time	1
during time measurements	1
during program execution	1
during program development,	1
during execution of	1
during start of	1
during installation of	2
initialized to zero	1
initialized to desired	1
initialized to valid	1
initialized or comes	1
initialized by a	1
initialized when the	3
initialized only the	1
initialized variables that	1
initialized arrays. I	1
occur and recovering	1
occur in the	3
occur in this	1
occur in multiplication	1
occur if a	1
occur as a	1
occur at random	1
occur has the	1
occur quite often	1
target of branches	1
target if the	1
target address is	2
target address can	1
target buffer is	1
target buffer can	1
target buffer (BTB).	1
target pointed to	1
target buffer. Contentions	1
target buffer, branch	1
especially in floating	1
especially in 32-bit	3
especially if the	3
especially if there	1
especially on the	1
especially when the	1
especially loop-carried dependency	1
smart and other	1
smart pointer is	2
smart pointer may	1
smart pointer then	1
smart pointer (see	1
smart pointers is	1
smart pointers are	1
smart pointer. If	1
smart pointer. But	1
smart pointer. Accessing	1
includes the time	1
includes the critical	1
includes the libraries	1
includes the addresses	1
includes the low-level	1
includes only the	1
includes static variables,	1
includes pointers and	1
includes optimized versions	1
includes standard function	1
includes languages such	1
entire program in	1
entire program will	1
entire cache line	1
entire floating point	1
entire library (or	1
entire 64 or	1
entire file in	1
entire list from	1
entire level-1 cache	1
entire object. Any	1
entire contents copied	1
executable to a	1
executable to be	1
executable has the	1
executable because it	1
executable code. Most	1
executable file and	2
executable file when	1
executable file needs	1
executable file stub.	1
executable file. Only	1
subexpression to make	1
subexpression containing only	1
subexpression occurs more	1
subexpression elimination and	1
subexpression elimination x	1
subexpression elimination If	1
subexpression c+b can	1
subexpression elimin., integer	1
subexpression elimin., float	1
subexpression elimination, constant	2
insert the values	1
insert the piece	1
insert the reciprocal	1
insert a code	1
insert a switch	1
insert a fixed	1
insert an instruction	1
insert only the	1
insert any other	1
insert optimization hints	1
insert nontemporal writes	1
nontemporal is used.	1
nontemporal write instruction	1
nontemporal write instructions	4
nontemporal Table 18.3.	1
nontemporal #pragma vector	1
nontemporal writes with	1
nontemporal writes automatically	1
nontemporal writes. If	1
bounds is probably	1
bounds of valid	1
bounds check on	1
bounds checking is	1
bounds checking and	1
bounds checking template	1
bounds violations, invalid	1
bounds checking, as	1
bounds checking). An	1
bounds violations and	1
bounds violation, integer	1
improved is that	1
improved in the	1
improved by a	1
improved by using	3
improved by inlining	1
improved by adding	1
improved by modifications	1
improved by consistent	1
improved performance. A	1
SSE and SSE2	1
SSE and later	1
SSE or SSE2	1
SSE or higher	1
SSE instruction set	1
SSE double 64	1
SSE 128 bit	1
SSE Store 4	1
SSE Store 16	2
SSE xmmintrin.h SSE2	1
discussed in the	1
discussed in manual	1
discussed on page	2
discussed which of	1
discussed which method	1
discussed how to	2
discussed below. Many	1
discussed below. Signed	1
discussed below. Cannot	1
updates to the	1
updates are necessary	1
updates if the	1
updates may come	1
updates should be	2
updates each time	1
updates through the	1
updates every time	1
updates Many software	1
updates .................................................................................................... 19	1
consider the following	1
consider that the	1
consider it unwise	1
consider if the	1
consider if it	1
consider if there	1
consider if intermediate	1
consider which method	1
consider making highly	1
consider whether it	1
consider whether others	1
loading the entire	1
loading a cache	2
loading of the	1
loading of several	1
loading of modules	1
loading can be	1
loading any cache	1
loading files or	1
loading ....................................................................................................... 19	1
loading Often, it	1
below the maximum	1
below the diagonal	3
below in example	1
below on page	1
below 2 GB,	1
below diagonal //	1
below diagonal swapd(a[r][c],	1
below shows. The	1
below shows. It	1
reading the value	1
reading the performance	1
reading of the	1
reading of x	1
reading and writing	2
reading or writing	2
reading as well	1
reading them again	1
reading disk files.	1
directly to the	2
directly to memory	1
directly // Writes	1
directly if the	1
directly with the	1
directly into the	1
directly without using	1
directly compiled code	1
directly compiled version	1
directly compiled code.	1
simplest and most	1
simplest possible user	1
simplest possible implementation	1
simplest way to	1
simplest code. If	1
simplest case is	1
simplest cases, but	1
simplest cases, composite	1
simplest expressions and	1
simplest cases. See	1
simplest method, but	1
situation is a	1
situation is more	1
situation of the	1
situation where the	3
situation where a	4
situation where they	1
message is provoked	1
message and then	1
message and stop	1
message in a	1
message in this	1
message if it	1
message when it	1
message loop of	1
message loop in	1
message function. The	1
message systems. All	1
delay the subsequent	1
delay the availability	1
delay is less	1
delay is just	1
delay is significant	1
delay in the	2
delay that the	1
delay on lazy	1
delay comes when	1
delay due to	1
condition is a	1
condition is known	1
condition is relatively	1
condition The most	1
condition can be	2
condition will generate	1
condition i <	1
condition inside the	1
condition terminates the	1
condition clause. Comparing	1
monitor counter is	1
monitor counter in	1
monitor counters in	1
monitor counters are	1
monitor counters when	1
monitor counters before	1
monitor counters instead	1
monitor counters Many	1
monitor counters ....................................................................	1
monitor counters. A	1
monitor counters. My	1
resource in 32-bit	1
resource for many	1
resource use in	1
resource use on	1
resource then it	1
resource files from	1
resource problems and	1
resource problems that	1
resource files, help	1
resource files, configuration	1
resource conflicts. But	1
cores is to	2
cores is slow.	1
cores and leave	1
cores in order	1
cores that do	1
cores are advantageous	1
cores can run	1
cores or logical	2
cores will grow	1
parallel if certain	1
parallel vector processing	1
parallel because it	1
parallel calculations on	1
parallel structure that	1
parallel calculations. Examples	1
parallel processing in	1
parallel processing, OpenMP	2
parallel execution. Example:	1
parallel processing. Scott	1
either in the	2
either by making	1
either on a	1
either as a	1
either as static	2
either C or	1
either way. Such	1
either case. Intrinsic	1
either sixteen integers	1
implementations of the	1
implementations of this	1
implementations of string	1
implementations of smart	1
implementations of Java	1
implementations of C++,	2
implementations of Pascal	1
implementations are less	1
implementations use just-in-time	1
implementations reveal a	1
calculating the value	1
calculating the address	2
calculating the addresses	1
calculating the physical	1
calculating the logarithm	1
calculating the movements	1
calculating a new	1
calculating a polynomial.	1
calculating row addresses	1
calculating self- relative	1
ebx is then	1
ebx is pushed	1
ebx that was	1
ebx on stack	1
ebx as a	1
ebx from stack	1
ebx ; shift	1
ebx ; top	1
ebx contains i/2+r.	1
ebx ecx, DWORD	1
ebx restores the	1
generation of processors	3
generation of CPUs	1
generation of computers	1
generation of identifier	1
generation can cause	1
generation class through	1
generation class gets	1
generation class (CGrandParent)	1
generation class (CParent<>)	1
enable the compiler	3
enable the SSE2	3
enable the desired	1
enable one or	1
enable constant propagation	1
enable fast floating	1
enable optimizations across	1
instructions. The automatic	1
instructions. The 512	1
instructions. The built-in	1
instructions. This is	1
instructions. A further	1
instructions. There are	1
instructions. Example: //	1
instructions. Function Assembly	1
instructions. Each type	1
instructions. My recommendation	1
instructions. Intrinsic functions	1
copied to the	3
copied to a	1
copied or transferred	1
copied or moved	1
copied by assignment,	1
copied from static	1
copied because the	1
copied into registers.	1
copied simply by	1
e.g. the option	1
e.g. a menu	1
e.g. Intel Math	1
e.g. how often	1
e.g. four numbers,	1
e.g. four floats.	1
e.g. every millisecond.	1
e.g. C++, and	1
e.g. AVX, AVX2	1
e.g. .R. for	1
e.g. /arch:SSE2. The	1
keep the same	1
keep the two	1
keep multiple memory	1
keep pointers to	1
keep up with	2
keep their CPU	1
keep together on	1
keep adding new	1
keep track of	2
PTR [edx] DWORD	2
PTR [edx] adds,	1
PTR [esp+8] DWORD	1
PTR [esp+8] eax,	1
PTR [eax+400] DWORD	1
PTR [eax+4], ecx	1
PTR [esp+4] DWORD	1
PTR [ecx+eax*4],ebx stores	1
PTR [esp+12] ;	1
PTR [eax], ecx	1
Automatic CPU dispatch	1
Automatic vectorization const	1
Automatic vectorization Automatic	1
Automatic vectorization .........................................................................................	1
Automatic vectorization Devirtualization	1
Automatic vectorization Good	1
Automatic updates Many	1
Automatic updates ....................................................................................................	1
Automatic updating of	1
Automatic paralleli- zation	1
Automatic updates. Automatic	1
Library functions are	1
Library versions tested	1
Library exp function	1
Library (STL) which	1
Library (MKL v.	1
Library __vrs4_expf __vrd2_exp	1
Library (WTL). A	1
Library (WTL): //	1
Library (ATL) and	1
Library (OWL). Several	1
Library amd_vrs4_expf amd_vrd2_exp	1
? a :	2
? b :	2
? c +	2
? 1 :	1
? 1.0f :	1
? 1.5f :	1
? (cc[i] +	1
? EXCEPTION_EXECUTE_HANDLER :	1
defined a constructor,	1
defined in a	2
defined in other	1
defined in Intel	1
defined in two	1
defined with enum,	1
defined as powers	1
defined inside the	1
defined inside a	1
defined outside any	1
Visual Studio can	1
Visual Studio This	1
Visual Studio when	1
Visual Studio IDE.	1
Visual Studio optimizes	1
Visual Studio 2008	1
Visual Basic .NET	1
Visual Basic .NET,	1
Visual Studio. This	1
Visual studio 2008,	1
Visual Basic, etc.	1
align the arrays	1
align by cache	1
align by 4	1
align data members	1
align table by	1
align its b	1
align large static	1
align large objects	1
align ; mark	1
align dynamically allocated	1
align arrays. //	1
sizes of the	1
sizes of matrices.	1
sizes to 1024	1
sizes and array	1
sizes are allocated	2
sizes other than	1
sizes were measured	1
sizes 1, 2,	1
sizes Integers can	1
sizes (char, short	1
temp; for (i	1
temp; for (r	2
temp; // Define	1
temp; } 70	1
temp; c =	1
temp; temp =	3
temp; temp +=	1
temp; 104 }	1
allow the compiler	1
allow you to	2
allow vector objects	1
allow variables to	1
allow up to	2
allow addition of	1
allow lazy binding	1
allow compile- time	1
allow assembly-like intrinsic	1
PathScale and Intel	1
PathScale and Gnu	1
PathScale compiler for	1
PathScale compilers can	2
PathScale C++ compiler	1
PathScale C++ v.	1
PathScale Gnu Intel	1
PathScale compilers. Intel	1
PathScale compilers. 8.3	1
PathScale compilers. (The	1
BSD and Mac	4
BSD are identical	1
BSD or Mac	1
BSD work the	1
BSD systems. The	1
BSD comes at	1
BSD Instruction set	1
BSD Shared objects	1
f; The compiler	1
f; int i;	7
f; } This	1
f; unsigned int	1
f; f=i; f	1
previous value as	2
previous value than	1
previous link pointer	1
previous iteration (except	1
previous chapter (page	1
previous value. It	1
previous value. Example:	1
previous branch. Example:	1
previous one. It	1
previous iteration. This	1
size; i +=	1
size; i++) {	7
size; i++) a[i]	1
size; i++) sum	1
size; i++) b[i]	1
rarely the other	1
rarely in Linux.	1
rarely program their	1
rarely possible for	1
rarely necessary to	1
rarely needed anyway.	1
rarely needed. 11	1
rarely enough to	1
rarely worth the	1
rarely found in	1
rarely justifies the	1
way. The first	1
way. The fact	1
way. The Codeplay	1
way. A branch	1
way. If the	1
way. There is	1
way. You may	1
way. See page	1
way. Such a	1
way. Here you	1
way. First you	1
vector. The use	1
vector. The other	1
vector. The simplest	1
vector. This is	1
vector. It may	1
vector. If n	1
vector. You may	1
vector. For example,	1
vector. These units	1
vector. Organize the	1
vector. 6. If	1
easier to use	1
easier to write	2
easier to maintain.	1
easier to understand	1
easier to test,	1
easier for the	3
easier if we	1
easier said than	1
identical to one	1
identical to some	1
identical to Linux	1
identical for the	1
identical code for	1
identical so that	1
identical performance for	1
identical branches The	1
identical branches Eliminate	1
identical constants in	1
identical pieces of	1
20 to 10	1
20 clock cycles	1
20 clock cycles.	2
20 times and	1
20 Copyright notice	2
20 3.8 System	1
20 3.9 Other	2
20 3.7 File	1
well. The conversion	1
well. The reason	1
well. This is	1
well. This compiler	1
well. A loop	1
well. A switch	1
well. Supports three	1
well. Even function	1
well. Open Watcom	1
well. Codeplay VectorC	1
well. Very poor	1
program, and the	1
program, and one	1
program, and while	1
program, for example	1
program, or between	1
program, it is	2
program, you will	1
program, you should	1
program, one for	1
program, especially if	1
list[i] is invalid	1
list[i] is equal	1
list[i] = i	1
list[i] = 0;	1
list[i] += i	1
list[i] += 1.0f;	2
list[i] += i_div_3;	1
list[i] > 1.0)	1
list[i] << endl;	1
list[i] =0; list[i+1]	1
under the worst-	1
under the framework,	1
under the best-case	1
under this unit-test	1
under CPU cache	1
under test but	1
under test finishes	1
under advanced system	1
under worst-case conditions	1
under worst-case conditions.	1
under test, but	1
expect the compiler	1
expect the table	1
expect the &&	1
expect a compiler	2
expect a particular	1
expect a directive	1
expect to use	1
expect to 99	1
expect this to	1
expect 64-bit programs	1
except the sign	2
except in the	2
except in special	1
except for the	1
except for some	1
except for small	1
except for char	1
except when several	1
except perhaps for	1
loops are implemented	1
loops are predicted	2
loops // The	1
loops or compile-time	1
loops if the	1
loops if a	1
loops by calls	1
loops would make	1
loops (except in	1
loops (less than	1
why the compiler	1
why it is	1
why this effect	1
why this delaying	1
why all modern	1
why compilers do	1
why object oriented	1
why there is	1
why such runtime	1
why exception handling	1
why bookkeeping is	1
dispatching. The code	1
dispatching. This function	1
dispatching. For example,	2
dispatching. Many Intel	1
dispatching. Unfortunately, the	1
dispatching. Obviously, you	1
dispatching. Add to	1
dispatching. Test if	1
dispatching. Underestimating the	1
cout << 1;	2
cout << 2;	2
cout << list[i]	1
cout << "Hello	2
cout << "Error:	2
cout << x.f;	1
references. It is	1
references. If we	1
references. 64-bit Mac	1
references. There is	1
references. You can	1
references. Therefore, it	1
references. Most importantly,	1
references. Shared objects	1
references. Arrays are	1
references. References are	1
come with the	2
come with compilers	1
come from example	1
come from operators	1
come from unknown	1
come into force	1
come last in	1
come first. If	1
come unpredictably at	1
statements is a	1
statements The high	1
statements that you	1
statements are most	1
statements because switch	1
statements should preferably	1
statements often suffer	1
statements like throw(A,B,C)	1
statements within each	1
statements (called static	1
u; if (u.i	1
u; if (u.i[1]	1
u; int n;	2
u; If you	1
u; double d;	3
u; u.i ^=	1
u; u.i &=	1
SSE4.1 and one	1
SSE4.1 and integer	1
SSE4.1 // Function	1
SSE4.1 // AVX2	1
SSE4.1 instruction set	2
SSE4.1 some more	1
SSE4.1 gives an	1
SSE4.1 instr. set	1
SSE4.1 smmintrin.h SSE4.2	1
chapter is aiming	1
chapter in manual	1
chapter 10 page	1
chapter (page 146).	1
chapter 12. If	1
chapter 12. Most	1
chapter describes how	1
chapter 9.10, then	1
chapter "Register usage	1
chapter 11. Using	1
similar to the	1
similar to a	1
similar CPU dispatch	1
similar objects of	1
similar method can	1
similar methods are	1
similar functions, but	1
similar thanks to	1
similar solutions may	1
similar utility for	1
course a considerable	1
course that reflects	1
course be the	1
course be a	1
course make the	1
course there is	1
course also time	1
course inefficient. Variables	1
course far from	1
course system-specific. In	1
back to the	1
back to single	1
back to around	1
back to normal	1
back in the	1
back into the	1
back again. This	1
back again. If	1
back again. Obviously,	1
back again. Accessing	1
risk of memory	1
risk of overflow	1
risk of overflow,	1
risk of overflow:	1
risk of underflow.	1
risk of losing	1
risk of activating	1
risk that the	1
risk that several	1
risk factor in	1
garbage collection can	1
garbage collection may	1
garbage collection when	1
garbage collection takes	1
garbage collection. The	1
garbage collection. A	1
garbage collection. Objects	1
garbage collector at	1
garbage collector which	1
garbage collection, as	1
templates in www.agner.org/optimize/cppexamples.zip.	1
templates for several	1
templates for polymorphism	1
templates are available	1
templates // Place	1
templates or modules	1
templates where the	1
templates makes the	1
templates (see p.	1
templates instead of	1
buffer is also	1
buffer and read	1
buffer that some	1
buffer can occur	1
buffer or send	1
buffer with fixed	2
buffer than as	1
buffer overflow on	1
buffer (BTB). Contentions	1
header for intrinsic	1
header file for	2
header file will	1
header file stdint.h	1
header file timingtest.h	1
header file mathimf.h	1
header files are	1
header files For	1
header files. 121	1
future compilers may	1
future compilers will	1
future version of	1
future we may	1
future processors. There	1
future processors. Consider	1
future CPUs. Half	1
future models of	1
future processors, and	1
future due to	1
whenever the objects	1
whenever a function	1
whenever a public	1
whenever a smart	1
whenever it is	1
whenever it goes	1
whenever it feeds	1
whenever an object	1
whenever an instance	1
whenever they are	1
unrolling the loop	2
unrolling is not	1
unrolling in example	1
unrolling should only	1
unrolling should preferably	1
unrolling also has	1
unrolling In some	1
unrolling so that	1
unrolling Some compilers	1
CriticalFunction is called	2
CriticalFunction in example	2
CriticalFunction = &CriticalFunction_386;	1
CriticalFunction = &CriticalFunction_SSE2;	1
CriticalFunction = &CriticalFunction_AVX;	1
CriticalFunction = &CriticalFunction_Dispatch;	1
CriticalFunction when code	1
CriticalFunction (); __asm__	1
swap the order	3
swap the operands	1
swap memory to	1
swap two array	1
swap two elements:	1
swap elements //	1
swap elements }	1
swap these elements	1
newer instruction set	1
newer instruction sets	1
newer Intel CPUs	1
newer version of	1
newer method of	1
newer versions of	1
newer processors. The	1
newer processors. Many	1
newer microprocessors in	1
newer models that	1
fraction is stored	1
fraction of the	2
fraction 2 63	1
fraction 2 23	1
fraction 2 52	1
fraction : 23;	1
fraction : 52;	1
fraction : 63;	1
fraction bits: //	1
modify the program	1
modify the carry	1
modify the ones	1
modify a double	1
modify an existing	1
modify x *const_cast<int*>(&x)	1
modify data members.	1
modify example 9.5	1
modify objects simultaneously.	1
modify x, while	1
seconds to access	1
seconds to zero	1
seconds and wait	1
seconds = 0;	1
seconds or microseconds	1
seconds has been	1
seconds because it	1
seconds count to	1
seconds was not	1
seconds remains zero	1
unaligned integer vector	6
unaligned arrays. There	1
unaligned reads and	1
unaligned op. Intel	1
unaligned op. AMD	1
address. The address	1
address. The linker	1
address. A call	1
address. If this	1
address. There are	1
address. Pointer arithmetic	1
address. Pointers can	1
address. (3) look	1
address. Step (1)	1
address. Relocation is	1
Store the result	4
Store 4 bytes	1
Store 8 bytes	1
Store 16 bytes	3
Store result //	1
sequence of operations	1
sequence of calculations	3
sequence of consecutive	1
sequence of backwards	1
sequence to be	1
sequence in a	1
sequence are not	1
sequence where each	1
compiler, the assumption	1
compiler, and the	1
compiler, or vice	1
compiler, you will	1
compiler, then make	1
compiler, which is	1
compiler, operating system	1
compiler, etc. #define	1
compiler, v. 10.1.020.	1
compiler, linker and	1
significant if a	1
significant as long	1
significant bit of	1
significant part of	1
significant n bits	1
significant effect on	1
significant amount of	1
significant contribution to	1
significant improvements. Making	1
significant digits, so	1
might be a	1
might be possible	2
might not be	1
might have other	1
might also be	1
might check for	1
might store the	1
might experience unacceptably	1
might clash with	1
CPU. It can	1
CPU. If the	1
CPU. If not,	1
CPU. See page	1
CPU. But it	1
CPU. These virtual	1
CPU. These methods	1
CPU. Algebraic reductions	1
CPU. Unrolling a	1
CPU. Should we	1
Vector class code	1
Vector class library	1
Vector class libraries	1
Vector operations are	3
Vector classes defined	2
Vector class, Intel	1
Vector class, Agner	1
length is not	1
length of the	2
length of a	5
length of each	1
length function scans	1
sets. The program	1
sets. The different	1
sets. However, the	1
sets. Most compilers	1
sets. Supports only	1
sets. Vector operations	1
sets. Likewise, the	1
sets. Does not	1
sets. Let me	1
sets. Covers PC's,	1
linear function of	2
linear array for	1
linear array with	1
linear array will	1
linear list with	1
linear array. No	1
linear algebra and	1
linear search, is	1
linear algebra) require	1
something to clean	1
something in a	1
something in static	1
something that can	2
something on these	1
something takes 10	2
something about it.	1
something about them.	1
f is set	1
f is zero	1
f is added	1
f is nonzero	1
f = 1;	1
f = (float)i;	1
f = float(i);	1
f = static_cast<float>(i);	1
f cout <<	1
f *= i;	1
penalty is only	1
penalty of cache	1
penalty of 10	1
penalty to using	1
penalty for using	1
penalty for mixing	2
penalty for organizing	1
penalty when going	1
penalty should be	1
F1 is prevented	1
F1 is supposed	1
F1 will never	1
F1 has to	1
F1 has saved	1
F1 only if	1
F1 also have	1
F1 without returning.	1
F1 calls another	2
invalid and cause	1
invalid in a	1
invalid if a	2
invalid as soon	1
invalid when i	1
invalid pointers can	1
invalid pointers, etc.	1
invalid pointers. The	1
invalid pointers. This	1
reasons of mathematical	2
reasons to use	1
reasons for this	1
reasons before leaving	1
reasons explained on	4
reasons why object	1
setting the sign	1
setting the priority	1
setting the fraction	1
setting the flush-to-zero	1
setting a register	1
setting a thread	1
setting an array	1
setting pointers to	1
setting these variables	1
setting up a	1
module for correctness	1
module or a	1
module by compiling	1
module then the	1
module then it	1
module then add	1
module static static	1
module (i.e. the	1
module __attribute__ ((visibility	1
module with, e.g.	1
beginning of the	7
beginning of a	1
beginning of list	1
beginning rather than	1
within the same	2
within the first	1
within the DLL	1
within the lifetime	1
within a certain	1
within a block	1
within a limited	1
within a year	1
within each clause	1
used, for example,	1
used, it is	1
used, then use	1
used, then there	1
used, but not	1
used, but any	1
used, there is	1
used, even when	1
used, while the	1
used, though. Some	1
checks for such	1
checks for array	1
checks which instruction	1
checks where necessary	1
checks where necessary.	1
checks makes the	1
checks whether the	3
checks both the	1
input and output	1
input in order	1
input or network	1
input or reading	1
input data is	1
input less efficient	1
input check if	1
input never exceeds	1
input data. A	1
input file. The	1
not. The loop	1
not. The Intel	1
not. The following	1
not. The advise	1
not. There are	1
not. You cannot	1
not. See page	1
not. I will	1
not. Supports 32-bit	1
not. Static cast	1
programmers to some	1
programmers and compiler	1
programmers and software	1
programmers and they	1
programmers have little	1
programmers have discovered	1
programmers use a	1
programmers do not	1
programmers write expressions	1
programmers rarely program	1
alternative is the	1
alternative is to	2
alternative to using	1
alternative solution is	1
alternative solution of	1
alternative implementations are	1
alternative version. The	1
alternative worth considering	1
alternative implementations. 7.22	1
My vector class	1
My example is	2
My test tool	2
My own function	1
My recommendation is	1
My recommendation for	1
My experimental results	1
My preference is	1
organized in a	1
organized if you	1
organized as a	2
organized as 32	1
organized as follows:	1
organized into lines	1
organized into vectors.	1
organized so that	2
stride is a	2
stride is 8192	1
stride and cause	1
stride for the	1
stride can be	1
stride will contend	1
stride then this	1
stride (see above,	1
stride causes all	1
set, and a	1
set, as listed	1
set, then you	1
set, but it	1
set, but possibly	1
set, one for	1
set, using asmlib	2
set, another version	1
set, e.g. /arch:SSE2.	1
current instruction set.	1
current compilers may	1
current compilers don't	1
current Intel CPUs	1
current array element.	1
current version satisfies	1
current operating systems	1
current CPUs optimally.	1
current .cpp file)	1
current position. Windows	1
'this' is incurred	1
'this' in a	1
'this' pointer to	1
'this' pointer in	1
'this' pointer which	2
'this' pointer takes	1
'this' pointer. It	1
'this' pointer. You	1
'this' pointer, common	1
problem. The compiler	1
problem. The most	1
problem. The official	1
problem. This new	1
problem. If the	1
problem. If a	1
problem. These instructions	1
problem. Whenever the	1
problem. 7.11 Type	1
problem. Vectors of	1
3 The latest	1
3 for a	1
3 - 4	1
3 - 5	1
3 - 6	1
3 breakpoint and	1
3 breakpoint again.	1
3 Finding the	2
3 1.1 The	1
counts a one	1
counts for threads	1
counts that you	2
counts are often	1
counts at the	1
counts should be	1
counts how many	1
counts give the	1
counts represent the	1
gain in performance	2
gain in speed	2
gain in performance.	1
gain if such	1
gain by optimizing	1
gain by testing	1
gain by unrolling	1
gain depends on	1
processors, a loop	1
processors, a switch	1
processors, and it	1
processors, and choose	1
processors, and 3	1
processors, as explained	1
processors, only the	1
processors, but is	1
processors, but not	1
processors, between PC's	1
happen to be	3
happen in the	1
happen that a	1
happen that (b*c)	1
happen if the	2
happen with the	1
happen quite often.	1
enough to be	2
enough to hold	1
enough to identify	1
enough to justify	2
enough for the	1
enough for a	1
enough registers then	1
enough bits for	1
apply the empty	1
apply to other	2
apply to floating	1
apply to very	1
apply to arrays	1
apply to modulo	1
apply as to	1
apply CPU dispatching	1
apply to. It	1
Obviously, the best	1
Obviously, the directly	1
Obviously, the initial	1
Obviously, a function	1
Obviously, it is	1
Obviously, you should	1
Obviously, this is	2
Obviously, all these	1
Obviously, we loose	1
version. The CPU	1
version. The Gnu	1
version. The examples	1
version. The penalty	1
version. See the	1
version. For team	1
version. For one-man	1
version. 2. Check	1
version. Note that	1
version. Updating mechanisms	1
row is a	1
row to the	1
row or column.	1
row by adding	1
row + column;	1
row < NUMROWS;	1
row addresses at	1
row length is	1
row 28 below	1
row 28 share	1
Compiler has insufficient	1
Compiler optimization options	2
Compiler directives and	1
Compiler v. 8.42n,	1
Compiler v. 11.1	1
Compiler v. 14.00	1
Compiler identification 16	1
Compiler Documentation for	1
Compiler Documentation". Included	1
matter of programming	4
matter of interpreting	2
matter of convenience	1
matter of habit,	1
matter and there	1
matter if the	1
declaration of the	1
declaration of c1	1
declaration to tell	1
declaration and the	2
declaration may in	1
declaration class CChild1	1
declaration makes it	1
declaration size, bits	1
declaration "static" or	1
allocate the final	1
allocate a new	3
allocate a small	1
allocate more memory	1
allocate more space	1
allocate more RAM	1
allocate one big	1
allocate variable-size arrays	1
series of branches	1
series of statements	1
series of five	3
series of manuals.	1
series of calculations:	1
series of calculations,	1
series of experiments	1
series float Exp(float	1
features of the	1
features of Intel	1
features of Java	1
features to each	1
features and for	1
features for automatic	1
features it has.	1
features as the	1
features rarely found	1
features 80386 32	1
added a bounds	1
added to the	3
added to a	2
added to p	1
added and then	1
added at any	1
added information about	1
user. The advantages	1
user. There may	1
user. Dynamic linking	1
user. Time is	1
user. Making exception-safe	1
user. With the	1
user. Installation problems.	1
user. Menus, buttons,	1
user. Compatibility problems.	1
user. Feature bloat.	1
to: // Example	10
waste a lot	1
waste of the	2
waste of time	2
waste of cache	2
waste of resources.	2
waste of time,	1
metaprogramming is the	1
metaprogramming in C++:	1
metaprogramming can be	1
metaprogramming // Template	1
metaprogramming so complicated?	1
metaprogramming would be	1
metaprogramming implementation analogous	1
metaprogramming is. //	1
metaprogramming features, including	1
metaprogramming tools to	1
map is needed	1
map are prone	1
map can be	1
map or an	1
map may also	1
map file from	1
map file includes	1
map file tells	1
map file /Fm	1
map file" option	1
define a structure	1
define a macro	1
define in this	1
define function type	1
define function names	1
define 64-bit integers,	1
define matrix //	1
define your own	1
define application-specific instructions	1
define fprintf //	1
returns. The next	1
returns. The preferred	1
returns. This is	1
returns. There is	1
returns. But what	1
returns. Make the	1
returns. Alternatively, you	1
returns. alloca may	1
returns. Global or	1
returns. Every time	1
Windows. The disadvantage	1
Windows. The integrated	1
Windows. It is	1
Windows. In 64-bit	1
Windows. Gnu Comes	1
Windows. 10 Multithreading	1
Windows. Borland /	1
Windows. Does not	1
Windows. Does not,	1
Windows. Integrates into	1
style that doesn't	1
style are that	1
style if it	1
style with character	1
style as character	1
style has both	1
style floating point	1
style string functions	1
style type-casting with	1
Load library at	1
Load eight consecutive	8
3; for (i	1
3; or __asm	1
3; } The	1
3; } if	1
3; } This	2
3; } return	1
3; return a	2
approximately two clock	2
approximately three times	1
approximately 12 -	1
approximately six in	1
approximately six integer	1
approximately seven significant	1
approximately so. It	1
approximately 500 clock	1
order. The same	1
order. The heap	1
order. The advice	1
order. This makes	1
order. If the	1
order. See page	1
order. Example: //	1
order. Some compilers	1
order. Long dependency	1
3: "The microarchitecture	8
3: printf("Delta"); break;	1
microarchitecture of Intel,	9
easy to make	1
easy to trace	1
easy to port	1
easy way to	2
easy development of	1
easy linking to	1
easy development. For	1
easy GUI development,	1
situations to avoid	1
situations where the	2
situations where a	2
situations where code	1
situations where automatic	1
situations where pre-increment	1
situations like example	1
implement the functions	1
implement the many	1
implement the dispatch	1
implement a microprocessor	1
implement a queue	1
implement a universal	1
implement in a	1
implement this "override"	1
implement OneOrTwo5[b!=0] as	1
65 8 Optimizations	2
65 bytes of	1
65 65 33	1
65 65 13.6	1
65 33 11.8	1
65 13.6 80.9	1
65 7.32 Preprocessing	1
65 7.33 Namespaces...........................................................................................................	1
chosen the wrong	1
chosen for the	2
chosen as the	1
chosen compiler doesn't	1
chosen only when	1
chosen version return	1
chosen based on	1
chosen expression. Example	1
256-bit vector as	1
256-bit vector register	1
256-bit integer vectors.	1
256-bit size are	1
256-bit registers named	1
256-bit instructions were	1
256-bit read operations	1
256-bit YMM vectors	1
256-bit YMM registers.	1
slightly more efficient	3
slightly more time.	1
slightly more resources	1
slightly faster in	1
slightly less efficient.	1
slightly less compact.	1
slightly less efficiently.	1
scattered around in	4
scattered around on	1
scattered around at	2
scattered everywhere in	1
scattered randomly around	1
contain the different	1
contain is provided	1
contain a typical	1
contain all data	1
contain many tips	1
contain pointers or	1
contain useful discussions	1
contain either sixteen	1
contain pure function	1
writes a file	1
writes to any	1
writes to matrix	1
writes to load	1
writes or reads	1
writes with normal	1
writes may slow	1
writes automatically in	1
writes only, then	1
device is a	1
device than in	1
device should preferably	1
device itself is	1
device drivers for	2
device drivers are	1
device drivers may	1
device driver. A	1
independent of the	2
independent of changes	1
independent and checks	1
independent code more	1
independent then you	1
independent code. The	1
independent code, see	1
independent divisions. Example:	1
allocation. The heap	1
allocation. This method	1
allocation. There is	1
allocation. You should	1
allocation. See page	1
allocation. Some programming	1
allocation. Dynamic memory	1
allocation. Do not	1
allocation. Container classes	1
non-static data members	2
non-static variables and	2
non-static member function	2
non-static member functions.	2
non-static access. 7.20	1
subsequent elements in	1
subsequent times because	1
subsequent instructions. The	1
subsequent counts give	1
subsequent counts represent	1
subsequent sections describe	1
subsequent manuals are	1
subsequent manuals. Please	1
subsequent counts. This	1
applies to the	1
applies to an	1
applies to arrays	1
applies to reading	1
applies to BSD	1
applies to default	1
applies to decrement	1
applies to 3-dimensional	1
applies only when	1
applied to a	5
applied to all	1
applied to 32-bit	1
applied to integers.	2
destructors of each	1
destructors to take	1
destructors to call.	1
destructors for local	1
destructors are called	1
destructors are called.	1
destructors A constructor	1
destructors after jumping	1
destructors .................................................................................. 55	1
integers. The branch	1
integers. The allocation	1
integers. It is	2
integers. It can	1
integers. But there	1
integers. Many 32-bit	1
integers. 7.25 Bitfields	1
integers. 7.5 Booleans	1
terms of code	1
terms of program	1
terms of execution	2
terms of specific	1
terms of usability	1
terms of speed.	1
terms of development,	1
terms in one	1
help the compiler	1
help the CPU	1
help the programmer	1
help of the	1
help if you	1
help files and	2
help files etc.	1
help files, data	1
transfer is more	1
transfer is avoided	1
transfer is avoided.	1
transfer a pointer	1
transfer of a	1
transfer for 'this'	1
transfer are eliminated.	1
transfer across all	1
transfer ownership of	1
blocks is more	1
blocks is faster	1
blocks of memory.	1
blocks of data",	1
blocks in order	1
blocks than there	1
blocks such as	1
blocks makes the	1
blocks rather than	1
away the variable	1
away the extra	1
away a const	1
away and the	1
away in the	1
away in reusable	1
away an overflow	1
away p and	1
away cpuid //	1
15.1b is easier	1
15.1b is implemented.	1
15.1b to metaprogramming	1
15.1b to 15.1c	1
15.1b to 15.1c.	1
15.1b to 15.1c,	1
15.1b to 15.1c?	1
15.1b and the	1
15.1b and d	1
low in order	1
low instruction set	1
low power consumption	1
low positive result.	1
low repeat count	1
low priority of	1
low priority thread,	1
low priority. In	1
low priority. Especially	1
multiply a nonzero	1
multiply and shift	1
multiply // square	1
multiply it by	1
multiply by a	1
multiply by -	1
multiply by xx-xx--x-	1
multiply integers of	1
multiply j by	1
share the same	9
enabled. The compiler	1
enabled. The advantage	1
enabled. A more	1
enabled. There are	1
enabled. Conversion from	1
enabled. Conversions between	1
enabled. Typically, the	1
enabled. Volatile The	1
enabled. Few compilers	1
explanation of the	1
explanation of this	1
explanation of return	1
explanation of branch	2
explanation of register	1
explanation and possible	1
explanation if you	1
explanation why this	1
near the maximum	1
near then the	1
near each other	5
near each other.	2
provided in the	1
provided in an	1
provided in manual	1
provided that the	2
provided as a	1
provided as an	1
provided several examples	1
provided below, on	1
latter is more	1
latter is slightly	1
latter is executed	1
latter function also	1
latter has one	1
latter case the	1
latter function, but	1
latter case, the	1
latter case, you	1
6 The 64-bit	1
6 clock cycles,	1
6 unused bytes	2
6 integer, pointer	1
6 Development process	1
6 Development process......................................................................................................	1
6 2.3 Choice	1
6 2.4 Choice	1
stores the time	1
stores the result	1
stores the offset	1
stores the lower	1
stores the thousand	1
stores a double	1
stores a pointer	1
stores this result	1
stores all the	1
to. A const	1
to. A reference	1
to. It is	2
to. For example:	2
to. Example: //	1
to. Therefore, it	1
to. Now ebx	1
default in 64-bit	1
default integer size	1
default size when	1
default unless there	1
default constructor is	1
default constructor that	1
default constructor //	1
default anyway in	1
default constructors, copy	1
Instruction set SSE2	1
Instruction set char	1
Instruction set needed	1
Instruction set control	1
Instruction set Header	1
Instruction set Prefetch	1
Instruction set Important	1
Instruction sets A	1
Instruction tables: Lists	1
finding the most	1
finding the hot	1
finding the right	2
finding the numerically	1
finding a suitable	1
finding problems that	1
finding hot spots,	1
finding elements. A	1
inefficient. The modern	1
inefficient. If a	1
inefficient. There is	1
inefficient. An allocated	1
inefficient. Dynamic memory	1
inefficient. Variables declared	1
inefficient. Objects of	1
inefficient. Division, square	1
inefficient. Linear arrays	1
c, d; a	1
c, d; if	1
c, d; c	2
c, d; };	1
c, temp; temp	1
c, d, y;	2
c, d, e,	1
search for updates	2
search for finding	1
search instructions AVX	1
search times 24	1
search facilities are	2
search facilities, binary	1
search requests for	1
Modern compilers can	1
Modern CPUs are	3
Modern CPUs can	1
Modern microprocessors in	1
Modern microprocessors are	2
Modern microprocessors can	1
block. This is	1
block. This requires	1
block. A large	1
block. A linked	1
block. There is	1
block. Do not	1
block. Any pointers	1
block. Thread-local storage	1
block. Walking through	1
critical. The branch	1
critical. The fastest	1
critical. The worst	1
critical. A very	1
critical. It is	1
critical. However, there	1
critical. Therefore, the	1
critical. Optimizing for	1
critical. 129 13.7	1
chains is stronger	1
chains in the	1
chains can be	2
chains with long	1
chains then each	1
chains (see p.	1
chains Modern microprocessors	1
chains ................................................................................................ 22	1
time-consuming function in	1
time-consuming than a	1
time-consuming data processing.	1
time-consuming part of	1
time-consuming (see page	1
time-consuming parts of	1
time-consuming tasks because	1
time-consuming tasks into	1
time-consuming garbage collector	1
brands of C++	1
brands of CPUs	2
brands of microprocessors	1
brands of CPUs.	1
brands of CPUs,	1
brands and similarly	1
brands or specific	1
brands or models	1
available. The most	1
available. The number	1
available. The best	1
available. The older	1
available. It should	1
available. See page	1
available. Some compilers	1
available. Microsoft Comes	1
available. declaration size,	1
Don't use an	1
Don't put a	1
Don't put something	1
Don't change &&	1
Don't rely on	1
Don't mix float	2
Don't mix nontemporal	1
Don't panic if	1
brand is likely	1
brand of CPU.	1
brand or model	1
brand new today	1
brand check is	1
brand simply by	1
brand was less	1
brand name and	1
brand names and	1
executed. The compiler	1
executed. This has	1
executed. It is	1
executed. If the	1
executed. An example	1
executed. However, the	1
executed. Furthermore, you	1
executed. Optimizes very	1
executed. Without static,	1
faster. The most	1
faster. The advantage	1
faster. The logic	1
faster. It is	1
faster. In the	2
faster. There may	1
faster. Division by	1
faster. Of course,	1
diagonal is swapped	1
diagonal and swap	1
diagonal are accessed	2
diagonal // swap	1
diagonal have been	1
diagonal there is	1
diagonal remain unchanged.	1
diagonal swapd(a[r][c], a[c][r]);	1
n; static char	1
n; i++) {	1
n; i++) f	1
n; switch (n)	1
n; #if defined(__unix__)	1
n; #endif return	1
n; x++) factorial	1
n; u.i =	1
n; 143 if	1
*p and calculate	1
*p = *p	2
*p = string;	2
*p or p->member	1
*p + 2;	2
*p + 2;}	1
logic of the	1
logic may need	1
logic structure of	1
logic allows parallel	1
logic allows it,	1
logic device is	1
logic device than	1
logic devices A	1
logic behind the	1
Microsoft, Intel and	4
Microsoft, Intel, Gnu	3
Microsoft, Intel, PathScale	1
Microsoft, Gnu, Clang	1
hard disk or	2
hard disk if	1
hard disk because	1
hard disk often	1
hard disk copying.	1
hard disk. A	1
hard disk. Test	1
hard working software	1
purposes the standard	1
purposes is beyond	1
purposes is allowed.	1
purposes in 32-bit	1
purposes are also	1
purposes than it	1
purposes than rendering	1
purposes such as	1
purposes (www.boost.org). The	1
typical set of	1
typical software project	1
typical way to	1
typical uses of	1
typical application to	1
typical implementation of	1
typical repeat count	1
typical sources of	1
typical degree of	1
usability may be	1
usability A better	1
usability problem in	1
usability problems and	2
usability problems that	1
usability reasons. The	1
usability ............................................................................................... 23	1
usability issues, and	1
pure function is	1
pure function with	1
pure function calls	1
pure function calls.	2
pure if the	1
pure function. Example:	1
pure functions, but	1
pure __attribute(( const))	1
vectorize the code	5
vectorize the loop	1
vectorize a loop	1
vectorize code explicitly	1
vectorize automatically. The	1
problems. The performance	1
problems. The procedures	1
problems. It is	2
problems. Some common	1
problems. All software	1
problems. Avoid nested	1
problems. Software developers	1
problems. More details	1
could be a	1
could be calculated	1
could be achieved	1
could have been	1
could calculate *p+2	1
could possibly be	1
could free the	1
could benefit from	2
parameter. The order	1
parameter. It can	1
parameter. If MultiplyBy	1
parameter. In other	1
parameter. There is	1
parameter. But it	1
parameter. No time	1
parameter. Templates may	1
parameter. Further details	1
derived class is	1
derived class in	1
derived class are	2
derived class (see	1
derived class through	1
derived class. This	1
derived class, it	1
derived class: //	1
mentioned in the	1
mentioned in table	1
mentioned in chapter	1
mentioned above for	1
mentioned below. Microsoft	1
mentioned above. The	1
mentioned above. An	1
mentioned above. Now	1
mentioned here: A	1
Time is a	1
Time for transposition	1
Time for transposing	1
Time // Serialize	1
Time before test	1
Time difference for	1
Time per element	3
Optimization of Numerically	2
Optimization in embedded	2
Optimization method Function	1
Optimization directives Some	1
Optimization directives ..............................................................................................	1
Optimization Guide for	1
Optimization Reference Manual".	1
expressions. It is	1
expressions. There are	1
expressions. See page	1
expressions. For example,	2
expressions. Most reductions	1
expressions. Floating point	1
expressions. Whether the	1
expressions. Operations that	1
include the appropriate	1
include a performance	1
include a few	1
include a profiler	1
include not only	1
include any part	1
include standard libraries	1
include C, C++,	1
include JavaScript, PHP,	1
y; // x,y	1
y; x =	1
y; } double	1
y; ... x.a	1
y; y =	4
y; bool b;	1
overflow. The exception	1
overflow. This function	1
overflow. For example,	1
overflow. Example: //	2
overflow. Table 8.1	1
overflow. Likewise, it	1
overflow. Signed versus	1
overflow. Taking the	1
element. The integer	1
element. The most	1
element. The table	1
element. The multiplication	1
element. In some	1
element. I have	1
element. 100 As	1
element. Matrix size	1
element. Rather than	1
oriented programming are	1
oriented programming can	1
oriented programming as	1
oriented programming without	1
oriented programming are:	1
oriented programming style	2
oriented programs can	1
oriented programs. If	1
fully compiled code.	1
fully optimized code	1
fully optimized yet.	1
fully compatible on	1
fully standardized and	1
fully portable in	1
fully optimized. Library	1
fully utilize systems	1
fully utilizing its	1
storage. The same	1
storage. Example 14.23b	1
storage. If you	1
storage. See page	1
storage. All x86	1
storage. No function	1
storage. Variables that	1
storage. Optimizing file	1
storage. Live range	1
addition, a floating	1
addition, and a	1
addition, set the	1
addition, fast approximate	1
addition, subtraction and	3
addition, subtraction, multiplication,	1
addition, subtraction, comparison,	1
everything is double	1
everything is float	1
everything in case	1
everything that is	1
everything that has	1
everything that depends	1
everything happens at	1
everything else. This	1
everything else. System	1
involves the problems	1
involves the overhead	1
involves the risk	2
involves eight or	1
involves eight floating	1
involves allocation of	1
involves multiplication or	1
involves pure function	1
Here the iteration	1
Here is a	1
Here are some	1
Here it is	1
Here you have	1
Here you cannot	1
Here we can	1
Here we prefer	1
Here CParent is	1
factorial = 1.0;	2
factorial function looks	1
factorial function (n!)	1
factorial } return	1
factorial (int n)	2
factorial *= x;	2
OpenMP is a	1
OpenMP and automatic	4
OpenMP directives for	2
OpenMP directives 32	1
OpenMP directives. OpenMP	1
eax to the	1
eax = i	1
eax with 100	1
eax / sar	1
eax ebx, 1	1
eax ebx, 31	1
eax edx, DWORD	1
eax holds the	1
eax $B2$2 ;	1
bb[], short int	9
mispredicted for this	1
mispredicted only when	3
mispredicted only one	1
mispredicted even if	1
mispredicted (See manual	1
mispredicted whenever it	1
mispredicted 50% of	1
standardized and done	1
standardized and supported	1
standardized as possible	1
standardized file formats	1
standardized allows us	1
standardized installation tools.	1
standardized details in	1
standardized across platforms.	1
standardized manner. 3.4	1
(or in addition	1
(or if a	1
(or at least	1
(or part of	1
(or malloc and	1
(or int) instead	1
(or later) instruction	1
(or higher) is	1
(or eight) points	1
across the function	1
across a call	1
across function calls.	2
across all .cpp	1
across compilers. Fastcall	1
across modules The	1
across modules (See	1
across platforms. See	1
cycle is the	2
cycle is 1	1
cycle if the	1
cycle on one	1
cycle on most	1
cycle on another	1
cycle counter is	1
cycle counter (see	1
aliasing is to	1
aliasing does not	1
aliasing (see page	2
aliasing When accessing	1
aliasing rule of	2
aliasing (/Oa). The	1
aliasing /Oa -fno-alias	1
aa[], short int	9
tool is not	1
tool is faster	1
tool is Microsoft	1
tool for using	1
tool for details	1
tool can be	1
tool can make	1
tool can set	1
tool supports both	1
parent and child	3
parent class and	2
parent class in	1
parent class data	1
parent classes in	1
parent class. The	1
care of the	3
care of this	1
care of all	1
care of some	1
care of communication	1
care to calculate	1
care about the	1
systems, and API's.	1
systems, you may	1
systems, you cannot	1
systems, this may	1
systems, but in	1
systems, there is	1
systems, though these	1
systems, especially if	1
parm1, int parm2)	7
parm1, int parm2);	1
included in the	3
included in a	1
included in compiler	1
included for the	1
included with the	1
included as part	1
false and 1	1
false = a	1
false = false,	1
false where it	1
false model number	1
false regardless of	1
false (0); and	1
false vendor string.	1
value. The loop	1
value. The copy	1
value. The keyword	1
value. This is	1
value. It does	1
value. There is	1
value. Example: //	1
value. However, the	1
file. The output	1
file. This enables	2
file. A console	1
file. If the	1
file. Use another	1
file. Only the	1
file. Keep often	1
*= i; return	1
*= x; This	1
*= x; x	1
*= x; n	1
*= x; Note	1
*= x; nfac	1
*= n+1; //	1
*= xx4; //	1
temporary object for	1
temporary array before	1
temporary objects for	1
temporary variable outside	1
temporary register for	1
temporary storage. Variables	1
temporary debug breakpoints	1
temporary intermediates, loop	1
12 or 16	1
12 - 25	1
12 option -fno-builtin	1
12 Using vector	2
12 bytes. The	1
12 2.7 Choice	1
12 $B1$1: push	1
memcpy is unsafe	1
memcpy function implicitly	1
memcpy rather than	1
memcpy function. There	1
memcpy 16kB aligned	2
memcpy 16kB unaligned	2
procedure to calculate	1
procedure 4 Most	1
procedure linkage table	5
procedure linkage table.	1
PC and then	1
PC processors is	1
PC processors are	1
PC processors with	1
PC processors. The	1
PC platform with	1
PC platforms. Graphics	1
PC platform. However,	1
frequent if the	1
frequent cause of	1
frequent allocation and	1
frequent source of	1
frequent causes of	1
frequent updates are	1
frequent sources of	2
unlimited 4 bytes	4
unlimited 8 bytes	4
parallelism is the	1
parallelism is obvious	1
parallelism is obvious.	1
parallelism and fine-grained	1
parallelism than with	1
parallelism when deciding	1
parallelism because communication	1
parallelism refers to	1
detection function of	1
detection function in	1
detection function that	1
detection function as	1
detection function In	1
detection mechanism in	1
detection function, one	1
detection mechanism. The	1
c2 and bc	1
c2 for elements	1
c2 = _mm_add_epi16(c,	2
c2 = _mm_and_si128(c2,	1
c2 with the	1
c2 < c1+TILESIZE;	1
c2 < r2;	1
"The microarchitecture of	8
throw() to the	1
throw() statement can	1
throw() Assume function	1
throw() throw() Assume	1
throw() throw() throw()	2
throw() specification. The	1
throw() specification to	1
prediction and misprediction	1
prediction are different	1
prediction or estimate	1
prediction into account	1
prediction (see p.	1
prediction turns out	1
prediction mechanism. See	1
prediction mechanisms. Modern	1
polymorphic function goes	1
polymorphic class has	1
polymorphic member of	1
polymorphic member function	1
polymorphic function. The	1
polymorphic functions. The	1
polymorphic child function:	1
polymorphic classes. Each	1
#if is more	1
#if is resolved	1
#if instead of	1
#if directives are	1
#if directives around	1
#if INSTRSET ==	2
#if defined(__unix__) ||	1
now that we	1
now be vectorized	1
now as follows.	1
now used in	1
now contains the	1
now contains only	1
now overlap. Compilers	1
now discontinued Object	1
unit is clock	1
unit is pipelined,	1
unit of received	1
unit for other	1
unit as additions.	1
unit intended for	1
unit throughput There	1
unit throughput .......................................................................................	1
conventions for different	6
conventions for functions	1
conventions are different.	1
register. The library	1
register. The above	1
register. This advantage	1
register. If the	1
register. In example	1
register. Factors that	1
register. Everything that	1
register. Registers are	1
kind of branch	1
kind of instructions	1
kind of error	1
kind of problems	1
kind of optimizations	1
kind of registers.	1
kind of branch.	1
kind of exceptions	1
graphical user interface	3
graphical user interface.	2
graphical user interfaces	1
graphical interface calls.	1
graphical interface frameworks	1
lower than a	1
lower instruction set.	1
lower 8 or	1
lower 16 bits	1
lower priority than	1
lower priority level,	1
lower priority. If	1
lower case: //	1
label is equal	1
label if i	1
label ; return	1
label ; save	1
label ; restore	1
label plus one,	1
label $B1$2:. This	1
label ;eax=addressofa ;edx=addressinr	1
iterations is not	1
iterations of redesign.	1
iterations and start	1
iterations in one.	1
iterations such as	1
iterations are: No	1
iterations back. The	1
iterations ahead. It	1
misprediction is approximately	1
misprediction of virtual	1
misprediction long before	1
misprediction before it	1
misprediction every time	1
misprediction penalty is	1
misprediction penalty of	1
misprediction penalty. Branches	1
integer, and the	1
integer, and this	1
integer, or an	1
integer, then you	1
integer, pointer or	1
integer, so that	1
integer, signed or	1
integer, usually 32.	1
binding is that	1
binding of function	1
binding can be	1
binding by default,	2
binding should therefore	1
binding definitely degrades	1
binding leads to	1
just-in-time compiler can	1
just-in-time compilation of	2
just-in-time compilation may	1
just-in-time compilation. The	1
just-in-time compilation. Some	1
just-in-time compilers, system	1
just-in-time compilers, etc.,	1
try to do	1
try to run	1
try to optimize	1
try to fix	1
try { F1();	1
try different libraries	1
try block or	1
try block. There	1
background is further	1
background are unnecessary	1
background calculations piece	1
background process running	1
background job can	1
background processes running,	1
background services under	1
background jobs. The	1
converted to a	4
converted to an	1
converted to unsigned.	1
converted to OMF	1
converted by the	1
pointed to is	3
pointed to can	2
pointed to by	2
pointed to. For	1
CPUs, as described	3
CPUs, not for	1
CPUs, different types	1
CPUs, but it	1
CPUs, but not	1
CPUs, but event-counters	1
account in the	1
account for unaligned	1
account that each	1
account when optimizing	1
account when deciding	3
account when choosing	1
p) { int	1
p) { return	4
p) { *p	2
p) {return p->a	1
chain is a	1
chain of function	1
chain in two:	1
chain may fill	1
chain has a	1
chain which prevents	1
chain where each	1
chain would make	1
algorithms is that	1
algorithms to predict	1
algorithms and data	1
algorithms in the	1
algorithms in order	1
algorithms for different	1
algorithms are described	1
algorithms used for	1
PLT and GOT.	1
PLT for all	1
PLT for internal	1
PLT tables are	2
PLT entry with	1
PLT entry initially	1
PLT lookups for	1
heavy work to	1
heavy mathematical calculations,	1
heavy graphics application	1
heavy graphics calculations.	1
heavy background calculations	1
heavy marketing of	1
heavy competition. Processors	1
heavy traffic and	1
once the hot	1
once The bitwise	1
once for each	2
once or multiple	1
once more by	1
once then the	1
once made a	1
additions and no	1
additions and shift	1
additions and multiplications.	1
additions in the	1
additions in one	1
additions are independent	1
additions by the	1
additions with double's.	1
hash table for	1
hash table can	1
hash table increases	1
hash map is	1
hash map can	1
hash map may	1
hash maps etc.	1
hash map. Do	1
ecx and edx	1
ecx and edx,	1
ecx = a	1
ecx = Induction	1
ecx contains the	1
ecx DWORD PTR	1
ecx now contains	1
ecx 86 add	1
system. The number	1
system. The best	1
system. This is	1
system. It will	1
system. See page	2
system. AVX is	1
system. Note that	1
variables, and for	1
variables, if possible.	1
variables, loop counters,	1
variables, but will	1
variables, integer Register	1
variables, floating point	1
variables, float Live	1
variables, arrays and	1
equally efficient because	1
equally efficient because,	1
equally likely to	1
equally fast whether	1
equally efficient. If	1
equally efficient. Simple	1
equally near then	1
equally fast. In	1
however, to pass	1
however, and it	1
however, if the	1
however, when b	1
however, there is	1
however, where there	1
however, where template	1
however, often write	1
designed to handle	1
designed to solve	1
designed for a	1
designed for this	1
designed for generality	1
designed by Intel	1
designed so as	1
designed program. 6	1
profiling and debugging.	1
profiling (see page	1
profiling support in	1
profiling support. Then	1
profiling tools that	1
profiling instruments in	1
profiling feasible. Interference	1
profiling methods: Instrumentation:	1
fragmented and caching	1
fragmented and scattered	1
fragmented and involve	1
fragmented when the	1
fragmented when objects	2
fragmented hard disk.	1
fragmented thanks to	1
inputs is limited	1
inputs to the	1
inputs for a	1
inputs are the	1
inputs have any	1
inputs when the	1
inputs give overflow	1
inputs give infinity.	1
fast. The result	1
fast. The lesson	1
fast. This can	1
fast. In general,	1
fast. All optimizing	1
fast. Simple integer	1
fast. Value of	1
fast. Calculating the	1
family of microprocessors	1
family and model	3
family can run	1
family have two	1
family number 6!	1
family number, which	1
4, we have:	1
4, while all	1
4, 8, 16,	1
4, Wednesday =	1
4, 6, 9	1
4, 2007 (www.intel.com/technology/itj/).	1
4, etc.). Older	1
4, anda *	1
Virtual function //	1
Virtual functions and	1
Virtual functions in	1
Virtual functions are	1
Virtual member functions	3
Virtual call to	1
j = order(i);	2
j by is	1
j as index	1
j * 32	1
j * (columns	1
j < columns;	1
j << 5.	1
interrupt the user	1
interrupt should preferably	1
interrupt 3 breakpoint	2
interrupt occurs in	1
interrupt 3. The	1
interrupt service routine	1
interrupt service routines,	1
-1 = a,	2
-1 = -1	2
-1 = ~a	1
-1 - n.a.	1
-1 x -	1
-1 (a&~b)|(~a&b)=a^b ---------	1
8, but not	1
8, 16 or	1
8, last byte	2
8, 16, 32	1
8, 16, 32,	1
8, 10, 12	1
8, Thursday =	1
units. The size	1
units. The problem	1
units. This means	1
units. If any	1
units. For example,	1
units. Each 128-bit	1
units. Any floating	1
units. Typically, there	1
who is still	1
who are satisfied	1
who have sent	1
who has to	1
who want to	2
who would like	1
who would know	1
fastest on different	1
fastest because you	1
fastest possible access	1
fastest way to	2
fastest execution is	1
fastest solution on	1
fastest first. However,	1
__restrict or #pragma	1
__restrict or __restrict__,	1
__restrict #pragma ivdep	2
__restrict __restrict __declspec(	1
__restrict __declspec( noalias)	1
__restrict aa, int	1
__restrict bb) {	1
arithmetic A pointer	1
arithmetic operations are	1
arithmetic operations with	1
arithmetic calculations go	1
arithmetic operations. The	1
arithmetic operations. When	1
arithmetic units, etc.	1
arithmetic expression. The	1
DLL is relocated	1
DLL can be	1
DLL or a	1
DLL with the	1
DLL use absolute	1
DLL at the	1
DLL takes more	1
DLL goes through	1
factors in the	1
factors for the	1
factors that can	2
factors that decide	1
factors are explained	1
factors are generated	1
factors as template	1
Gnu, Intel and	1
Gnu, Clang and	2
Gnu, Clang Supported	1
Gnu, Clang, Intel	3
Gnu, Clang, Intel,	1
arrays. // Example	1
arrays. It is	1
arrays. There are	1
arrays. I have	1
arrays. An array	1
arrays. Note that	1
arrays. Array size	1
arrays. Strings can	1
devices and using	1
devices and machines	1
devices are becoming	1
devices are CPLDs	1
devices if you	1
devices with limited	1
devices A programmable	1
devices typically have	1
branch. The common	1
branch. It may	1
branch. If it	1
branch. There is	1
branch. See the	1
branch. Example: //	1
branch. After each	1
branch. Microprocessor designers	1
required is not	1
required a PC.	1
required for performance	1
required for finding	1
required for putting	1
required // This	1
required amount of	2
(unsigned int if	1
(unsigned int)b /	2
(unsigned int)b %	2
(unsigned int)size) {	1
(unsigned int)a /	1
(unsigned int)(max -	1
almost the entire	1
almost all modern	1
almost all respects	1
almost always advantageous	1
almost certain to	1
almost certain that	1
almost identical performance	1
almost independent of	1
GOT and PLT	4
GOT for all	1
GOT through a	1
GOT lookup process	1
GOT entry. You	1
array. The values	1
array. The disadvantage	1
array. The constructor	1
array. // Example	1
array. This method	1
array. But the	1
array. No link	1
array. eax holds	1
listed in the	2
listed in table	3
listed in manual	1
listed on page	1
listed below in	1
general function libraries	1
general method is	1
general case where	1
general statement can	1
general purposes in	1
general case, but	1
general literature on	1
general improvements in	1
preferred to use	2
preferred to declare	1
preferred when speed	1
preferred because of	1
preferred method for	1
preferred programming language	1
preferred language will	1
cycles, then this	1
cycles, then we	1
cycles, but it	1
cycles, depending on	5
explicitly in many	1
explicitly that pointers	1
explicitly if data	1
explicitly by using	1
explicitly by writing:	1
explicitly as in	1
explicitly when alloca	1
explicitly what kind	1
space. The syntax	1
space. A floating	1
space. A union	1
space. A situation	1
space. It may	1
space. It should	1
space. Excessive use	1
space. Putting simple	1
fixed size to	1
fixed size array	1
fixed size arrays	1
fixed address might	1
fixed repeat count	1
fixed size, not	1
fixed breakpoint in	1
fixed strides. Uncached	1
Memory and string	1
Memory access Accessing	1
Memory allocated with	2
Memory swapping is	1
Memory copying. There	1
Memory swapping. Software	1
Memory access....................................................................................................... 22	1
zero. The []	1
zero. A good	1
zero. It is	1
zero. You may	1
zero. An OR	1
zero. Execution time	1
zero. 14.3 Use	1
zero. Zero can	1
non-sequential which makes	1
non-sequential order in	1
non-sequential access and	1
non-sequential order. The	2
non-sequential order. Example:	1
non-sequential manner then	1
non-sequential manner. It	1
multiplying the index	1
multiplying by other	1
multiplying by 3,	1
multiplying with the	3
multiplying with a	1
multiplying them. This	1
Conversion of a	2
Conversion of an	1
Conversion of unsigned	1
Conversion of integers	1
Conversion to floating	1
Conversion from integer	1
Conversion from floating	1
down the execution	2
down a program	1
down to zero	1
down to 36.	1
down and restarted	1
down sign bit	1
down dependency chains	1
software. This is	1
software. A negative	1
software. It may	1
software. You should	1
software. For more	1
software. Such an	1
software. Smaller microcontrollers	1
software. Background services.	1
interpreted in the	1
interpreted as a	1
interpreted as an	1
interpreted version of	1
interpreted line by	1
interpreted languages where	1
interpreted again and	1
interpreted script languages,	1
exactly the same	2
exactly the same.	1
exactly as efficient	2
exactly what you	1
exactly identical for	1
exactly identical code	1
jump to a	1
jump to top	1
jump by copying	1
jump from a=a*2;	1
jump between multiple	1
jump through a	1
jump targets. A	1
jump tables, and	1
determined in advance,	1
determined by the	3
determined by a	1
determined by considerations	1
determined with system	1
determined where the	1
cc[]) { for	1
cc[]) { //	6
cc[]) { Vec16s	1
line. The cache	1
line. The delay	1
line. This is	1
line. Some compilers	1
line. But these	1
line. Only one	1
line. 132 Table	1
line. Time-based sampling:	1
easily be implemented	1
easily be organized	1
easily be obtained.	1
easily available from	1
easily optimize away	1
easily become fragmented	1
easily justify a	1
easily ported to	1
identification 16 bit	1
identification adds extra	1
identification (RTTI) If	1
identification (RTTI) Runtime	1
identification (RTTI) /GR–	1
identification (RTTI) ...........................................................................	1
identification (RTTI). See	1
identification (RTTI), which	1
vectors. The following	1
vectors. The operators	1
vectors. This data	1
vectors. A lot	1
vectors. There are	1
vectors. These function	1
vectors. 12.10 Conclusion	1
vectors. Code that	1
2) { //	1
2) { a[i]	1
2) { sum1	1
2) { FuncA(i);	1
2) 2 -	1
2) 2 a+a+a+a=a*4	1
2) : (bb[i]	1
2) SelectAddMul_pointer =	1
applications. The string	1
applications. The choice	1
applications. Some systems	1
applications. But we	1
applications. Therefore, it	1
applications. Alternatively, use	1
applications. Remember that	1
applications. 2.8 Overcoming	1
volatile is that	1
volatile int DontSkip;	1
volatile int seconds;	1
volatile then an	1
volatile doesn't mean	1
volatile keyword makes	1
volatile keyword specifies	1
volatile volatile int	1
misses is not	1
misses and branch	2
misses in the	2
misses are very	1
misses by making	1
misses have occurred.	1
tables of mathematical	1
tables are not	2
tables are particular	1
tables can be	1
tables if this	1
tables Reading a	1
tables ................................................................................................. 132	1
random than normal.	1
random number generators.	1
random times and	1
random access. Reading	1
random order. The	1
random order. This	1
random manner. This	1
random events that	1
X The code	1
X make position-independent	1
X operating system	1
X operating systems,	1
X Compilers for	1
X #else //	1
X (Darwin) are	1
X __attribute__((aligned(16))) #endif	1
Conversions of float	1
Conversions between different	1
Conversions between floating	2
Conversions between integers	1
Conversions between signed	1
Conversions between float,	1
Conversions involving class	1
YMM in the	1
YMM register state.	1
YMM registers The	1
YMM registers are	1
YMM registers .................................................................	1
YMM vectors are	1
YMM registers. The	1
YMM registers. Disadvantages	1
resolved when the	2
resolved at compile	3
resolved at runtime.	1
resolved before the	1
purpose is to	1
purpose of the	1
purpose of this	1
purpose of using	1
purpose of finding	1
purpose in order	1
purpose libraries are	1
-fpic is much	1
-fpic and it	1
-fpic in 32-bit	1
-fpic in 64	1
-fpic because the	1
-fpic according to	1
-fpic option. Then	1
D is compiled	1
D are not	1
D has many	1
D language allows	1
D : public	2
D language. D	1
had the full	1
had a different	1
had in fact	1
had not been	1
had an interpreter	1
had used intrinsic	1
had read from	1
parameters. This is	1
parameters. A template	1
parameters. In 64-bit	1
parameters. There is	1
parameters. Therefore, make	1
parameters. Floating point	1
parameters. Or it	1
ebx, 1 ebx,	1
ebx, DWORD PTR	2
ebx, eax /	1
ebx, eax ebx,	2
ebx, 31 ebx,	1
measure the clock	1
measure that is	1
measure are much	1
measure // Number	1
measure how long	1
measure how much	1
measure exactly what	1
poorly for the	1
poorly designed program.	1
poorly predictable then	1
poorly predictable branch	1
poorly predictable. It	1
poorly predictable. For	1
poorly predictable, then	1
this: // Example	6
this: Use assembly	1
sections are dominating	1
sections can be	1
sections below. The	1
sections SSE instruction	1
sections /Gy -ffunction-	1
sections describe some	1
sections describe various	1
Software that relies	1
Software should use	1
Software developers should	1
Software developers typically	1
Software Developer’s Manual",	2
Software distributors are	1
Even function calls	1
Even with all	1
Even some of	1
Even big software	1
Even worse, many	1
Even better, you	1
Even better: store	1
19 in manual	1
19 }; S1	1
19 Avoid an	1
19 Literature Other	1
19 Literature .....................................................................................................................	1
19 3.5 Program	1
19 3.6 Dynamic	1
important. This can	1
important. This manual	1
important. A language	1
important. A virtual	1
important. Some systems	1
important. An important	1
important. 9.2 Cache	1
carry and zero	1
carry bit is	1
carry bit can	1
carry bit must	1
carry flag or	1
carry flag then	1
carry flag (e.g.	1
lazy loading of	1
lazy binding is	1
lazy binding of	1
lazy binding by	2
lazy binding definitely	1
lazy binding leads	1
xn is calculated	1
xn = x;	1
xn = x∙xn-1,	1
xn as x4∙xn-4.	1
xn / nfac;	1
xn n 0	1
xn *= x;	1
stamp counter in	1
stamp counter can	1
stamp counter //	1
stamp counter before	1
stamp counter becomes	1
stamp counter. The	1
stamp counter. This	1
debugging and exception	1
debugging and profiling	1
debugging and maintaining	1
debugging if required	1
debugging support which	1
debugging options prevent	1
debugging facilities, easy	1
10; a =	4
10; // Convert	1
10; int i;	1
10; Templates are	1
table. The 16-byte	1
table. If the	1
table. If a	1
table. Unfortunately, few	1
table. Optimization method	1
table. Even better:	1
table. Type size,	1
1, but operators	1
1, 2, 4	1
1, 2, 6,	2
1, 2, 3,	1
1, Monday =	1
1, 2A, 2B,	1
vector, the four	1
vector, and the	1
vector, such as	1
vector, bits Vector	1
vector, bits Instruction	1
vector, while you	1
vector, uses SSE3.	1
(b) { a	4
(b) { return	1
(b) { y	2
object, and a	1
object, and ownership	1
object, you may	1
object, then the	2
object, unless there	1
object, except for	1
allowed to have	1
allowed to change	1
allowed and which	1
allowed in C++	1
allowed in assembly	1
allowed only for	1
allowed inputs are	1
delete the object.	1
delete is to	1
delete to allocate	1
delete or with	1
delete or malloc	1
delete it and	1
delete (or malloc	1
Likewise, the compiler	1
Likewise, a pointer	1
Likewise, it is	1
Likewise, if the	1
Likewise, you cannot	1
Likewise, when a	1
Likewise, all non-static	1
follows: // Example	1
follows: struct Sfloat	1
follows: Instruction set	2
follows: Type of	1
follows: Matrix size	1
follows: floatvalue (	1
simultaneously. This is	1
simultaneously. This processor	1
simultaneously. If the	2
simultaneously. In multithreaded	1
simultaneously. Each thread	1
simultaneously. Actually, only	1
itself is a	2
itself and take	1
itself and recompile	1
itself in order	1
itself when running.	1
itself is. The	1
solution. The compiler	1
solution. It might	1
solution. Many containers	1
solution. (In my	1
solution. Is a	1
solution. Is searching	1
solution. Sort the	1
algebra and statistics,	1
algebra in a	1
algebra are the	1
algebra reductions: x--	1
algebra reductions: a+b	1
algebra reductions: a+b=b+a	1
algebra reductions: !(!a)=a	1
suitable for example	1
suitable functions in	1
suitable set of	1
suitable choice of	1
suitable containers class	1
suitable pivot element.	1
suitable duration. The	1
Template for pow(x,N)	1
Template Library (STL)	1
Template Library (WTL).	1
Template Library (WTL):	1
Template Library (ATL)	1
Template meta- programming	1
Template Library) and	1
spend a lot	1
spend on redesigning	1
spend time on	1
spend time doing	1
spend more CPU	1
spend most of	2
switches is smaller	1
switches and garbage	1
switches are more	1
switches can reduce	1
switches by making	1
switches A context	1
switches after each	1
disk. A big	1
disk. A few	1
disk. Memory swapping	1
disk. Software that	1
disk. Test with	1
disk. Provoke cache	1
disk. Memory-hungry applications	1
serious when n	1
serious problem with	1
serious errors can	1
serious legal issue.	1
serious legal issue,	1
serious limitations to	1
serious burden is	1
c); // Store	2
c); // Compare	2
c); ... return	2
c); a.store(aa+i); }	1
Studio can build	1
Studio This is	1
Studio when compiling	1
Studio IDE. Has	1
Studio optimizes reasonably	1
Studio 2008 version).	1
Studio 2005). Borland	1
a[100]; for (i	1
a[100]; // 400	1
a[100]; int i;	2
a[100]; int i,	1
a[100]; float sum	1
a[100]; float s0	1
trick is to	1
trick of using	2
trick that N1	1
trick will fail	1
trick which is	1
trick violates the	1
disadvantages of using	1
disadvantages of dynamic	1
disadvantages that make	1
disadvantages when C++	1
disadvantages when deciding	1
disadvantages mentioned above	1
disadvantages compared to	1
eax, 8 edx,	1
eax, 1 eax,	1
eax, 100 /	1
eax, 100 $B1$2	1
eax, eax edx,	1
eax, ecx and	1
eax, edx, ecx,	1
distributed to the	2
distributed and stored	1
distributed as it	1
distributed as object	1
distributed as binary	1
distributed between multiple	1
generally not thread	1
generally used that	1
generally possible on	1
generally very fast.	1
generally faster and	1
generally assume that	2
mode, the parameters	1
mode, and an	1
mode, and more	1
mode, for reasons	1
mode, as explained	1
mode, where it	1
mode, we encounter	1
Linux. The compiler	1
Linux. It can	1
Linux. 32-bit Mac	1
Linux. Has many	1
Linux. 82 Keywords	1
Linux. Asmlib My	1
Linux. Address calculation	1
C1 or C2,	1
C1 { public:	1
C1 : public	2
C1 x; ...	1
C1 obj1; C0	1
C1 Object1; C2	1
instances of the	2
instances of S1	1
instances of structures	1
instances that take	1
instances will be	1
instances makes the	1
called, a dispatch	1
called, or what	1
called, it is	1
called, it can	1
called, it allocates	1
called, even if	1
called, while the	1
update the program	1
update or even	1
update when the	1
update automatically when	1
update mechanism to	1
update process should	1
update process. 3.5	1
<= n <	1
<= n; i++)	1
<= n; x++)	1
<= (unsigned int)(max	1
<= 16; n++)	1
<= u.f <	1
<= max) {	1
integer. The compiler	1
integer. The conversion	1
integer. If a	1
integer. If two	1
integer. But the	1
integer. Floating point	1
integer. 158 Integer	1
body is very	1
body is defined	1
body of the	1
body of a	1
body inside the	1
body now contains	1
body begins at	1
definition code in	1
definition language is	2
definition language in	1
definition language defines	1
definition language. Such	1
definition language, such	1
Java and C#	1
Java are based	1
Java virtual machine	1
Java virtual machine.	1
Java machines use	1
Java implementations. However,	1
Java today. But	1
Math core library	1
Math Library __vrs4_expf	1
Math Kernel Library	1
Math Kernel Library"	2
Math Kernel Library,	1
Math Kernel Library.	1
generates the following	2
generates is to	1
generates to see	1
generates no extra	1
generates too little	1
generates 127. The	1
executing the same	1
executing the critical	1
executing a critical	1
executing library functions.	1
executing instructions are	1
executing instructions out	1
executing instructions during	1
Open files and	1
Open source library.	1
Open database connections.	1
Open BSD are	1
Open Watcom Another	1
Open Watcom C/C++	1
Open source. Supports	1
256; // Array	1
256; i +=	5
256; i++) {	1
optimizations. The keyword	1
optimizations. The results	1
optimizations. In most	1
optimizations. See page	1
optimizations. Most C++	1
optimizations. Do not	1
optimizations. Loops with	1
Cache control instructions.	1
Cache contentions in	2
Cache contentions expected.	1
Cache misses are	1
Cache organization It	1
Cache organization ...................................................................................................	1
slower or require	1
slower than the	1
slower than a	2
slower than static	1
slower than intended	1
slower than truncation	1
free the memory	2
free and open	1
free in the	1
free register left	1
free are: There	1
free E-book Usability	1
consuming because it	2
consuming library functions	1
consuming calculations into	1
consuming parts only.	1
consuming updates may	1
consuming features of	1
hold the value	1
hold the numbers	1
hold only one	1
hold many renamed	1
hold 8 double's	1
hold four double	1
hold e.g. four	1
memory, as in	1
memory, at least	1
memory, but not	1
memory, using new.	1
memory, such as	1
memory, depending on	1
memory, windows, mutexes,	1
p. 43). There	1
p. 87). There	1
p. 104). The	1
p. 22). 159	1
p. 28) The	1
p. 26). Variables	1
p. 57). It	1
SIZE; r++) {	4
SIZE; c++) {	2
SIZE; r1 +=	1
case. The best	1
case. The -fpie	1
case. A binary	1
case. You cannot	1
case. Loop unrolling	1
case. Intrinsic functions	1
case. Inlined functions	1
( short int	3
( ; i	1
( 1)sign 2exponent	3
expensive and more	1
expensive in some	1
expensive that it	1
expensive if they	1
expensive - in	1
expensive than an	1
expensive cache contentions,	1
rounding and truncation.	2
rounding mode has	1
rounding unless the	1
rounding instead of	2
rounding 137 errors	1
130 for an	1
130 for how	2
130 for details).	1
130 14 Specific	1
130 14.4 511	1
130 Compile for	1
far from the	1
far from each	1
far from optimal.	1
far data segment	1
far pointers, and	1
far procedures are	1
far (arrays can	1
They can be	2
They can detect	1
They may be	1
They have not	1
They have worked	1
They sometimes give	1
exceptions is to	1
exceptions a function	1
exceptions in this	1
exceptions are indeed	1
exceptions can be	1
exceptions throw() throw()	1
exceptions thrown by	1
system, the more	1
system, and therefore	1
system, and 512	1
system, as explained	1
system, not by	1
system, this requires	1
system, but you	1
absolute value of	2
absolute value by	1
absolute addresses that	1
absolute references in	1
absolute addresses. This	1
absolute values: //	1
(a + b)	1
(a * c	1
(a > b	2
(a >= b)	1
(a == 0)	1
(a != 0)	1
machine are frameworks	1
machine code is	1
machine code to	1
machine code and	1
machine code becomes	1
machine instructions executed,	1
machine instructions. Intrinsic	1
Induction = r;	1
Induction variables for	3
Induction variables are	1
Induction variables An	1
Induction ; edx	1
120 for how	1
120 for discussion	1
120 However, there	1
120 13 Making	1
120 ms by	1
120 12.10 Conclusion	1
120 12.9 Aligning	1
hardly any performance	1
hardly any speed	1
hardly any effect	1
hardly any loss	1
hardly relevant to	1
hardly worth the	1
hardly ever used,	1
CPUID is artificially	1
CPUID instruction doesn't	1
CPUID instruction was	1
CPUID instruction directly,	1
CPUID information that	1
CPUID information about	1
CPUID was manipulated	1
saved in the	1
saved in a	1
saved in registers,	1
saved from one	1
saved all information	1
saved variable members	1
saved either in	1
changes the function	2
changes of the	1
changes in the	1
changes for each	1
changes then you	1
changes fastest: //	1
integers, and they	1
integers, as long	1
integers, then the	1
integers, which is	1
integers, but they	1
integers, while the	1
integers, depending on	1
collection of a	1
collection of example	1
collection can occur	1
collection may start	1
collection when the	1
collection takes a	1
collection contains well-tested	1
manuals is copyrighted	1
manuals are for	1
manuals are used	1
manuals are always	1
manuals can be	1
manuals by Agner	1
manuals from Intel:	1
processor. The CPU	1
processor. This is	1
processor. However, this	1
processor. Such a	1
processor. Extra time	1
processor. Nested loops	2
Shared objects in	6
Shared objects are	1
storing the elements	1
storing function return	1
storing data without	1
storing user data.	1
storing intermediate results	1
storing strings in	1
storing text or	1
developers may therefore	1
developers should be	1
developers should take	1
developers typically have	1
developers choose other	1
developers who want	1
developers feel that	1
parm2) { //	1
parm2) {...} //	6
T is a	1
T to T+5,	1
T // Constructor	1
T const &	1
T & operator[]	1
T max(T const	1
T a[N]; public:	1
eliminate this jump	1
eliminate one division	1
eliminate i and	1
eliminate common subexpressions	1
eliminate common sub-expressions.	1
eliminate everything that	1
eliminate branches, as	1
2: // Example	1
2: template <bool	1
2: 12 $B1$1:	1
2: "Optimizing subroutines	3
2: printf("Gamma"); break;	1
composite objects to	1
composite objects are	1
composite type is	2
composite type can	1
composite type such	1
composite object, you	1
profilers are not	1
profilers are often	1
profilers are useful	1
profilers such as	1
profilers available which	1
profilers require that	1
profilers are: Coarse	1
highly system dependent	1
highly optimized for	2
highly optimized code	1
highly optimized program	1
highly compatible with	1
highly optimized, using	1
again and again	1
again and again.	1
again for every	1
again from address	1
again two times	1
again takes extra	1
again before the	1
127 int CriticalFunction_AVX(int	1
127 will generate	1
127 bytes is	1
127 1 fraction	1
127 127 126	1
127 126 12.2	1
127 int8_t short	1
language. It is	1
language. C++ takes	1
language. In fact,	1
language. See page	1
language. Such a	1
language. Here are	1
language. D has	1
aware of when	1
aware of possible	1
aware of these	1
aware of situations	1
aware that there	2
aware of. Big	1
Alternatively, you can	1
Alternatively, you may	4
Alternatively, use a	1
Alternatively, make a	1
capabilities of modern	1
capabilities for 32-bit	1
capabilities are very	1
capabilities can overlap	1
capabilities (see page	1
capabilities still have	1
capabilities (except in	1
4) { //	3
4) { s0	1
4) + a.	1
4) | ((C	1
4) | (C	1
linker to a	1
linker to remove	1
linker and the	1
linker and loader	1
linker will generate	1
linker makes an	1
linker extracts the	1
int64_t 2 AVX2	1
int64_t 4 AVX2	1
int64_t 64 I64vec1	1
int64_t 128 I64vec2	1
int64_t 256 uint64_t	1
int64_t MS compiler:	1
int64_t 29 64-bit	1
bits. The vector	1
bits. The unsigned	1
bits. The method	1
bits. This is	2
bits. This makes	1
bits. There is	1
measurements to avoid	1
measurements to see	1
measurements are unstable	1
measurements can become	1
measurements on this	1
measurements as accurate	1
measurements may require	1
representation is particularly	1
representation of the	1
representation of float,	1
representation of &list[100]	1
representation of N:	1
representation directly with	1
representation according to	1
SomeFunction (int a,	5
SomeFunction (int x)	1
SomeFunction (int n)	1
size, not as	1
size, because these	1
size, which is	1
size, bits minimum	1
size, while high-level	1
size, bytes alignment,	1
size, etc. There	1
is. The 64-bit	1
is. The type	1
is. // Example	1
is. This above	1
is. It is	1
is. ecx contains	1
is. Factors that	1
reductions: Common subexpression	1
reductions: x-- x	1
reductions: a+b =	1
reductions: a+b=b+a a*b=b*a	1
reductions: !(!a)=a x-xxxxxxx	1
reductions: a+b=b+a, a*b=b*a	1
reductions: ~(~a) =	1
waiting for each	1
waiting for user	2
waiting for better	1
waiting for response	1
waiting for disk	1
waiting for response.	1
available, one from	1
available, such as	1
available, we may	1
available, 256 bits	1
available, though less	1
available, e.g. AVX,	1
available, i.e. in	1
automatically. The code	1
automatically. The development	1
automatically. The alignment	1
automatically. It is	1
automatically. There is	1
automatically. For example,	1
automatically. However, there	1
powers of 2	5
powers of 2.	1
powers of 2:	1
debug and maintain.	1
debug version of	2
debug version and	1
debug version with	1
debug information in	1
debug breakpoints at	1
polymorphism is needed	1
polymorphism that is	1
polymorphism or with	1
polymorphism with virtual	1
polymorphism with templates	1
polymorphism A template	1
polymorphism effect with	1
Clang and Intel	2
Clang The Clang	1
Clang compiler is	1
Clang compiler combined	1
Clang compilers. The	1
Clang Supported operating	1
measured in this	1
measured with millisecond	1
measured on a	1
measured time is	1
measured simply by	1
measured results were	1
measured separately. The	1
details. The behavior	1
details. The funny	1
details. // Example	1
details. Use function	1
details. Note that	1
details. Development time	1
details. Inheritance from	1
factor is a	1
factor of 1,	1
factor to multiply	1
factor in itself,	1
factor 4 in	1
factor rather than	1
factor sizeof(S1) =	1
x); // x^1,	1
x); } //	1
x); } void	1
x); } 112	1
x); const int	1
x); s =	1
x); 136 ...	1
core. It is	2
core. There are	1
core. For example,	1
core. Unfortunately, contemporary	1
core. Two threads	1
core. Try to	1
rules of algebra	2
rules of algebra,	1
rules for prediction	1
rules about register	1
rules apply to	1
rules apply as	1
speed. This includes	1
speed. A simple	1
speed. In the	1
speed. In this	1
speed. Assume that	1
speed. Optimizing for	1
speed. Delays or	1
vectorization. The compiler	1
vectorization. The Gnu	1
vectorization. The newest	1
vectorization. It is	1
vectorization. 3. Use	1
vectorization. Optimizes reasonably	1
vectorization. Optimizes moderately	1
anyway. The exception	1
anyway. It may	1
anyway. If we	1
anyway. You may	1
anyway. Software distributors	1
anyway. Pure function.	1
anyway. Updates to	1
smallest data size	1
smallest integer size	3
smallest list of	1
smallest members last:	1
smallest devices, you	1
responsibility of the	7
Mathematical vector function	1
Mathematical functions The	1
Mathematical functions for	2
Mathematical functions must	1
Mathematical functions .......................................................................................	1
Mathematical functions Encryption,	1
MMX to 128-bit	1
MMX int 32	1
MMX long long	1
MMX short int	1
MMX char 8	1
MMX registers, which	1
MMX mmintrin.h SSE	1
reliable and reproducible	1
reliable than third	1
reliable source so	1
reliable results for	1
reliable solution. (In	1
reliable results. If	1
reliable decision. 13.4	1
Borland and Digital	1
Borland compiler with	1
Borland C++ builder.	1
Borland C++ 5.82	1
Borland / CodeGear	1
Borland Microsoft Constant	1
Borland bcc, v.	1
sense to dispatch	1
sense that the	2
sense that all	1
sense that each	2
sense that C++	1
latest instruction set	2
latest compilers from	1
latest version of	3
latest versions of	1
Now the code	1
Now the two	1
Now it is	1
Now call the	1
Now ebx contains	1
Now s0, s1,	1
Now 1.0 <=	1
units and hence	1
units in the	1
units are used	1
units can be	1
units same size	1
units rather than	1
units smaller than	1
do. The following	1
do. The reason	1
do. This is	1
do. This results	1
do. It is	1
do. All the	1
do. Hence, it	1
reciprocal of the	2
reciprocal in the	1
reciprocal n.a. -	1
reciprocal Boolean algebra	1
reciprocal square root,	1
reciprocal factorials so	1
d, __m128i const	4
d, y; y	2
d, e, f,	1
threads. The compiler	1
threads. The use	1
threads. The overhead	1
threads. There are	1
threads. Each thread	1
threads. Don't put	1
threads. Out-of-order execution	1
log is a	1
log are pure	1
log on with	1
log on process	2
log off the	1
log (b[i] *	1
thousand cache misses	1
thousand so the	1
thousand times then	1
thousand times lower;	1
thousand numbers as	1
thousand results in	1
thousand numbers. With	1
compile-time if statements	1
compile-time constant n,	1
compile-time while loops,	1
compile-time whether the	1
compile-time generation of	1
compile-time polymorphism. It	1
compile-time polymorphism, which	1
remove the const	1
remove the interrupt	1
remove the memset	1
remove or modify	1
remove all disturbing	1
remove any objects	1
remove unreferenced functions.	1
Intel's CPU dispatcher.	2
Intel's compilers and	1
Intel's profiler is	1
Intel's Math Kernel	2
Intel's term for	1
16. This is	1
16. This method	1
16. If you	1
16. In example	1
16. You can	1
16. Library versions	1
16. Alignment of	1
registers, and possibly	1
registers, not in	1
registers, not on	1
registers, which are	1
registers, regardless of	1
registers, whereas 64-bit	1
registers, totaling up	1
transpose the matrix	1
transpose a matrix	2
transpose and copy	2
transpose function swapd(a[r][c],	1
transpose matrix //	1
wait for the	2
wait for a	1
wait for another	1
wait until the	1
wait until a	1
wait until seconds	1
number. The only	1
number. If the	1
number. If a	1
number. I have	1
number. Therefore, it	1
number. We can	1
number. Failure to	1
break a few	1
break a dependency	1
break will occur	1
break at the	1
break while the	1
break down dependency	1
constant. The compilers	1
constant. // General	1
constant. It is	1
constant. If the	1
constant. Example: //	1
constant. 14.2 Bounds	1
linkage table (PLT)	3
linkage table (PLT).	2
linkage table. If	1
possible, and the	1
possible, and make	1
possible, and avoid	1
possible, and replaced	1
possible, or the	1
possible, so that	1
scan instruction is	1
scan instruction and	2
scan instructions. My	1
scan instruction. Programmers	1
scan forward) instruction	1
systems: The number	1
systems: int 16	1
systems: long int	1
systems: unsigned int	1
systems: unsigned long	1
systems: Pointers, references,	1
predictable the branch	1
predictable than the	1
predictable than integer	1
predictable then replace	1
predictable branch by	1
predictable operand first.	1
"Hello 2" The	1
"Hello 2" Here	1
"Hello "; //	1
"Hello "; Disp();	1
"Hello 1" //	2
equal to the	5
equal amount of	1
CodeGear compiler cannot	1
CodeGear / Embarcadero	1
CodeGear Microsoft Table	1
CodeGear Borland bcc,	1
CodeGear compiler). Fastcall	1
CodeGear compiler) integer	1
compact and efficient	1
compact and takes	1
compact if the	1
compact by joining	1
compact than an	1
compact so that	1
polynomial of the	1
polynomial The calculation	1
polynomial can be	1
polynomial // Polynomial	1
polynomial with induction	1
polynomial (Vec4f const	1
Common subexpression elimination	2
Common subexpression elimin.,	2
Common devices are	1
Common Language Runtime,	1
reads to the	1
reads and writes	1
reads or writes	2
reads from address	1
reads from addresses	1
plus the costs	1
plus a constant	1
plus an index	1
plus 6 integer,	1
plus one, because	1
plus i*sizeof(S1). This	1
5: calling conventions.	1
5: "Calling conventions	5
increase the time	1
increase the size	1
increase the speed	1
increase the throughput	1
increase the likelihood	1
increase in develop-	1
casting of pointers	2
casting // C++	1
casting // Constructor-style	1
casting operator that	1
casting operator These	1
course, and causes	1
course, that you	1
course, if the	1
course, this works	1
course, because you	1
course, but this	1
scope of the	1
scope of a	1
scope of this	3
scope or namespaces.	1
principle is useful	1
principle of table	1
principle of lazy	1
principle for a	1
principle for objects	1
principle as in	1
throughput of the	1
throughput of an	1
throughput of CPU-intensive	1
throughput There is	1
throughput (see p.	1
throughput ....................................................................................... 22	1
spent in the	2
spent on function	1
spent on reading	1
spent on executing	1
spent fighting with	1
16; a =	2
16; // This	2
16; int i;	1
16; n++) {	1
Func is executed.	2
Func with a	1
Func 87 used	1
Func () {	1
Func ;a ;r	1
identify the critical	1
identify the circumstances	1
identify a hot	1
identify and isolate	1
identify performance bottlenecks	1
identify individual functions	1
15 on the	1
15 clock cycles	1
15 Integer overflow	1
15 byte at	1
15 Metaprogramming Metaprogramming	1
15 Metaprogramming .......................................................................................................	1
14 - 45	1
14 3 Finding	1
14 2.8 Overcoming	1
14 Specific optimization	2
14 Portability C++	1
this. The Intel	1
this. It also	1
this. See page	1
this. Unfortunately, the	1
this. My example	1
this. (In Windows,	1
Register variables The	1
Register allocation and	1
Register storage A	1
Register ebx is	1
Register variables, integer	1
Register variables, float	1
complex and often	1
complex if the	1
complex integer expressions.	1
complex cases it	1
complex framework requiring	1
complex digital operation	1
Intrinsic function name	1
Intrinsic function Size	1
Intrinsic functions for	1
Intrinsic functions are	2
Intrinsic functions look	1
call. The function	1
call. A branch	1
call. I have	1
call. Load library	1
call. Algebraic reduction	1
call. (2) find	1
notice is that	2
notice that the	1
notice that some	1
notice This series	1
notice .......................................................................................................... 164	1
Add the keyword	1
Add to this	2
Add to 122	1
Add 2 to	2
prediction. The time	1
prediction. A loop	1
prediction. A Pentium	1
prediction. If one	1
prediction. Example: //	1
prediction. Modern microprocessors	1
expected to be	2
expected to replace	1
expected for further	1
expected that the	1
expected real-time speed.	1
declare the function	1
declare the table	1
declare it locally	1
declare an int,	1
declare all functions	1
declare objects and	1
application. The integer	1
application. The development	1
application. The availability	1
application. If hyperthreading	1
application. In example	1
application. You may	1
here. The compiler	1
here. The address	1
here. It may	1
here. It reveals	1
here. You cannot	1
here. Any code	1
largest vector register	1
largest available register	1
largest element in	2
largest element (approximately):	1
largest vector. These	1
dispatched function is	1
dispatched function then	1
dispatched function call	1
dispatched function calls	1
dispatched version return	2
members. The code	1
members. This alignment	1
members. A simple	1
members. It is	1
members. If the	1
members. But each	1
fits the microprocessor	1
fits the application.	1
fits into a	2
fits best into	2
x-xxxx--x x-xxxx--x x-xx-----	1
x-xxxx--x x-xx----- x--x-----	1
x-xxxx--x Profile-guided optimization	1
x-xxxx--x ~a&~b=~(a|b) --xxxx---	1
x-xxxx--x (a|b)&(a|c) =	1
x-xxxx--x Constantfolding xxxxxxxxx	1
giving the function	1
giving it some	1
giving this example	1
giving each constant	1
giving access to	1
giving specific optimization	1
comparisons are more	1
comparisons are slow	1
comparisons are inefficient	1
comparisons by one	1
comparisons more efficient.	1
comparisons i <	1
Performance and usability	2
Performance for further	1
Performance Primitives (IPP).	1
Performance Primitives" library	1
Performance Primitives". These	1
above, the maximum	1
above, it is	1
above, but read	1
above, page 87)	1
above, so that	1
above, p. 26).	1
above. The generality	1
above. A shared	1
above. An object	1
above. Now the	1
above. Examples are	1
above. 7. If	1
Pointer type conversion	1
Pointer aliasing When	1
Pointer arithmetic A	1
Pointer arithmetic operations	1
Pointer elimination A	1
Pointer elimination Common	1
detect the misprediction	1
detect that the	1
detect if any	1
detect an error	1
detect which instruction	1
detect opportunities for	1
normal on some	1
normal return route.	1
normal unsigned int	1
normal writes or	1
normal array. The	1
normal afterwards. The	1
Several function libraries	1
Several other programming	1
Several modern programming	1
Several special purpose	1
Several graphical interface	1
Several internet forums	1
convenient to have	1
convenient to make	1
convenient to calculate	1
convenient to rely	1
convenient for adding	1
convenient way of	1
show the values	1
show a discrete	1
show a disassembly,	1
show that it	1
show how tortuous	1
show various ways	1
column to the	1
column < NUMCOLUMNS;	1
column 28 because	1
column 28 above	1
column 29 with	1
column 28, the	1
{...} // SSE2	2
{...} // AVX	2
{...} // Dispatcher.	1
{...} // Prototype	1
Test the whole	1
Test and maintenance	2
Test if the	1
Test with different	1
Test Processor memcpy	1
c1 for all	1
c1 { const	1
c1 other than	1
c1 < r1;	1
c1 before MemberPointer	1
c1 += TILESIZE)	1
x- x x	3
x- x -----	1
x- x (x)	1
x- x- x	1
Number of elements	2
Number of times	1
Number of simultaneous	1
Number 18 will	1
Number 17 will	1
portability is important.	1
portability to 64-bit	1
portability and development	1
portability and ease	1
portability could be	1
portability issue to	1
SSE3 instruction set	1
SSE3 required //	1
SSE3 instr. set	1
SSE3 tmmintrin.h SSE4.1	1
SSE3 pmmintrin.h Suppl.	1
SSE3 horizontal add,	1
evaluate the loop	1
evaluate a only	1
evaluate and are	1
evaluate b when	1
evaluate whether it	1
evaluate both operands.	1
embedded systems .............................................................................	1
embedded systems Microcontrollers	1
embedded systems. A	1
embedded systems. Today	1
embedded applications have	1
embedded microcontrollers. I	1
Agner vector classes	1
Agner 8 8	1
Agner Available from	1
Agner Fog. Technical	1
Agner Fog. Public	1
Agner Fog The	1
availability of an	1
availability of x	1
availability of these	1
availability of good	1
availability of various	1
availability of powerful	1
13.1 can be	1
13.1 // CPU	1
13.1 CPU dispatch	2
13.1 page 127.	1
13.1 below. 126	1
reference, the compiler	1
reference, a const	1
reference, or the	1
reference, or void.	1
reference, 64-bit mode	1
reference, 32-bit mode	1
.NET and the	1
.NET framework and	1
.NET framework are	1
.NET framework as	1
.NET framework should	1
.NET framework. Obviously,	1
!= 0; 35	1
!= 0) {	3
!= 0) *(p++)	1
!= INVALID_HANDLE_VALUE &&	1
files, data base	1
files, preferably in	1
files, resource files,	1
files, help files	2
files, configuration files,	1
Pointers to contained	1
Pointers and references	3
Pointers can be	1
Pointers versus references	1
half the size	1
half the single-thread	1
half a square.	1
half of it,	1
half speed or	1
half speed because	1
converting the data	1
converting a to	2
converting a pointer	1
converting to floating	1
converting to double	1
occurs in the	1
occurs in each	1
occurs more than	1
occurs because the	1
occurs during execution	1
occurs somewhere in	1
Set function pointer	1
Set pointer to	2
Set sign bit	1
Set flush-to-zero and	1
Set flush-to-zero mode	1
costly to many	1
costly and which	1
costly if XMM	1
costly when it	1
costly because all	1
costly because they	1
newest CPU of	1
newest CPU model,	1
newest instruction set	1
newest instruction sets	1
newest instruction set.	1
newest processors. Supports	1
specifying the type	1
specifying the size.	1
specifying that two	1
specifying that pointers	1
specifying parallel processing	1
specifying otherwise. In	1
follows the mathematical	1
follows a simple	3
follows in 64-bit	1
follows (using Intel	1
comparing the loop	1
comparing it to	1
comparing i with	1
comparing bits 32-62.	1
comparing signed with	1
comparing them as	1
efficient, and sometimes	1
efficient, and that's	1
efficient, but the	1
efficient, but not	1
efficient, but risky.	1
efficient, way of	1
computers to keep	1
computers and my	1
computers with more	1
computers have memory	1
computers have very	1
computers have become	1
B and C	1
B = 2.2,	2
B value in	1
B before the	1
B values. The	1
System code has	1
System code should	1
System programming ..........................................................................................	1
System programming Device	1
System database It	1
System database ......................................................................................................	1
five or ten	1
five values have	1
five manuals is	1
five times. Thread-local	1
five manuals. See	1
five manuals: 1.	1
step of the	1
step of interpretation	1
step in the	1
step by step.	1
step where the	1
step rather than	1
poor if data	1
poor because it	1
poor CPU dispatching.	1
poor performance for	1
poor branch prediction.	1
poor documentation and	1
prefetch the data.	1
prefetch more than	1
prefetch data for	1
prefetch data automatically	1
prefetch data explicitly	1
prefetch instruction can	1
9 and 13	1
9 and 64,	1
9 + 3;	1
9 extra overhead	1
9 Optimizing memory	2
deciding which version	1
deciding whether to	3
deciding whether it	2
self-relative addresses is	1
self-relative references in	1
self-relative address. (3)	1
self-relative addressing of	2
self-relative addressing. In	1
(float const x)	1
(float x) {	3
(float a) {	1
(float *)alloca(n *	1
Core and later	1
Core 2 0.12	1
Core 2 0.77	1
Core 2 0.63	1
Core Math Library	1
Core i7 processor	1
debugger is not	1
debugger to identify	1
debugger and press	1
debugger can execute	1
debugger then it	1
debugger cannot set	1
^ b ---xx----	1
^ 1; You	1
^ -1 =	1
^ ~a =	1
^ operator. The	1
^ ~b =	1
regardless of the	2
regardless of precision	1
regardless of whether	2
regardless of scope	1
truncation and make	1
truncation and back	1
truncation when the	1
truncation takes much	1
truncation so the	1
truncation towards zero,	1
base is not	1
base a software	1
base class is	1
base address plus	1
base classes. You	1
base access, etc.	1
result. The conversion	1
result. A compiler	1
result. You can	1
result. Example: //	1
result. An overflow	1
result. An uncaught	1
How compilers optimize	2
How much is	2
How much you	1
How was it	1
chain. A microprocessor	1
chain. If a	1
chain. We want	1
chain. Such dependency	1
chain. 3.16 Execution	1
chain. Nothing in	1
Reading a value	1
Reading or writing	4
Reading again from	1
compilation is finished.	1
compilation of the	1
compilation of an	1
compilation or interpretation	1
compilation may be	1
compilation before it	1
spots and measuring	1
spots in the	2
spots have been	1
spots Before you	1
spots .................................................................................. 16	1
behavior of the	2
behavior of static	1
behavior of signed	1
behavior can be	1
behavior well-defined with	1
happens if the	1
happens when a	1
happens at runtime).	1
happens inside the	1
happens quite often	1
happens rarely. The	1
7 and Windows	1
7 The efficiency	2
7 int d;	1
7 program can	1
7 through 14,	1
87 for a	1
87 used cache	1
87 about memory	1
87 9.3 Functions	1
87 9.1 Caching	1
87 9.2 Cache	1
Type of elements	2
Type conversions The	1
Type size, bytes	1
Type casting of	1
Type conversions.................................................................................................... 40	1
places in the	1
places when the	1
places making the	1
places back in	1
places back. Thus,	1
places back, where	1
unwinding The preceding	1
unwinding that is	1
unwinding information can	1
unwinding mechanism is	1
unwinding mechanism may	1
unwinding .............................................................................. 65	1
static, the logarithm	1
static, as explained	1
static, when applied	4
am not making	1
am not going	1
am using this	1
am using CPU	1
am always happy	1
am giving this	1
leaf function is	2
leaf function by	2
leaf functions and	1
leaf function. Leaf	1
evaluated in the	1
evaluated if a	2
evaluated at all	1
evaluated only when	1
evaluated every time	1
completely because of	1
completely independent divisions.	1
completely rule out	1
completely contained in	1
completely unrolled to	1
completely absent in	1
again. The following	1
again. This may	1
again. If there	2
again. Obviously, it	1
again. Accessing system	1
powerful and may	1
powerful solution is	1
powerful development tools.	1
powerful computers to	1
powerful computers with	1
powerful facilities that	1
form a logical	1
form of a	2
form of error	1
form of templates	1
form than if	1
deallocated in all	1
deallocated in random	2
deallocated when the	2
deallocated when returning	1
times. This is	1
times. This can	1
times. A queue	1
times. It is	1
times. Then again	1
times. Thread-local storage	1
32- and 64-bit	3
32- bit version	1
32- bit x86	1
32- bit mode,	1
edx can be	1
edx = point	1
edx = r	1
edx as a	1
edx but the	1
edx contains the	1
rule of standard	2
rule out the	3
rule out aliasing	1
one. The compiler	1
one. The existing	1
one. This prevents	1
one. It may	1
one. You can	1
one. I have	1
permissible to assume	1
permissible in all	1
permissible for reasons	2
permissible if the	1
permissible when it	1
worst possible case	1
worst possible performance.	1
worst case is	1
worst case situation	2
worst problem of	1
job of the	1
job can be	1
job into multiple	1
job before you.	1
job optimizing a	1
job fast enough.	1
due to the	2
due to general	1
due to poor	1
due to interrupts	1
due to controversies	1
1.0; for (x	1
1.0; int i;	1
1.0; } };	1
1.0; while (n	1
1.0; list[i].b =	1
1.0; temp->b =	1
depend on the	3
depend on x	1
depend on network	1
depend on system-specific	1
biggest time consumers	2
biggest possible vector	1
biggest disadvantage of	1
biggest vectors: for	1
biggest time-consumer in	1
?Func@@YAXQAHAAH@Z is the	1
?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROCNEAR	1
?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z PROC	1
?Func@@YAXQAHAAH@Z ENDP +	1
?Func@@YAXQAHAAH@Z PROCNEAR ;	1
?Func@@YAXQAHAAH@Z PROC NEAR	1
defines a 128	3
defines an algorithm	1
defines hardware circuits	1
defines electrical connections	1
overlap. If c	1
overlap. You can	1
overlap. You should	1
overlap. See page	1
overlap. Compilers do	1
overlap. 27 The	1
processing, and mathematical	1
processing, data compression	1
processing, OpenMP and	2
processing, signal processing,	1
processing, sound processing,	1
SelectAddMul(short int aa[],	6
users and much	1
users in many	1
users with nagging	1
users as well	1
users will prefer	1
users have. The	1
soon be obsolete.	1
soon as the	1
soon as you	1
soon also 512	1
soon get a	1
soon became available	1
six in 32-bit	1
six integer registers	1
six integer parameters	1
six instructions rather	1
six times as	1
six years old	1
Testing the speed	1
Testing for the	1
Testing multiple conditions	2
Testing speed Testing	1
Testing speed.............................................................................................................. 153	1
general, the out-of-order	1
general, it is	1
general, you can	2
general, you have	1
general, there is	1
roll out the	4
roll out a	2
(i.e. the current	1
(i.e. if the	1
(i.e. where the	1
(i.e. variables defined	1
(i.e. 2, 4,	1
(i.e. Microsoft, Intel	1
edx, to ebx.	1
edx, DWORD PTR	2
edx, eax $B2$2	1
edx, ecx, edx,	1
edx, respectively. (In	1
C++, and a	1
C++, and other	1
C++, it is	1
C++, directly compiled	1
C++, Pascal and	1
C++, D, Pascal,	1
i); // result	1
i); // Load	3
i); // Add	2
mixed with x87	1
mixed language 11	1
mixed precision require	1
mixed implementation can	1
mixed types or	1
mixed sizes. For	1
protection means are	1
protection schemes are	3
protection against overflow	1
protection scheme should	1
counter. The test	1
counter. This is	1
counter. A microprocessor	1
counter. Example: //	2
counter. Any expression	1
structure. The extra	1
structure. The situation	1
structure. This is	1
structure. It is	1
structure. For example:	1
structure. Incrementing or	1
4. The if	1
4. The reason	1
4. Instruction tables:	1
4. Even worse,	1
4. So the	1
4. Align arrays	1
security reason for	1
security reasons before	1
security problem. The	1
security software. Background	1
security advices in	1
security matters. Problems	1
branches. The following	1
branches. The algorithms	1
branches. A simple	1
branches. If you	1
branches. They can	1
branches. Manual 3:	1
Is16vec8 a =	1
Is16vec8 b =	1
Is16vec8 c =	1
Is16vec8 Vec8s 16	1
Is16vec8 two(2,2,2,2,2,2,2,2); //	1
Is16vec8 zero(0,0,0,0,0,0,0,0); //	1
cores. A process	1
cores. You may	2
cores. Each thread	1
cores. 3.15 Dependency	1
cores. 60 The	1
communication and synchronization	2
communication with a	1
communication between different	1
communication between threads	2
avoiding the virtual	1
avoiding the costs	1
avoiding pointer arithmetics	1
avoiding any public	1
avoiding this. The	1
avoiding infinite loop	1
anything it has	1
anything by using	1
anything else on	1
anything else than	1
anything else being	1
anything here because	1
INSTRSET is used	1
INSTRSET == 2	3
INSTRSET == 8	1
INSTRSET == 5	1
Accessing a data	1
Accessing a variable	1
Accessing a member	1
Accessing an object	1
Accessing data from	1
Accessing system devices	1
internal functions in	1
internal variables and	1
internal references. 64-bit	1
internal references. There	1
internal references. Therefore,	1
internal multi-threading, e.g.	1
type-casting with a	1
type-casting i to	1
type-casting without adding	1
type-casting its 'this'	1
type-casting its address:	1
type-casting pointers: The	1
requirements of the	1
requirements of optimizing	1
requirements of compatibility	1
requirements for strict	1
requirements are less	1
requirements are often	1
profiler. The result	1
profiler. This does	1
profiler. A simple	1
profiler. It is	1
profiler. For Intel	1
__fastcall or __attribute__((fastcall)).	1
__fastcall keyword is	1
__fastcall changes the	1
__fastcall __attribute(( fastcall))	1
__fastcall Noncached write	1
loss of precision	1
loss of precision.	1
loss of precision,	2
loss of efficiency.	1
cleanup of allocated	1
cleanup that may	1
cleanup before terminating	1
cleanup jobs is	1
cleanup jobs to	1
Functions that are	2
Functions Function calls	1
Functions _intel_fast_memcpy and	1
Functions ................................................................................................................ 48	1
handling. It is	1
handling. You have	1
handling. See the	1
handling. 8.6 Optimization	1
handling. Omitting the	1
Fortran is also	1
Fortran and several	1
Fortran are based	1
Fortran where the	1
Fortran code. The	1
increment the loop	1
increment and decrement	1
increment an integer	1
increment operators also	1
increment i++. cmp	1
drivers for 64-bit	1
drivers for Windows.	1
drivers are particularly	1
drivers may need	1
drivers differ a	1
economize the use	2
economize the library	1
economize the resource	1
economize resource use	1
Templates are efficient	1
Templates are instantiated	1
Templates may be	1
Templates A template	1
Templates make the	1
28 because the	1
28 above the	1
28 Dynamic memory	1
28 below the	1
28 share the	1
seven memory allocations	1
seven different compilers.	1
seven different brands	1
seven times faster	1
seven significant digits,	1
turned into a	1
turned up to	1
turned on, the	1
turned on, including	1
turned on. Most	1
inheritance is now	1
inheritance by making	1
inheritance class B1;	2
inheritance where a	1
overcome the dangers	1
overcome the obstacle	1
overcome by defining	1
overcome this limitation).	1
overcome these disadvantages	1
maintain. The time	1
maintain. If the	1
maintain. Most compiler	1
maintain. Any specific	1
maintain. And it	1
fourteen in 64-bit	1
fourteen integer registers	1
fourteen register parameters.	1
fourteen parameters to	2
122 for how	2
122 this the	1
122 13.1 CPU	1
122 13.2 Model-specific	1
consuming. A collection	1
consuming. There is	1
consuming. Therefore, the	1
consuming. Therefore, you	1
consuming. Sometimes it	1
method. // This	1
method. A longer	1
method. When the	1
method. 7.29 Threads	1
method. Your measurement	1
backwards and much	1
backwards compatible with	1
backwards compatible instruction	1
backwards compatibility with	1
backwards though the	1
remote or removable	1
remote data locally.	1
remote help files,	1
remote databases usually	1
remote database, and	1
int, without specifying	1
int, signed or	2
int, float, double,	1
int, float. Similar	1
bc for each	1
bc = _mm_mullo_epi16	2
bc = _mm_andnot_si128(mask,	1
bc with the	1
tools. The simplest	1
tools. A popular	1
tools. It should	1
tools. Automatic updates.	1
tools. One popular	1
operation. A good	1
operation. For example,	1
operation. For example,a	1
operation. Example: //	1
operation. x*8 is	1
future. If a	1
future. 6 The	1
future. Typically, the	1
future. To use	1
future. 12.3 Automatic	1
swapping the order	1
swapping is a	1
swapping of memory	1
swapping and other	1
swapping column 29	1
AVX512 instruction set	1
AVX512 double 64	1
AVX512 float 32	1
AVX512 long long	1
AVX512 Table 12.1.	1
considerable amount of	1
considerable delay comes	1
considerable improvement in	1
considerable job, but	1
considerable debate about	1
memset is deprecated.	1
memset and memcpy	1
memset and memcpy,	1
memset and memcpy:	1
memset line if	1
rest of the	5
on, the compilers	1
on, then it	2
on, while it	1
on, including relaxed	1
Agner's vector class	4
Agner's vector classes	1
Digital Mars This	1
Digital Mars compiler	1
Digital Mars compilers	1
Digital Mars Compiler	1
Digital Mars PGI	1
third thread can	1
third thing that	1
third generation class	1
third party security	1
third generations classes	1
Roll out loop	5
Critical function to	1
Critical parts of	1
Critical innermost loop:	1
Critical device drivers	1
Critical pieces of	1
"Calling conventions for	5
CISC instruction set	3
CISC instruction sets	1
CISC processors, between	1
22 one or	1
22 4 Performance	1
22 3.14 Context	1
22 3.15 Dependency	1
22 3.16 Execution	1
AND each element	2
AND operator (&)	1
AND operation isolates	1
AND operations: __m128i	1
effort is concentrated	2
effort to make	2
effort on that	1
numbers. The exponent	1
numbers. It can	1
numbers. You may,	1
numbers. Therefore, 64-bit	1
numbers. With a	1
popular and used	1
popular at the	1
popular version of	1
popular user interface	1
popular development tool	1
SIZE = 512;	2
SIZE = 64;	1
SIZE must be	1
SIZE % 128	1
Runtime type identification	3
Runtime polymorphism is	1
Runtime polymorphism with	1
principles of software	1
principles to use.	1
principles in order	1
principles are the	1
principles here: functional	1
context switch is	1
context switches is	1
context switches can	1
context switches by	1
context switches after	1
names. The details	1
names. Use fastcall	1
names. But a	1
names. We can	1
names. Remember to	1
reducing the time	1
reducing the number	1
reducing the performance	1
reducing integer expressions	1
reducing example 15.1d	1
benefit from the	1
benefit from using	1
benefit from register	1
benefit from its	1
benefit from setting	1
worth the effort	2
worth the effort.	2
worth considering is	1
manual. The subsequent	1
manual. This option	1
manual. There are	1
manual. You have	1
manual. 2.3 Choice	1
specifies the calculation	1
specifies that a	1
specifies that all	1
specifies how to	1
specifies truncation so	1
searching and parsing	1
searching for updates	1
searching for vacant	1
searching needed before	1
searching needed after	1
versus unsigned integers	1
versus dynamic libraries	1
versus dynamic libraries............................................................................	1
versus XMM registers.	1
versus references Pointers	1
propagation is not	1
propagation and other	1
propagation and reduce	1
propagation An expression	1
propagation Pointer elimination	1
reduction is a	1
reduction in this	1
reduction would be	1
reduction would cause	1
reduction Most compilers	1
effects of object	2
effects or if	1
effects into account.	1
effects are: Variables	1
1.; } The	1
1.; } else	1
1.; } Here,	1
1.; Eliminate jumps	1
1.; x.b =	1
live range of	1
live ranges do	3
live ranges now	1
multidimensional array is	1
multidimensional array should	2
multidimensional array sequentially.	1
multidimensional structure needed?	1
install a program	1
install a software	1
install a large	1
install this important	1
install automatic updates	1
development, and a	1
development, and that	1
development, each new	1
development, database integration,	1
development, testing and	1
strict when compiling	1
strict floating point	1
strict aliasing rule	2
strict formalism that	1
(c = 0;	4
(c + d);	1
Position-independent code is	2
Position-independent code Shared	1
Position-independent code. All	1
Position-independent code.................................................................................. 148	1
obvious to the	1
obvious to do	1
obvious and the	1
obvious reductions as	1
obvious thing to	1
swapped to the	1
swapped to disk.	1
swapped with element	2
swapped then both	1
21 3.10 Graphics	1
21 3.11 Other	1
21 3.13 Memory	2
21 3.12 Network	1
vectors: for (int	5
OR the results	1
OR operator (|)	1
OR operator (^)	1
OR combination of	1
OR operator, which	1
Array of 100	1
Array with N	1
Array with bounds	1
Array size divisible	1
Array size Alignd	1
processes or threads	1
processes because it	1
processes running on	1
processes simultaneously. Actually,	1
processes running, and	1
portable to systems	1
portable to platforms	1
portable in the	2
portable way of	1
consume a lot	2
consume a significant	1
consume time at	1
consume more time	1
schemes are based	2
schemes are frequent	1
schemes are annoying	1
schemes cause problems	1
80 for an	1
80 into a	1
80 clock cycles	1
80 clock cycles,	1
80 Unfortunately, this	1
Arrays that are	1
Arrays are often	1
Arrays are always	1
Arrays An array	1
Arrays ..................................................................................................................... 38	1
lists the available	1
lists of specific	1
lists and other	1
lists in most	1
lists that are	1
event of an	1
event that it	2
event it is	1
event counts for	1
computer. The Pentium	1
computer. The measured	1
computer. The proxy	1
computer. Big supercomputers	1
computer. Security software	1
Static linking includes	1
Static linking (multithreaded)	1
Static versus dynamic	2
Static cast The	1
becoming more and	1
becoming more popular	1
becoming better and	1
becoming increasingly important.	1
becoming increasingly blurred	1
select the most	1
select the best	1
select all installation	1
select between two	1
select function, and	1
list, the compiler	1
list, on the	1
list, set and	1
list, database, or	1
list, rolled out	1
executed as it	1
executed only once	1
executed faster in	1
executed even though	1
executed 10 times	1
actual clock frequency	1
actual values before	1
actual load address.	1
actual calculations. This	1
actual processor. However,	1
case, the performance	1
case, the calculation	1
case, you may	1
case, but in	1
case, N is	1
over the disadvantages	1
over the C99	1
over other programming	1
over new and	1
over 32 bit	1
realistic set of	2
realistic number of	1
realistic performance test	1
realistic goal is	1
abc is a	1
abc is 12	1
abc can be	1
abc * p;	1
abc {int a;	1
finished. The optimal	1
finished. This method	1
finished. Example: //	1
finished. Obviously, this	1
finished. Register allocation	1
hand, the compiler	1
hand, a just-in-time	1
hand, it is	1
hand, if your	1
hand, does not	1
_WIN64 not _WIN64	1
_WIN64 64 bit	1
_WIN64 _M_X64 _M_X64	1
_WIN64 _LP64 Windows	1
_WIN64 _LP64 _WIN64	1
recover in the	1
recover from a	1
recover from errors.	2
recover from exceptions.	1
console or to	1
console mode program	3
console mode program.	1
advice of making	1
advice in the	1
advice given here	1
advice given above.	1
advice applies to	1
ways. The critical	1
ways. The first	1
ways. This means	1
ways. Example: //	1
ways. Switch statements	1
16.2 The pitfalls	2
16.2 calls the	1
16.2 #include <stdio.h>	1
16.2 above, but	1
pow and log	1
pow The method	1
pow function when	1
pow function uses	1
pow at compile-	1
split the tasks	1
split into two	1
split between several	1
split up the	1
split up into	1
generated by the	4
generated from the	1
created a file	1
created or modified.	2
created it will	1
created by one	1
hundred or even	1
hundred clock cycles	2
hundred times because	1
hundred times. This	1
250 times with	1
250 μs is	1
250 μs on	1
250 ms. This	1
250 ms. If	1
computing power than	1
computing mathematical functions	1
computing resources than	1
computing resources. Typically,	1
computing i/2+r. The	1
pointers, and far	1
pointers, by initializing	1
pointers, etc. And	1
pointers, references, 'this'	1
pointers, e.g.: //	1
limit the range	1
limit to the	2
limit can be	2
90 for a	1
90 for examples	1
90 9.6 Dynamic	1
90 9.7 Container	1
90 Gives a	1
follow the advice	1
follow the guidelines	1
follow the track	1
follow the rows,	1
follow a sequence	1
loop-carried dependency chains	1
loop-carried dependency chain.	3
loop-carried dependency chains,	1
library, you are	1
library, you divide	1
library, but this	1
library, except when	1
library, SSE4.1 gives	1
recommendation is to	1
recommendation of which	1
recommendation for good	1
recommendation about which	1
recommendation was the	1
Objects of a	1
Objects and arrays	1
Objects that are	1
Objects inside containers	1
Objects bigger than	1
compromise on the	1
compromise when portability	1
compromise between development	1
compromise between efficiency,	1
compromise safety is	1
Mars This is	1
Mars compiler is	1
Mars compilers produce	1
Mars Compiler v.	1
Mars PGI PathScale	1
already in the	1
already been allocated.	1
already works is	1
already known then	1
already known at	1
nothing to gain	1
nothing to clean	1
nothing between 8	1
nothing while seconds	1
nothing inside the	1
(a&&b) || (a&&c)	2
(a&&b) || (a&&b&&c)	1
(a&&b) || (!a&&c)	2
physical register to	1
physical processors and	1
physical processors but	1
physical movements of	1
physical factors. The	1
((unsigned int)i <	1
((unsigned int)i >=	1
((unsigned int)n <	2
((unsigned int)(i -	1
xxxxxxxxx Codeplay Watcom	1
xxxxxxxxx x-xxx---- a-(-b)=a+b	1
xxxxxxxxx -- -	1
xxxxxxxxx 0/a=0 ---x---xx	1
xxxxxxxxx xxxxxxx-x xxxxxxxxx	1
constructors and overloaded	1
constructors and destructors	2
constructors and destructors.	1
constructors are called.	1
increased the available	1
increased to 16	1
increased by more	1
increased when the	1
increased from 64-bit	1
programming, compiler technology,	1
programming, but in	1
programming, how to	1
programming, etc. In	1
programming, modularity, reusability	1
factor. A little	1
factor. If a	1
factor. If not,	1
factor. For example,	1
factor. Loop unrolling	1
i.e. in 64-bit	1
i.e. if there	1
i.e. each element	1
i.e. stored at	2
nonzero and normal	1
nonzero } else	1
nonzero floating point	2
nonzero u.i +=	1
unacceptably long response	4
unacceptably long. Lazy	1
process. This can	1
process. A dynamic	1
process. These requirements	1
process. Obviously, we	1
process. 3.5 Program	1
Calculate x to	1
Calculate integer power	1
Calculate integer power,	1
Calculate polynomial The	1
Calculate polynomial with	1
Only the registers	1
Only the executable	1
Only for SSE2	1
Only one of	1
Only available for	1
adds the elements	1
adds an extra	1
adds this to	1
adds 16 to	1
adds extra information	1
() { //	1
() { static	1
() { C1	1
() { CChild1	1
() { __declspec(__align(64))	1
Division of a	1
Division by a	3
Division takes 14	1
pitfalls of CPU	1
pitfalls of unit-testing	2
pitfalls here. You	1
pitfalls here: The	1
package is not	1
package and make	1
package in order	1
package on a	1
package several times	1
equivalent to a	1
equivalent to const	1
equivalent expression b	1
equivalent reductions at	1
equivalent if(!(a ||	1
understand and therefore	1
understand when we	1
understand how variables	1
understand it. I	1
understand compiler-generated assembly	1
Fortunately, the solution	1
Fortunately, it is	1
Fortunately, all compilers	1
Fortunately, most compilers	1
Fortunately, there are	1
command or do	1
command line or	2
command line with	1
command received by	1
a[i]; The above	1
a[i]; // Return	1
a[i]; It is	1
a[i]; s1 +=	1
a[i]; Converting an	1
relatively small gain	1
relatively costly because	1
relatively cheap if	1
relatively primitive programming	1
relatively expensive, while	1
priority. The gain	1
priority. If the	1
priority. In many	1
priority. Other tasks	1
priority. Especially the	1
files. This can	1
files. See page	1
files. Use 64-bit	1
files. 13.2 Model-specific	1
files. 121 13	1
inefficient, of course,	1
inefficient, and it	1
inefficient, especially in	1
inefficient, however, when	1
inefficient, (4) get	1
guidelines are provided	1
guidelines can be	1
guidelines by using	1
guidelines should be	1
guidelines below. You	1
Kernel Library (MKL	1
Kernel Library" and	1
Kernel Library" contains	1
Kernel Library, available	1
Kernel Library. The	1
necessarily stored sequentially	1
necessarily accessed through	1
necessarily done by	1
necessarily stay in	1
necessarily newer. The	1
returns a pointer	1
returns a reference	1
returns // Volatile	1
returns from the	1
returns even though	1
jobs is to	1
jobs to do.	1
jobs and 10	1
jobs simultaneously. Each	1
jobs simultaneously or	1
Data that are	1
Data caching is	1
Data members of	2
Data alignment. __declspec(align(16))	1
frameworks that typically	1
frameworks are used	1
frameworks are available	1
frameworks are frequent	1
frameworks typically used	1
excessive memory swapping	1
excessive loop unrolling	1
excessive number of	3
safer to use	2
safer to do	1
safer to calculate	1
safer implementation would	1
Aligning data Loading	1
Aligning dynamically allocated	2
Aligning RGB video	2
execution. The most	1
execution. This means	1
execution. It is	1
execution. There is	1
execution. Example: //	1
a[size], b[size]; //	3
a[size], b[size], i;	1
a[size], b[size], c[size];	1
latency of the	1
latency of a	1
latency and the	1
latency or by	1
latency which is	1
specify the compiler	1
specify the options	1
specify the alignment	1
specify an option	1
specify static linking	1
for(i=0; i<300; i++){	2
for(i=0; i<300; i+=3){	1
for(i=0; i<100; i++)a[i]=2*i;	1
for(i=0; i<301; i+=3){	1
larger than the	1
larger memory footprint	1
larger vector size.	1
larger floating point	1
larger address space	1
-(-a) to a.	1
-(-a) = a	2
-(-a) = a,	1
-(-a) very often,	1
Multiple calls to	1
Multiple applications running	1
Multiple inheritance class	1
Multiple divisions can	1
Multiple threads? Container	1
unfortunately the unit-test	1
unfortunately it prevents	1
unfortunately this is	1
unfortunately there is	1
unfortunately very common.	1
n! is calculated	1
n! // Table	1
n! = n∙(n-1)!.	1
n! int i,	1
n! 117 A	1
pieces of a	1
pieces of code	2
pieces of data	1
pieces of code.	1
Basic is Visual	1
Basic was too	1
Basic .NET and	1
Basic soon became	1
Basic .NET, which	1
(In the above	1
(In 64-bit mode,	1
(In Windows you	1
(In my tests,	1
(In Windows, SetThreadAffinityMask,	1
microprocessors. The function	1
microprocessors. Integer division	1
microprocessors. Many of	1
microprocessors. 7.13 Loops	1
microprocessors. Multiplication and	1
modules. This may	1
modules. This makes	1
modules. This enables	1
modules. You may	1
modules. 3.12 Network	1
s = (short	1
s = _mm_hadd_ps(x,	1
s = _mm_hadd_ps(s,	1
s += xxn	1
s += x^n/n!	1
project at hand.	1
project together and	1
project goes to	1
project window or	1
project built with	1
divided into multiple	1
divided into many	1
divided into threads	1
divided into small	1
divided into three	1
www.agner.org/optimize/asmlib.zip. The following	1
www.agner.org/optimize/asmlib.zip. The name	1
www.agner.org/optimize/asmlib.zip. // Example	1
www.agner.org/optimize/asmlib.zip. If you	1
www.agner.org/optimize/asmlib.zip. Currently includes	1
Wednesday = 8,	1
Wednesday or Friday	1
Wednesday | Friday)	1
Wednesday | Friday))	1
Wednesday || Day	1
mispredictions. The performance	1
mispredictions. Boolean vector	1
mispredictions. When the	1
mispredictions. Test the	1
mispredictions. 44 In	1
relies on the	1
relies on exception	1
relies on network	1
relies on structured	1
relies on non-	1
And it is	2
And here is	1
And whenever a	1
And who would	1
platforms, and in	1
platforms, it is	1
platforms, different screen	2
platforms, including 32-bit	1
compare the performance	1
compare it to	1
compare with end	1
compare two positive	1
compare absolute values:	1
valid only until	1
valid values or	1
valid address. Pointers	1
valid 63 number	1
valid addresses, or	1
CPU-intensive software is	1
CPU-intensive code. But	1
CPU-intensive programs when	1
CPU-intensive applications with	1
CPU-intensive code, as	1
Is the size	2
Is a multidimensional	1
Is searching needed	2
so. The compilers	1
so. It may	1
so. See page	1
so. These containers	1
so. 58 If	1
seen in the	2
seen in 64	1
seen can reduce	1
seen many examples	1
Typically, the conversion	1
Typically, the full	1
Typically, a specific	1
Typically, there is	1
Typically, there are	1
107 for how	1
107 number of	1
107 12.2 AVX-512	1
107 12.4 Using	1
107 12.3 Automatic	1
contiguous in program	1
contiguous with other	2
contiguous memory block.	1
contiguous memory. See	1
gets the new	1
gets the latest	1
gets from the	1
gets information about	2
manuals. See page	1
manuals. I want	1
manuals. I am	1
manuals. 7.1 Different	1
manuals. Please note	1
tells the compiler	1
tells the CPU	1
tells the address	1
tells the operating	1
tells that a	1
wrap the allocated	2
wrap around on	1
wrap around. Adding	1
wrap around, (3)	1
separately and test	1
separately in software	1
separately if there	1
separately with the	1
separately through multiple	1
__attribute(( aligned(16))) Assume	1
__attribute(( aligned(16))) __declspec(	1
__attribute(( const)) Assume	1
__attribute(( const)) __attribute((	1
__attribute(( fastcall)) __fastcall	1
necessary. A virtual	1
necessary. If F1	1
necessary. 101 Multithreading	1
necessary. Take the	1
necessary. Fast versions	1
increasing the thread	1
increasing function of	1
increasing number of	2
increasing faster than	1
16, 32 and	1
16, last byte	1
16, i.e. stored	2
16, 32, 64,	1
threads, but the	1
threads, but it	1
threads, but that's	1
threads, such as	1
threads, while data	1
Development in C++	1
Development time Some	1
Development process There	1
Development Environments) have	1
Development process...................................................................................................... 25	1
AND'ed with the	1
AND'ed with this	1
AND'ed with all	2
AND'ed b with	1
elimination and loop-invariant	1
elimination x n.a.	1
elimination A pointer	1
elimination If the	1
elimination Common subexpression	1
all. This makes	1
all. This method	1
all. In the	1
all. Fortunately, there	1
all. Can only	1
.......................................................................................... 21 3.12	1
.......................................................................................... 96 9.10	1
.......................................................................................... 126 13.5	1
.......................................................................................... 150 15	1
.......................................................................................... 66 8.1	1
upper 32 bits	2
upper limit to	1
upper limit can	2
addresses. The names	1
addresses. This works	1
addresses. If caching	1
addresses. Therefore, the	1
addresses. Especially the	1
loop-invariant code that	1
loop-invariant code containing	1
loop-invariant code motion	1
loop-invariant code motion.	1
loop-invariant expression that	1
sum1 and sum2	1
sum1 = 0,	1
sum1 from time	1
sum1 += list[i];	1
sum1 += sum2;	1
~a a ^a	1
~a = 0	2
~a = -1	1
~a ^ ~b	1
Compilers and IDE's	1
Compilers for 32-bit	1
Compilers will usually	1
Compilers do not	1
Compilers cannot make	1
); // Function	1
); // Make	1
); #else //	1
); Alignd (	1
); 7.26 Overloaded	1
18 will evict	1
18 software optimization	1
18 3.4 Automatic	1
18 Overview of	2
them. The hardware	1
them. This would	1
them. You should	1
them. Some important	1
them. Pure functions	1
point. The reason	1
point. // After	1
point. This does	1
point. Use 64-bit	1
point. Conversion of	1
consumption of different	1
consumption of each	1
consumption are actually	1
consumption as the	1
consumption was down	1
8. The size	1
8. The number	1
8. There are	1
8. Avoid branches	1
8. 71 The	1
key in the	1
key or moving	1
key values are	1
key press or	1
key press. 19	1
explanation. The value	1
explanation. The following	1
explanation. Note that	1
explanation. (The Microsoft	1
explanation. Please skip	1
itself. You may	1
itself. But a	1
itself. Function addresses	1
itself. Another disadvantage	1
itself. Constructors are	1
updated to a	1
updated every time	1
updated since 2004.	1
updated 2014-08-07. Contents	1
updated lately. Vector	1
appear to take	1
appear in the	3
appear as a	1
Codeplay and Watcom	1
Codeplay compiler has	1
Codeplay Watcom Digital	1
Codeplay VectorC A	1
Codeplay VectorC v.	1
(except in device	1
(except in Fortran	1
(except for the	2
(except for char	1
combined by some	1
combined with the	1
combined size of	2
combined into a	1
definitely the preferred	1
definitely be avoided	2
definitely be avoided.	1
definitely degrades performance	1
jumps between different	1
jumps back to	1
jumps to. Example:	1
jumps Eliminate branches	1
jumps Jumps can	1
elements. The instruction	1
elements. The size	1
elements. A hash	1
elements. Example: //	1
elements. 12.1 AVX	1
.cpp files into	2
.cpp modules that	1
.cpp modules into	1
.cpp file) should	1
features, and you	1
features, and current	1
features, but also	1
features, see http://www.agner.org/optimize/	1
features, including the	1
flag and don't	1
flag in the	1
flag or in	1
flag then the	1
flag (e.g. DEC,	1
8) { //	4
8) SelectAddMul_pointer =	1
ever more powerful	1
ever bigger software	1
ever used, though.	1
ever seen can	1
ever happens. This	1
Writes to a	1
Writes "Hello 2"	2
Writes "Hello 1"	2
13 // 2	1
13 Making critical	2
13 Asmlib Gnu	1
13 objects, respectively	1
b[i] and c[i]	2
b[i] = a[i];	1
b[i] = Func(a[i]);	1
b[i] + 2;	1
doubled. The time	1
doubled. The length	1
doubled. This makes	1
doubled. A thread	1
doubled. Thin clients	1
written in C,	1
written in Java,	1
written as 2eee	1
written table may	1
written back. The	1
languages, it is	1
languages, but also	1
languages, such as	1
languages, operating systems,	1
languages, profiling and	1
malloc is typically	1
malloc and free	1
malloc and free.	2
malloc and free)	1
runs most of	1
runs quite fast	1
runs under the	1
runs alone in	1
runs satisfactorily on	1
true, and all	1
true, if any	1
true, then the	1
true, which is	2
division. The compiler	1
division. Some compilers	1
division. Older CPUs	1
division. 12.4 Using	1
division. Correction for	1
C; } polynomial	1
C; double Z	1
C; Assuming that	1
C; x.abc =	1
C; x.a =	1
0.18 0.18 0.18	1
0.18 0.18 0.11	1
0.18 0.11 memcpy	1
0.18 0.11 1.21	1
0.18 0.12 0.11	1
MS compiler Windows	3
MS compiler: unsigned	1
MS compiler: __int64	1
#endif // SSE2	1
#endif // INSTRSET	1
#endif double Func1(double)	1
#endif return n;}	1
#endif const int	1
present in the	1
present processors rather	1
present manual is	2
present manual. There	1
15.1c is faster	1
15.1c as intended,	1
15.1c would of	1
15.1c was done	1
15.1c automatically, and	1
1000; int i;	1
1000; int List[ArraySize];	1
1000; float a[size],	1
1000; unsigned int	1
1000; i++) {	1
strlen function in	1
strlen function for	1
strlen function. The	1
strlen 128 bytes	2
__asm int 3;	1
__asm fistp dword	1
__asm fld qword	1
__asm ("fldl %1	1
__asm ("int 3");	1
cycle. The operators	1
cycle. The OR	1
cycle. The highest	1
cycle. This means	1
cycle. In 64-bit	1
11 clock cycles	1
11 short int	1
11 programming, etc.	1
11 Out of	2
belong to the	2
belong to one	1
belong to set	1
belong to each	1
50 - 100	1
50 clock cycles	1
50 simple cases,	1
50 7.16 Function	1
50 7.17 Structures	1
facilities of the	1
facilities for making	1
facilities that do	1
facilities are needed,	2
5. The loop	1
5. If columns	1
5. But the	1
5. Calling conventions	1
5. www.amd.com. 163	1
currently not up	1
currently only supported	1
currently used for	1
currently doesn't works	1
currently available, one	1
here: The inequality	1
here: A large	1
here: return *(T*)0;	1
here: a[i] =	1
here: functional decomposition	1
Does not support	1
Does not optimize	2
Does not allocate	1
Does not, by	1
macros is that	1
macros are sometimes	1
macros with short	1
macros instead of	1
macros Compiler identification	1
prefer is a	1
prefer a to	1
prefer to use	1
prefer to run	1
prefer to write	1
divisor is a	2
divisor is not	1
divisor is known	1
divisor that is	1
Program installation The	1
Program installation ..................................................................................................	1
Program loading .......................................................................................................	1
Program loading Often,	1
better. The loop	1
better. If the	1
better. Whenever a	1
better. Remember again,	1
BSD, the slow	1
BSD, but the	1
BSD, Windows and	1
BSD, Intel-based Mac	1
bit-mask: __m128i mask	2
bit-mask: c2 =	1
bit-mask: bc =	1
two. In the	1
two. Some other	1
two. Some compilers	1
two. Often, it	1
up, as explained	1
up, which is	1
up, which happens	1
up, even if	1
up. The two	1
up. This is	1
up. If an	1
up. Some modules	1
reasons. The programmer	1
reasons. This may	1
reasons. C++ is	1
reasons. Use these	1
103 for examples	1
103 // Example	1
103 12 Using	1
103 11 Out	1
Choosing the optimal	4
slices is determined	1
slices of typically	1
slices to 120	1
slices allocated to	1
exception. The costs	1
exception. A frame	1
exception. 64 If	1
exception. Therefore, you	1
enum is simply	1
enum as well	1
enum Weekdays {	2
repeats a thousand	1
repeats 20 times	1
repeats 1000 times	2
highest instruction set	1
highest performance that	1
highest efficiency is	1
highest level of	1
96 void transpose(double	1
96 9.9 Access	1
96 9.11 Explicit	1
96 9.10 Cache	1
recommend that no	1
recommend that every	1
recommend object oriented	1
recommend any specific	1
lead to a	4
additional integer counter.	1
additional floating point	1
additional information about	1
additional parameters. Therefore,	1
51 for the	1
51 performance penalty	1
51 7.19 Class	1
51 7.18 Class	1
56 public: float	1
56 7.27 Overloaded	1
56 7.28 Templates...............................................................................................................57	1
56 7.26 Overloaded	1
type. The example	1
type. Likewise, a	1
type. References are	1
type. Interrupt service	1
place the user	1
place to the	1
place in the	1
place indicated by	1
preferable to make	1
preferable to keep	1
preferable to allocate	1
preferable for speed-critical	1
overlap the call	1
overlap the calculations	1
overlap the iterations	1
overlap or if	1
eight-element vectors: for	4
40 - 80	1
40 i =	1
40 clock cycles.	1
40 7.12 Branches	1
43 for an	1
43 about branch	1
43 7.13 Loops......................................................................................................................	1
43 speculatively executing	1
sixteen in 64-bit	2
sixteen vector registers	1
sixteen integers of	1
turning the frame	1
turning off the	2
turning off all	1
initialization. The compiler	1
initialization. The program	1
initialization. A copy	1
initialization. Each code	1
Graphics and sound	1
Graphics A graphical	1
Graphics accelerators The	1
Graphics ................................................................................................................. 21	1
obstacles to efficient	1
obstacles to optimization	2
obstacles and to	1
asmlib function library	1
asmlib library int	2
asmlib library at	1
Furthermore, it is	1
Furthermore, you may	1
Furthermore, this solution	1
Furthermore, most C++	1
obtain the desired	2
obtain most of	1
obtain much more	1
ebx. The next	1
ebx. The square	1
ebx. 9 Optimizing	1
ebx. Only the	1
estimate is correct	1
estimate of the	1
estimate that the	1
estimate can be	1
enabled in 64-bit	1
enabled there is	1
enabled (there is	1
enabled (single precision	1
enables the compiler	2
enables interprocedural optimizations.	2
Obstacles to optimization	4
r) { int	2
r) { r	1
r) {return r.a	1
regular time intervals.	1
regular access patterns	1
regular patterns with	1
regular pattern, while	1
m is transferred	2
m is replaced	1
m and therefore	1
Metaprogramming can be	1
Metaprogramming means to	1
Metaprogramming Metaprogramming means	1
Metaprogramming ....................................................................................................... 150	1
explain the above	1
explain the difference,	1
explain this with	1
explain how metaprogramming	1
Dispatch on first	1
Dispatch on every	1
Dispatch at load	1
Dispatch at installation	1
well, of course.	1
well, but the	1
well, but it	1
well, others are	1
sufficiently large to	2
sufficiently fast on	1
sufficiently accurate for	1
126 Make pointer	1
126 12.2 128	1
126 13.6 CPU	1
126 13.5 Implementation	1
bad The C/C++	1
bad on a	1
bad CPU dispatching.	1
bad dilemma. You	1
p(double x) {	4
said that the	1
said than done	1
said here about	2
modulo operator %.	1
modulo 16. This	1
modulo calculations: //	1
modulo operations: //	1
databases with lots	1
databases Many software	1
databases usually requires	1
databases ....................................................................................................... 21	1
_EM_OVERFLOW); // if	2
_EM_OVERFLOW); // _controlfp(0,	2
against the costs	1
against this problem:	1
against overflow is	1
against overkill. Don't	1
Vectorized with SSE2	1
Vectorized code is	1
Vectorized code often	1
Vectorized table lookup	1
break; } This	1
break; case 3:	1
break; case 2:	1
break; case 1:	1
loader to a	1
loader will have	1
loader calls the	1
loader (requires binutils	1
Failure to do	3
Failure to handle	1
declared. If the	1
declared. An object	1
declared. Therefore, it	1
declared. Avoid multiple	1
resources, and the	1
resources, such as	1
resources, even if	1
resources, databases, etc.	1
true. The program	1
true. The trick	1
true. Boolean variables	1
true. template<> class	1
objects. The size	1
objects. This is	1
objects. STL vector	1
objects. Storage on	1
parallel. Modern CPUs	1
parallel. Small lightweight	1
parallel. Fine-grained parallelism	1
parallel. Coarse-grained parallelism	1
one, and only	1
one, because it	1
one, into an	1
one, auto_ptr that	1
list[300]; int i;	3
list[300]; int i,	1
r++) { for	3
r++) { //	1
parabola (float x)	3
parabola (2.0f); b	1
x^4 // Define	1
x^4 // x^8	1
x^4 F32vec4 xx4(x4);	1
x^4 F32vec4 s(0.f,	1
mouse inputs when	1
mouse move or	1
mouse input. It	1
mouse move. It	1
specialization is allowed	1
specialization for N	3
index. The data	1
index. The integer	1
index. A good	1
index. Are objects	1
options. CPU vendors	1
options. I don't	1
options. Many optimization	1
options. Supports parallel	1
c++) { //	2
c++) { StoreNTD(&a[c][r],	1
c++) { a[c][r]	1
are. For example,	1
are. However, there	1
are. Dynamic memory	1
are. Declare the	1
needed, and new	1
needed, or they	1
needed, but only	1
needed, however, if	1
declaring the function	1
declaring the table	1
declaring it inside	1
declaring an integer	1
SVML and LIBM	1
SVML + ia32intrin.h	1
SVML v.10.3 &	1
SVML v.10.2 &	1
*.so). The program	1
*.so). The mechanism	1
*.so). The installation	1
*.so). There are	1
(u.i * 2	1
(u.i & 0x7FFFFFFF)	2
(u.i > v.i)	1
support. There is	1
support. Make a	1
support. Then you	1
support. Hardware updating.	1
subtraction and multiplication	3
subtraction (3 -	1
Multiply by constant	1
Multiply b and	2
Multiply (int x,	1
|= 0x80000000; //	2
|= 0x20; If	1
|= 0x20; 46	1
pool. See the	1
pool. See www.agner.org/optimize/cppexamples.zip.	1
pool. 15 Integer	1
pool. Alignment? Some	1
performs best under	1
performs better on	1
performs well. The	1
performs poorly. It	1
"Intel 64 and	1
"Intel Math Kernel	2
"Intel Performance Primitives"	1
Are objects accessed	2
Are objects identified	1
Are objects numbered	1
pre-increment is more	1
pre-increment to post-increment.	1
pre-increment or post-increment.	1
pre-increment operator ++i	1
ownership is transferred	1
ownership of the	3
88 for details.	1
88 9.5 Alignment	1
88 Object oriented	1
88 9.4 Variables	1
0x80000000; // set	1
0x80000000; // Set	1
0x80000000; // flip	1
0x80000000; because this	1
move the object	1
move or key	1
move out loop-invariant	1
move outside the	1
Can the container	1
Can be reduced	1
Can only run	1
Can do automatic	1
defining a container	1
defining integer types	1
defining constants. For	1
defining _mm_malloc and	1
produces a string	1
produces a negative	1
produces a low	1
produces another C++	1
precision, and intermediate	1
precision, as explained	1
precision, but there	1
precision, especially in	1
non-inlined copy is	1
non-inlined copy of	2
non-inlined copy Function	1
drawbacks of the	2
drawbacks of using	1
drawbacks of C++.	1
__declspec(align(16)) or __attribute__((aligned(16))).	1
__declspec(align(16)) static const	1
__declspec(align(16)) struct S1	1
__declspec(align(16)) X #else	1
u.f and v.f	1
u.f < 2.0	1
u.f We can	1
u.f > v.f	1
commercial compiler for	1
commercial compilers due	1
commercial compilers. Mixing	1
commercial license Table	1
configuration files and	1
configuration files (*.ini	1
configuration files, resource	1
configuration files, help	1
134 and 135	1
134 on bounds	1
134 } else	1
134 14.3 Use	1
lines. The critical	1
lines. The 17	1
lines. This makes	1
lines. A few	1
restrictions on using	2
restrictions on alignment	1
restrictions on mixing	1
Constant propagation Pointer	1
Constant folding and	2
Constant folding -	1
manager for each	1
manager can spend	1
manager will start	1
manager has a	1
pattern can also	1
pattern can be,	1
pattern or if	1
pattern history, etc.	1
x86-64 instruction set	1
x86-64 platform _M_IX86	1
x86-64 platforms. AMD	1
x86-64 platforms. Comparison	1
*p+2 is a	2
*p+2 a hundred	1
*p+2 and store	1
Watcom compilers are	1
Watcom Another open	1
Watcom Digital Mars	1
Watcom C/C++ v.	1
round function using	1
round memory addresses	1
round addresses in	1
round addresses. Especially	1
cores, and a	1
cores, and it	1
cores, vector processing	1
cores, we need	1
chooses the least	1
chooses between two	3
running. The main	1
running. If there	1
running. Such frameworks	1
running. Programs using	1
serial in the	1
serial code for	2
serial because each	1
cc into vector	4
Header file for	2
Header file MMX	1
Header files for	1
150 for further	1
150 you want	1
150 16 Testing	1
150 15 Metaprogramming	1
thanks to the	2
thanks to out-of-order	1
thanks to heavy	1
2.0; x <=	1
2.0; } The	1
2.0; } In	1
2.0; i >=	1
pipeline and later	1
pipeline then the	1
pipeline where instructions	1
pipeline structure has	1
n) { //	2
n) { if	1
n) { double	1
input. The time	1
input. It is	1
input. Many programs	1
input. (In Windows	1
8.1 below. Devirtualization	1
8.1 How compilers	2
8.1 (page 77)	1
conditions. A dispatcher	1
conditions. For example,	1
conditions. All disturbing	1
conditions. Programs that	1
choosing the most	1
choosing the best	1
choosing a programming	1
choosing a container	1
146 below. Position-independent	1
146 below. 3.7	1
146 Multiple applications	1
146 14.12 Position-independent	1
.............................................................................................. 50 7.17	1
.............................................................................................. 56 7.27	1
.............................................................................................. 82 8.7	1
.............................................................................................. 99 10	1
_mm256_zeroupper() before any	1
_mm256_zeroupper() before calling	1
_mm256_zeroupper() before leaving	2
Making critical code	2
Making too many	1
Making exception-safe code	1
flush-to-zero and denormals-are-zero	1
flush-to-zero mode rather	1
flush-to-zero mode unless	1
flush-to-zero mode (SSE):	1
Taylor series float	1
Taylor expansions and	1
Taylor series, vectorized	1
Taylor series. The	1
SelectAddMul_pointer = &SelectAddMul_AVX2;	1
SelectAddMul_pointer = &SelectAddMul_dispatch;	1
SelectAddMul_pointer = &SelectAddMul_SSE2;	1
SelectAddMul_pointer = &SelectAddMul_SSE41;	1
dispatcher. The dispatcher	1
dispatcher. // After	1
dispatcher. See page	2
Clang, Intel or	3
Clang, Intel, Microsoft	1
14.9 is changed	1
14.9 Using integer	2
14.9 struct S1	1
n, then we	1
n, including the	1
n, factorial =	2
14.8 and 14.9	1
14.8 const int	1
14.8 Conversions between	2
overflow, and the	1
overflow, and invalid	1
overflow, this code	1
overflow, such as	1
x++) { Table[x]	2
x++) factorial *=	2
optimal. The branches	1
optimal. There are	1
optimal. Use 12	1
optimal. Best-case testing	1
*)d, x); }	3
*)d, x);} void	1
class, it checks	1
class, Intel Vector	1
class, structure or	1
class, Agner 8	1
z = y	3
z != 0;	1
advance and the	1
advance and stored	1
advance which of	1
advance rather than	1
c: CPU dispatching	1
c: __m128i c	2
c: Is16vec8 c	1
guaranteed to be	3
guaranteed to wrap	1
think that it	1
think that you	1
think that exception	1
think that programmers	1
example. The only	1
example. A union	1
example. We might	1
example. My example	1
older processors and	1
older microprocessors is	1
older processors, a	1
older MMX registers,	1
commonly the case	1
commonly used set	1
commonly used variables	1
commonly used methods	1
queue of pending	1
queue as a	1
queue should be	2
{} which would	1
{} brackets in	1
{} brackets. However,	1
{} vector(float a,	1
1.0f; The compiler	1
1.0f; This needs	1
1.0f; } The	1
1.0f; } A	1
ALIGN 4 PUBLIC	2
ALIGN ; mark_end;	1
ALIGN ?Func@@YAXQAHAAH@Z ENDP	1
modification is profitable.	1
modification of the	1
modification to compensate	1
modification if implemented	1
solutions to this	1
solutions are now	1
solutions may some	1
solutions are: Avoid	1
guide for assembly	1
guide for x86	1
guide for Windows,	2
appendix to this	3
appendix at www.agner.org/optimize/cppexamples.zip	1
17 will evict	1
17 Optimization in	2
17 debug version	1
empty throw() statement	1
empty throw() specification.	1
empty throw() specification	1
empty throw()specification is	1
maintenance - to	1
maintenance There are	1
maintenance .......................................................................................... 126	1
maintenance easier. I	1
1: // Example	1
1: 4 +	1
1: 8 +	1
1: printf("Beta"); break;	1
Out of order	2
Out (FIFO) basis	1
Out (FILO) basis	1
protected operating system	1
protected operating system,	1
protected mode and	2
Container classes are	1
Container classes can	1
Container classes Whenever	1
Container classes .....................................................................................................	1
alternatives to the	1
alternatives to using	1
alternatives to exception	1
alternatives that can	1
modifications of the	1
modifications to the	1
modifications in the	1
modifications actually increase	1
i_div_3; } 138	1
i_div_3; list[i+1] +=	1
i_div_3; list[i+2] +=	1
i_div_3; for(i=i_div_3=0; i<300;	1
s; An integer	1
s; s =	2
s; 40 i	1
case" and "best	1
case" counts that	1
case" counts. In	1
case" values. Which	1
distinguish between coarse-grained	1
distinguish between recoverable	1
distinguish elements with	1
distinguish these two	1
missing in the	1
missing in many	1
missing functions can	1
missing check for	1
subroutines in assembly	4
tools to be	1
tools for supporting	1
tools that fit	1
tools have powerful	1
0x2710 and later	1
0x2710 and (set)	1
0x2710 will cause	2
spot and make	1
spot that uses	1
spot has been	1
spot but also	1
powN is //	1
powN { public:	1
powN template is	2
C-style method of	1
C-style type casting	1
C-style type-casting without	1
C-style type-casting. It	1
While an empty	1
While C++ has	1
While we are	1
While some of	1
Bitfield { int	1
Bitfield { struct	1
Bitfield x; int	2
clean up in	1
clean up then	1
clean up everything	1
clean solution is	1
according to the	4
Bounds checking is	1
Bounds checking In	1
Bounds checking (see	1
Bounds checking ..................................................................................................	1
u.i = (n	1
u.i += n	1
u.i ^= 0x80000000;	1
u.i &= 0x7FFFFFFF;	1
dramatic when contentions	1
dramatic effect on	1
dramatic degradation of	1
dramatic consequences. I	1
IDE. It is	1
IDE. Does not	1
IDE. Has not	1
IDE. Free trial	1
lengths of the	1
lengths to reduce	1
lengths in the	1
lengths that are	1
expensive. A variable	1
expensive. A limited	1
expensive. You may	1
expensive. Using complicated	1
efficiency. The expression	1
efficiency. For example,	1
efficiency. These are	1
efficiency. Using unaligned	1
Copyright conditions are	1
Copyright notice This	1
Copyright notice ..........................................................................................................	1
Copyright © 2004	1
extended to the	1
extended to 64	1
extended to 256-bit	1
extended number of	1
size) = (total	1
size) { cout	1
size) / (number	1
size) % (number	1
(Gnu) all intrin.h	1
(Gnu) AMD FMA4	1
(Gnu) Table 12.2.	1
(Gnu) AES, PCLMUL	1
contained in a	1
contained in p1	1
contained object because	1
contained objects? It	1
transferring the variable	1
transferring 'this' in	1
transferring composite objects	1
transferring additional parameters.	1
Access to static	1
Access to remote	1
Access data sequentially	2
saving a backup	1
saving and restoring	1
saving memory space	1
saving registers that	1
years to come.	1
years before your	1
years old version	1
years old. The	1
y, a1, a2,	2
y, z; a	1
y, z; bool	1
structured and object-oriented	1
structured software development	1
structured exception handling	1
structured exception handling.	1
documentation and lack	1
documentation for the	1
documentation for detailed	1
documentation Intel: "IA-32	1
CChild1 * p1;	1
CChild1 : public	2
CChild1 Object1; CChild2	1
PGI compiler supports	1
PGI C++ compiler	1
PGI C++ v.	1
PGI PathScale Gnu	1
As we can	1
As table 9.3	1
As explained above,	1
As soon as	1
(RTTI) If any	1
(RTTI) Runtime type	1
(RTTI) /GR– -fno-rtti	1
(RTTI) ........................................................................... 54	1
default, which makes	1
default, so 1.2	1
default, even when	1
default, conform to	1
xpow10(double x) {	4
a2, b1, b2;	2
a2, b1, b2,	2
inconvenient to the	1
inconvenient times when	1
inconvenient times. This	1
inconvenient times. A	1
expressed as a	2
expressed as an	1
expressed as follows:	1
bottleneck is file	1
bottleneck is elsewhere	1
bottleneck or any	1
bottleneck than memory	1
directive to tell	1
directive for a	1
directive never takes	1
directive __declspec(cpu_dispatch(...)). See	1
not, and therefore	1
not, by default,	1
not, then it	1
not, then you	1
scarce resources. However,	1
scarce resource in	1
scarce resource. Do	1
scarce resource, especially	1
12.4b and 12.4c	1
12.4b can be	1
12.4b shows how	1
12.4b executes three	1
lrint function is	1
lrint (double const	2
lrint function: //	1
versions. The x86	1
versions. This method	1
versions. A 32-	1
versions. It is	1
............................................................................................. 87 9.1	1
............................................................................................. 56 7.28	1
............................................................................................. 136 14.5	1
............................................................................................. 113 12.6	1
Alignment of data	4
going to be	1
going to recommend	1
going from AVX	1
going either way.	1
underflow and give	1
underflow in XMM	1
underflow except in	1
underflow neutralize each	1
ranges do not	3
ranges now overlap.	1
splitting the dependency	1
splitting of software	1
splitting of N	1
splitting 256-bit read	1
user's time. The	1
user's time. Other	1
user's needs. The	1
user's computers. At	1
__INTEL_COMPILER n.a. n.a.	1
__INTEL_COMPILER __INTEL_COMPILER n.a.	1
__INTEL_COMPILER __INTEL_COMPILER 161	1
__INTEL_COMPILER 161 32	1
cleaned up in	1
cleaned up include:	1
cleaned up, as	1
cleaned up. If	1
cached. The subsequent	1
cached. This can	1
cached. See page	1
cached. Usually it	1
video or 3-dimensional	2
video should also	1
video processing, signal	1
aa: StoreVector(aa +	3
aa: a.store(aa+i); }	1
information. It is	1
information. Each function	1
information. They have	1
information. 1.1 The	1
Whenever the code	1
Whenever a function	1
Whenever a processor	1
Whenever dynamic memory	1
area is usually	1
area of system	1
area for a	1
area for different	1
consequence is that	1
consequence of such	1
consequence of n	1
consequence that it	1
a1, a2, b1,	4
unsigned. The following	2
unsigned. // Example	1
unsigned. This typically	1
pointers. The advantages	1
pointers. The absence	1
pointers. This is	1
pointers. 144 The	1
26 point constants,	1
26 about data	1
26 7.2 Integers	1
26 7.1 Different	1
Smaller microprocessors have	1
Smaller microcontrollers have	3
29 for details.	1
29 with line	1
29 64-bit Linux:	1
29 7.3 Floating	1
sum2 are called	1
sum2 = 0;	1
sum2 from time	1
sum2 += list[i+1];}	1
(n & 1)	1
(n & 0x7FFFFF)	1
(n > 0)	1
(n != 0)	1
(b + c)	1
(b == 0)	2
(b != 0)	1
2n and not	1
2n by adding	1
2n by subtracting	1
2n -1. The	1
idea to make	1
idea to put	1
idea to collect	1
idea how a	1
...................................................................................................... 20 3.9	1
...................................................................................................... 21 3.13	1
...................................................................................................... 90 9.6	1
...................................................................................................... 37 7.8	1
C, C++ or	1
C, specifying that	2
C, C++, D,	1
Same as example	1
Same example, using	2
Same example, vectorized	1
disable it in	1
disable exception handling	2
disable power-save options	1
assumption is that	1
assumption that the	1
assumption that signed	1
assumption about an	1
treated as an	1
treated as different	1
treated as bigger	1
treated like a	1
Fastcall is not	1
Fastcall function __fastcall	1
Fastcall functions are	1
Fastcall functions /Gr	1
RGB video or	2
RGB image data	1
RGB color difference.	1
avoids the branch	1
avoids the overflow.	1
avoids many of	1
avoids overflow: a[i]	1
prevented in other	1
prevented by calling	1
prevented from assuming	1
prevented from cleaning	1
....................................................................................... 5 2.2	1
....................................................................................... 22 4	1
....................................................................................... 145 14.11	1
....................................................................................... 24 6	1
seldom used branches	1
seldom used functions,	1
seldom used. It	1
seldom occur and	1
mixing code compiled	2
mixing different floating	1
mixing single and	1
Branches and switch	2
Branches are implemented	1
Branches are relatively	1
double. The intrinsic	1
double. Another problem	1
double. Here we	1
double. Misaligned data.	1
16.1 const int	1
16.1 Using performance	2
16.1 #include <intrin.h>	1
(r = 0;	2
(r = 1;	2
50% of the	3
50% or less	1
suboptimal way has	1
suboptimal code. Intrinsic	1
suboptimal way. The	1
suboptimal way. Here	1
16kB aligned operands	2
16kB unaligned op.	2
tasks. A critical	1
tasks. For example,	1
tasks. Sometimes it	1
tasks. Before you	1
image data have	1
image base is	1
image processing, sound	1
image processing. Yeppp.	1
worst-case conditions in	1
worst-case maximum repeat	1
worst-case conditions. Programs	1
worst-case performance: The	1
(1) is not	1
(1) or false	1
(1) get its	1
(1) check for	1
float, but not	1
float, double and	2
float, double, bool,	1
9.5 because we	1
9.5 so that	1
9.5 Alignment of	2
Induction; ; parameter	1
Induction; ; a[i+1]	1
Induction; a[i+1] =	1
Induction; Induction++; }	1
uncached or even	1
uncached memory and	1
uncached write is	1
uncached read because	1
individual functions or	1
individual array elements	1
individual bits of	1
individual installation tools.	1
begin the calculation	1
begin with _mm.	1
begin at an	1
begin calculating a	1
interface. A console	1
interface. It is	1
interface. Applications that	1
interface. Otherwise the	1
9.3 #include <malloc.h>	1
9.3 Functions that	2
9.3 shows, the	1
option. This requires	1
option. Use the	1
option. Then we	1
option. 8.4 Obstacles	1
diagonal. The elements	1
diagonal. The first	1
diagonal. The c	1
diagonal. Each element	1
interfaces to network	1
interfaces and system	1
interfaces and interfaces	1
interfaces from scratch.	1
floats for (int	1
floats A structure	1
floats F32vec4 xxn(x4,	1
floats exp function	1
another. The object	1
another. These costs	1
another. Therefore, it	1
another. Therefore, micro-	1
N> class powN	1
N> class SafeArray	1
N> class powN<true,N>	1
N> static inline	1
Class data members	2
Class member functions	2
Small data types:	1
Small functions are	1
Small hand-held devices	1
Small lightweight processors	1
N1 = N&(N-1)	1
N1 } };	1
N1 could have	1
N1 (N &	1
alloca is used.	1
alloca may not	1
alloca was called.	1
alloca over new	1
aliasing. The only	1
aliasing. See page	1
aliasing. Operations that	1
aliasing. __declspec(noalias) or	1
eliminated if the	3
eliminated completely. For	1
detailed optimization more	1
detailed instructions. Example:	1
detailed explanation of	1
detailed overview of	1
F32vec4 xx4(x4); //	1
F32vec4 xxn(x4, x2*x,	1
F32vec4 F64vec2 F32vec8	1
F32vec4 s(0.f, 0.f,	1
mask to choose	1
mask = _mm_cmpgt_epi16(b,	2
mask out multiple	1
original is destroyed.	1
original pointer actually	1
original object is	1
original method of	1
caches and cause	1
caches are organized	1
caches have to	1
caches work can	1
recognize that the	2
recognize that 10	1
recognize VIA processors	1
513 513 58.7	1
513 513 2056	1
513 58.7 168.3	1
513 2056 38.1	1
Threads are used	1
Threads are useful	1
Threads Threads are	1
Threads .................................................................................................................. 60	1
Overloaded functions The	1
Overloaded functions ..............................................................................................	1
Overloaded operators An	1
Overloaded operators .............................................................................................	1
Contentions in the	4
illustrated in this	1
illustrated in example	2
illustrated by the	1
words, the program	1
words, it is	1
words, you need	1
words, you must	1
returned in registers	1
returned in registers.	1
returned by copying	1
returned pointer or	1
existing object can	1
existing object rather	1
existing systems and	1
existing program. Weighing	1
Let's take the	1
Let's look at	2
Let's repeat the	1
is, and is	1
is, in order	1
is, but must	1
is, I guess,	1
illustrates the difference	1
illustrates such a	1
illustrates how to	1
illustrates this. My	1
unit-testing is necessary	1
unit-testing is unfortunately	1
unit-testing It is	1
unit-testing ...................................................................................... 156	1
i<300; i++){ list[i]	2
i<300; i+=3){ list[i]	1
i<300; i+=3,i_div_3++){ list[i]	1
{return a +	1
{return b;} };	1
{return r.a +	1
{return p->a +	1
b2; This can	1
b2; int c;	1
b2; y =	2
Remember to insert	1
Remember to remove	1
Remember that container	1
Remember again, that	1
explicit use of	1
explicit CPU dispatching	1
explicit induction variable.	1
explicit checks for	1
mirror the entire	1
mirror the remote	1
mirror elements matrix[c][r]	1
mirror position above	1
dedicated test server.	1
dedicated microprocessor and	1
dedicated microprocessor core	1
dedicated physics processor	1
Disp() { cout	4
r, c; for	2
r, c; double	2
8.26a by rolling	1
8.26a void Func(int	1
8.26a compiled to	1
8.26a (32-bit mode):	1
breakpoint and show	1
breakpoint in the	2
breakpoint again. The	1
b1, b2; y	2
b1, b2, y1,	2
appears to be	2
appears in the	1
appears on the	1
functionality of an	1
functionality to an	1
functionality and a	1
functionality without polymorphism	1
languages. This section	1
languages. But the	1
languages. My preference	1
languages. www.yeppp.info And	1
sequential order and	1
sequential order. If	1
sequential labels is	1
sequential instructions, where	1
www.agner.org/optimize/cppexamples.zip for how	1
www.agner.org/optimize/cppexamples.zip for examples	1
www.agner.org/optimize/cppexamples.zip contains examples	1
www.agner.org/optimize/cppexamples.zip containing container	1
style. The time	1
style. The advantages	1
style. It is	1
style. Some compilers	1
MOVNTQ instruction cannot	1
MOVNTQ instruction must	1
MOVNTQ _mm_stream_pi SSE	1
MOVNTQ _mm_empty(); //	1
optimized. We cannot	1
optimized. Note that	1
optimized. Library functions	1
optimized. Jumps between	1
......................................................................................... 65 7.33	1
......................................................................................... 87 9.2	1
......................................................................................... 107 12.4	1
......................................................................................... 132 14.1	1
CHello { public:	3
CHello * p;	1
found in other	1
found in my	1
found in Wikipedia	1
found elsewhere. 13.5	1
me explain the	1
me explain this	1
me corrections and	1
me manually, but	1
counts. The value	1
counts. This is	1
counts. It is	1
counts. In any	1
measurement code should	1
measurement should not	1
measurement instruments into	1
measurement instruments directly	1
layers of abstraction	2
layers and it	1
layers and frameworks	1
handler to call	1
handler in the	1
handler calls exit(),	1
handler needs all	1
coded in a	2
coded as an	1
coded as _mm_empty()	1
changing the dividend	1
changing in the	1
changing this to:	1
changing then the	1
unit-test may have	1
unit-test but has	1
unit-test without taking	1
unit-test does not	1
implicit pointer known	1
implicit parameter to	1
implicit 'this' pointer	2
smaller. The lengths	1
smaller. This manual	1
smaller. It is	1
smaller. Structure and	1
interval is a	1
interval from 0	1
interval 0 <=	1
interval [1.0, 2.0)	1
33 result is	1
33 7.5 Booleans...................................................................................................................	1
33 7.6 Pointers	1
33 11.8 127	1
31 for more	1
31 ebx, eax	1
31 7.3 Floating	1
31 11.6 64	1
int)b / 10;	1
int)b / 16;	1
int)b % 10;	1
int)b % 16;	1
3. The code	1
3. The Gnu	1
3. The microarchitecture	1
3. Use appropriate	1
μs is less	1
μs on the	1
μs on a	1
μs today, then	1
module. The compiler	1
module. The size	1
module. The static	1
module. This non-inlined	1
cast The dynamic_cast	1
cast The const_cast	1
cast The reinterpret_cast	1
cast The static_cast	1
8-bit integers with	1
8-bit integers which	1
8-bit signed number.	1
8-bit signed number,	1
Integers of smaller	1
Integers can be	1
Integers variables and	2
Calling a function	1
Calling a member	1
Calling conventions for	1
Calling exit may	1
(double const x)	2
(double x) {	1
(double x, unsigned	1
Weekdays { Sunday,	1
Weekdays { Sunday	1
Weekdays Day; if	2
application-specific code. The	1
application-specific code. If	1
application-specific instructions that	1
application-specific information in	1
first. If it	1
first. If one	1
first. However, you	1
first. b+c =	1
considerations of efficiency,	1
considerations that are	1
considerations should be	1
considerations such as	1
63 number (e.g.	1
63 31 11.6	1
63 63 31	1
63 . The	1
represented with or	1
represented with 64	1
represented as an	1
represented as two	1
force the operating	1
force the swapping	1
force a member	1
force when I	1
manually. The effect	1
manually. This principle	1
manually. It must	1
manually. I have	1
identified by a	2
identified by their	1
identified by consecutive	1
www.agner.org/optimize/cppexamples.zip. If the	1
www.agner.org/optimize/cppexamples.zip. An array	1
www.agner.org/optimize/cppexamples.zip. These may	1
www.agner.org/optimize/cppexamples.zip. 9.9 Access	1
virus scanners to	1
virus scanners and	1
virus scanner that	1
virus attacks and	1
structures. For example,	1
structures. On the	1
structures. Accessing a	1
structures. Useful for	1
exp function of	2
exp exp 12.8	1
exp 12.8 Aligning	1
(in bytes) is	1
(in bytes) of	2
(in Windows: __rdtsc()).	1
pointer, a reference,	1
pointer, but it	1
pointer, but this	1
pointer, common subexpressions,	1
kept in the	1
kept in different	1
kept small in	1
kept entirely inside	1
Y and Z.	1
Y // Update	1
Y = C;	1
Y += Z;	1
interprocedural optimization is	1
interprocedural optimizations of	1
interprocedural optimizations. The	1
interprocedural optimizations. See	1
incompatible or error	1
incompatible with floating	1
incompatible with old	1
incompatible with debugging.	1
bytes) is a	1
bytes) of the	1
bytes) of each	1
bytes) on future	1
selected if the	1
selected instruction set.	1
selected version FuncType	1
selected during the	1
multiplied by the	3
multiplied by a	1
reproducible as possible.	1
reproducible time measurements:	1
reproducible results. This	1
reproducible results. If	1
normally use the	1
normally use this	1
normally compiled with	1
normally belongs to	1
constants. For example,	2
constants. Integer constants	1
constants. Register storage	1
cache, code cache,	1
cache, at least	1
cache, where it	1
cache, branch target	1
entry with the	1
entry point extern	1
entry point. //	1
entry initially points	1
inferior to the	1
inferior to their	1
inferior version of	1
inferior version on	1
obsolete. But if	1
obsolete. Programmers very	1
obsolete. Microprocessor documentation	1
obsolete. Rick Booth:	1
simultaneously can share	1
simultaneously or out	1
simultaneously or seemingly	1
simultaneously prefetching the	1
routine that is	1
routine that loads	1
routine should do	1
routine sets a	1
auto_ptr to another	1
auto_ptr and shared_ptr.	1
auto_ptr that owns	1
auto_ptr has the	1
tree or a	2
tree or switch	1
tree may be	1
unable to access	1
unable to predict	1
unable to vectorize	1
unable to respond	1
Optimizes very well.	1
Optimizes reasonably well.	2
Optimizes moderately well.	1
constants, and initialized	1
constants, array initializer	1
constants, string constants,	2
techniques of multithreading.	1
techniques in the	1
techniques can be	1
techniques like square	1
otherwise can only	1
otherwise would be	1
otherwise optimize across	1
otherwise go undetected.	1
Smart pointers are	1
Smart pointers can	1
Smart pointers A	1
Smart pointers ..........................................................................................................	1
opens the possibility	2
opens a file	1
opens and closes	1
modified by the	3
modified should be	1
15.1a to an	1
15.1a to 15.1c	1
15.1a to 15.1c).	1
15.1a to 151	1
Comparison of function	1
Comparison of different	2
Comparison of optimizations	1
finished the calculations	1
finished the calculation	1
finished the time-consuming	1
finished using the	1
run. The time	1
run. Some implementations	1
run. Examples include	1
run. Both the	1
sequentially in memory	1
sequentially in memory.	1
sequentially A cache	1
sequentially .......................................................................................... 96	1
Intel: "Intel 64	1
Intel: "IA-32 Intel	2
Intel: "Intel® C++	1
format. The intermediate	1
format. The formats	1
format. Other compilers	1
format. Alternatively, make	1
programs. The profiler	1
programs. It is	1
programs. If you	1
programs. Writing past	1
manner to make	1
manner by returning	1
manner then it	1
manner where the	1
work. The C++	1
work. The updating	1
work. The recommendations	1
work. Data alignment.	1
uint64_t 128 Vec2uq	1
uint64_t 256 float	1
uint64_t Table 7.1.	1
uint64_t MS compiler:	1
(level >= 4)	2
(level >= 11)	2
tests are done	1
tests with the	1
tests on Intel	1
tests were carried	1
Then you make	1
Then we are	1
Then we get	1
Then again two	1
soft processor is	1
soft processor activates	1
soft cores that	1
soft processor. Such	1
100, c =	1
100, y; y	1
100, max =	1
100, NUMCOLUMNS =	1
results. This is	1
results. If you	2
results. Integer operators	1
hyperthreading is not	1
hyperthreading or not	1
hyperthreading by using	1
hyperthreading processor to	1
operators. Function parameters	1
operators. Make a	1
operators. Vectorized code	1
operators. 7.7 Function	1
simpler in 64-bit	1
simpler than a	1
simpler when using	1
simpler because it	1
format is not	1
format is standardized	1
format and getting	1
format instead of	1
reasonable solution is	1
reasonable upper limit	2
reasonable estimate can	1
resolution of the	1
resolution and the	1
resolution can be	1
resolution if time	1
units, and 22	1
units, memory ports,	1
units, one or	1
units, etc. and	1
12.2 128 128	1
12.2 __declspec(align(16)) struct	1
12.2 AVX-512 instruction	2
b: from cc	1
b: __m128i b	2
b: Is16vec8 b	1
processing. Visual Studio	1
processing. Yeppp. Open	1
processing. Running multiple	1
processing. Scott Meyers:	1
well-defined with option	1
well-defined interface to	2
well-defined functionality and	1
Still faster if	4
45 for (i	1
45 clock cycles.	1
45 clock cycles).	1
45 7.14 Functions	1
bb into vector	4
detail in manual	2
detail on page	1
advices in critical	1
advices on optimization	1
advices may apply	1
conclusion is that	2
conclusion to this	1
deleted by another	1
deleted when the	1
deleted properly and	1
49 and manual	1
49 for a	1
49 first eight	1
parameters, as example	1
parameters, local variables,	1
parameters, pointers, references,	1
Storing the parameters	1
Storing variables in	1
Storing something in	1
(set) = (memory	1
(set) = (10000	1
(set) = (0x2710	1
fine-grained parallelism when	1
fine-grained parallelism because	1
fine-grained parallelism. The	1
Execution time too	1
Execution unit throughput	2
LoadVector(cc + i);	3
arbitrary memory address	1
arbitrary cache line.	1
arbitrary name that	1
Which of these	1
Which method you	1
Which solution you	1
behave according to	1
behave differently on	1
behave differently because	1
bits, and the	1
bits, but 32-bit	1
bits, so you	1
compact. The biggest	1
compact. See page	1
compact. Accessing a	1
behaves like a	1
behaves like an	1
behaves differently on	1
FPGA in the	1
FPGA as a	1
FPGA soft cores	1
earlier Intel processors	1
earlier CPUs. The	1
earlier vmlsExp4 vmldExp2	1
5) { //	1
5) SelectAddMul_pointer =	1
5) {} which	1
&, |, ^,	2
&, |, ~.	1
101 for further	1
101 Multithreading works	1
101 10.1 Hyperthreading	1
reasons: The function	1
reasons: The size	1
reasons: Each object	1
consecutively and can	1
consecutively in the	1
consecutively in memory.	1
Extra time is	1
Extra memory space	1
Extra data conversion,	1
error. The calculations	1
error. The allocated	1
error. // You	1
carried out with	1
carried out independently	1
carried dependency chain	1
reordering the data	1
reordering has made	1
reordering easier for	1
platform. Intel The	1
platform. However, with	1
platform. 14.8 Conversions	1
satisfied with the	1
satisfied with more	1
satisfied with making	1
catch an exception	1
catch programming errors	1
catch (...) {	1
/arch:AVX etc. for	1
/arch:AVX /openmp /MT	1
/arch:AVX /QaxSSE3, etc.	1
93 for discussion	1
93 9.8 Strings	1
93 themselves. But	1
53 function at	1
53 7.21 Runtime	1
53 7.20 Virtual	1
#else // 32-bit	1
#else // Gnu	1
#else #define pure_function	1
addition. This is	1
addition. If the	1
addition. Comparing two	1
Text strings and	1
Text strings are	1
Text strings typically	1
big-endian storage. Example	1
big-endian storage. All	1
big-endian storage. Optimizing	1
54 class D	1
54 7.22 Inheritance	1
54 7.23 Constructors	1
119 The function	1
119 for more	1
119 12.8 Aligning	1
!a = true	1
!a = false,	1
!a && !b	1
abstraction is a	1
abstraction in the	1
abstraction which makes	1
each, or two	1
each, four integers	1
each, eight integers	1
11) and vector	1
11) { //	2
code). The source	1
code). If the	1
code). Supports 32-bit	1
...................................................................................... 16 3.2	1
...................................................................................... 90 9.7	1
...................................................................................... 156 16.3	1
wrong branch is	1
wrong branch. Microprocessor	1
wrong type. References	1
LoadVector(bb + i);	3
alias any elements	1
alias anything by	1
alias upon the	1
blocks, for example:	1
blocks, or if	1
blocks, either in	1
feedback should be	1
feedback comes from	1
feedback seriously. User	1
pure_function ; double	1
pure_function #endif double	1
pure_function __attribute__((const)) #else	1
a-a = 0	3
chains. A dependency	1
chains. In this	1
chains. Another thing	1
prefetching the code	1
prefetching data for	1
prefetching so this	1
compiler-generated code in	1
compiler-generated code by	1
compiler-generated assembly code.	1
redesign of the	1
redesign of a	1
redesign can not	1
differently on different	1
differently on signed	1
differently because there	1
B, and the	1
B, C; x.abc	1
B, C; x.a	1
reasonably well. Codeplay	1
reasonably well. Very	1
reasonably well, but	1
Two or more	1
Two libraries of	1
Two threads running	1
55 In this	1
55 7.24 Unions	1
55 7.25 Bitfields	1
libraries: Intel vector	1
libraries: Intel short	1
libraries: long vector	1
projects can be	1
projects have become	1
projects made with	1
1)sign 2exponent 127	1
1)sign 2exponent 16383	1
1)sign 2exponent 1023	1
14.6 float list[16];	1
14.6 Floating point	2
combination of a	1
combination of these	1
combination of additions	1
libraries, but who	1
libraries, also called	2
mean use the	1
mean good performance).	1
mean atomic. It	1
inserts extra code	1
inserts temporary debug	1
inserts built-in code	1
const*)p); } //	3
hidden by using	1
hidden pointer. The	1
hidden behind the	1
x*x*x*x*x*x*x*x = ((x2)	2
x*x*x*x*x*x*x*x = ((x2)2)2	1
errors. The following	1
errors. If you	1
errors. See page	1
One may argue	1
One popular development	1
One kilobyte is	1
blocking and similar	1
blocking for the	1
blocking or tiling.	1
Faster if divisor	2
Faster than most	1
sources of compatibility	1
sources of resource	1
sources of frustration	1
well-tested libraries for	1
well-tested container classes.	1
well-tested functions, classes,	1
devices, as discussed	1
devices, you don't	1
devices, but there	1
multiplication, to mix	1
multiplication, etc. is	1
multiplication, etc.) inside	1
part. It is	1
part. If a	2
API and the	1
API function which	1
API calls rather	1
starts running and	1
starts up, even	1
starts up. Some	1
only. The following	1
only. This can	1
only. Critical pieces	1
counters, function parameters,	1
counters, as in	1
counters, etc. In	1
execution, as explained	1
execution, you have	1
execution, even if	1
list[i+1] = 1;	2
list[i+1] += i_div_3;	1
distance the critical	1
distance in memory	1
distance between rows	1
14.28 can be	1
14.28 will shift	1
14.28 union {	1
zero, by setting	1
zero, rather than	1
zero, c +	1
r1 and c1	1
r1 < SIZE;	1
r1 += TILESIZE)	1
r2 and c2	1
r2 < r1+TILESIZE;	2
(MS) smmintrin.h (Gnu)	1
(MS) xopintrin.h (Gnu)	1
(MS) x86intrin.h (Gnu)	1
aligning the data	1
aligning data #ifdef	1
aligning dynamically allocated	1
assuming that the	1
assuming that *p+2	1
assuming no pointer	1
r; for (i	1
r; c++) {	2
analysis of the	1
analysis The live	1
analysis Join identical	1
seem a little	1
seem to do	1
seem illogical that	1
perhaps for a	1
perhaps }; //	1
perhaps Mac OS.	1
service routine should	1
service routines and	1
service routines, system	1
Comes with the	2
Comes with Microsoft	1
esp ; align	1
esp ebx ecx,	1
esp ;alignby4 ;	1
features. The programmer	1
features. User feedback	1
features. Take user	1
---xx---- (a+c==b+c)=(a==b) ----x----	1
---xx---- a<<b<<c=a<<(b+c) x-xxx--xx	1
---xx---- (-a>-b)=(a<b) ---xx---x	1
............................................................................................... 4 2	1
............................................................................................... 50 7.16	1
............................................................................................... 23 5	1
C/C++ standard specifies	2
C/C++ v. 1.4,	1
100. It compares	1
100. pop ebx	1
100. Now, according	1
b;}; S1 list[100];	1
b;}; S1 list[100],	1
b;}; Sab ab[size];	1
consumes a lot	1
consumes CPU time.	1
consumes most of	1
numbers, then you	1
numbers, but on	1
numbers, we have	1
129 130 14.4	1
129 129 130	1
129 13.7 CPU	1
reload the value	1
reload the level-1	1
reload *p and	1
124 2 13.4	1
124 necessary information	1
124 13.3 Difficult	1
motion A calculation	1
motion Induction variables	1
motion manually when	1
speed-critical program on	1
speed-critical functions by	1
speed-critical functions. Many	1
numbers: // Example	3
(page 77) shows	1
(page 131) shows	1
(page 146). In	1
12. If the	1
12. Most modern	1
12. Higher inputs	1
1000 * 100	1
1000 times and	1
1000 times then	1
long. This is	1
long. If the	1
long. Lazy binding	1
organization for different	1
organization It is	1
organization ................................................................................................... 87	1
slow, you know).	1
slow, then the	1
slow, difficult to	1
performed with a	1
performed on a	1
performed on multiple	1
high-level language with	1
high-level language need	1
high-level languages are	1
advance. The frequent	1
advance. The disadvantages	1
advance. This reduces	1
anyway and you	1
anyway in 64-bit	1
anyway if you	1
(*.dll or *.so).	2
(*.dll or *.so)	1
Intel-based Mac OS	2
Intel-based Mac OS,	1
main() are compiled	1
main() { int	2
x2 = x	2
x2 * x2;	1
database, and a	1
database, and other	1
database, or other	1
Works with all	2
Works well with	1
calculations: for (	1
calculations: // Example	2
basis for this	1
basis then use	2
updating of software	1
updating in the	1
updating mechanism should	1
manipulation is required	1
manipulation Mathematical functions	1
manipulation tricks Michael	1
28. The calculation	1
28. This means	1
28. We take	1
C0 { public:	2
C0 * p	1
access, as given	1
access, etc. The	1
access, sort and	1
calculations, and then	1
calculations, should be	1
calculations, where each	1
multi-core CPUs, as	1
multi-core CPUs, but	1
multi-core processing. Visual	1
level, and the	1
level, and in	1
level, typically in	1
Exception handling is	2
Exception Specifications, Dr	1
optimization, the compiler	1
optimization, it does	1
optimization, which will	1
Whether the constants	1
Whether you want	1
Whether you choose	1
contents of the	1
contents of data	1
contents copied to	1
books and manuals.	1
books contain many	1
books 1994. Mostly	1
removed the contentions	1
removed from the	1
removed after debugging	1
164 1 Introduction	1
164 below. Those	1
matrix[rows][columns]; int i;	1
matrix[rows][columns]; int i,	2
list. Each element	1
list. Do not	1
list. 94 Are	1
exponential function can	1
exponential functions, trigonometric	2
generality of the	1
generality and flexibility	1
generality and flexibility,	1
takes. The version	1
takes. See page	1
takes. Debugging. The	1
multithreaded applications it	1
multithreaded program, or	1
multithreaded applications: The	1
list[i+2] = 2;	2
list[i+2] += i_div_3;	1
Total size of	2
Total kilobytes Time	1
explicitly. In example	1
explicitly. There are	1
explicitly. Divisions can	1
programs, more than	1
programs, except for	1
programs, 99% of	1
optimizes the code.	1
optimizes a piece	1
optimizes reasonably well,	1
instruments in the	1
instruments into the	1
instruments directly into	1
After each iteration	1
After first call	2
involving integer addition,	1
involving class objects	1
involving division and	1
(vector) reductions: Common	1
(vector) reductions: a+b=b+a,	1
(vector) reductions: ~(~a)	1
unfortunate because truncation	1
unfortunate method that	1
unfortunate consequence that	1
"Optimizing subroutines in	3
parameter, and the	1
parameter, or as	1
parameter, so there	1
exceptions. The function	1
exceptions. The mechanism	1
exceptions. See page	1
time- consuming calculations	1
time- consuming features	1
time- consuming. There	1
K8 0.24 0.25	1
K8 1.09 1.25	1
K8 0.38 0.44	1
loaded. This makes	1
loaded. This method	1
loaded. 21 3.13	1
(i=0; i<100; i++)	1
(i=0; i<n; i++)	1
(i=0; i<n; ++i).	1
14.30 will therefore	1
14.30 const int	1
14.30 finds the	1
b;} vector operator	1
b;} }; The	1
b;} }; int	1
wasteful in the	1
wasteful copying of	1
wasteful behavior can	1
Return the size	1
Return a null	1
Return reference to	1
StoreVector(void * d,	3
microcontrollers have no	3
character arrays is	1
character arrays. Note	1
character arrays. Strings	1
implemented. The highest	1
implemented. The recursion	1
implemented. Use the	1
fact, the compiler	1
fact, the STL	1
fact, you may	1
runtime. Example 7.43	1
runtime. #define directives	1
runtime. Polymorphism is	1
manually by the	1
manually when it	1
manually unless there	1
xxn * _mm_load_ps(coef+i);	1
xxn rather than	1
xxn *= xx4;	1
|, ^, ~	1
|, ^, ~,	1
|, ~. The	1
7.2 a =	1
7.2 Integers variables	2
Thread-local storage is	1
Thread-local storage should	1
Thread-local storage Most	1
81 for an	1
81 optimization is	1
81 8.6 Optimization	1
7.1 float SomeFunction	1
7.1 Different kinds	2
signal an error	1
signal processing and	1
signal processing, data	1
circular buffer with	2
circular buffer than	1
7.4 we are	1
7.4 Enums An	1
7.4 Enums ......................................................................................................................	1
ignore the problem	1
ignore a request	1
ignore overflow or	1
keywords and directives	1
keywords relevant to	1
keywords Fast function	1
7.8 if (handle	1
7.8 Member pointers	1
7.8 Member pointers.......................................................................................................37	1
once. The reasons	1
once. Example: //	1
once. One may	1
89 for an	2
89 int a[1000];	1
list[100]; int i;	1
list[100]; Func1(list, &list[8]);	1
list[100]; memset(list, 0,	1
considered a software	1
considered a container	1
considered metaprogramming in	1
Windows). The XMM	1
Windows). There are	1
Windows). Alternatively, you	1
for. The names	1
for. In other	1
for. Some systems	1
divisions are given	1
divisions can be	1
divisions (Division is	1
8; // exponent	1
8; // SIZE	1
8; float matrix[rows][columns];	1
reflects the floating	1
reflects the order	1
reflects the conflicting	1
..................................................................................................... 103 11	1
..................................................................................................... 126 13.6	1
..................................................................................................... 93 9.8	1
lies in the	2
lies r places	1
trigonometric functions. The	1
trigonometric functions, etc.	2
manipulate the data	1
manipulate the different	1
manipulate all the	1
fractional part unsigned	2
fractional part 142	1
-128 to +127.	1
-128 generates 127.	1
-128 127 int8_t	1
spaced a multiple	1
spaced by a	2
approximate reciprocal square	1
approximate comparison of	1
approximate reciprocal, fast	1
comparisons, which are	1
comparisons, such as	1
comparisons, etc. For	1
User work that	1
User feedback should	1
User complaints should	1
dividend is unsigned	1
dividend is unsigned.	1
dividend to unsigned	1
unpredictable times and	1
unpredictable errors elsewhere	1
unpredictable intervals which	1
LoadVector(void const *	3
step. The intermediate	1
step. In most	1
step. With a	1
Z = A	1
Z } The	1
Z += A2;	1
separated by commas.	1
separated by semicolons,	1
separated from the	1
64, but the	1
64, depending on	1
64, ...). We	1
copies the table	1
copies the sign	1
copies them into	1
brand. The version	1
brand. Critical parts	1
brand. Future processors	1
annoying to the	2
annoying time consumer	1
CodeAnalyst. There are	1
CodeAnalyst. These profilers	1
CodeAnalyst. Unfortunately, profilers	1
Literature on code	1
Literature Other manuals	1
Literature ..................................................................................................................... 163	1
study the code	1
study the available	1
study of how	1
stack, which is	1
stack, which makes	1
stack, except for	1
collection. The allocated	1
collection. A more	1
collection. Objects that	1
occurs, but this	1
occurs, even for	1
occurs, (2) use	1
-fno-pic and link	1
-fno-pic when compiling	1
-fno-pic apparently has	1
_M_IX86 and _WIN64	1
_M_IX86 x86-64 platform	1
_M_IX86 _M_IX86 x86-64	1
elsewhere and get	1
elsewhere in the	1
elsewhere then there	1
bypassing the dispatch	1
bypassing the so-called	1
bypassing syntax checks.	1
0x273F will be	1
0x273F into one	1
0x273F would still	1
135 The if	1
135 show various	1
135 14.4 Integer	1
looks like this:	3
{double a; double	2
{double d; unsigned	1
implementing a matrix	1
implementing a compile-time	1
implementing polymorphic classes.	1
int. A short	1
int. Therefore, it	1
int. Reinterpret cast	1
space, if necessary,	1
space, as explained	1
space, even when	1
skip the following	1
skip this section	1
skip large expressions	1
137 about division).	1
137 errors must	1
137 14.6 Floating	1
132 Table lookup	1
132 14.2 Bounds	1
132 14.1 Use	1
position- independent code	1
position- independent code.	1
position- independent code,	1
Index out of	3
Specifies a function	1
Specifies that pointer	1
Specifies alignment of	1
residual error is	1
residual error and	1
residual error for	1
operations, and to	1
operations, as explained	1
operations, see page	1
C++. This typically	1
C++. Critical device	1
C++. Yet, D	1
input/output than the	1
input/output operations. It	1
input/output Graphics and	1
packages and who	1
packages faster and	1
packages include a	1
operations: // Example	2
operations: __m128i a	1
Explicit CPU dispatching	1
Explicit cache control	2
purpose. The clumsy	1
purpose. It is	1
purpose. It just	1
reciprocal_divisor; y2 =	1
reciprocal_divisor; 14.7 Don't	1
reciprocal_divisor; reciprocal_divisor =	1
compilation. The program	1
compilation. The following	1
compilation. Some early	1
(number of sets).	1
(number of sets)	1
(number of ways).	1
endian systems you	1
endian storage (e.g.	1
endian storage. If	1
allocates the required	1
allocates memory on	1
allocates one memory	1
136 and 137,	1
136 ... for	1
136 14.5 Integer	1
reveals a funda-	1
reveals that similar	1
reveals three things	1
filled up if	1
filled up, which	1
filled up. This	1
(requires a microprocessor	1
(requires no specific	1
(requires binutils version	1
offer the choice	1
offer the possibility	1
offer profile-guided optimization.	1
Bitfields may be	1
Bitfields Bitfields may	1
Bitfields ................................................................................................................... 56	1
At the diagonal	1
At this time,	1
At least, it	1
up-to-date function library	1
up-to-date version. The	1
up-to-date solution. The	1
leaving the AVX	2
leaving their workplace	1
Inheritance from multiple	1
Inheritance An object	1
Inheritance .............................................................................................................. 54	1
153 for further	1
153 16.1 Using	1
153 spends most	1
degree of optimization	1
degree of randomness	1
degree polynomial of	1
_mm_storeu_si128((__m128i *)d, x);	2
_mm_storeu_si128((__m128i *)d, x);}	1
automatically, and only	1
automatically, but as	1
automatically, although it	1
sequentially. The opposite	1
sequentially. It works	1
sequentially. Some applications	1
Enums are exactly	1
Enums An enum	1
Enums ...................................................................................................................... 33	1
Algebraic reductions Most	1
Algebraic reduction is	1
Algebraic reduction Most	1
A, B and	1
A, B, C;	2
operands. The advantages	1
operands. You cannot	1
operands. Nevertheless, the	1
i<100; i++) sum	1
i<100; i++,i2+=2.0f)a[i]=i2; 41	1
i<100; i++)a[i]=2*i; The	1
0.11 memcpy 16kB	1
0.11 0.18 0.18	1
0.11 1.21 0.57	1
0.12 memcpy 16kB	1
0.12 0.18 0.12	1
0.12 0.11 0.18	1
nearest integer int	1
nearest element to	1
nearest integer. If	1
To use multiple	1
To prevent this	1
To explain the	1
x-- x x--	2
x-- x ---	1
language, all conversions	1
language, such as	1
language, e.g. C++,	1
145 and 119	1
145 SSE2 instruction	1
145 14.11 Static	1
140 a =	1
140 for further	1
140 14.8 Conversions	1
141 for details	1
141 #include <emmintrin.h>	1
141 14.9 Using	1
RISC and CISC	1
RISC in situations	1
RISC cores, vector	1
Consider the time	1
Consider the following	1
Consider running the	1
text or input	1
text strings in	2
Object Windows Library	1
Object files generated	1
Object oriented programming	1
14.10 int a,	1
14.10 Mathematical functions	2
14.11 int a,	1
14.11 Static versus	2
<int N> class	1
<int N> static	1
<int m> int	1
back. The method	1
back. The so-called	1
back. Thus, we	1
8.4 double a	1
8.4 Obstacles to	2
8.7 int SomeFunction	1
8.7 Checking what	2
listing to see	1
listing reveals three	1
listing /FA -S	1
twice for handling	1
twice because the	1
twice because both	1
Pascal and Fortran	1
Pascal has many	1
Pascal used an	1
expected. The 64	1
expected. I believe	1
expected. Use square	1
14.4 Integer multiplication	2
14.4 511 511	1
Vec16s when compiling	1
Vec16s a, b,	1
Vec16s Vec16us Vec8i	1
Simple function parameters	1
Simple integer operations	1
Simple member pointers	1
Manual", Volume 1	1
Manual", Volume 1,	1
Manual", Volume 2A	1
leave the last	1
leave a background	1
leave them enabled	1
solved by making	2
solved this problem	1
supplied in the	1
supplied in Intel's	1
supplied with Intel's	1
Available from Intel	1
Available from www.agner.org/optimize/asmlib.zip.	1
Available protocols and	1
translated to the	1
translated to just	1
translated into machine	1
Linux: long int	1
Linux: unsigned long	1
Linux: -ffunction-sections) which	1
With the high	1
With a long	1
With a short	1
Has not been	1
Has an IDE	1
Has many good	1
overriding of public	1
overriding Intel's CPU	2
Opteron K8 0.24	1
Opteron K8 1.09	1
Opteron K8 0.38	1
systems". The parameters	1
systems". For this	1
systems". 7.16 Function	1
correct or if	1
correct result because	1
correct child class	1
caching. This problem	1
caching. Smaller microcontrollers	1
caching. 3.14 Context	1
overflow: // Example	1
overflow: a[i] =	1
overflow: _controlfp_s(&dummy, 0,	1
scans a string	1
scans all files	2
way: // Example	1
way: There are	1
way: bool a,	1
Sometimes the compiler	1
Sometimes it is	1
Sometimes it takes	1
-fno-builtin to get	1
-fno-builtin Gnu 32-bit	2
justify the method.	1
justify a possible	1
justify such a	1
contrary, the code	1
contrary, you should	1
contrary, each thread	1
conventions. The dot	1
conventions. Optimizes reasonably	1
conventions. FreeBSD and	1
initialization routine that	2
initialization routine sets	1
Internet at regular	1
Internet where you	1
Internet forums Several	1
cover the worst	2
cover graphics processors.	1
Constructors and destructors	2
Constructors are therefore	1
PC's and mainframes,	1
PC's in a	1
PC's had an	1
7.21 int i;	1
7.21 Runtime type	2
delays in the	1
delays if the	1
delays execution by	1
a); } }	2
a); } 111	1
c[i] are so	1
c[i] are too	1
c[i] = temp	1
cleaning up and	1
cleaning up because	1
cleaning up spaces	1
way, the first	1
way, then many	1
way, etc. The	1
Big arrays should	1
Big runtime frameworks.	1
Big supercomputers with	1
ZMM registers The	1
ZMM registers by	1
ZMM registers ..........................................................	1
coefficients is calculated	1
coefficients // Table	1
coefficients double Table[100];	1
DOS and Windows	1
DOS and 16-bit	1
DOS compilers). The	1
-fpie because the	1
-fpie option is	1
-fpie instead of	1
labels is simply	1
labels that have	1
labels follow a	1
6, 9 and	1
6, 24, 120,	2
ret returns from	1
ret ALIGN ;	1
ret ALIGN ?Func@@YAXQAHAAH@Z	1
Signed and unsigned	1
Signed / unsigned	1
Signed versus unsigned	1
logarithms and trigonometric	1
logarithms in the	1
logarithms take a	1
stored. The storage	1
stored. This makes	1
stored. All identical	1
manner. This applies	1
manner. It is	1
manner. 3.4 Automatic	1
Today, the 8	1
Today, the choice	1
Today, it is	1
easiest and the	1
easiest way to	2
pop ebx restores	1
pop ebx. 9	1
pop ret ALIGN	1
3.5 will be	1
3.5 Program loading	2
-S or /Fa	1
-S - masm=intel	1
-S Generate map	1
inlined. An alternative	1
inlined. But beware	1
inlined. (In the	1
cmp eax, 100	1
cmp jl $B1$3:	1
cmp ja $B2$3:	1
flow and the	1
flow and algorithms	1
flow at inconvenient	1
directives. This is	1
directives. For example	1
directives. OpenMP is	1
deallocated. The program	1
deallocated. Failure to	2
(128 or 256	1
(128 bit float	1
(128 vectors of	1
Programmers that have	1
Programmers very often	1
Programmers do, however,	1
focus the optimization	1
focus is on	1
focus on the	1
definition. This will	1
definition. This tells	1
definition. Inlining a	1
track of the	1
track of when	1
track backwards though	1
condition. In general,	1
condition. Replacing two	1
condition. Things that	1
s3 can be	1
s3 = 0,	1
s3 += a[i+3];	1
s2 and s3	1
s2 = 0,	1
s2 += a[i+2];	1
contemporary operating systems	1
contemporary processors. The	1
contemporary 106 CPUs	1
66 float a,	1
66 8.1 How	1
66 8.2 Comparison	1
probably the most	1
probably be improved	1
probably without information	1
longjmp is used	1
longjmp in time-critical	1
longjmp if possible.	1
2exponent 127 1	1
2exponent 16383 one	1
2exponent 1023 1	1
leads to the	1
leads to a	1
leads to suboptimal	1
Alignd ( short	3
improving the code.	1
improving code that	1
improving performance. Stefan	1
sizes. The results	1
sizes. For example:	1
sizes. Fortunately, the	1
....................................................................................................... 19 3.6	1
....................................................................................................... 21 3.10	1
....................................................................................................... 150 16	1
holds the index,	1
holds a memory	1
holds a precision	1
competing for the	1
competing brands of	1
competing product is	1
questions to me.	1
questions if you	1
questions from everybody.	1
register, not even	1
register, do an	1
register, add the	1
etc., and if	1
etc., can be	1
etc., as is	1
ReadTSC as a	1
ReadTSC function. 154	1
ReadTSC listed below	1
with: // Example	3
kernel in the	1
kernel version 2.6.30	1
kernel code" in	1
CPUs"). This is	1
CPUs"). This can	1
CPUs"). Const cast	1
j; int order(int	1
j; float x;	1
j; ... for	1
natural order and	1
natural parallelism. The	1
natural ordering? If	1
Examples are provided	1
Examples are image	1
Examples include JavaScript,	1
(iset >= 2)	1
(iset >= 8)	1
(iset >= 5)	1
F2 and call	1
F2 that can	1
F2 actually throws	1
moving the mouse.	2
moving each object	1
9.6b. The MOVNTQ	2
9.6b. #include "xmmintrin.h"	1
-O3 or (requires	1
-O3 or -Ofast	1
-O3 Interprocedural optimization	1
unusual for the	2
unusual that a	1
misses, branch mispredictions,	2
misses, branch misprediction,	1
Divide by constant	3
sorted list is	1
sorted list can	1
sorted list or	1
efficiency, then you	1
efficiency, platform independence,	1
efficiency, portability and	1
same. The maximum	1
same. This is	1
same. If the	1
(STL) is a	1
(STL) if the	1
(STL) which comes	1
rid of the	2
rid of all	1
ms for background	1
ms for foreground	1
ms by selecting	1
arrays, a and	1
arrays, it may	1
arrays, then it	1
matrix[r][c] is swapped	1
matrix[r][c] below the	2
issue to catching	1
issue an error	1
issue because an	1
solve this problem	1
solve this problem.	1
solve all the	1
since the CPU	1
since we are	1
since 2004. Can	1
beyond the scope	3
readable and not	1
readable when you	1
readable but unfortunately	1
infinity or NAN	2
infinity or NAN.	1
bookkeeping is needed:	1
bookkeeping in order	1
bookkeeping depends very	1
formula in each	1
formula into a	1
formula a[i] =	1
technical problems or	1
technical details of	1
technical problems. Some	1
instr. set AVX	1
instr. set Automatic	1
instr. set SSE4.1	1
specified on a	1
specified instruction set.	1
specified types (See	1
organizing the data	1
organizing the data.	1
organizing data into	1
9.5a on a	1
9.5a const int	1
9.5a goes from	1
false, a ||	2
false, then the	1
open the possibility	1
open source compiler	1
open source. It	1
decomposition of the	1
decomposition and data	1
decomposition here means	1
measuring the time	1
measuring the overall	1
measuring performance by	1
File access Reading	1
File input/output Graphics	1
File access................................................................................................................ 20	1
negligible when the	1
negligible because there	1
negligible contribution to	1
took several minutes	1
took advantage of	1
took 50 clock	1
on. Most IDE's	1
on. Replace or	1
on. 7.31 Other	1
Hyperthreading is Intel's	1
Hyperthreading Some versions	1
Hyperthreading ..................................................................................................... 103	1
30 // f	1
30 ms for	1
30 Overflow behaves	1
initially points to	3
occur. The reason	1
occur. In the	1
occur. See page	1
Strings can be	1
Strings Text strings	1
Strings ...................................................................................................................... 96	1
Preprocessing directives .........................................................................................	1
Preprocessing directives Preprocessing	1
Preprocessing directives (everything	1
utilize the multiple	1
utilize the computational	1
utilize systems with	1
(0,0,0,0,0,0,0,0) __m128i zero	2
(0,0,0,0,0,0,0,0) Is16vec8 zero(0,0,0,0,0,0,0,0);	1
38 // Example	1
38 7.11 Type	1
38 7.10 Arrays	1
reference. This will	1
reference. A const	1
reference. Registers are	1
FUNCNAME SelectAddMul_SSE41 #elif	1
FUNCNAME SelectAddMul_SSE2 #elif	1
FUNCNAME SelectAddMul_AVX2 #endif	1
history of that	1
history of CPU	1
history of programming	1
CChild2 * p2;	1
CChild2 : public	1
CChild2 Object2; CChild1	1
bit: // Example	2
bit: absvalue =	1
forums and newsgroups	1
forums on the	1
forums Several internet	1
addressing of data.	3
1024; int a[size],	2
1024; struct Sab	1
C#, Visual Basic	1
C#, Visual Basic,	1
C#, managed C++,	1
allocating more space	1
allocating when a	1
allocating piecewise or	1
a+b is calculated	1
a+b = b+a	1
a+b = b+a,	1
taken into account	3
microprocessor. These algorithms	1
microprocessor. Integer division	1
microprocessor. Multiplication takes	1
argument is that	1
argument to be	1
argument does not	1
Func1 and Func2	1
Func1 when compiling	1
Func1 (int a[],	1
Unix-like systems use	1
Unix-like systems. Mac	1
Unix-like platforms. Clang	1
----- - x-xxx	1
----- x---- x----	1
----- ~(~a)=a x-xxxxx--	1
2.5 may be	1
2.5 Choice of	2
read-only can be	1
read-only data sections	1
read-only data. The	1
well-structured code and	1
well-structured program that	1
well-structured C++ program	1
represent the "worst	1
represent a known	1
represent a monotonically	1
elsewhere. In this	1
elsewhere. Faster than	1
elsewhere. 13.5 Implementation	1
micro-op cache (e.g.	1
micro-op cache. The	1
micro-op cache. Compilers	1
best. Some common	1
best. These cases	1
best. 3.11 Other	1
returning a composite	1
returning a null	1
returning from the	1
Long double precision	2
Long dependency chains	1
r1; c2 <	1
r1; c1 +=	1
r1; r2 <	1
CPU- specific functions	1
CPU- specific optimizations	1
CPU- specific profiler.	1
top of loop	3
decide to do	1
decide which programming	1
decide how advantageous	1
other. This is	1
other. See page	2
brackets in which	1
brackets mean use	1
brackets index, just	1
2004. No differences	1
2004. Open Watcom	1
2004. Can do	1
odd and you	1
odd number then	1
odd here. The	1
7.7 unsigned int	1
7.7 Function pointers	2
Documentation of the	1
Documentation for details.	1
Documentation License shall	1
prone. The vectorized	1
prone. A discussion	1
prone. All these	1
compile- time if	1
compile- time loops	1
compile- time, but	1
Global or static	1
Global variables are	1
Global variables may	1
lookups for local	1
lookups are needed	1
lookups Max. number	1
Whole program optimization	3
a*b = b*a	2
a*b - n.a.	1
linker. The delay	1
linker. The map	1
linker. Both code	1
security. b &	1
security. There are	1
security. Standard C++	1
lookup. For example:	1
lookup. These instructions	1
lookup. Lookup tables	1
78 for an	2
78 Therefore, it	1
handled in a	1
handled at half	1
handled separately: for	1
a[], int *	1
a[], int &	2
implicitly when copying	1
implicitly when calculating	1
implicitly converting a	1
terminating a thread.	1
terminating zero and	2
_WIN32 n.a. MS	1
_WIN32 Linux platform	1
_WIN32 _WIN32 Linux	1
(2n / b)	3
measures the number	1
measures the speed	1
measures not only	1
multiplications. The following	1
multiplications. How was	1
multiplications. Subtractions use	1
intensive may very	1
intensive program is	1
intensive applications. Some	1
moved with a	1
moved out of	2
ReadTSC() - time1;	1
ReadTSC() { int	1
ReadTSC() from library	1
valid. For example,	1
valid. For example:	1
valid. Re-interpreting the	1
b[size]; // set	2
b[size]; // ...	1
Not all code	1
Not optimized for	1
Not optimized as	1
none of the	3
"what is the	1
"what works best	2
Comparing an integer	1
Comparing two pointers	1
Comparing performance of	1
instructions, but these	1
instructions, multiple cores,	1
instructions, where a	1
Microprocessor documentation Intel:	1
Microprocessor designers have	1
Microprocessor producers keep	1
metaprogramming. The next	1
metaprogramming. Don't panic	1
metaprogramming. None of	1
Size of each	3
metaprogramming, as explained	1
metaprogramming, but this	1
metaprogramming, loops are	1
bypass the CPU	1
bypass the virtual	1
bypass the check	1
output. The assembly	1
output. The optimized	1
output. On most	1
........................................................................................... 5 2.1	1
........................................................................................... 6 2.3	1
........................................................................................... 139 14.7	1
numerically largest element	3
expression. The size	1
expression. Example 12.4b	1
expression. Assume, for	1
.......................................................................................................... 120 13	1
.......................................................................................................... 164 1	1
.......................................................................................................... 38 7.10	1
InstructionSet() function is	1
InstructionSet() #include "asmlib.h"	2
Eliminate branches Remove	1
Eliminate jumps Eliminate	1
Eliminate jumps Jumps	1
backup copy of	1
backup copying without	1
backup features, and	1
13.6 CPU dispatching	2
13.6 80.9 512	1
Get supported instruction	2
Get upper 32	1
throw an exception	1
throw any exception	1
throw exceptions throw()	1
More complicated cases	1
More examples of	1
More details about	1
---x----- x -	1
---x----- x--xx---- (a&&b)||(a&&!b)=a	1
---x----- x---x---x x-xxx----	1
_mm_loadu_si128((__m128i const*)p); }	2
_mm_loadu_si128((__m128i const*)p);} //	1
Before you start	2
Before starting a	1
Applications that are	1
Applications that use	1
Applications that generate	1
25 clock cycles,	1
25 7 The	1
25 Since most	1
AVX-512 instruction set	3
23 5 Choosing	1
23 software. This	1
23 , doublevalue	1
evict the cache	1
evict number 1.	1
evict number 2,	1
Copying the table	1
Copying or clearing	1
Copying constant data	1
(x = 0;	2
(x = 2.0;	1
being out of	1
being initialized. The	1
being said, I	1
sum, then the	1
sum, then f	1
sum, initialize to	1
unrolled to avoid	1
unrolled loop takes	1
unrolled double xpow10(double	1
slow. If the	1
slow. Today, the	1
slow. Value of	1
StoreVector(aa + i,	3
7.11 bool a;	1
7.11 Type conversions	1
7.11 Type conversions....................................................................................................	1
market the application	1
market is developing	1
market for many	1
vectors, and these	1
vectors, as is	1
vectors, but the	1
resource. The C++	1
resource. The CISC	1
resource. Do not	1
Architecture Software Developer’s	2
Architecture Programmer’s Manual",	1
7.12 void FuncA	1
7.12 Branches and	2
limited. There are	1
limited. Example: //	1
limited. Dynamic memory	1
11.3 is independent	1
11.3 const int	1
11.3 even without	1
typedef int CriticalFunctionType(int	1
typedef void FuncType(short	1
typedef instead of	1
0x2700 to 0x273F	3
Replace or bypass	1
Replace macro by	1
Replace with: //	1
Instead, the following	1
Instead, you can	1
Instead, I will	1
frameworks, rather than	1
frameworks, intermediate code,	1
frameworks, interpreters, just-in-time	1
*(p++) is more	1
*(p++) |= 0x20;	2
(Intel CPU only)	2
(Intel Atom). The	1
nearby address again	1
nearby parts of	1
nearby branches. The	1
fragmented. This makes	1
fragmented. This garbage	1
fragmented. An alternative	1
truncation. The missing	1
truncation. This is	1
truncation. Efficient conversion	1
Different compilers behave	1
Different kinds of	2
logarithm of each	1
logarithm would be	1
logarithm again, but	1
Day for signifying	1
Day == Wednesday	1
Day == Friday)	1
ported to multiple	1
ported to systems	1
ported to another	1
inline. This may	1
inline. This will	1
inline. Replacing a	1
big. The compiler	1
big. In the	1
big. 7.14 Functions	1
deallocation of memory	1
deallocation of big	1
deallocation and garbage	1
(PLT) and a	1
(PLT) in the	1
(PLT) that is	1
7.22 short int	1
7.22 Inheritance An	1
7.22 Inheritance ..............................................................................................................	1
Context switches are	1
Context switches A	1
Context switches..................................................................................................... 22	1
7.23 int i;	1
7.23 Constructors and	2
services that run	1
services only when	1
services under advanced	1
7.20 int i;	1
7.20 Virtual member	2
extremely complicated and	1
extremely costly to	1
extremely inefficient, (4)	1
kb = 8192	1
kb size with	1
kb / 8	1
joining the operations:	1
joining a and	1
joining identical pieces	1
decrement operators The	1
decrement operators on	1
decrement operators. 7.7	1
0x1C. If the	1
0x1C. There are	1
0x1C. Reading or	1
free. This can	1
free. These operators	1
free. Visual Studio	1
Check that all	1
Check that index	1
Check if level-2	1
double, then the	1
double, then sizeof(S1)	1
double, bool, enum	1
periodic pattern can	2
periodic pattern or	1
7.27 float x;	1
7.27 Overloaded operators	2
7.24 float a;	1
7.24 Unions A	1
7.24 Unions ....................................................................................................................	1
product is one	1
product is Borland's	1
product makes sure	1
7.25 unsigned int	1
7.25 Bitfields Bitfields	1
7.25 Bitfields ...................................................................................................................	1
7.28 class c1	1
7.28 Templates A	1
7.28 Templates...............................................................................................................57 7.29	1
references, and stack	1
references, which can	1
references, 'this' pointer,	1
CPUs" for an	2
CPUs" gives more	1
experience to get	1
experience before trying	1
experience unacceptably long	1
determine the worst-case	1
determine if the	1
determine whether it	1
<typename T, unsigned	1
<typename T> static	1
<typename MyChild> class	1
Generate optimization report	1
Generate assembly listing	1
Generate map file	1
certainly a very	1
certainly more convenient	1
certainly something that	1
Devirtualization class C0	1
Devirtualization An optimizing	1
Devirtualization ---x----- x	1
pivot in a	1
pivot element. The	1
pivot search: //	1
__declspec( align(16)) __attribute((	2
__declspec( noalias) __restrict	1
mispredictions if the	1
mispredictions by making	1
mispredictions (see page	1
a[100], b; for	1
a[100], b, temp;	1
a[100], temp; temp	1
allocations is limited.	1
allocations of large	1
allocations of sizes	1
necessary, to fit	1
necessary, by using	1
necessary, each compiled	1
9.4 const int	1
9.4 Variables that	2
float. The type	1
float. (Both use	1
float. Similar operations	1
1.0f;} The compiler	1
1.0f;} The advantages	1
1.0f;} 66 float	1
indeed a very	1
indeed of the	1
indeed vectorized as	1
9.1 show that	1
9.1 Caching of	2
(not a number).	1
(not member of	1
(not up to	1
built-in code is	1
built-in code instead	1
built-in test feature	1
n. The constant	1
n. You can	1
n. But not	1
complete code examples	1
complete redesign of	2
(x) x x	1
(x) x (x)	1
(x) x-xx--xx- x--x-----	1
ecx, 1 eax,	1
ecx, DWORD PTR	1
ecx, edx, DWORD	1
modified. This can	2
modified. Unlike a	1
folding and constant	2
folding - n.a.	1
expects a GOT	1
expects an immediate	1
expects immediate responses	1
Call to virtual	1
Call critical function	2
joined into a	1
joined into one	1
joined together in	1
classes, as explained	1
classes, such as	1
classes, templates or	1
compute a /	1
compute (FuncRow(i)*columns +	1
compute i/2 in	1
interpreting the same	2
interpreting or compiling	1
LIBM libraries are	1
LIBM library. Only	1
LIBM Library amd_vrs4_expf	1
accesses to functions	1
accesses data members	1
accesses b through	1
$B1$2 is the	1
$B1$2 ebx ;	1
$B1$2 label if	1
copying. The benefits	1
copying. There are	1
copying. Security. The	1
Volume 1 -	1
Volume 1, 2A,	1
Volume 2A and	1
placed in a	1
placed in separate	1
placed immediately before	1
spot. Use the	1
spot. Sometimes, the	1
spot. Repeating the	1
variable, for example	1
variable, it makes	1
variable, pointer or	1
jumping out of	2
jumping around and	1
compared to the	1
compared to 32	1
compared with the	1
3-dimensional vectors RGB	1
3-dimensional vectors .......................................................	1
3-dimensional geometry and	1
x. The compiler	1
x. This is	1
x. It is	1
a. This operation	1
a. You can	1
a. I don't	1
post-increment. The effect	1
post-increment. There are	1
post-increment. For example,	1
sufficient to have	1
sufficient to make	1
sufficient for less	1
evicted when we	1
evicted from the	1
evicted before we	1
flags on certain	1
flags register into	1
flags stall because	1
Sum2 and Sum3	2
Sum2 and Sum3.	1
(2,2,2,2,2,2,2,2) __m128i two	2
(2,2,2,2,2,2,2,2) Is16vec8 two(2,2,2,2,2,2,2,2);	1
[edx] DWORD PTR	1
[edx] DWORD PTR[ecx+eax*4],ebx	1
[edx] adds, not	1
7.14 class c1;	1
7.14 Functions Function	1
7.14 Functions ................................................................................................................	1
7.16 float list[100];	1
7.16 Function return	2
7.17 const int	1
7.17 Structures and	2
templates. The powN	1
templates. Two or	1
templates. Ready made	1
7.13 struct abc	1
7.13 Loops The	1
7.13 Loops...................................................................................................................... 45	1
7.19 int i;	1
7.19 Class member	2
beware of the	1
beware that these	1
beware that macro	1
7.18 int FuncRow(int);	1
7.18 Class data	2
card for other	1
card or integrated	1
(4) access the	1
(4) get a	1
elements: #define swapd(x,y)	2
viable solution in	1
viable compromise when	1
7.10 Arrays An	1
7.10 Arrays .....................................................................................................................	1
_mm_set1_epi16(2); // Roll	2
templates, as explained	1
templates, such as	1
complexity of modern	1
complexity (en.wikipedia.org/wiki/Standard_Template_Library). The	1
511 511 2040	1
511 2040 38.7	1
Member pointers In	1
Member pointers.......................................................................................................37 7.9	1
modifying the name	1
modifying only half	1
undesired results. Integer	1
undesired effects. This	1
7.15 Function parameters	2
symbol interposition is	1
symbol interposition feature	1
problematic because there	1
problematic because these	1
invest in ever	1
invest more efforts	1
memcpy, at least	1
memcpy, memmove, memset,	1
Sum3 in 32-bit	1
Sum3 are doing	1
Pure functions A	1
Pure function. __attribute__((const))	1
impossible to work	1
impossible with references.	1
B1; class B2;	2
forwarding delay in	2
storage, but other	1
storage, far pointers,	1
107). The Gnu	1
107). Agner's vector	1
64) can improve	1
64) % 32	1
static. This makes	1
static. Example: //	1
_M_X64 _M_X64 162	1
_M_X64 162 19	1
CriticalFunction(); ... //	1
CriticalFunction(); timediff[i] =	1
x-xxx---x x -	1
x-xxx---x x-xxx---x x	1
shown in the	1
shown in example	1
lack the necessary	1
lack of advanced	1
a2 * b1	1
a2 / b2;	1
a1 * b2	1
a1 / b1;	1
16) { b.load(bb+i);	1
16) shows that	1
debugger. You may	1
debugger. However, the	1
mostly compatible with	1
mostly relative references	1
a) { return	2
ptr x; __asm	1
ptr n; #endif	1
fastcall functions The	1
fastcall modifier can	1
accumulators for floating	1
accumulators if there	1
aliasing" if you	1
aliasing" (if valid)	1
Implementation The CPU	1
Implementation ..................................................................................................... 126	1
significantly simply by	1
significantly just by	1
parallelism. The way	1
parallelism. The gain	1
479001600}; if ((unsigned	1
479001600}; ... int	1
"Performance Optimization of	2
type-casted to a	2
x4 = x2	1
x4 = x2*x2;	1
frequency. The core	1
frequency. For example,	1
interpretation or compilation	1
interpretation on the	1
(chapter 11) and	1
(chapter 12) are	1
research, not on	1
research, I have	1
SIAM 2001. 9.11	1
SIAM 2001. Advanced	1
a[i+1] = Induction;	2
x-xxx---- a-(-b)=a+b a-a	1
x-xxx---- a*b*c=a*(b*c) a+b+c+d	1
send data from	1
send your programming	1
string[100], *p =	2
SSSE3 a few	1
SSSE3 _mm_perm_epi8 32	1
expressions, but no	1
expressions, even though	1
CriticalFunctionType * CriticalFunction	1
CriticalFunctionType CriticalFunction_Dispatch; //	1
71). The conclusion	1
71). In this	1
ASCII string to	1
ASCII form. A	1
overlapping or aliasing,	1
overlapping calculations. The	1
computationally intensive may	1
computationally intensive program	1
executes a series	1
executes three to	1
window of a	1
window or makefile.	1
ten times and	1
ten years old.	1
Structure of 4	1
Structure and class	1
jobs. The context	1
jobs. For example,	1
please don't send	1
please install this	1
Unions A union	1
Unions .................................................................................................................... 55	1
AMD: "Software Optimization	1
AMD: "AMD64 Architecture	1
((a*x+b)*x+c)*x+d x*x*x*x*x*x*x*x =	2
9.2 Cache organization	2
1024 bits is	1
1024 bytes, so	1
programmed. But if	1
programmed. Therefore, it	1
Aligned arrays //	1
Aligned operands means	1
past the end	1
past history of	1
9.6 Dynamic memory	2
object's class or	1
object's class. Make	1
b2, y1, y2;	1
b2, y1, y2,	1
partial template specialization	1
partial flags stall	1
(a+b)+(c+d) a*b+a*c=a*(b+c) a*x*x*x	2
(16 or 32	1
(16 bits), unless	1
xor mov $B1$2:	1
xor eax,eax. This	1
again, that most	1
again, but it	1
9.9 Access data	2
resolve any branch	1
resolve compatibility problems.	1
context. The keyword	1
context. It is	1
(May use a	2
131. Intel Performance	1
131. AMD LIBM	1
goal is to	1
goal of 18	1
discovered that there	1
discovered that many	1
Exp(float x) {	2
9.8 Strings Text	1
9.8 Strings ......................................................................................................................	1
_MSC_VER and not	1
_MSC_VER // If	1
16.3 Worst-case testing	2
chance of going	1
chance that the	1
manipulated to fake	1
manipulated with C	1
c+b can be	1
c+b will generate	1
override the CPU	1
override public symbols,	1
branches, as explained	1
branches, provided that	1
applications, but it	1
applications, but not	1
developed a test	1
developed as C++	1
7.29 Threads Threads	1
7.29 Threads ..................................................................................................................	1
CriticalFunction. If your	1
CriticalFunction. You cannot	1
discusses how to	2
#elif INSTRSET ==	2
7.26 Overloaded functions	2
"Instruction tables". There	1
"Instruction tables". Tips	1
400 bytes. first	1
400 here. Any	1
invariant code motion	2
c*x + d	2
carefully to make	1
carefully optimized and	1
CriticalInnerFunction is called.	1
CriticalInnerFunction () {	1
a/1=a xxxxxxxxx 0/a=0	1
a/1=a x-xxx-x-- 0/a=0	1
__m128 defines a	1
__m128 s; s	1
operator; and you	1
operator; you can	1
subexpression. A constant	1
subexpression. For example,	1
freed when the	1
freed before the	1
operator, or an	1
operator, which can	1
p->Hello(); } //	1
p->Hello(); p =	1
CPUs: use the	1
CPUs: An optimization	1
0's when false.	1
0's gives zero.	1
chip that can	1
chip can be	1
operator. The code	1
operator. The &	1
proceed in a	1
proceed unattended. Uninstallation	1
CriticalFunction_386(int parm1, int	2
scientific vector processors.	1
scientific computing, but	1
biased allows us	1
biased binary integer,	1
minor error in	1
minor increase in	1
screen. There is	1
screen. However, such	1
market. But the	1
market. Such a	1
aligned(16))) Assume pointer	1
aligned(16))) __declspec( align(16))	1
justified in case	1
justified for general	1
exit the loop.	1
exit may not	1
cos(x); } z	1
cos(x); z =	1
having the same	1
having different types.	1
for-loop or while-loop	1
for-loop has three	1
char, short int,	1
char, signed or	1
a/a=1 --------x a/1=a	1
a/a=1 ----x---x a/1=a	1
legal issue. See	1
legal issue, as	1
resource, such as	1
resource, especially in	1
parallelization. The Gnu,	1
parallelization. Supports vector	1
keeping a CPU	1
keeping data together.	1
sampling: The profiler	2
12.5. Vector classes	1
12.5. Aligned arrays	1
reduces the code	1
reduces example 15.1a	1
non-member functions. 80	1
non-member function, means	1
vectorized, because a	1
vectorized, but the	1
y=temp;} // Check	1
y=temp;} int r,	1
influences in order	1
influences are removed,	1
explains the logic	1
explains why bookkeeping	1
emulate the while	1
emulate a 256-bit	1
four, we will	1
four, depending on	1
believe that the	1
believe that software	1
stdint.h or inttypes.h	1
stdint.h char 8	1
elimin., integer Common	1
elimin., float Register	1
instance. The function	1
instance. Non-static members	1
TransposeCopy(double a[SIZE][SIZE], double	2
insufficient information about	1
insufficient amount of	1
dangers of a	1
dangers to be	1
aligned. It is	1
aligned. See page	1
external libraries. www.agner.org/optimize/#vectorclass	1
external clock. This	1
"Error: Index out	2
smmintrin.h (Gnu) AES,	1
smmintrin.h SSE4.2 nmmintrin.h	1
frameworks. The .NET	1
frameworks. This is	1
Monday, etc. are	1
Monday, Tuesday, Wednesday,	1
X, 32-bit and	1
X, unless you	1
GNU General Public	1
GNU Free Documentation	1
127. The Intel	1
127. The calculation	1
FuncType * SelectAddMul_pointer	1
FuncType SelectAddMul, SelectAddMul_SSE2,	1
C1::f } 73	1
C1::f directly without	1
Splitting up a	2
Algorithms that are	1
Algorithms that rely	1
-mAVX /arch:AVX /QaxSSE3,	1
-mAVX -axSSE3, etc.	1
worry about loss	1
worry much about	1
instruction. The CPU	1
instruction. Programmers that	1
x^2 // x^4	1
x^2 float x4	1
disabled in the	1
disabled will crash	1
CPU-specific and each	1
CPU-specific versions of	1
8.26b void Func(int	1
8.26b compiled to	1
preprocessing directives that	1
preprocessing macro INSTRSET	1
strides. Therefore, you	1
strides. Uncached memory	1
15. If i	1
15. C++ is	1
develop and market	1
develop and publish	1
Full template specialization	2
(N & N-1)==0	1
(N & (N-1))	1
Enable the AVX	1
Enable exception for	1
cases: The CPU	1
cases: If part	1
non-AVX code because	1
non-AVX code. This	1
a+(b+c) - n.a.	1
a+(b+c) - a*b+a*c	1
mouse. The .NET	1
mouse. This task	1
www.amd.com. 163 Internet	1
www.amd.com. Advices on	1
-56 which will	1
-56 rather than	1
difficult. The functions	1
difficult. On the	1
-msse3 -mssse3 -msse4.1	1
-msse3 /arch:SSE3 -mssse3	1
(32-bit or 64-bit	1
(32-bit mode): ;	1
values. The choice	1
values. Which of	1
/arch:SSE2 -msse2 SSE3	1
/arch:SSE2 -msse2 /arch:SSE2	1
Vec8s 16 8	1
Vec8s a, b,	1
CParent is a	1
CParent : public	1
Adding the compiler	1
Adding 1 to	1
developer.intel.com. Many advices	1
developer.intel.com. AMD: "AMD64	1
frame- pointer No	1
frame- pointer -fomit-	1
<stdio.h> // define	1
<stdio.h> #include <asmlib.h>	1
9.11 Explicit cache	2
relocations in the	2
NAN (not a	1
NAN (Not A	1
9.10 Cache contentions	2
2" The dispatching	1
2" Here CParent	1
sum; for (int	1
sum; } Here,	1
12.10 Conclusion There	1
12.10 Conclusion ..........................................................................................................	1
semaphores, mutexes, etc.	1
semaphores, mutexes and	1
Multiplication and division	1
Multiplication takes 4	1
N&(N-1) is 0.	1
N&(N-1) gives the	1
assembly: ALIGN 4	2
regularly. Intel: "Intel®	1
regularly. AMD: "Software	1
vacant then the	1
vacant spaces. This	1
early implementations of	1
early planning stage	1
non-polymorphic functions in	1
non-polymorphic member functions.	1
3.3; // Polynomial	1
3.3; double Table[100];	1
users. In some	1
users. Firewalls, virus	1
extern "C" int	1
extern "C" declaration	1
heap. The space	1
heap. The heap	1
formats can be	1
formats should be	1
ruled out or	1
ruled out by	1
reused again and	1
reused elsewhere. In	1
Organize the data	2
CParent<CChild1> { has	1
CParent<CChild1> { public:	1
14.12b and 14.13b	1
14.12b int list[300];	1
types: long long,	1
types: char, short	1
FDIV bug is	1
FDIV bug causes	1
decimal point is	1
decimal point in	1
nfac = 1.f;	1
nfac *= n+1;	1
connections. Open files	1
connections. Temporary files	1
PC. Nevertheless, it	1
PC. Similarly, we	1
hacks and direct	1
hacks that violate	1
24 6 Development	1
24 dramatically for	1
suffer from poor	1
suffer from mispredictions.	1
throw. It is	1
throw. In fact,	1
differently. The link	1
differently. A negative	1
align(16)) __attribute(( aligned(16)))	2
element, bits Number	2
Often, it is	1
Often, it takes	1
Replacing a function	1
Replacing two comparisons	1
b*x*x + c*x	2
language". The method	1
language". While we	1
that's about the	1
that's what they	1
13.3 Difficult cases	1
13.3 Difficult cases........................................................................................................	1
inherent performance costs	1
inherent support for	1
-static Generate assembly	1
-static /MT 160	1
ArrayOfStructures[100]; This reordering	1
ArrayOfStructures[100]; Here, there	1
13.2 Model-specific dispatching	2
comparison is likely	1
comparison of doubles	1
hint and the	1
hint about no	1
13.5 Implementation The	1
13.5 Implementation .....................................................................................................	1
13.4 Test and	2
13.7 CPU dispatching	2
code" in manual	1
code" actually implies	1
course. A branch	1
course. It is	1
<dvec.h> // Define	2
loop, the if	1
loop, for example	1
number, or no	1
number, which is	1
case: // Example	2
rolling out the	2
loop: for (i	1
loop: // Example	1
2.0f; } 115	1
2.0f; x.i |=	1
52. The member	1
52. You may	1
supporting multiple platforms	1
supporting multi-threaded software	1
thrown by F2	1
thrown exceptions are	1
invoking the compiler	1
invoking the overhead	1
{1, 1, 2,	2
construct an object	1
construct obscure examples	1
compiled. This is	1
compiled. #if directives	1
transpose(double a[SIZE][SIZE]) {	2
Checking what the	2
elimination, constant propagation,	2
StringLength; for (i	1
StringLength; i >	1
integration, mixed language	1
integration, web application	1
kilobytes at a	1
kilobytes Time per	1
got low priority.	1
got RISC cores,	1
locally in the	1
locally or remotely.	1
it, for example	1
it, it may	1
32. This is	1
32. In 64-bit	1
minimum value maximum	1
minimum supported instruction	1
thread-specific data is	1
thread-specific data and	1
a[2]; for (i	1
a[2]; a[0] =	1
can't be reached	1
can't have public	1
Vec4f polynomial (Vec4f	1
Vec4f Vec2d Vec8f	1
(2) use unsigned	1
(2) find the	1
paragraph and manual	1
paragraph described a	1
remain unchanged. The	1
remain locked after	1
scanners to consume	1
scanners and other	1
calculates the sum	1
calculates four consecutive	1
databases, etc. The	1
databases, network and	1
C++". Addison-Wesley, 1996.	1
C++". Addison-Wesley. Third	1
2008 version). This	1
2008 R2 as	1
/Gy -ffunction- sections	2
Assuming that the	1
Assuming that processor	1
search, is fast	1
search, or even	1
......................................................................... 128 13.7	1
......................................................................... 130 14	1
constructs are costly	1
constructs Most programmers	1
screen resolutions, different	1
screen resolutions, etc.	1
Loops The efficiency	1
Loops with a	1
Plus2 (int *	1
Plus2 (&a); The	1
a*0 = 0	2
a*1 = a	2
"vectorclass.h" // vector	1
"vectorclass.h" // Define	1
b[size], i; ...	1
b[size], c[size]; float	1
Table[100]; int x;	2
describe some of	1
describe various ways	1
GOT. The symbol	1
GOT. Another possibility	1
dynamic_cast more time-consuming	1
dynamic_cast operator is	1
Finding the biggest	2
120, 720, 5040,	2
uninitialized or come	1
uninitialized variables that	1
77 Pointer aliasing	1
77 8.4 Obstacles	1
string. The old	1
string. In the	1
74 x x	1
74 8.3 Obstacles	1
73 and 72	1
73 Without optimization,	1
Object2; CChild1 *	1
Object2; CHello *	1
destination both have	1
destination array. But	1
lookup: // Example	2
72 for discussions.	1
72 This may	1
(Tuesday | Wednesday	2
b:2; int c:2;	2
string; int i,	1
string; while (*p	1
putting the right	1
putting the smallest	1
14.14b double a,	1
14.14b automatically but	1
non- standardized details	1
non- sequential order.	1
15.1c. We can	1
15.1c. Calculate integer	1
73). It is	1
73). Current compilers	1
....................................................... 20 3.7	1
....................................................... 120 12.10	1
mutexes, etc. is	1
mutexes, database connections,	1
volatile. The volatile	1
volatile. This prevents	1
relocation. The DLLs	1
relocation. All public	1
(~a&c) | (b&c)	1
(~a&c) a&b&c&d =	1
90% of the	1
90% chance that	1
MultiplyBy in this	1
MultiplyBy (int x)	1
suited for the	1
suited for vector	1
Developer’s Manual", Volume	2
y1, y2; y1	1
y1, y2, reciprocal_divisor;	1
14.14a with 14.14b	1
14.14a double a,	1
settings and different	1
settings are lost.	1
Compile for a	1
Compile once for	1
Provoke cache misses	1
Provoke branch mispredictions	1
import table and	1
import table or	1
turns out to	2
0x4700. These addresses	1
0x4700. Reading again	1
x---- ----- ~(~a)=a	1
x---- x---- -----	1
Overcoming the drawbacks	2
a*1=a (-a)*(-b)=a*b a/a=1	1
a*1=a x-xxxxx-x (-a)*(-b)=a*b	1
Take the example:	1
Take user feedback	1
shuffling, such as	1
shuffling, packing, unpacking	1
priorities to different	1
priorities then the	1
range"; } else	1
range"; 134 }	1
corrections and suggestions	1
corrections for sign	1
safe. This safety	1
safe. In other	1
supported. The calculation	1
supported. For example,	1
anonymous object. The	1
anonymous namespace. 3.	1
pure. This allows	1
pure. Virtual functions	1
SSE4.2 string search	1
SSE4.2 nmmintrin.h (MS)	1
clock; } //	1
clock; __cpuid(dummy, 0);	1
12.4a where current	1
12.4a so that	1
matrices, clock cycles	2
inconsistent and sometimes	1
inconsistent results if	1
bc); // Store	1
bc); // OR	1
join all source	1
join them into	1
range. The next	1
range. This may	1
c:2; }; char	1
c:2; }; Bitfield	1
Value of a	1
Value of b	1
CGrandParent { public:	2
two); // Multiply	2
-- - -	1
-- - xx	1
bypassed by any	1
bypassed when the	1
drivers, interrupt service	1
drivers, configuration files	1
-0 } It	1
-0 (zero with	1
accelerator card for	1
accelerator card. Some	1
3.10 Graphics A	1
3.10 Graphics .................................................................................................................	1
3.11 Other system	2
increases the size	1
increases the amount	1
3.13 Memory access	1
3.13 Memory access.......................................................................................................	1
3.14 Context switches	1
3.14 Context switches.....................................................................................................	1
3.15 Dependency chains	2
3.16 Execution unit	2
Sum1 has an	1
Sum1 slightly more	1
a*x*x*x + b*x*x	2
0x20; If the	1
0x20; 46 A	1
TILESIZE // Loop	1
TILESIZE = 8;	1
expression, or first	1
expression, but none	1
consumers ................................................................................ 16	1
consumers 3.1 How	1
CPU, an insufficient	1
CPU, which counts	1
&Object1; p1->Hello(); CChild2	1
&Object1; p->NotPolymorphic(); p->Hello();	1
............................................................................. 158 18	1
............................................................................. 84 9	1
exp(x) for small	2
programming. The CPU	1
programming. 13.3 Difficult	1
time1; // This	1
time1; long long	1
events, for example	1
events, such as	1
achieved more efficiently	1
achieved when none	1
<emmintrin.h> // Define	1
<emmintrin.h> static inline	1
2.8 Overcoming the	2
answers to your	1
answers in the	1
starting a new	1
starting and stopping	1
disadvantages: The unrolled	1
disadvantages: It is	1
2.3 Choice of	2
ahead of time	2
inserted in the	1
inserted UnusedFiller in	1
2.2 Choice of	2
/arch:SSE -msse SSE2	1
/arch:SSE -msse /arch:SSE	1
2.1 Choice of	2
2.0 This method	1
2.0 / 3.0;	1
40320, 362880, 3628800,	2
Func(int); const int	2
invalidate the cache.	1
invalidate each other's	1
opposite of register	1
opposite order of	1
itself, and the	1
itself, during installation	1
2.7 Choice of	2
a[1000]; float b[1000];	1
a[1000]; F1(a); }	1
2.6 Choice of	2
S. Goedecker and	1
S. Warren, Jr.:	1
environment block. Thread-local	1
environment (IDE) supports	1
F2(b); } }	2
handles this code.	1
handles eight elements	1
2.4 Choice of	2
note that this	1
note that my	1
others are not.	1
others have done	1
needs. The search	1
needs. 9.8 Strings	1
sar add mov	1
sar ebx,1 adds	1
("internal"))) __attribute__ ((visibility	1
("internal"))) Vectorize #pragma	1
8.15a were float	1
8.15a struct S1	1
footprint is unreasonably	1
footprint than the	1
14.13b int list[300];	1
14.13b works only	1
namespaces. Therefore, you	1
namespaces. 65 8	1
preventing program errors	1
preventing illegitimate copying.	1
Lowest version int	2
Saturday = 0x40	1
Saturday }; Weekdays	1
a*b+a*c=a*(b+c) a*x*x*x +	2
resolutions, different system	1
resolutions, etc. Accessibility	1
So the address	1
So please don't	1
9.6a const int	1
9.6a Time per	1
a*(b+c) - n.a.	1
a*(b+c) - -(-a)	1
events that are	1
events as task	1
__fastcall. The implicit	1
__fastcall. Function parameters	1
a+0 = a	2
Delays in program	1
Delays or glitches	1
Report on C++	2
(bb[i] * cc[i]);	1
(bb[i] > 0)	1
specified. The code	1
specified. Insert an	1
prototype to tell	1
prototype CriticalFunctionType CriticalFunction_Dispatch;	1
39 shows how	1
39 matrix[i][j] +=	1
let's look at	1
let's say that	1
(Day & (Tuesday	1
(Day == Tuesday	1
visible in the	1
visible at all	1
Kbytes to 2	1
Kbytes and a	1
proxy is smaller	1
proxy for the	1
Microprocessors with the	1
Microprocessors with out-of-order	1
105. Floating point	1
105. 8.7 Checking	1
recently than to	1
recently 4 ?Func2@@YAXQAHAAH@Z	1
creating and deleting	2
order(i); matrix[j][0] =	1
order(i); list[j].a =	1
refers to the	1
refers to. For	1
floppy disk. A	1
floppy disks and	1
underflow. The range	1
underflow. The fact	1
37 A compiler	1
37 7.8 Member	1
36 C++ as	1
36 7.7 Function	1
3) << 4)	1
3) <<6 );	1
contrived example, but	1
contrived examples exist.	1
Manual on using	1
Manual 3: "The	1
Excessive use of	1
Excessive loop unrolling	1
FuncA and FuncB,	1
FuncA (int *	1
web application integration,	1
web browsing that	1
occur, but the	1
occur, but unfortunately	1
reorder instructions for	1
reorder instructions without	1
microseconds to execute	1
microseconds as a	1
Standard C++ imple-	1
Standard Template Library	1
const_cast operator is	1
const_cast operator here	1
though. In some	1
though. Some instructions	1
compiler: unsigned __int64	1
compiler: __int64 64	1
y) { if	1
y) { union	1
/MT -msse3 /arch:SSE3	1
/MT 160 /Qparallel	1
overwritten, and even	1
overwritten, possibly in	1
[esp+8] DWORD PTR	1
[esp+8] eax, eax	1
annoyingly long and	1
annoyingly high for	1
list[size]; int i,	1
list[size]; ... if	1
license Table 12.4.	1
license included in	1
y1 = a1	2
y2 = a2	2
swapd(x,y) {temp=x; x=y;	2
int)i < 10)	1
int)i >= (unsigned	1
CriticalFunction_SSE2(int parm1, int	2
GHz then the	1
GHz CPU. Should	1
false. The value	1
false. Likewise, you	1
Multithreading The clock	1
Multithreading works more	1
New versions are	2
CriticalFunctionDispatch(void) { //	1
CriticalFunctionDispatch(void) __asm__ ("CriticalFunction");	1
methods. The most	1
methods. If you	1
became available because	1
became available. It	1
if, a level-2	1
if, and only	1
computers. At this	1
computers. Today, the	1
x.abc = A	1
x.abc = (A	1
Worst-case testing Most	1
Worst-case testing ................................................................................................	1
Operations that are	2
named YMM in	1
named MKL, VML	1
a*0=0 a*1=a (-a)*(-b)=a*b	1
a*0=0 --xxxx-xx a*1=a	1
p2 = &Object2;	1
p2 having different	1
p1 and p2	1
p1 = &Object1;	1
major platforms. However,	1
major platforms. Pascal	1
internet or intranet	1
internet forums and	1
p; int i;	1
p; p =	1
lrintf and lrint.	1
lrintf (float const	1
resulting code will	1
resulting machine code	1
a[c][r]); // swap	1
a[c][r]); void test	1
math. Memory copying.	1
math. Libraries for	1
2048 bytes =	1
2048 230.7 513	1
3.5; c =	1
3.5; Here, the	1
DLLs are relocated	1
DLLs use relocation.	1
Unix systems allow	1
Unix applications and	1
Lookup tables are	1
Lookup tables can	1
differ a lot	1
differ then you	1
InstructionSet(); // Set	2
F1() { C1	1
F1() throw(); This	1
safety is to	1
safety problem can	1
predefined vector classes	2
variable-size array with	1
variable-size arrays with	1
obj1; C0 *	1
obj1; p->f(); //	1
Codes", by S.	1
Codes", SIAM 2001.	1
summarized in table	1
summarized below. Intrinsic	1
small. The number	1
small. Are objects	1
................................................................................ 16 3.1	1
................................................................................ 61 7.31	1
buffer. It should	1
buffer. Contentions in	1
list[size], sum =	1
list[size], sum1 =	1
"asmlib.h" // Define	1
"asmlib.h" // Lowest	1
ArraySize = 1000;	1
ArraySize by the	1
Live range analysis	2
mask); // Store	1
mask); 110 //	1
suffixes are listed	1
suffixes such as	1
programmer. There is	1
programmer. 79 Floating	1
x-xxxxxx- a*0=0 --xxxx-xx	1
x-xxxxxx- x-xxxx-x- x-xxxxxxx	1
name. In the	1
name. #define directives	1
third-party graphics framework	1
third-party profilers such	1
(a+b)+c=a+(b+c) --xx----- (a&&b)	1
(a+b)+c=a+(b+c) a+b+c=c+b+a a+b+c+d	1
audio and video	1
audio or video	1
arguments are sure	1
arguments while pointers	1
infinite loop if	1
infinite loop. The	1
flow. However, this	1
flow. Failure to	1
worse, it can	1
worse, many software	1
miss can be	1
miss on a	1
unsafe code is	1
unsafe because serious	1
away. It is	1
away. Note that	1
movements of objects	2
((x2) 2) 2	2
windows, mutexes, database	1
windows, graphic brushes,	1
pressing a key	1
pressing a button	1
Factors that make	2
price, and in	1
price, compatibility, second	1
Jumps can be	1
Jumps between CPU	1
maintaining a new	1
maintaining such code	1
Nevertheless, the bitwise	1
Nevertheless, it is	1
sound processing Memory	1
sound processing, and	1
servers that run	1
servers should be	1
utility. The conclusion	1
utility. It supports	1
executable. SSE2 is	1
executable. Most compilers	1
controlled. The network	1
controlled. Small hand-held	1
literature for more	1
literature on algorithms	1
512; // number	2
precautions to account	1
precautions for speeding	1
smarter ways of	2
2001. 9.11 Explicit	1
2001. Advanced book	1
Current compilers are	1
Current CPUs have	1
concentrated on CPU	1
concentrated on arranging	1
aa[i] = (bb[i]	1
aa[i] = bb[i]	1
null reference to	1
null reference. This	1
capable of register	1
capable of making	1
FuncC(i); } This	1
FuncC(i); FuncB(i+1); FuncC(i+1);	1
updating. The change	1
updating. The update	1
MOVNTDQ require that	1
MOVNTDQ _mm_stream_si128 SSE2	1
renaming and doing	1
renaming mechanism works	1
considering is the	1
considering whether a	1
worthwhile to unroll	1
worthwhile to invest	1
a-(-b)=a+b a-a =	1
a-(-b)=a+b ---xxx-x- a+0=a	1
f(); }; class	1
f(); }; void	1
separately. The fallacy	1
separately. The allocation,	1
patterns with fixed	1
patterns containing multiple	1
93. Avoid the	1
93. 7.10 Arrays	1
lowest of the	1
lowest instruction set	1
EXCEPTION_FLT_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER	1
EXCEPTION_FLT_OVERFLOW 0xC0000091L void	1
constructor, if any,	1
constructor, an overloaded	1
syntax: __asm fld	1
syntax: __asm ("fldl	1
1.2; // everything	1
1.2; // Mixing	1
26. The heap	1
26. Avoid global	1
parentheses can be	1
parentheses manually. The	1
check. It does	1
check. There are	1
experiments in order	1
experiments on seven	1
................................................................................................. 103 12	1
................................................................................................. 132 14.2	1
tables". There are	1
tables". Tips about	1
jl $B1$2 is	1
jl $B1$3: pop	1
computation time is	1
computation time. 4	1
thread-local storage of	1
thread-local storage p.	1
date. A more	1
date. Mac The	1
physics processor for	1
physics processing unit	1
first, then all	1
first, then d+e,	1
below) then it	1
below) 16.1 Using	1
eliminated. Loop unrolling	1
eliminated. Code caching	1
c.load(cc+i); a =	1
c.load(cc+i); // result	1
x-xxxxxxx xxxxxxxxx xxxxxxx-x	1
x-xxxxxxx ---x----- x--xx----	1
Unrolling the loop	1
Unrolling a loop	1
hyperthreading. If so,	1
hyperthreading. On the	1
bytes, so we	1
bytes, 4 ways,	1
(*.lib, *.a) or	2
irrelevant software installed,	1
irrelevant within a	1
careful when swapping	1
careful optimization. A	1
compression and cryptography	1
compression Most compilers	1
intervals are short.	1
intervals which may	1
(c2 = r1;	1
(c2 = c1;	1
immediate response to	1
immediate responses to	1
Object1; CChild2 Object2;	1
Object1; C2 Object2;	1
etc.) have little-endian	1
etc.) inside the	1
64-bit. Supports OpenMP	1
64-bit. They have	1
indirect function feature	1
indirect function" has	1
(-a==-b)=(a==b) ---xx---- (a+c==b+c)=(a==b)	1
(-a==-b)=(a==b) ---xx---- (-a>-b)=(a<b)	1
hyperthreading, then try	1
hyperthreading, but the	1
exponent, and the	1
exponent, and fffff	1
FuncA(i); } else	1
FuncA(i); FuncC(i); FuncB(i+1);	1
cross-platform compatibility is	1
cross-platform portability. Unfortunately,	1
{temp=x; x=y; y=temp;}	2
decomposition. It is	1
decomposition. Functional decomposition	1
parameter: // Example	1
parameter: template <typename	1
determines the program	1
determines whether the	1
(properties) The data	1
(properties) ............................................................................ 51	1
ABC = 123;	1
ABC 123 and	1
comments about how	1
comments generated by	1
..................................................................................................................... 38 7.11	1
..................................................................................................................... 163 20	1
profitable to use	1
profitable (see page	1
behind the program	1
behind the C++	1
Technical Report on	1
Technical University of	1
Neither is it	1
Neither can you	1
calculation. In most	1
calculation. However, the	1
const)) Assume function	1
const)) __attribute(( const))	1
test, but is	1
test, maintain and	1
-ffunction- sections SSE	1
-ffunction- sections /Gy	1
-msse SSE2 instruction	1
-msse /arch:SSE -msse	1
Initialize to zero	1
Initialize loop counter	1
indices or by	1
indices when you	1
s0 = 0,	1
s0 += a[i];	1
/FA -S -	1
/FA -S Generate	1
marketing of 64-bit	1
marketing reasons. This	1
parm2); // Function	1
parm2); } int	1
--xx----- (a&&b) ||	1
--xx----- x-xxx---x x-xxx---x	1
20, columns =	2
conflicting with the	1
conflicting considerations of	1
20; i +=	1
20; i++) {	1
61 function calls	1
61 7.31 Other	1
looking at a	1
looking name ?Func@@YAXQAHAAH@Z	1
coarse-grained parallelism and	1
coarse-grained parallelism than	1
matrix[c][r] at its	1
matrix[c][r] above the	1
-mssse3 -msse4.1 -mAVX	1
-mssse3 /arch:SSSE2 -msse4.1	1
isolate the most	1
isolate the hot	1
Let me explain	2
question. You may	1
question. For example,	1
x^n // sum,	1
x^n } return	1
treats different brands	1
treats non-Intel CPUs	1
topics ......................................................................................... 132	1
topics 14.1 Use	1
(3) look up	1
(3) trap integer	1
table: // Example	2
unstable or if	1
unstable due to	1
60 The cost	1
60 7.30 Exceptions	1
iterations. The advantage	1
iterations. Here the	1
Join identical branches	2
bb[i] + 2;	1
bb[i] > 0	1
sampling requires a	1
sampling generates too	1
(memory address) /	1
(memory pooling) than	1
verifying the functionality	1
verifying and maintaining	1
3.6 Dynamic linking	2
3.4 Automatic updates	2
log(b[i]) + log(c[i]);	1
log(b[i]) + log(c[i]);.	1
Now, the factor	1
Now, according to	1
a+a+a+a=a*4 -(-a)=a -	1
a+a+a+a=a*4 -(-a)=a --xxxxxx-	1
doubt how big	1
doubt obtained with	1
78). A matrix	1
78). Adding the	1
v.f are both	1
v.f if both	1
manner? If objects	2
generating overflow. Likewise,	1
generating denormal numbers	1
Especially the use	1
Especially the memory	1
.................................................................................................... 10 2.6	1
.................................................................................................... 19 3.5	1
3.2 Use a	2
F1(a); } else	2
Switch between different	1
Switch statements are	1
_mm_set1_epi16(0); // Make	2
everywhere in the	1
everywhere by default.	1
a&&(b||c) !a &&	1
a&&(b||c) (a&&!b) ||	1
(a&b) | (~a&c)	2
3.3 Program installation	2
3.1 How much	2
randomly one way	1
randomly around in	1
Useful for vector	1
Useful when no	1
3.8 System database	2
3.9 Other databases	2
............................................................................................ 66 8.2	1
............................................................................................ 36 7.7	1
mainframe computer. Big	1
mainframe computers. Today,	1
(time before) }	1
(time after) -	1
Everything that is	2
required. The Intel	1
required. See page	1
theoretical possibility that	1
theoretical background is	1
12.1a. Automatic vectorization	1
12.1a. Enable the	1
file, is acceptable.	1
file, especially if	1
working with sets	1
working software users.	1
pragmas in the	1
pragmas must be	1
use. The installation	1
use. I am	1
use, as explained	1
use, incompatible or	1
favorable: Small data	1
favorable: Larger data	1
color settings and	1
color difference. Newest	1
8192 / 4	1
8192 bytes, 4	1
_mm_cmpgt_epi16(b, zero); //	2
lost. This dilemma	1
lost. It is	1
Exceptions and error	2
question when efficiency	1
question without generating	1
afterwards a BSF	1
afterwards reads or	1
Every time a	1
Every fourth of	1
denormals-are-zero mode if	1
denormals-are-zero mode (SSE2):	1
declaration. The type	1
declaration. This is	1
exceptions: while (i	1
exceptions: __except (GetExceptionCode()	1
read. It is	1
read. If a	1
Non-static member functions	1
Non-static members of	1
re- allocating when	1
re- usable library	1
requiring the same	1
requiring many files	1
{int a; int	2
branching is done	1
branching takes time.	1
changed. This will	1
changed. 7.8 Member	1
belongs to the	1
belongs to class	1
(a&&c) = a&&(b||c)	1
(a&&c) || (a&&b&&c)	1
NumberOfTests = 10;	1
NumberOfTests times //	1
obviously takes time	1
obviously influenced by	1
undetected. The principle	1
undetected. Converting class	1
alone in the	1
alone compiler when	1
caller to the	1
caller through a	1
understanding of the	1
understanding of how	1
influence the performance	1
influence on the	1
x-xx----- x--x----- ---x-----	1
x-xx----- 75 (a&&b)	1
Lazy binding can	1
Lazy binding should	1
Volatile to prevent	1
Volatile The volatile	1
lock a thread	1
lock a container	1
allowed. The code	1
allowed. Non-public distribution	1
today will be	1
today where cache	1
(double)(signed int)u; //	1
(double)(signed int)u; 14.9	1
programmable logic device	2
checks. But it	1
checks. These conversions	1
mechanisms often disturb	1
mechanisms explained above.	1
8.1. The table	1
8.1. Comparison of	1
G values in	1
G values, and	1
Align by 16	1
Align arrays and	1
c) The creation	1
c) 139 can	1
&CriticalFunction_386; } //	1
&CriticalFunction_386; } int	1
(three on CodeGear	1
(three parameters on	1
goto CFALSE; }	1
goto DTRUE; }	1
testing. Here, you	1
testing. Trying to	1
feature. This includes	1
feature. All accesses	1
interposition is intended	1
interposition feature that	1
loads the library	1
loads the appropriate	1
*.a) or dynamic	2
dispatchers are designed	1
dispatchers up to	1
Registers are a	2
Event-based sampling: The	1
Event-based sampling requires	1
associated with dynamic	1
associated with profiling,	1
time-consumer in the	1
time-consumer even for	1
mechanism. The CPU	1
mechanism. See page	1
Optimizations in the	2
machines with embedded	1
machines use just-in-time	1
problem: 1. Relocation.	1
problem: (1) check	1
constructors, and any	1
constructors, copy constructors,	1
References are useful	1
References are safer	1
mutually incompatible. A	1
mutually incompatible. You	1
_mm_empty() as shown	1
_mm_empty() after the	1
report that memset	1
report /Qopt-report -opt-report	1
disturbing influences in	1
disturbing influences are	1
develop- ment in	1
develop- ment time	1
negative. The method	1
negative. The last	1
facilities, binary trees,	1
facilities, easy GUI	1
creation of a	1
creation of temporary	1
warning for such	1
warning from the	1
min = 100,	1
min && i	1
14.2 Bounds checking	2
14.3 Use bitwise	2
14.1 Use lookup	2
vectorclass manual for	1
vectorclass www.agner.org/optimize/#vectorclass. The	1
14.7 Don't mix	2
debugging. A debugger	1
debugging. A command-line	1
Func(int a[], int	2
(columns * sizeof(float)).	1
(columns * sizeof(float))	1
14.5 Integer division	1
14.5 Integer division......................................................................................................	1
defined. The cost	1
defined. This can	1
-msse4.1 -mAVX -axSSE3,	1
-msse4.1 /arch:SSE4.1 -mAVX	1
x^10 // loop	1
x^10 // return	1
branches): if (level	2
DoThisThreeTimesAWeek(); } 135	1
DoThisThreeTimesAWeek(); } By	1
-msse2 SSE3 instruction	1
-msse2 /arch:SSE2 -msse2	1
logarithms, exponential functions,	2
default. This is	1
default. Position-independent code	1
WTL application is	1
WTL applications can	1
_controlfp(0, _EM_OVERFLOW); //	2
load. The clock	1
load. A light-weight	1
select(b > 0,	2
framework. The optimized	1
framework. Obviously, the	1
8.6 Optimization directives	2
synchronization between the	1
synchronization between threads,	1
Without static, the	1
Without optimization, the	1
millisecond resolution and	1
millisecond resolution. A	1
sizeof(S1) = 16	1
sizeof(S1) would be	1
high-priority threads are	1
high-priority thread can	1
development. This unit-testing	1
development. For example,	1
push and pop	1
push mov xor	1
Numerically Intensive Codes",	2
verify that all	1
verify than a	1
us to compare	1
us to manipulate	1
searching, and mathematical	1
searching, or the	1
known. This information	1
known. Example: //	1
14.13 System programming	2
14.12 Position-independent code	1
14.12 Position-independent code..................................................................................	1
area. The nontemporal	1
area. Join identical	1
14.19 static inline	1
14.19 below. The	1
rounding. This is	1
rounding. Pointer type	1
column; for (row	1
column; Do not	1
dramatically for very	1
dramatically by unrolling	1
148 It is	1
148 14.13 System	1
8.5 Compiler optimization	2
Polynomial coefficients //	1
Polynomial coefficients double	1
temporarily. This is	1
temporarily. Using the	1
obscure examples where	1
obscure possibility of	1
14.1c is copied	1
14.1c void CriticalInnerFunction	1
142 unsigned int	1
142 14.10 Mathematical	1
"assume no pointer	2
properly and the	1
properly aligned or	1
issue. See my	1
issue. But it	1
restarted anyway. Software	1
restarted anyway. Updates	1
Func2() { int	2
x--x----- ---x----- x---x---x	1
x--x----- --xx----- x-xxx---x	1
PCs. The clock	1
PCs. Therefore, it	1
8.2 Comparison of	2
Possible solutions to	1
Possible solutions are:	1
IDE's for D	1
IDE's (Integrated Development	1
8.3 Obstacles to	2
obtained. If a	1
obtained. In the	1
C++: An optimization	1
C++: Preprocessor directives.	1
sin(x); } 68	1
sin(x); z =	1
delay. See page	1
delay. But if	1
1.f; for (int	1
1.f; float nfac	1
Divisions can sometimes	1
Divisions take longer	1
7.32 Preprocessing directives	2
largest_index = 0;	1
largest_index = i;	1
wide, should be	1
wide, while an	1
list[i].a and list[i].b.	1
list[i].a = 1.0;	1
model. You may	1
model. Instead, I	1
7.33 Namespaces........................................................................................................... 65	1
7.33 Namespaces There	1
manipulating floating point	2
Dependency chains Modern	1
Dependency chains ................................................................................................	1
additions. When used	1
additions. Divisions take	1
MOVNTPD and MOVNTDQ	1
MOVNTPD _mm_stream_pd SSE2	1
158 Integer variables	1
158 18 Overview	1
A; double Y	1
A; x.b =	1
cycle? In this	1
cycle? ...................................................................................... 16	1
server. Use large	1
server. These problems	1
156 16.3 Worst-case	2
fine-tuned for a	1
fine-tuned for specific	1
157 17 Optimization	2
draw the attention	1
draw each pixel	1
examples. The table	1
examples. You cannot	1
class: // Example	1
class: class CGrandParent	1
sharing the same	2
155 16.2 The	1
155 test. You	1
7.30 Exceptions and	2
ways, with a	1
ways, as explained	1
predicted. The target	1
predicted. This is	1
i<n; i++) is	1
i<n; ++i). But	1
dividing by 2	1
dividing repeatedly with	1
complications that make	1
complications with member	1
AVX, as explained	1
AVX, AVX2 Mathematical	1
7.31 Other cases	2
redo the calculations	1
redo the calculation	1
parallelization of code	1
parallelization in the	1
Matrix size Time	1
Matrix size Total	1
.................................................................................. 16 3.3	1
.................................................................................. 55 7.24	1
a.store(aa+i); } }	2
0x7FFFFFFF) { //	2
add, etc. SSSE3	1
add, remove or	1
fed into the	1
fed directly to	1
array, or approximately	1
array, which it	1
AVX. These suffixes	1
AVX. 5. The	1
Alignd(X) X __attribute__((aligned(16)))	1
Alignd(X) __declspec(align(16)) X	1
_mm_add_epi16(c, two); //	2
waits for user	1
waits until the	1
loops, then the	1
loops, etc. Optimizing	1
Tuesday, Wednesday or	1
Tuesday, Wednesday, Thursday,	1
loops. 13.1 CPU	1
loops. Consider the	1
Increment and decrement	1
Increment loop counter	1
cached as good	1
cached more efficiently	1
propagation, and loop-invariant	1
propagation, etc. Whether	1
exceeds an acceptable	1
exceeds 64 kbytes.	1
Wikipedia under CPU	1
Wikipedia article on	1
................................................................................................ 22 3.16	1
................................................................................................ 157 17	1
mask. The expression	1
mask. Poor reproducibility.	1
conclude that most	1
conclude this section	1
shared. You can't	1
shared. Any writable	1
relocated by the	1
relocated (rebased) once	1
else. This normally	1
else. System code	1
FIFO queue should	1
FIFO manner? If	1
Library" and "Integrated	1
Library" contains many	1
dealing with in	1
dealing with this	1
Hello() { cout	2
Various development tools	1
Various graphics function	1
software, it is	1
software, but it	1
Overflow may occur	1
Overflow behaves differently	1
multiplications and divisions	1
multiplications only. The	1
differences were observed	1
differences due to	1
2.2, C =	2
machine. The best	1
machine. The virtual	1
containers. If the	1
containers. See page	1
tree. On older	1
tree. Is searching	1
approach to CPU	1
approach to error	1
dynamically. The advantages	1
dynamically. Arrays that	1
__asm__ (".type CriticalFunction,	1
__asm__ ("CriticalFunction"); typeof(CriticalFunction)	1
difficulties making floating	2
deleting the object	1
deleting containers. If	1
discussion. Integer to	1
discussion. 7.33 Namespaces	1
...................................................................................................................... 96 9.9	1
...................................................................................................................... 33 7.5	1
int) are only	1
int) instead of	1
(y) { int	1
(y) { F1(a);	1
purpose, or you	1
purpose, you must	1
algorithms, are not	1
algorithms, cannot easily	1
&CriticalFunction_SSE2; } //	1
&CriticalFunction_SSE2; } else	1
Disp(); class C1	1
Disp(); void Hello()	1
consistent for the	1
consistent modularity and	1
1.23456. The conclusion	1
1.23456. But we	1
v; if (u.i	2
(b, c); //	2
reveal a zigzag	1
reveal things that	1
created. There is	1
created. Far Systems	1
denormal numbers in	1
denormal numbers. You	1
optional and off	1
optional commercial license	1
op. Intel Core	1
op. AMD Opteron	1
experiment are given	1
experiment where 10	1
Induction++; } }	1
Induction++; ; point	1
precisions when the	1
precisions take no	1
Difficult cases In	1
Difficult cases........................................................................................................ 124	1
interpreter for Basic.	1
interpreter which interprets	1
(PLT). The memory	1
(PLT). And whenever	1
order(int x); const	1
order(int x); 136	1
digital operation can	1
digital building blocks	1
i++){ list[i] =	1
i++){ list[i] +=	1
0.40 n.a. 1.00	1
0.40 0.30 4.5	1
z; a =	1
z; bool b;	1
139 can sometimes	1
139 14.7 Don't	1
0.44 0.12 memcpy	1
0.44 0.40 n.a.	1
cc); } //	1
cc); } #endif	1
__GNUC__ and not	1
__GNUC__ #define pure_function	1
covered the address	1
covered in manual	1
fashioned C style	2
alloca. This is	1
alloca. 9.7 Container	1
Efficient caching is	1
Efficient conversion from	1
spaces for different	1
spaces that are	1
$B1$1: mov mov	1
$B1$1: push mov	1
362880, 3628800, 39916800,	2
(line size) =	1
(line size) %	1
column. The access	1
column. Number 17	1
complex, that there	1
complex, but not	1
3.7 File access	1
3.7 File access................................................................................................................	1
cheap if they	1
cheap compiler for	1
purity. In many	1
purity. For example,	1
0.f, 0.f, 1.f);	1
0.f, 1.f); //	1
14.23b and 14.30	1
14.23b union {	1
below). The 256-bit	1
below). A variable	1
division, which is	1
division, square root	1
received by an	1
received data in	1
degradation of performance	1
degradation in code	1
"override" feature. This	1
"override" feature. All	1
11.2b const int	1
11.2b was an	1
matrix[j][0] is calculated	1
matrix[j][0] = i;	1
x--xx---- (a&&b) ||	1
x--xx---- (a&&b)||(a&&!b)=a x--xx----	1
Sometimes, the best	1
Sometimes, functions are	1
distribute function libraries	1
distribute all the	1
"worst case" and	1
"worst case" counts.	1
overdetermined in the	1
overdetermined Boolean variables	1
ms. This delay	1
ms. If the	1
thing. Example: //	1
thing. An expression	1
squares: for (r1	1
squares: const int	1
MemberPointer is declared.	2
www.intel.com. (See also	1
www.intel.com. Manual on	1
TILESIZE) { for	1
TILESIZE) { //	1
sources. The above	1
sources. For example,	1
first-in-last-out fashion. It	1
first-in-last-out nature of	1
3628800, 39916800, 479001600};	2
uncommon for software	1
uncommon for virus	1
coprocessor or graphics	1
coprocessor might also	1
23; // add	1
23; // fractional	1
82 8.7 Checking	1
82 Keywords that	1
relates to security.	2
7.9 Smart pointers	2
alignment. See www.agner.org/optimize/cppexamples.zip	1
alignment. __declspec(align(16)) or	1
7.5 Booleans The	1
7.5 Booleans................................................................................................................... 33	1
deal of programming	1
deal of research	1
binutils version 2.20	1
binutils version 2.20,	1
7.6 Pointers and	2
Specific optimization topics	2
__attribute__((const)) #else #define	1
__attribute__((const)) (Linux only).	1
unnecessary for the	1
unnecessary functions Some	1
b[1000]; }; if	1
b[1000]; F2(b); }	1
7.3 Floating point	2
performing an illegal	1
performing software product	1
once, rather than	1
once, while the	1
s1 = 0,	1
s1 += a[i+1];	1
(called static if),	1
(called x86) of	1
84 for (i	1
84 9 Optimizing	1
"C" int CriticalFunction	1
"C" declaration and	1
respects and highly	1
respects relevant to	1
License license included	1
License shall automatically	1
ISO/IEC TR 18015,	1
ISO/IEC TR18015 Technical	1
command-line version of	1
command-line versions without	1
i++ are as	1
i++ ;checkifi<100 ;	1
137). The second	1
137). This also	1
template. The powN	1
template. 57 Templates	1
General case, N	1
General Public License,	1
container, then a	1
container, preferably with	1
integrated in the	1
integrated development environment	1
started. The length	1
started. It takes	1
transposes a matrix	1
transposes a quadratic	1
container. STL deque	1
container. Can the	1
(*SelectAddMul_pointer)(aa, bb, cc);	2
crash the program.	1
crash on old	1
1.1, B =	2
reserve the amount	1
reserve resources for	1
Older operating systems	1
Older CPUs with	1
deleted. Smart pointers	1
deleted. User work	1
Asmlib Gnu 64	1
Asmlib My own	1
Both the executable	1
Both code cache	1
&Object2; p->Hello(); }	1
&Object2; p2->Hello(); //	1
a:4; int b:2;	2
(-a)*(-b)=a*b a/a=1 ----x---x	1
(-a)*(-b)=a*b ---xxx--- a/a=1	1
left for transferring	1
left out if	1
c2++) { swapd(a[r2][c2],a[c2][r2]);	2
Nested loops are	2
ipow faster than	1
ipow (double x,	1
comparison, which is	1
comparison, bit operations	1
produced regularly. Intel:	1
produced regularly. AMD:	1
NotPolymorphic(); virtual void	1
NotPolymorphic(); }; //	1
a*b+a*c = a*(b+c)	2
11.1a to 11.1b	1
11.1a float a,	1
support, and the	1
support, then call	1
forget to make	1
forget to delete	1
inverted bit-mask: bc	1
inverted mask. The	1
11.1b float a,	1
11.1b automatically, although	1
80. The keyword	1
80. The difference	1
i. The size	1
i. This index	1
worked well in	1
worked sufficiently fast	1
needed: // Example	2
Introduction This manual	1
Introduction ....................................................................................................................... 3	1
i+=3){ list[i] =	1
i+=3){ list[i] =0;	1
PUBLIC ?Func@@YAXQAHAAH@Z ?Func@@YAXQAHAAH@Z	2
-(-a)=a - -	1
-(-a)=a --xxxxxx- a-(-b)=a+b	1
"IA-32 Intel Architecture	2
loaded, the loader	1
loaded, but waits	1
(a&&b&&c) = a&&(b||c)	1
(a&&b&&c) = a&&b	1
a+0=a a*0=0 a*1=a	1
a+0=a x-xxxxxx- a*0=0	1
7.15b below shows.	1
7.15b SafeArray <float,	1
grows by only	1
grows during program	1
0. The constant	1
0. The division	1
r2++) { for	2
index, just as	1
index, i. This	1
time-consumers are discussed	1
time-consumers mentioned in	1
enough. A hash	1
enough. For example,	1
720, 5040, 40320,	2
tedious and the	1
tedious indeed. It	1
correctly. The speed	1
correctly. A code	1
flexible, but quite	1
flexible, well tested,	1
ARRAYSIZE = 100;	1
ARRAYSIZE && list[i]	1
annotation in the	1
annotation option if	1
respectively. (In 64-bit	1
respectively. Increment and	1
1.1 The costs	2
43). The Boolean	1
43). There is	1
^= 0x80000000; //	1
^= 0x80000000; because	1
1's is unchanged,	1
1's when bb[i]	1
hexadecimal numbers because	1
hexadecimal numbers, we	1
u, v; if	2
extending the sign-bit	1
extending with zero-bits	1
^, ~ are	1
^, ~, <<,	1
systematic and well	1
systematic manner to	1
forces the compiler	1
forces the variable	1
rolled out by	2
__attribute__ ((visibility ("internal")))	2
Java, use dynamic	1
Java, C#, Visual	1
ivdep Assume function	1
ivdep __restrict #pragma	1
Gnu. It is	1
Gnu. There is	1
recursion must always	1
recursion template<> class	1
^a = 0	2
algebra, it is	1
algebra, we may	1
management and garbage	2
lots of data.	1
lots of things	1
163 20 Copyright	1
163 Internet forums	1
projects, it is	2
160 19 Literature	1
160 /Qparallel -parallel	1
(This is faster	1
(This eliminates the	1
Mac. The Gnu	1
Mac. Supports parallel	1
chip. Such units	1
chip. Such hybrid	1
wrapped into a	2
perfectly on a	1
perfectly varies between	1
zero); // Use	1
zero); // AND	1
added? If search	2
Addison-Wesley, 1996. These	1
Addison-Wesley, 2003. Contains	1
counter, which is	1
counter, comparing the	1
modifier can make	1
modifier will be	1
-Ofast /O3 -O3	1
-Ofast -mveclibabi -fopenmp	1
test. You can	1
test. disable power-save	1
respond to a	1
respond quickly to	1
Intensive Codes", by	1
Intensive Codes", SIAM	1
planning phase in	1
planning stage that	1
C2 : public	1
C2 Object2; CHello	1
R value in	1
R values first,	1
release version of	1
release version with	1
fraction. The sign	1
fraction. For example,	1
Friday is set	1
Friday = 0x20,	1
textbooks recommend that	1
textbooks recommend object	1
slower. Many compilers	1
slower. Another disadvantage	1
9.7 Container classes	2
c1; int c1::*MemberPointer;	1
c1; c2 <	1
compilers, system database,	1
compilers, etc., as	1
subtracting 1 from	1
subtracting n from	1
Returns a pointer	1
Returns time stamp	1
insight can lead	1
insight you gain	1
a*b=b*a x n.a.	1
a*b=b*a a+b+c=a+(b+c) (a+b)+c=a+(b+c)	1
r1+TILESIZE; r2++) {	2
0/a = 0	2
hope that such	1
hope that future	1
Portability C++ is	1
Portability note: This	1
compilers). The best	1
compilers). The representation	1
Catch floating point	1
Catch exceptions in	1
99% of the	2
"; // call	1
"; Disp(); class	1
Sab {int a;	1
Sab ab[size]; int	1
contribution to the	2
distinction between the	1
distinction between leaf	1
Update induction variable	2
Supported compilers Intel,	1
Supported operating systems	1
ment in order	1
ment time when	1
typeof(CriticalFunction) * CriticalFunctionDispatch(void)	2
ones that are	1
ones mentioned in	1
busy doing the	1
busy concentrating on	1
optimally on any	1
optimally aligned. See	1
Fast function calling.	1
Fast versions of	1
funny things with	1
funny looking name	1
queries is beyond	1
queries can often	1
saying that it	1
saying please install	1
normal. This happens	1
normal. 157 17	1
1" // Writes	2
updated. It is	1
updated. Most copy	1
clumsy and tedious.	1
clumsy AND-OR construction	1
int)u; // Faster,	1
int)u; 14.9 Using	1
trivial programming work	1
trivial tasks such	1
a[SIZE][SIZE]) { //	2
x64 141 #include	1
x64 (Visual Studio	1
systems). 28 Dynamic	1
systems). 42 If	1
wasted on software	1
wasted on runtime	1
Public distribution and	1
Public License, optional	1
dummy elements at	1
dummy element to	1
symbolic link to	1
symbolic link. Use	1
fetched and decoded	1
fetched from the	1
0x40 bytes from	1
0x40 }; Weekdays	1
(a&b)|(a&c) = a&(b|c)	2
relocation, but only	1
relocation, especially in	1
(The Microsoft compiler	1
(The PGI compiler	1
Mixing float and	1
Mixing object files	1
decides which function	1
decides whether to	1
<xmmintrin.h> _mm_setcsr(_mm_getcsr() |	1
<xmmintrin.h> _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It	1
Func1(x) + 1.;	1
Func1(x) * Func1(x)	1
5040, 40320, 362880,	2
ability to define	1
ability to override	1
3, 5 and	1
3, 4, 6,	1
3.12 Network access	2
123 and static	1
123 correspond to	1
provoke an error	1
provoke error //	1
VectorC A commercial	1
VectorC v. 2.1.7,	1
processes. The data	1
processes. The profiler	1
((visibility ("internal"))) __attribute__	1
((visibility ("internal"))) Vectorize	1
stronger for level-2	1
stronger when they	1
accessible from other	1
accessible from compilers	1
reusable and well-	1
reusable classes. Security	1
procedures for installation	1
procedures are inefficient.	1
!(a < b)	1
!(a || b)	1
Overview of compiler	2
ammintrin.h AMD XOP	1
ammintrin.h (MS) xopintrin.h	1
sequences of code.	1
sequences of operations.	1
stop the program	1
stop the thread.	1
expansions of the	1
expansions and Newton-Raphson	1
bit. The fact	1
bit. We can	1
Conclusion There is	1
Conclusion .......................................................................................................... 120	1
linking. The file	1
linking. A dynamic	1
Free Documentation License	1
Free trial versions	1
bottlenecks is to	1
bottlenecks can lead	1
interrupts and task	1
interrupts at certain	1
legacy code, specific	1
legacy software. It	1
segment by using	1
segment then it	1
__unix__ __linux__ x86	1
__unix__ __linux__ __unix__	1
attempts to set	1
attempts to translate	1
Code that is	1
Code caching will	1
Day; if (Day	2
swapd(a[r2][c2],a[c2][r2]); } }	2
bb, cc); }	2
power. There are	1
power. Connecting several	1
consumer to many	1
consumer if it	1
parenthesis around the	1
parenthesis around such	1
Security The most	1
Security software that	1
limit, then you	1
limit, etc. In	1
~ for NOT.	1
~ are useful	1
swapd(a[r][c], a[c][r]); //	1
swapd(a[r][c], a[c][r]); void	1
Single precision is	1
Single precision division,	1
0.28 strlen 128	1
0.28 0.22 memcpy	1
Booleans The order	1
Booleans as output	1
0.24 n.a. 1.00	1
0.24 0.25 0.24	1
Caching of code	2
interfere with any	1
interfere with real	1
-fomit- frame- pointer	2
0.25 0.28 0.22	1
0.25 0.24 n.a.	1
_mm_mullo_epi16 (b, c);	2
FMA4 instruction set.	1
FMA4 fma4intrin.h (Gnu)	1
distribution to a	1
distribution and mirroring	1
>> can test	1
>> n with	1
do, at least	1
do, however, often	1
appropriate. 8. Avoid	1
appropriate. Compiler-specific keywords	1
Please skip the	1
Please note that	1
Network access Some	1
Network access ......................................................................................................	1
__int64 64-bit Linux:	1
__int64 64 -263	1
mispredictions, floating point	1
mispredictions, etc. These	1
rows; i++) for	1
rows; i++) {	1
together. The link	1
together. Data members	1
organize the code	1
organize data to	1
bitfield is less	1
bitfield by the	1
15.1b. Calculate integer	1
15.1b. Branches are	1
sees the constant	1
sees a relative	1
Interpreted code is	1
Interpreted languages are	1
treat a variable	1
treat non-Intel CPUs	1
a[SIZE][SIZE], double b[SIZE][SIZE])	2
(a<b && b<c	1
(a<b && b<c)	1
processor). Integer division	1
processor). Optimizing compilers	1
occurred. // Reset	1
occurred. This makes	1
corresponding instruction set.	1
corresponding bitwise operators	1
memset(a, 0, sizeof(a));	2
m;} int a,	1
m;} template <int	1
recovering or for	1
recovering from error	1
Sunday, Monday, etc.	1
Sunday, Monday, Tuesday,	1
incompatible. A function	1
incompatible. You may	1
2;} // add	1
2;} int a;	1
fast, compact, and	1
fast, -fp- model	1
University of Denmark.	1
University courses in	1
log, and logarithms	1
log, exp, sin,	1
begins with #)	1
begins at the	1
14.26 does not	1
14.26 union {	1
14.27 union {	1
14.27 assumes that	1
somewhat more complicated	1
somewhat less efficiently	1
predictable. It may	1
predictable. For example:	1
subtraction, multiplication, etc.	1
subtraction, comparison, bit	1
14.23 page 143.	1
14.23 union {	1
slight degradation in	1
slight imprecision in	1
unit. For example,	1
unit. Various graphics	1
direct access to	1
direct hardware access.	1
generic version that	1
generic branch, which	1
unit, but this	1
unit, either on	1
invalid. The heap	1
invalid. Boolean variables	1
heavily on table	1
heavily loaded. 21	1
self- relative addresses	1
self- relative addresses.	1
log2 a global	1
log2 = log(2.0);	1
counters. A performance	1
counters. My test	1
speed, memory economy	1
speed, memory economy,	1
(!a&&c) = a	1
(!a&&c) || (b&&c)	1
[] array index	1
[] operator will	1
122. The code	1
122. The Intel	1
messages to the	1
messages saying please	1
x[]); void F3(bool	1
x[]); void F2(float	1
only) -O3 or	1
only) (Intel CPU	1
although it appears	1
although slightly less	1
primitive programming style	1
primitive operations in	1
Goedecker and Adolfy	1
Goedecker and A.	1
Model-specific dispatching There	1
Model-specific dispatching ....................................................................................	1
-fno-rtti Assume no	1
-fno-rtti /GR- -fno-rtti	1
initialization, or if	1
initialization, condition, and	1
largest_abs = 0;	1
largest_abs = absvalue;	1
implementations. However, these	1
implementations. 7.22 Inheritance	1
24, 120, 720,	2
studying the bottlenecks	1
studying a piece	1
87). There is	1
87). Data caching	1
contentions. See page	1
contentions. Use simple	1
SafeArray { protected:	1
SafeArray <float, 100>	1
58 If it	1
58 shows an	1
increasingly important. A	1
increasingly blurred as	1
accurate and reproducible	1
accurate for the	1
efforts in optimizing	1
efforts on the	1
starts. The user	1
starts. The disadvantage	1
i/2+r. The instructions	1
i/2+r. The next	1
reader has a	1
reader what is	1
usability, program compactness,	1
usability, but I	1
template<> class powN<true,0>	1
template<> class powN<true,1>	1
low-level C language	1
low-level optimizations. Most	1
available: // Example	2
_controlfp_s(&dummy, 0, _EM_OVERFLOW);	2
mangled function name	2
Transforming serial code	2
contend for the	2
collector at inconvenient	1
collector which is	1
int)n < 4)	1
int)n < 13)	1
Far storage, far	1
Far Systems with	1
factorials: static const	1
factorials: const int	1
........................................................................................ 53 7.21	1
........................................................................................ 109 12.5	1
compares the array	1
compares eax with	1
shows. The best	1
shows. It is	1
By giving each	1
By Agner Fog.	1
certainty that the	1
certainty which version	1
1-bit in binary	1
1-bit removed. If	1
Or it might	1
Or #include <ia32intrin.h>	1
Programs that produce	1
Programs using such	1
operation, which is	2
closed. The same	1
closed. The file	1
source. It comes	1
source. Supports all	1
:1;//signbit }; struct	2
avoided, if possible,	1
avoided, there are	1
book on optimization	1
book "Performance Optimization	1
avoided. The disadvantage	1
avoided. 37 A	1
EMMS } const	1
EMMS instruction before	1
immediately before the	2
sizeof(a)); // copy	1
sizeof(a)); } int	1
105). If the	1
105). Using the	1
usage in kernel	1
usage convention says	1
fix the thread	1
fix the problem	1
b[SIZE][SIZE]) { int	2
press or mouse	1
press break while	1
sorting and searching,	1
sorting algorithms, are	1
(*.dll, *.so). The	1
(*.dll, *.so). There	1
1.00 0.25 0.28	1
1.00 0.35 0.29	1
, longdoublevalue (	1
, doublevalue (	1
efficiently. This method	1
efficiently. It is	1
word static is	1
word processor the	1
B2 { public:	1
B2 b2; int	1
10.1 Hyperthreading Some	1
10.1 Hyperthreading .....................................................................................................	1
Converting an integer	1
Converting class objects	1
matrix. For example,	1
matrix. My experimental	1
B; for (x	1
B; x.c =	1
divisions. It is	1
divisions. Example: //	1
chains, especially loop-carried	1
chains, namely the	1
coprocessors is beyond	1
coprocessors to take	1
x.a = A;	1
x.a = y.a	1
effect. GOT and	1
effect. Which method	1
keyboard and mouse	1
keyboard or mouse	1
39916800, 479001600}; if	1
39916800, 479001600}; ...	1
Approximate exp(x) for	2
Table[x] = A*x*x	1
Table[x] = Y;	1
restriction on x.	1
restriction from a	1
x.c = C;	1
x.c = y.c	1
misleading results or	1
misleading reports of	1
#ifdef _MSC_VER //	1
#ifdef __GNUC__ #define	1
.................................................................................................. 18 3.4	1
.................................................................................................. 134 14.3	1
Sum of a	2
x.b = B;	1
x.b = y.b	1
CPUs". A branch	1
CPUs". 9.3 Functions	1
shr add sar	1
shr ebx,31 copies	1
each. The critical	1
each. The type	1
0/a=0 ---x---xx (-a==-b)=(a==b)	1
0/a=0 ---xx--xx (-a==-b)=(a==b)	1
replacing a function	1
replacing an integer	1
1.0f + b	1
1.0f : 2.5f;	1
manual, but you	1
manual, I am	1
involve the loading	1
involve a high	1
Optimize for speed	1
Optimize function #pragma	1
list[i]; This has	1
list[i]; sum2 +=	1
initialize to x^0/0!	1
initialize sum for(inti=0;i<16;i+=4){	1
117 A C++	1
117 12.7 Mathematical	1
previously in the	1
previously required a	1
113 Number of	1
113 12.6 Transforming	1
root and mathematical	2
statistics, and the	1
statistics, signal processing	1
times, one for	1
times, even for	1
obstacle of possible	1
obstacle to vectorization.	1
Fog. Technical University	1
Fog. Public distribution	1
12.8 Aligning dynamically	2
IDE with many	1
IDE on some	1
12.9 Aligning RGB	2
removing the call	1
removing superfluous code,	1
setup may look	1
setup but slow	1
_LP64 Windows platform	1
_LP64 _WIN64 _LP64	1
type, a pointer,	1
type, but you	1
b.load(bb+i); // Load	1
b.load(bb+i); c.load(cc+i); a	1
factorials so that	1
factorials don't depend	1
subroutine for the	1
subroutine if it	1
later. The AVX	1
later. Example: //	1
12.4 Using intrinsic	2
12.5 Using vector	2
manipulations of floating	1
manipulations on integer	1
leaks and other	1
leaks if you	1
says that the	1
says that a	1
12.6 Transforming serial	2
140). The SSE2	1
140). Mathematical functions	1
12.7 Mathematical functions	2
52 or class	1
52 , longdoublevalue	1
obey any specific	1
obey certain rules	1
72. It is	1
72. You have	1
b*a - n.a.	1
b*a (a+b)+c=a+(b+c) a+b+c=c+b+a	1
95 and 120	1
95 not needed.	1
12.1 AVX instruction	2
time-critical code. 7.32	1
time-critical part of	1
12.3 Automatic vectorization	2
universal solution is	1
universal algorithm (e.g.	1
Suppl. SSE3 instr.	1
Suppl. SSE3 tmmintrin.h	1
crash. See page	1
crash. Furthermore, it	1
a+b+c+d = (a+b)+(c+d)	2
99 read from	1
99 10 Multithreading..............................................................................................................	1
Remove branch that	1
Remove right-most 1-bit	1
interpreters, just-in-time compilers,	2
9. Avoid table	1
9. Multiplications are	1
any, is usually	1
any, must be	1
thread-safe function should	1
thread-safe functions. A	1
F3(bool y) {	2
exclusive access by	1
exclusive mode, and	1
9.2. All these	1
9.2. Cache control	1
NumberOfTests; i++) {	2
stay in the	1
stay on until	1
extension of vector	1
extension to the	1
"best case" counts	1
"best case" values.	1
functions) has no	1
functions) /Gy -ffunction-	1
repeated until the	1
repeated 1024/4 =	1
FactorialTable[13] = {1,	2
Friday) in example	1
Friday) { DoThisThreeTimesAWeek();	1
function: // Example	1
function: (static_cast<MyChild*>(this))->Disp(); }	1
8.21 is indeed	1
8.21 void Func1	1
&CriticalFunction_AVX; } if	1
&CriticalFunction_AVX; } else	1
105 The vector	1
105 12.1 AVX	1
interpret the bits	1
interpret that string	1
Writing a =	1
Writing past the	1
bug is a	1
bug causes floating	1
Compare each element	2
x=y; y=temp;} //	1
x=y; y=temp;} int	1
better, you may	1
better, make your	1
flip the sign	1
flip sign bit	1
float's when the	1
float's fits into	1
minutes to write	1
minutes to start	1
109 } It	1
109 12.5 Using	1
(a+1) * (a+1);	1
(a+1) / 4;	1
reasons, the preferred	1
reasons, but part	1
better: store the	1
better: -Ofast -mveclibabi	1
method, it is	1
method, but it	1
whose address is	1
whose distance in	1
delete, and often	1
delete, or malloc	1
accessed, and this	1
accessed, it is	1
a&(b|c) - n.a.	1
a&(b|c) x-xxxx--x (a|b)&(a|c)	1
assigning a new	1
assigning different priorities	1
10% of the	2
Mostly obsolete. Microprocessor	1
Mostly obsolete. Rick	1
4: "Instruction tables".	2
4; The compiler	1
4; Register variables	1
have. The developers	1
have. In some	1
relieving the const	1
relieving a syntax	1
10, columns =	1
10, 12 or	1
ENDP + esp	1
ENDP ecx, 1	1
incremented to 5	1
incremented every second	1
48 Use macros	1
48 7.15 Function	1
Tuesday = 4,	1
Tuesday || Day	1
internally as a	1
internally as (int)&matrix[0][0]	1
fourth of these	1
fourth value to	1
tips on advanced	1
tips on improving	1
shared_ptr than for	1
shared_ptr allows multiple	1
BSD. The Windows	1
BSD. If a	1
effort. 7.21 Runtime	1
effort. Square blocking	1
today. You may	1
today. But this	1
Put the function	1
Put in an	1
CriticalFunction_AVX(int parm1, int	2
(r2 = r1;	1
(r2 = r1+1;	1
writing: 103 //	1
writing: __declspec(align(64)) int	1
B2; class D	1
B2; 54 class	1
overall performance of	1
overall computation time	1
Structures and classes	1
Structures and classes............................................................................................	1
executables. This method	1
executables. Make sure	1
inherently parallel because	1
inherently serial, such	1
me. You will	1
me. My vector	1
non-virtual member function,	1
non-virtual functions. Avoid	1
safer. It may	1
safer. Type casting	1
b+c = 100000001.23456.	1
b+c will be	1
__linux__ x86 platform	1
__linux__ __unix__ __linux__	1
-32768 32767 int16_t	1
b+a a*b =	1
factorials, but this	1
convenience - there	1
231. This extra	1
pow(x,10); } The	1
companies often fail	1
dominate in the	1
preferences for the	1
optimize("a",on). Specifies that	1
optimize(...) Fastcall function	1
x---x---x x-xxx---- a*b*c=a*(b*c)	1
16383 one fraction	1
extensions. If a	1
today, then it	1
14.5b if ((unsigned	1
14.5a const int	1
otherwise. In difficult	1
//Loopby4 s +=	1
b2); y1 =	1
1./3628800., 1./39916800., 1./4.790016E8,	1
niche in scientific	1
10) { ...	1
fistp dword ptr	1
SetThreadAffinityMask, in Linux,	1
common, and there	1
(low numbers mean	1
common. Even some	1
segments (32-bit or	1
Darwin8 g++ v	1
108 You may	1
compact, and simple	1
102 also useful	1
namespace. 3. The	1
update, or update	1
similarity between the	1
106 CPUs if	1
function) should be	1
"move constructor" to	1
function" has been	1
Friday, Saturday };	1
bits), unless the	1
Correction for the	1
vulnerability of software	1
reinstallation work to	1
ignoring the higher	1
sums } This	1
N-1)==0 if N	1
1./6., 1./24., 1./120.,	1
{x = a;	1
Rather than comparing	1
code-based methods or	1
N+1 supports at	1
512-bit ZMM registers	1
7.6. Set flush-to-zero	1
circumvent operating system	1
---x---xx (-a==-b)=(a==b) ---xx----	1
blog. Here, you	1
OpenMP. www.openmp.org. Documentation	1
Includes many functions	1
$B2$2 ; Induction++;	1
effects. This effect	1
Delight". Addison-Wesley, 2003.	1
AND-operations in just	1
precompiled code. The	1
typo in a	1
51). The order	1
Included with Intel	1
Updates to the	1
'@' and '$'	1
(methods) Each time	1
count. The method	1
masm=intel /FA -S	1
warn against overkill.	1
warm up the	1
noticed that i	1
constructs........................................................................ 26 7.1	1
a<<b<<c = a<<(b+c)	1
leak. An even	1
utility for modifying	1
clumsy, as you	1
16-byte instructions MOVNTPS,	1
zeroes. Example: //	1
caveats. We can	1
$B1$2:. This is	1
repagination are running	1
a[i+2] ; compare	1
recognizes it as	1
recognized in 64-bit	1
cleans up the	1
(bitwise and) will	1
portability. Unfortunately, the	1
independently. The CPU	1
9.5b void transpose(double	1
answer questions from	1
(Standard Template Library)	1
13.2. CPU dispatching	1
adds, not edx	1
objconv or a	1
purpose: Contain one	1
limitations to what	1
x8*x2; return x10;	1
limitation). 14.11 Static	1
speculatively executing instructions	1
disassembly window of	1
(en.wikipedia.org/wiki/L2_cache). The details	1
attempt is made	1
0+1.23456 = 1.23456.	1
before) } printf("\nResults:");	1
blocks. A method	1
timingtest.h from www.agner.org/optimize/testp.zip	1
C1::Disp() or C2::Disp()	1
predictor. On other	1
128. These lines	1
accurate, however, and	1
Misaligned data. Extra	1
FAQ for the	1
before. This is	1
Xnu project. Some	1
initialized. The dispatcher	1
so). A template	1
Remember, therefore, always	1
/fp:fast=2 -fp-model fast,	1
/MT). In Linux	1
MKL). Works with	1
B1 { public:	1
CParent::Hello() has multiple	1
user-defined function is	1
spots, but for	1
B. In order	1
exploiting fine-grained parallelism.	1
sets). Here, /	1
lost at the	1
i+1; The compiler	1
terminated. The purpose	1
burden is the	1
(a&&!b) || (!a&&b)	1
SafeArray: // Example	1
Is8vec16 Vec16c 8	1
weakness or bottleneck,	1
imple- mentations have	1
Yeppp. Open source	1
nested function calls	1
source) { _mm_stream_pi((__m64*)dest,	1
1994. Mostly obsolete.	1
side effects or	1
ample resources. For	1
(MMX), 128 bits	1
1/50 of the	1
/openmp /MT -msse3	1
forgot to tell	1
clauses are separated	1
reproducibility. Delays in	1
-abs(x);. There are	1
x-xxx - xx(-)x-	1
timediff[i] = ReadTSC()	1
Be sure not	1
for(inti=0;i<16;i+=4){ //Loopby4 s	1
message. It is	1
coordination with other	1
distant future. 12.3	1
Sunday = 1,	1
restore ebx from	1
47 Most compilers	1
1996. These two	1
www.agner.org/optimize. Copyright conditions	1
row++) for (column	1
resume after exceptions:	1
x-xxxxx-- (a&b)|(a&c) =	1
areas. Data that	1
qword ptr x;	1
Repeat NumberOfTests times	1
/EHs- No stack	1
union: // Example	1
(12.4e) with automatic	1
steals resources from	1
(add with carry)	1
moved, which may	1
moved. A binary	1
areas, and there	1
longdoublevalue ( 1)sign	1
unconventional manner by	1
*const_cast<int*>(&x) += 2;}	1
(option -fno-pic). 64	1
x-xxxxx-x (-a)*(-b)=a*b ---xxx---	1
Handles to windows,	1
strange and unexpected	1
invalid, and by	1
_mm_stream_si128 SSE2 Table	1
/Gy, Linux: -ffunction-sections)	1
(there is one	1
sqrt and pow	1
b.y + c.y	1
SSE. Several function	1
bits: // Example	1
264-1 uint64_t Table	1
generality. The most	1
sin(0.8); The sin	1
esp+12 and loaded	1
bounds-checking to an	1
owns the allocated	1
i--, x++) factorial	1
versa. But most	1
body. A function	1
CString uses new	1
58.7 168.3 Table	1
Prevent optimizing away	1
"express" edition is	1
(en.wikipedia.org/wiki/Standard_Template_Library). The objects	1
zero: // Example	1
*(int*)&x |= 0x80000000;	1
-fno-pic). 64 bit	1
tread can take	1
rows. Let's look	1
saturated. This can	1
rows, not the	1
uncaught overflow condition	1
macro, but the	1
virtualization. The time	1
seek information elsewhere	1
macro. If you	1
constructed. All non-static	1
data, including local	1
FuncB (int &	1
limits the CPU	1
xx4(x4); // x^4	1
precious resource for	1
15h Processors". www.amd.com.	1
installed, a lot	1
installed. The installation	1
point: // Example	1
IA-32/Intel64, 2009. Gnu	1
_mm_perm_epi8 32 1	1
min) <= (unsigned	1
LLVM is a	1
7.40a struct Bitfield	1
7.40b union Bitfield	1
7.40c x.abc =	1
(FuncRow(i)*columns + FuncCol(i))	1
(Darwin) are part	1
see, it is	1
importance of structured	1
comparable to a	1
interpretation. The program	1
x∙xn-1, and each	1
rarely. The above	1
optimize("a", on) __restrict	1
neither faster nor	1
correctly whether vectorization	1
sets) (line size)	1
libraries........................................................................................ 12 2.7	1
mind. In some	1
sets, cache size,	1
dot in the	1
a2*b1) / (b1*b2);	1
mispredicted. A branch	1
Day. Note the	1
mispredicted, which causes	1
Good compilers such	1
after) - (time	1
OneOrTwo5[2] = {1.0f,	1
intermediates, loop counters,	1
incremented. See page	1
incremented, while in	1
here's an explanation.	1
insufficient. The user	1
she is busy	1
not-too-big upper limit	1
evictions and other	1
bit, the exponent,	1
Prefetch PREFETCH _mm_prefetch	1
core). The counters	1
noalias) __restrict #pragma	1
transposition of different	1
other's caches and	1
below, on page	1
illegitimate copying. The	1
legitimate backup copying	1
121 13 Making	1
architecture of the	1
renamed instances of	1
unacceptable to the	1
hardware-related details depend	1
12, last byte	1
12) are more	1
"More Effective C++".	1
"Effective C++". Addison-Wesley.	1
Dispatcher void SelectAddMul_dispatch(short	1
Boost collection contains	1
ebx,31 copies the	1
matters. Problems with	1
<ia32intrin.h> etc. //	1
finish. 3.8 System	1
inappropriate CPU dispatch	1
0: printf("Alpha"); break;	1
IA-32 Architectures Optimization	1
x87 style floating	1
a+b+c=a+(b+c) (a+b)+c=a+(b+c) --xx-----	1
6.0f; Constant folding	1
brackets. However, most	1
NULL. There should	1
b*(2.0/3.0) unless you	1
.a), but not	1
tolerance may be	1
Processor memcpy 16kB	1
Files on remote	1
compactness, and execution	1
(partial) template specialization.	1
Abrash: "Zen of	1
T+1 to T+6,	1
0] in this	1
Edition, 2005; and	1
14.7b is converted	1
Otherwise the program	1
suggested improvements). //	1
14.3a int n;	1
14.3b int n;	1
(DLL) which is	1
SelectAddMul_SSE41 #elif INSTRSET	1
thenaandbcannot use the	1
Hat). PathScale C++	1
int32_t long long	1
issuing an error	1
unchanged across a	1
Deallocation has no	1
initiative whenever it	1
bloat and complexity	1
Division, square root	1
Gives a more	1
C- style type-casting	1
boolb=0; static const	1
C# and avoids	1
(0); and the	1
acceptable limit, then	1
FuncB, then FuncC.	1
removed. If N	1
trigger the error	1
basic understanding of	1
j++) 39 matrix[i][j]	1
once................................... 135 14.4	1
statements, as explained	1
compiling. This prevents	1
frustration and waste	1
2-3 clock cycles	1
prone to even	1
switches..................................................................................................... 22 3.15	1
deeper into the	1
b)) even though	1
less. Fortunately, all	1
"function". Multiple calls	1
Max. number of	1
operator[] (unsigned int	1
enabled: // Example	1
owns. A destructor	1
wrapper classes with	1
161 32 bit	1
162 19 Literature	1
be, for example,	1
algebra) require other	1
be. The distinctions	1
Re-do the calculation	1
algebra. For example,	1
slices. This will	1
transformation of example	1
x^8 // x^10	1
2.11 ifunc branch).	1
power-save options in	1
situations: The stack	1
balance between these	1
0.35 0.29 0.28	1
over. Virtualization is	1
over- loaded type	1
a<c) = (a<b	1
a1/b1 + a2/b2;	1
"memory" ); #else	1
2009. Gnu C++	1
situations, and which	1
vendor string. In	1
list; // Make	1
Non-polymorphic functions go	1
investment. A redesign	1
MOVNTPS, MOVNTPD and	1
(80 bits). The	1
matrix[NUMROWS][NUMCOLUMNS]; int row,	1
149 All code	1
x);} void SelectAddMul(short	1
cc[i]+2 is AND'ed	1
Iu32vec2 64 1	1
Iu32vec4 Vec4ui 64	1
time1 = ReadTSC();	1
plug-ins that add	1
Vec32c unsigned char	1
interval, for example	1
time? If the	1
&SelectAddMul_AVX2; (iset >=	1
i7 processor with	1
kit (SDK or	1
i) { //	1
(Vec4f const &	1
transitions between the	1
Usually it takes	1
a[size]; unsigned int	1
................................................................................................... 87 9.3	1
x?" or "how	1
separating the flags	1
(the instruction set	1
g() { C1	1
technology, and microprocessor	1
800 bytes smaller.	1
tolerated. PGI C++	1
Gbytes. This large	1
p1; p1 =	1
CriticalFunctionType(int parm1, int	1
deleted, copied or	1
a/1 = a	1
Yet, D is	1
-263 263-1 int64_t	1
assigned previously in	1
functional decomposition and	1
2eee 1.fffff, where	1
human readable and	1
plug-in to Microsoft	1
_mm_setcsr(_mm_getcsr() | 0x8040);	1
2-20, but this	1
yet as well	1
Newton-Raphson iterations. Here	1
regarded as a	1
pixel or line	1
affinity mask. Poor	1
PROCNEAR ; parameter	1
119). The AMD	1
stack). ecx now	1
ago, the recommendation	1
reuse the same	1
Beginners are advised	1
Error: lowest instruction	1
pool, as explained	1
reordered, inlined, or	1
doublevalue ( 1)sign	1
(IPP). Works with	1
hand. Low-level languages	1
hand- written table	1
|) instead of	1
standardization of programming	1
Patches should be	1
object-oriented programming, modularity,	1
WriteFile if the	1
link. Use different	1
strategies........................................................................................ 122 13.2	1
monitoring options. CPU	1
printf("Beta"); break; case	1
re-use a container	1
dead code if	1
Core2 processor performs	1
meaning. 2. Put	1
meaning, then you	1
2014-08-07. Contents 1	1
(int)&matrix[0][0] + j	1
Safe [] array	1
i*12, because the	1
__thread or __declspec(thread).	1
(BTB). Contentions in	1
meanings depending on	1
capabilities. Here is	1
paragraph. The target	1
Sum2(S3 * p)	1
18015, "Technical Report	1
alignments and different	1
status: _fpreset(); _controlfp_s(&dummy,	1
Including the appropriate	1
millisecond. The profiler	1
list[100], *temp; for	1
benchmark performance of	1
ifbit=1 bitofn //	1
f(x) or g(x)	1
floatvalue ( 1)sign	1
Inlining a function	1
remains zero in	1
worst- case conditions.	1
titles. Literature on	1
11.2a const int	1
/GR– -fno-rtti /GR-	1
~C1(); }; void	1
(vector const &	1
initial value of	1
optimize/#vectorclass Include file	1
powN<true,N/2>::p(x); } };	1
accumulators. Current CPUs	1
22. Avoid long	1
addressed relative to	1
F0() { try	1
OS, etc.) have	1
vmlsExp4 vmldExp2 Intel	1
-mcmodel=large, but this	1
+127. An integer	1
precision: // Example	1
223 to a	1
x[1] = b;	1
Adolfy Hoisie: "Performance	1
64; // number	1
products fail to	1
dvec.h vectorclass.h Supported	1
(.dll or .so).	1
stages before they	1
InstructionSet().The following example	1
64. Each cache	1
sticks may not	1
Parallelization by OpenMP	1
covers 64 consecutive	1
die. See www.gnu.org/copyleft/fdl.html.	1
153. A profiler	1
65535 uint16_t unsigned	1
/Qopt-report -opt-report Table	1
low-priority thread steals	1
Vectorization with alignment	1
Profile-guided optimization Whole	1
destructors. The copy	1
Locked mutexes. Open	1
independence, and easy	1
libraries............................................................................ 146 14.12	1
fine-tuning, testing, verifying	1
exits. For example,	1
exits, when in	1
mangling are explained	1
utilities in 2010.	1
cases........................................................................................................ 124 2	1
alleviated in the	1
decimals, for example,	1
cell for different	1
transfers ownership of	1
list[j].b + list[j].c;	1
list[j].a = list[j].b	1
12.4a. Loop with	1
12.4a, depending on	1
example,a * 16is	1
obeyed. Copy protection.	1
sufficient, and the	1
product. It is	1
restores the value	1
2011). Instead, the	1
serial, such as	1
restored before the	1
managed C++, and	1
Disadvantages are: Long	1
real-time speed. Delays	1
1./40320., 1./362880., 1./3628800.,	1
exceeding that of	1
(a+c==b+c)=(a==b) ----x---- !(a<b)=(a>=b)	1
18.2. Compiler directives	1
click becomes inconsistent	1
1.23456, y; y	1
download updates through	1
/Qopenmp -m32 -m64	1
technique is illustrated	1
de-allocation of memory	1
x<<3, which is	1
optimizer. Borland/CodeGear/Embarcadero C++	1
division). The object	1
monotonically increasing function	1
top-of-stack index. Are	1
configurations with the	1
off. It is	1
Vec8ui Vec4q Vec4uq	1
2.20 or later	1
2.23 0.95 0.6	1
std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP. www.openmp.org.	1
relocate, but these	1
advised to seek	1
button or moving	1
positions in the	1
did not improve	1
Vec8us 32 4	1
<excpt.h> #include <float.h>	1
minimal difference between	1
Library, available from	1
Systems with segmented	1
more. Many software	1
telling the user	1
unexpected behaviors. Arrays	1
feasible. Interference from	1
x2*x2; double x8	1
Mathcad (v. 15.0)	1
-mveclibabi=acml. Agner's vector	1
friendly compiler with	1
running, and a	1
targets is small.	1
exit. Calling exit	1
switching. This cost	1
alternatives: Make the	1
operations............................................................................................... 105 12.1	1
27). The maximum	1
................................................................................... 81 8.6	1
log(c[i]); // Increment	1
assignment, as a	1
assignment. shared_ptr allows	1
diagnose. It is	1
8.9b int SomeFunction	1
15.1c). 16 Testing	1
vector(float a, float	1
c;}; abc *	1
8.9a int SomeFunction	1
sets........................... 122 13.1	1
Integrates into the	1
AddTwo(int * __restrict	1
Violation of array	1
evenly between the	1
identified, then it	1
simultaneous lookups Max.	1
incrementing a loop	1
imprecise or simply	1
Technology Journal Vol.	1
-100, b =	1
p->f() goes to	1
DontSkip = dummy[0];	1
1./2., 1./6., 1./24.,	1
blend instruction if	1
e + f;	1
flexibility of the	1
SelectAddMul_SSE2, SelectAddMul_SSE41, SelectAddMul_AVX2,	1
Greek[4] = {	1
Windows: __rdtsc()). The	1
wealth of advanced	1
correlated with preceding	1
independently of other	1
Output array element	1
T, unsigned int	1
T> static inline	1
SelectAddMul, SelectAddMul_SSE2, SelectAddMul_SSE41,	1
throw()specification is useful	1
asa << 4,	1
themselves. But implementing	1
ARRAYSIZE. Another example:	1
electrical connections rather	1
A2 = A	1
"=m"(n) : "m"(x)	1
A. Hoisie, SIAM	1
(IDE) supports multiple	1
TR 18015, "Technical	1
Numbers in the	1
amounts of memory	1
fld qword ptr	1
Calculating the difference	1
(v. 15.0) is	1
polygon or bitmap	1
~(~a)=a x-xxxxx-- (a&b)|(a&c)	1
/vms Fastcall functions	1
sample more data	1
everybody. So please	1
unwise to use	1
systems"). An application	1
looses ownership of	1
p2->Hello(); // Writes	1
8.23b. Calculate polynomial	1
d); Now the	1
144 The above	1
circuits consisting of	1
14.1b int factorial	1
143 if (u.i	1
14.1a int factorial	1
ecx+eax*4. The result	1
Reinterpret cast The	1
max = 110;	1
77) shows which	1
theory. Advice on	1
constructor" to transfer	1
14, with some	1
Number) if an	1
grow in the	1
Pointers, references, and	1
Unpredictable branches that	1
QueryPerformanceCounter functions for	1
workload between multiple	1
u[0]. 14.10 Mathematical	1
class). If the	1
seeing an increasing	1
distributors are often	1
2B, and 3A	1
(Red Hat). PathScale	1
optimally. The speed	1
optimally, or from	1
view. This instruction	1
competition. Processors with	1
8.42n, 2004. Open	1
group books 1994.	1
thank the many	1
www.openmp.org. Documentation of	1
interesting because it	1
~a&~b=~(a|b) --xxxx--- a	1
;eax=addressofa ;edx=addressinr ;	1
"static" or "__attribute__((visibility	1
0x800 apart. I	1
subtract this value	1
works, here's an	1
@gnu_indirect_function"); // Make	1
optimizations, as explained	1
matrixes. Algorithms that	1
speeds. If I	1
tmmintrin.h SSE4.1 smmintrin.h	1
{}; void xplus2()	1
forgets that the	1
7. If the	1
integer: // Example	1
module2.cpp. The simplest	1
last: // Example	1
14.0 80.8 65	1
SelectAddMul_AVX2, SelectAddMul_dispatch; //	1
Choose the strongest	1
list[j].c; } Here,	1
r.a + r.b;}	1
places). Some compilers	1
Linux) 4. Align	1
decrementing a pointer	1
Accessibility guidelines should	1
constructors. A class	1
x10 = x8*x2;	1
Generic version CriticalFunction	1
F64vec4 Table 12.5.	1
system-independent, in another	1
DynamicArray[i] = WhateverFunction(i);	1
cross-module optimizations when	1
therefore, always to	1
FuncCol(i)) * sizeof(float)	1
requesting a map	1
locally. Access to	1
8.3a float parabola	1
12.4c. Same example,	1
a+b=0, and then	1
"Software Optimization Guide	1
listing. Use the	1
eax. The loop	1
game or animation.	1
polynomial(x) = 2.5*x^2	1
cc[i]); } 109	1
Time-based sampling: The	1
uninstallation of programs	1
a+b=b+a a*b=b*a a+b+c=a+(b+c)	1
remaining bits represent	1
u.d is negative	1
branch). This feature	1
conversions.................................................................................................... 40 7.12	1
forbids the user	1
107. A disadvantage	1
Walking through a	1
(1985). This standard	1
de-allocated. This is	1
.................................................................................................................. 60 7.30	1
/O3 -O3 Interprocedural	1
dispatching: 1. How	1
dispatching, then it	1
C++0x support. Make	1
(b1*b2); The trick	1
1./1.30767E12, 1./2.09227E13}; float	1
*temp; for (temp	1
segmented memory, such	1
integral number of	1
compiler). Fastcall functions	1
Weighing the above	1
workaround methods depend	1
Users should get	1
Problems with invalid	1
-m32 -m64 -static	1
bool, enum as	1
branch, which is	1
/arch:SSE4.1 -mAVX /arch:AVX	1
performance: The first	1
editions). Do not	1
[ecx+eax*4]. This is	1
Borland/CodeGear/Embarcadero C++ builder	1
easier. I have	1
1000. The loop	1
ready made containers	1
studied do not	1
0.666666666666666666667; This is	1
A2; // Table	1
commpage. These functions	1
uses. There are	1
powN<true,0> { public:	1
0x3700, 0x3F00 and	1
matrix[row][column] = row	1
performance). Aligned operands	1
describes how this	1
{2.6f, 1.5f}; a	1
non-sequentially because it	1
1% goes to	1
errors; make sure	1
1) y *=	1
(typically 64) can	1
hackers often have	1
errors, and some	1
formula: (set) =	1
Certainly not! 250	1
occupies a space	1
multi-threading, e.g. Intel	1
"xmmintrin.h" // header	1
occupied throughout the	1
experimental results in	1
condition: // Example	1
runtime). The following	1
c1, c2; double	1
Dr Dobbs Journal,	1
switching to protected	1
formulas in this	1
trace with a	1
Single-Instruction-Multiple-Data (SIMD) operations.	1
condition, and increment.	1
protected: T a[N];	1
zigzag course that	1
topic, see my	1
complaints should be	1
(XMM), 256 bits	1
local: 1. Add	1
20. The fact	1
D, Pascal, Fortran	1
throw(A,B,C) to tell	1
fills up the	1
local. This makes	1
precise floating point	1
Predefined macros Compiler	1
local, and use	1
column-wise. Assume now	1
__intel_cpu_features_init_x() does the	1
stall because the	1
=0; list[i+1] =	1
accelerators The choice	1
Addison-Wesley. Third Edition,	1
absvalue = a[i].u[1]	1
eax,0. The loop	1
dword ptr n;	1
ger or double)	1
recommendations are based	1
decomposition, we should	1
targets. A switch	1
undesired. Example: //	1
bytes). This has	1
Turn on the	1
12.6. Function with	1
7.32b. A for-loop	1
VTune, for AMD	1
[1.0, 2.0) by	1
if), but no	1
referencing it twice.	1
VTune; AMD's profiler	1
stupid things. Looking	1
worrying too much	1
storing. The standard	1
...................................................................... 32 7.4	1
7.29b floata; boolb=0;	1
"Hacker's Delight". Addison-Wesley,	1
Storage on the	1
Unsigned is faster	1
blurred as the	1
7.29a float a;	1
dummy; double a[arraysize],	1
eliminating the if-branch	1
FatalAppExitA(0,"Array index out	1
emulating the so-called	1
satisfies the user's	1
(int)n - 2,	1
with, e.g. the	1
appropriately. Users should	1
168.5 513 513	1
x10; } //	1
168.3 Table 9.3.	1
streaming audio or	1
(2.5f * x	1
commas and semicolons	1
reciprocal_divisor = 1.	1
usual object file	1
?Func2@@YAXQAHAAH@Z ENDP ecx,	1
<float.h> #include <math.h>	1
temp++ actually adds	1
doing. See the	1
unreasonably large. 156	1
popularity when a	1
(rebased) once more	1
ja $B2$3: ret	1
(YMM), and soon	1
2.0) by setting	1
dates back to	1
Called directly //	1
(-a)*(-b) = a*b	1
row, column; for	1
position above the	1
constructor. A default	1
2B. There are	1
number). Different compilers	1
(0, 2, 4,	1
78. Assume no	1
decimals of the	1
executables for 32-bit	1
among the most	1
Installing a second	1
largest_abs) { largest_abs	1
8.15b. The integer	1
towards zero, rather	1
b[i]*c[i], though this	1
Compiler-specific keywords Fast	1
maintained for the	1
efficient: // Example	1
LoadVectorA(void const *	1
c[arraysize]; // Enable	1
performance, it is	1
sensible balance between	1
Interprocedural optimization /Og	1
Assembly name Intrinsic	1
powN<true,N> { public:	1
a+b+c = a+(b+c)	1
compelling security reason	1
profile. It may	1
cumbersome to use	1
403 int ReadB()	1
pmmintrin.h Suppl. SSE3	1
experience. Occasionally, the	1
executable: a debug	1
vector). The first	1
Environments) have facilities	1
machines? Possible solutions	1
those who want	1
a[i].u[1] * 2;	1
scheme should be	1
IDE, for debugging	1
(N-1)) return powN<(N1&(N1-1))==0,N1>::p(x)	1
investigating performance problems.	1
novector to tell	1
110; int i;	1
spaces. This is	1
signaling the availability	1
passed as parameters	1
<pmmintrin.h> // SSE3	1
sub-vector. A long	1
IEEE standard 754	1
(|) works even	1
expensive, while the	1
N-1 is inferior.	1
dominating and there	1
fastcall)) __fastcall Noncached	1
interrupted. Now it	1
17.4 129 129	1
script languages, it	1
lookup[b]; If a	1
const*)p);} // Function	1
Vec16uc 16 8	1
xxn(x4, x2*x, x2,	1
i/2; } }	1
According to the	1
microarchitecture. A higher	1
team projects, it	1
abs(v.f) } The	1
(".type CriticalFunction, @gnu_indirect_function");	1
one-man projects, it	1
vectorization............................................................. 117 12.7	1
None of the	1
MAX(a,b) (a >	1
buffer, branch pattern	1
roughly estimate that	1
pow(x,n) As we	1
<<6 ); 7.26	1
arrays: // Example	1
Processors". www.amd.com. Advices	1
Instrumentation: The compiler	1
i&15 is guaranteed	1
("hidden")))". A more	1
buffers for storing	1
_mm256_i64gather_pd unlimited 8	1
twice. You can	1
(2013) both 32-bit	1
capability to reduce	1
_endthread() cleans up	1
2.5*x^2 - 8*x	1
__debugbreak();. If you	1
system- specific parts	1
calls, if there	1
fine- tune the	1
asmlib, which is	1
aiming at explaining	1
found, then it	1
subtask before coordination	1
lrint. Unfortunately, these	1
c[i]); } }	1
231-1 int32_t long	1
serves as entry	1
latencies are listed	1
audience for educational	1
ced functions) /Gy	1
full. This may	1
if. This is	1
bloat. It is	1
radical solution of	1
Putting simple variables	1
absence of such	1
FuncB(i); } FuncC(i);	1
solving the problem	1
programmers' time, but	1
Four typical uses	1
(a+b). This can	1
objects? It may	1
y. The purpose	1
violations, invalid pointers,	1
processor) when the	1
sourcebook for fast	1
horizontal add, etc.	1
comparison. On big	1
broken up. The	1
*)alloca(n * sizeof(float));	1
spell-checking and repagination	1
int)size) { cout	1
7.34a. Use macro	1
SSE). The YMM	1
CPU-type is already	1
communicating between threads.	1
even-numbered logical processors	1
meaning for member	1
a<<(b+c) - n.a.	1
mixes float and	1
encryption algorithms, cannot	1
tried to make	1
coef[16] = {	1
fallacy of measuring	1
referenced from any	1
0xC0000091L void MathLoop()	1
formalism. The splitting	1
underflow: // Example	1
mark end of	1
sub-vectors that fit	1
polymorphism. It is	1
__assume_aligned directive to	1
polymorphism, which is	1
polymorphism: // Example	1
menus of a	1
(Microsoft, Intel) know	1
f, x, y;	1
date): Microsoft Visual	1
Examples: // Example	1
MOVNTPS _mm_stream_ps SSE	1
lacks the self-explaining	1
arranged in regular	1
(c+d) before it	1
pushed on the	1
USB sticks may	1
brand, family and	1
(b+c) can be	1
"frame pointer". The	1
Sdouble { unsigned	1
tested, and very	1
Sum3(S3 & r)	1
duration. The best	1
lifetime of your	1
temp++) { temp->a	1
14.13c int list[301];	1
consecutively? If objects	1
14.13a int list[300];	1
fill up the	1
8.15b struct S1	1
_mm_i64gather_pd unlimited 8	1
finally (4) access	1
hybrid solutions are	1
Func1(list, &list[8]); }	1
workday or more.	1
instantiated at compile	1
flaws in the	1
pointers). An optimizing	1
file" option for	1
IntegerPower<10>(x); } 152	1
tested: Microsoft C++	1
analyzing program performance	1
S2 { public:	1
S3 { public:	1
(a+b)+c = a+(b+c)	1
{1.1, 0.3, -2.0,	1
elements, as follows:	1
(static_cast<MyChild*>(this))->Disp(); } };	1
cross- compiled on	1
GetLogicalProcessorInformation in Windows)	1
it). This can	1
substantial. This gain	1
A*x*x + B*x	1
AES, PCLMUL wmmintrin.h	1
u < 231	1
driver. A call	1
combined. For example:	1
disadvantages. The original	1
loose the ability	1
Processors with multiple	1
investing in a	1
arguments. This closely	1
www.agner.org/optimize/asmlib.zip contains various	1
Round to nearest	1
reductions. Algebraic reduction	1
kludgy. The few	1
sched_setaffinity). The program	1
answer. Beginners are	1
out-of- order calculation	1
r1, r2, c1,	1
GUI development, database	1
fence instructions, but	1
eee is the	1
(Scalar means not	1
Omitting the standard	1
nine, even though	1
$B2$2: mov mov	1
7.10b char a	1
d.y; Fortunately, most	1
7.10a bool a,	1
randomness in order	1
thread, and only	1
development", Addison- Wesley	1
selected. Compiler has	1
BigArray[1024] __attribute__((aligned(64))); //	1
shortly. The following	1
latencies, throughputs and	1
perspective of usability.	1
latencies. 8.5 Compiler	1
<<, >> can	1
FuncRow(int); int FuncCol(int);	1
versions: class CChild1	1
1.0E8, c =	1
12.4c is quite	1
"Intel® C++ Compiler	1
illogical that the	1
Programmer’s Manual", Volume	1
AND-OR construction in	1
(short int)i; This	1
!b) rather than	1
versions, each carefully	1
microcontrollers. I am	1
-b to a	1
-a > -b	1
_mm_prefetch SSE Store	1
12.4. Vector class	1
MyChild> class CParent	1
bb[size] ); Alignd	1
building blocks such	1
universal, flexible, well	1
pool all the	1
&list[100] is (int)(&list[100])	1
Entry to dispatched	1
add_elements(__m128 const &	1
Returning objects of	1
++i). But when	1
NUMROWS = 100,	1
(s0+s1)+(s2+s3); Now s0,	1
Primitives (IPP). Works	1
narrow range then	1
12.4e. Same example,	1
DLL's (dynamically linked	1
"Moving blocks of	1
sqaure: for (r2	1
&SelectAddMul_dispatch; // Dispatcher	1
mutexes. Open database	1
move. It is	1
nfac; xn *=	1
detecting errors that	1
move, depending on	1
"Inner Loops: A	1
distinct tasks. A	1
(a&b)&(c&d) a ^0	1
License, optional commercial	1
core, but it	1
string, wstring or	1
0.82 0.59 0.27	1
heading You can	1
60. In the	1
Prefetching data The	1
vectorization, such as	1
position. Windows DLLs	1
0.89 0.40 0.30	1
ahead. It is	1
15] += 1.0f;	1
scanner that scans	1
logic. Some guidelines	1
ifunc branch). This	1
/Gr Function level	1
n∙(n-1)!. If we	1
Transposing a matrix	1
controlling the order	1
shared_ptr. auto_ptr has	1
databases. The operating	1
trying the techniques	1
multitasking environment, between	1
(27 - 80	1
(20 - 45	1
(total cache size)	1
8.5b a +=	1
/GL --combine -fwhole-	1
8.5a void Plus2	1
it) load into	1
strategies It is	1
requested. See page	1
delayed for several	1
List[i]++; Here, the	1
you. Optimized function	1
assumes that we	1
variable: // Example	1
2003. Contains many	1
assumed that the	1
builder. Not optimized	1
! and the	1
nowadays stress the	1
Templates...............................................................................................................57 7.29 Threads	1
OneOrTwo5[b!=0] as OneOrTwo5[(b!=0)	1
maps etc. It	1
9.10, then the	1
steps. All source	1
Updating mechanisms often	1
-axAVX. This will	1
inverting the sign	1
(int)(&list[100]) = (int)(&list[0])	1
_mm_or_si128(c2, bc); //	1
ebx,eax / shr	1
specialization. This is	1
specialization, not with	1
improved. 3.2 Use	1
Fortran. These directives	1
Meyers: "Effective C++".	1
(a1*b2 + a2*b1)	1
evaluated, because the	1
OneOrTwo5[b!=0]; will also	1
x(0) {}; void	1
vmldExp2 Intel SVML	1
rounded to 100000000.	1
Truncation is slow.	1
1.2345; Change this	1
duration compared with	1
pointers: The trick	1
_mm. These functions	1
Wikibooks. The following	1
switches; so that	1
interleave the two	1
27 The number	1
0.57 0.44 0.12	1
0); DontSkip =	1
Eclipse when compiling	1
real time applications.	1
B*x + C;	1
2002). In some	1
"generate map file"	1
true/false Loopunrolling x-xxxx--x	1
detected until 10	1
supercomputers with massively	1
initializing pointers to	1
mirrored in the	1
matrix[FuncRow(i)][FuncCol(i)] += x;	1
Implicit type conversion	1
underestimate this time	1
rule. Splitting up	1
Installation problems. The	1
undocumented. 2.7 Choice	1
bitmap than to	1
0x7FFFFF) | 0x3F800000;	1
2A and 2B.	1
valuable source of	1
type-casting. It is	1
bases, but there	1
redirects it to	1
(SSE2): #include <xmmintrin.h>	1
severe delays if	1
member. This pointer	1
vectors) /arch:SSE -msse	1
mentally flawed approach	1
connect them. The	1
bility of the	1
n+1; // Approximate	1
Sutter: A Pragmatic	1
primitive, but efficient,	1
transposing and copying	1
computer, including the	1
closest to the	1
print out results	1
evaluation of the	1
foreground jobs and	1
only). Specifies a	1
obtain, such as	1
investigated by the	1
power, loop unrolled	1
(handle != INVALID_HANDLE_VALUE	1
11.1 for IA-32/Intel64,	1
Constructor // Initialize	1
11.6 64 64	1
media such as	1
benefits of a	1
11.8 127 127	1
powN<(N & N-1)==0,N>::p(x);	1
bias of the	1
utilized appropriately. Users	1
MKL relies on	1
263-1 int64_t 29	1
F64vec2 F32vec8 F64vec4	1
language", section 17.9:	1
X. 14.13 System	1
(remove unreferen- ced	1
X" is simply	1
developing so fast	1
aligned, and make	1
2.0/3.0 than to	1
7.31b char string[100],	1
7.31a char string[100],	1
powN<true,N-N1>::p(x); #undef N1	1
Language Runtime, CLR,	1
noticeable. The following	1
gigabytes of data.	1
>>= 1; }	1
103) will be	1
learning process where	1
7.43b. Compile-time polymorphism	1
links. 20 Copyright	1
UnusedFiller; }; int	1
50-50 chance of	1
know). The code	1
overview of the	1
supposed to call	1
14.4b if ((unsigned	1
15.1a. Calculate x	1
Mbytes. There may	1
interactive programs because	1
version). This wasteful	1
bitofn // return	1
happens. This is	1
error-prone. The program	1
article on compiler	1
entries. This may	1
risky. The returned	1
built with another	1
Members of parent	1
majority of end	1
build code for	1
(multithreaded) /arch:AVX /openmp	1
int)(i - min)	1
justifies the relatively	1
8.13a int i,	1
8.13b int i,	1
~, <<, >>	1
wheel. The containers	1
come. Even big	1
(gcc v. 4.5.2,	1
self-explaining menus of	1
actively invalidate the	1
2.5}; return list[x];	1
a.x, y +	1
weigh the advantages	1
resource-hungry applications to	1
zero-bits if unsigned.	1
reorganized in such	1
(a&~b)|(~a&b)=a^b --------- ~a	1
__try { //	1
minimizing memory fragmentation.	1
relation to execution	1
b[r][c]; } }	1
enum, const, or	1
8.21, you could	1
14.15b if (a	1
fine then it	1
Usability for Nerds	1
CPU-dispatching (see page	1
double) /arch:SSE2 -msse2	1
main, but also	1
truly represent a	1
allocation, deallocation and	1
seen, is certainly	1
(MFC). A competing	1
sprintf, etc. But	1
double: // Example	1
CriticalFunction, @gnu_indirect_function"); //	1
reorganize: // Example	1
convoluted template metaprogramming	1
b[i]; c[i] =	1
.R. for AVX.	1
restrictions. A GNU	1
copyrighted by Agner	1
network. Various development	1
arraysize; i++) {	1
express any algorithm	1
cheaper and more	1
re-allocation is needed.	1
de-referenced in order	1
Web systems should	1
restart the computer	1
(dynamically linked libraries	1
(j = 0;	1
clearing arrays It	1
auto_ptr. Smart pointers	1
Non-strict floating point	1
List[ArraySize]; ... for	1
experiments. Contentions in	1
acceptable. 3.6 Dynamic	1
*(++p) because in	1
Vec4uq Vec4f Vec2d	1
Modulo by a	1
improvements). // Example	1
vectorize, or #pragma	1
doubles by comparing	1
so, then you	1
Compile-time polymorphism with	1
weekdays. The maximum	1
price GNU General	1
PSDK). Supports the	1
Noncached write #pragma	1
printf(Greek[n]); } The	1
Unlike a pointer	1
interface, another thread	1
(MKL v. 7.2).	1
response. It is	1
MFC application. The	1
supported"); return; }	1
misprediction, or long	1
loader. 2. Position-independent	1
(1./1.2345) at compile	1
array[++i] because in	1
Func1(int x) {	1
responses to simple	1
offering profiling tools	1
Programming in the	1
First-In-Last- Out (FILO)	1
Inserting your own	1
(10000 / 64)	1
cpuid // Read	1
16.2. The measured	1
Advice on how	1
a+a+a+a = a*4	1
PTR[ecx+eax*4],ebx eax, 1	1
mode): ; Example	1
{1.0f, 2.5f}; a	1
kludgy that it	1
clauses: initialization, condition,	1
throughout the whole	1
x8 = x4*x4;	1
eliminates the need	1
straightforward. The MASM	1
create a new	1
non-const reference, a	1
dropping the graphical	1
Studio. This tool	1
SSE4A ammintrin.h AMD	1
friend function or	1
inlining, common subexpression	1
linking, as explained	1
12.2, the optimized	1
unnecessarily wasteful in	1
caught by the	1
structure), the microprocessor	1
checked before storing.	1
a[i+1]; s2 +=	1
(true) { a	1
107), OpenMP and	1
122) for the	1
62. If the	1
source, and the	1
96. 14.5 Integer	1
coded. If the	1
further. The first	1
Branch/loop function vectorized:	1
key? If the	1
sizeof(float)); // (Some	1
x-xxx-x-- 0/a=0 ---xx--xx	1
xx x x-	1
key. Do objects	1
Menus, buttons, dialog	1
conform to the	1
sizeof(float)). Now, the	1
password. The log	1
Linked lists and	1
classes): // Example	1
compilers............................................................................. 74 8.3	1
transition from AVX	1
(3 - 10	1
Copy protection. Some	1
10.1.020. Functions _intel_fast_memcpy	1
TR18015 Technical Report	1
happening. It is	1
keys within a	1
assignment operator, or	1
Namespaces........................................................................................................... 65 8	1
alternatingly several times	1
e, f, x,	1
2005. Codeplay VectorC	1
_mm_malloc and _mm_free.	1
exit(), abort(), _endthread(),	1
sizeof(list)); A multidimensional	1
hand-held devices are	1
a;} float parabola	1
5.82 (Embarcadero/CodeGear/Borland C++	1
year or two.	1
ex xn n	1
1./720., 1./5040., 1./40320.,	1
throughputs and micro-operation	1
for(i=i_div_3=0; i<300; i+=3,i_div_3++){	1
meta- programming is	1
CFALSE; } }	1
CFALSE: c =	1
Except for the	1
Include file dvec.h	1
entirely inside one	1
(&ArraySize) is taken.	1
form. A disadvantage	1
cut off the	1
developed. A CPU	1
frequency, as explained	1
lineage of software	1
nor slower than	1
x*x + 1;	1
error-handling function that	1
correspondence between function	1
areas where speed	1
occasionally predict that	1
forms a long	1
reusability and systematization	1
141. Applications that	1
First-In-First-Out or First-In-Last-Out	1
old-fashioned. Development in	1
n;} This code	1
u[1] by u[0].	1
indication of which	1
x*8 is replaced	1
complicated. If the	1
block, but this	1
ended queue) allocates	1
-msse2, -mavx, etc.	1
strongest optimization option	1
remember that your	1
Keep often used	1
Memory-hungry applications force	1
sizeof operator. The	1
server in full	1
affects other parts	1
decision at different	1
0.75 0.18 0.11	1
0.77 0.89 0.40	1
Nothing in the	1
<bool IsPowerOf2, int	1
staircase function of	1
?: operator here	1
economy and small	1
1./8.71782E10, 1./1.30767E12, 1./2.09227E13};	1
ipow(x,10); // used	1
packing, unpacking needed.	1
Contains many bit	1
attribute which can	1
E-book Usability for	1
(int)d; // Truncation	1
7.2. Alignment of	1
s1, s2 and	1
_intel_fast_memcpy and __intel_new_strlen	1
graphic brushes, etc.	1
vectors........................................................................ 119 12.8	1
9.1a int Func(int);	1
9.1b int Func(int);	1
absvalue, largest_abs =	1
mathimf.h that come	1
GetTickCount or QueryPerformanceCounter	1
registers; see page	1
(.lib or .a),	1
2'nd order polynomial:	1
verifying, debugging and	1
lesson we can	1
forward access to	1
original, poorly designed	1
translate these addresses	1
Occasionally, the clock	1
improvements. Making too	1
absvalue; largest_index =	1
position-independent, makes a	1
conditional move, depending	1
9.1. Time for	1
frame, saving and	1
frame" or "frame	1
int8_t short int	1
104). The table	1
Vec8f Vec4d 16	1
Vec8i Vec8ui Vec4q	1
x^3, x^4 F32vec4	1
.................................................................................... 124 13.3	1
1.5f : 2.6f;	1
--combine -fwhole- program	1
_mm256_i32gather_epi32 unlimited 4	1
__declspec(noalias) or __restrict	1
unequally can become	1
(b&c) = (a&b)	1
.exe file, is	1
printf("Gamma"); break; case	1
polynomial: // Example	1
commas. There should	1
popped from the	1
engineering principles to	1
polynomial. Scheduling A	1
burdensome position-independent code	1
trial versions are	1
contiguous. The code	1
................................................................. 107 12.2	1
thinks "what works	1
_mm_load_ps(coef+i); // s	1
maintenance. However, this	1
downloaded program updates	1
(*CriticalFunction)(parm1, parm2); }	1
b1; y2 =	1
explaining the relative	1
(ArraySize) is constant	1
prepared for several	1
iterators that are	1
implies more than	1
200. Next, we	1
safety, you may	1
(a|b)&(a|c) = a|(b&c)	1
2006 (Red Hat).	1
2007 (www.intel.com/technology/itj/). 10.1	1
2004 - 2014.	1
53). No general	1
ready-made profiler. This	1
Detect supported instruction	1
GetPrivateProfileString and WritePrivateProfileString	1
vector::reserve with a	1
CParent<CChild2> { public:	1
storage............................................................................. 26 7.2	1
query certain operating	1
7.33b const int	1
delete). 88 Object	1
compose a bitfield	1
prototype: void F1()	1
fragmentation. Bounds checking	1
OK, however, to	1
sorting, searching, and	1
y2; y1 =	1
fatal errors if	1
scarcity of registers.	1
Rick Booth: "Inner	1
MOVNTI _mm_stream_si32 SSE2	1
-100+100+100 = 100.	1
classes............................................................................................ 51 7.18	1
initializer lists, switch	1
(www.intel.com). If you	1
1./362880., 1./3628800., 1./39916800.,	1
non-zero, and therefore	1
initializes x to	1
g(x) is calculated	1
discover that there	1
-2.0 55 In	1
93). All common	1
(release version) in	1
publicly available information.	1
optimized, using assembly	1
discrete icon signaling	1
-opt-report Table 18.2.	1
unsatisfied with the	1
safe, of course.	1
entries use 64	1
other, then put	1
seemingly simultaneously. If	1
imported pointer, but	1
standardized. It is	1
compensate for the	1
maintain and verify	1
sin. Pointer elimination	1
sin, etc. Overriding	1
rightmost 1-bit removed.	1
............................................................................... 8 2.5	1
insertion of a	1
object: (1) get	1
instead. The Gnu	1
saved. Any other	1
_mm_andnot_si128(mask, bc); //	1
8.11b int SomeFunction	1
8.11a int SomeFunction	1
(Integrated Development Environments)	1
opposite). 9.10 Cache	1
"AMD64 Architecture Programmer’s	1
0x20, Saturday =	1
DTRUE: d =	1
DTRUE; } }	1
exchange data or	1
supposedly is system-independent,	1
digits. The exponent	1
44. The dispatching	1
digits, so the	1
www.agner.org/optimize/#vectorclass All these	1
(absvalue > largest_abs)	1
8.23b has two	1
defined(__GNUC__) // 32-bit	1
excuse that "we	1
SelectAddMul_SSE2 #elif INSTRSET	1
system-specific. In order	1
Predictable branches that	1
Later models had	1
www.agner.org/ optimize/#vectorclass Include	1
factors. The way	1
operators). The same	1
(b&&c) = a	1
35 This is	1
34 else {	1
'?', '@' and	1
-2.0, 4.4, 2.5};	1
int)a / 10;	1
holding the pointer.	1
module, and to	1
Running multiple threads	1
hint, but it	1
system-specific graphical interface	1
instrset_detect(); 116 //	1
remotely. If frequent	1
distributions of Linux,	1
Loops: A sourcebook	1
"we don't support	1
little-known alternative to	1
Hoisie: "Performance Optimization	1
InstructionSet(): // Example	1
decryption, data compression	1
crystal ball reveals	1
resolution. A much	1
absent in a	1
Similarly, we are	1
name, regardless of	1
(approximately): if (absvalue	1
reset or goes	1
disassembly, probably without	1
ordering? If you	1
arranging data in	1
hints as pragmas	1
functionality. This will	1
decoded in several	1
a<<b<<c=a<<(b+c) x-xxx--xx a	1
__intel_cpu_feature_indicator where each	1
Vol. 11, Iss.	1
unchanged. The problem	1
unchanged, while the	1
tag on a	1
Or, if protection	1
Combining the Borland	1
fetch the variable	1
(c1 = 0;	1
reserved for dynamic	1
balanced mix of	1
convenient. It is	1
(when vector operations	1
effectively preventing illegitimate	1
specification. The empty	1
high. It may	1
native floating point	1
rendering graphics on	1
First-In-First- Out (FIFO)	1
line: static inline	1
dilemma can be	1
(b*c)/d, it can	1
propagate through the	1
varies between 9	1
line, because the	1
framework........................................................................... 14 2.8	1
floats: float *	1
timediff[NumberOfTests]; for (i	1
floats. The same	1
22). 159 18	1
Place non-polymorphic functions	1
abc; }; Bitfield	1
ambiguous and may	1
models. However, we	1
correspond to any	1
_mm_permutevar_ps 4 4	1
7.38b. Alternative to	1
Y; Y +=	1
BigArray[1024]; // Windows	1
3B. developer.intel.com. AMD:	1
steps to access	1
looping through a	1
Func1(2); ... }	1
flawed approach to	1
about. Function inlining	1
pop-up messages saying	1
signifying one of	1
renaming. The CPU	1
manually, but if	1
<malloc.h> void SomeFunction	1
spell checking. Any	1
sequential, and you	1
&list[0]; temp <	1
(Not A Number)	1
day be implemented	1
complications. A double	1
least, it can	1
VTune and AMD	1
__vrs4_expf __vrd2_exp AMD	1
x-xx----x x-xxxxxx- x-xxxx-x-	1
identifies any hot	1
--------x a/1=a x-xxx-x--	1
a|(b&c) x-xxxx--x ~a&~b=~(a|b)	1
double's of 8	1
lists. A linked	1
lists, switch statement	1
programmed in a	1
most. The opposite	1
Print heading You	1
designers have gone	1
Try to allocate	1
contiguously in the	1
8.1b float parabola	1
x,y coordinates //	1
8.1a float square	1
-fno-strict-overflow. You may	1
usable library if	1
Reset floating point	1
likelihood that certain	1
fixed-size array is	1
dependent. The stack	1
right-most 1-bit in	1
--------- ~a ^	1
143. The trick	1
||). The bitwise	1
facilitate porting between	1
2007. PGI C++	1
12.9b. Taylor series,	1
esp+8 and esp+12	1
...................................... 88 9.5	1
economy, cache efficiency	1
lately. Vector class	1
structures: // Example	1
row-wise, then the	1
lookup-table static. Example:	1
reached with a	1
8.16 float a,	1
__rdtsc()). The time	1
(GOT). These table	1
8.17 char a	1
8.18 float a	1
Sequential forward access	1
may, in addition,	1
multithreading. 7.30 Exceptions	1
7.43 on page	1
7.42 int Multiply	1
renewed. Context switches	1
7.45 // Portability	1
7.44 class C1	1
7.4. Signed and	1
two(2,2,2,2,2,2,2,2); // Roll	1
while-loop is also	1
Compiled languages include	1
1/n! 1., 1./2.,	1
378.7 168.5 513	1
counting clock cycles	1
"\nError: Instruction set	1
neutralize each other.	1
x.i |= 0x80000000;	1
38.1 97 Table	1
38.7 512 512	1
"__attribute__((visibility("hidden")))". Use whole	1
animations is of	1
Manual". developer.intel.com. Many	1
demonstration purposes. Available	1
cards, etc. Use	1
1./6.22702E9, 1./8.71782E10, 1./1.30767E12,	1
hand and insert	1
caller, and so	1
32, 64, ...).	1
provokes an error.	1
operand. Likewise, if	1
memory-hungry software in	1
provoked here in	1
32; float matrix[rows][columns];	1
WhateverFunction(i); // ...	1
unavoidable. It may	1
apparently has no	1
DLL. Another alternative	1
_mm_stream_ps SSE Store	1
perform poorly for	1
mark_end; This solution	1
96). Virtual functions	1
x^1, x^2, x^3,	1
-ftrapv, but this	1
libircmt.lib. Function names	1
1.2345); The compiler	1
repetitive. The simplest	1
(n) { case	1
consumers. Choose the	1
request for inlining	1
N: #define N1	1
"Alpha", "Beta", "Gamma",	1
(be aware of	1
artificially changed to	1
animation. It is	1
cons of using	1
tolerance. The time	1
0x3F00 and 0x4700.	1
17is calculated as(a	1
reputation. The compactness	1
Iu8vec8 16 4	1
(/Oa). The easiest	1
saturated addition, fast	1
offsets). Example: //	1
$B1$2: mov shr	1
knowledge of the	1
list[i].b = 2.0;	1
stub. If different	1
Espresso) that can	1
Guide for AMD	1
"Integrated Performance Primitives".	1
T+6, and the	1
examples: strlen function.	1
bear in mind,	1
log(2.0) is only	1
andnot(a,a) = 0	1
12.8a. Sum of	1
0x7FFFFFFF; // set	1
-mavx, etc. for	1
"__attribute__((visibility ("hidden")))". A	1
2:8+esp eax, edx,	1
c2, mask); //	1
anything, you have	1
pulses since the	1
disappears when running	1
requests for elements	1
reliable. Event-based sampling:	1
Typically it should	1
constructing the object	1
Non-public distribution to	1
GB, but not	1
writable data section	1
c2; double temp;	1
inttypes.h is available	1
attempting to write	1
Debugging. The profiler	1
indexes, working with	1
--xxxxxx- a-(-b)=a+b ---xxx-x-	1
preprocessor can do	1
enters the market	1
July 2011). Instead,	1
lookup[2] = {2.6f,	1
Surprisingly, we end	1
because, in most	1
jeopardizing safety, you	1
draws a whole	1
UNIX shell script.	1
_mm256_permutevar_ps 4 4	1
'$' are allowed	1
exist. Therefore the	1
9.3. Time for	1
freely without any	1
taking cache effects	1
values: // Example	1
zation by multiple	1
(4096). This will	1
process...................................................................................................... 25 7	1
values, and last	1
maximum, saturated addition,	1
discussions about code	1
#define, const or	1
_fpreset(); _controlfp_s(&dummy, 0,	1
observed between the	1
15.1d to 15.1c	1
package, including all	1
piecewise or re-	1
division: Integer division	1
unused. This removed	1
ab[size]; int i;	1
steal the user's	1
array[i++] is more	1
FPGAs. The difference	1
x^n/n! xxn *=	1
access................................................................................................................ 20 3.8	1
OMF format. Alternatively,	1
nicely into the	1
finishes in a	1
keyword: // Example	1
keyword, for floating	1
2GHz A clock	1
cryptography (www.intel.com). If	1
Professional and Enterprise	1
keyword. The CodeGear	1
strcpy, strcat, strlen,	1
7.35b struct S1	1
7.35a struct S1	1
plain old data	1
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); It is	1
_mm_stream_si32 SSE2 Store	1
GB. When considering	1
advisable to make	1
mentations have no	1
_mm_i32gather_ps unlimited 4	1
100000001.23456. The float	1
9.6b 64 64	1
processors). It has	1
weighed against the	1
/arch:SSE2. The compiler	1
2009). Intel C++	1
UnusedFiller in the	1
flaws: The best	1
Booleans................................................................................................................... 33 7.6	1
notion of a	1
Atom). The following	1
kbytes. This is	1
Intel) know that	1
comparison: // Example	1
Intel. See Intel	1
FreeBSD and Open	1
somewhat. The AVX2	1
set: // Example	1
SelectAddMul_dispatch(short int aa[],	1
<intrin.h> long long	1
reduced. This may	1
Avoiding the cost	1
reporting here: return	1
profiling, but it	1
profiling. When a	1
numbered consecutively? If	1
phase in order	1
(b1 * b2);	1
builder Has an	1
Uncached memory store	1
responsi- bility of	1
thought about the	1
(SVML). This is	1
xx(-)x- - x-xxxx--x	1
8.23a. Loop to	1
indexed in a	1
event-counters do. This	1
often. This is	1
Microcontrollers used in	1
genuine compiler became	1
calculate. If there	1
modularity, reusability and	1
modularity. For example,	1
localize the first	1
optimize, and reading	1
Instead of returning	1
Repeating the break	1
Fine-grained parallelism is	1
script. Interpreted code	1
28) The threads	1
work, 133 although	1
28, the cache	1
calculated. Therefore, it	1
"FDIV bug". The	1
3.1, 2007. PGI	1
slower, especially when	1
reciprocal: // Example	1
__attribute__((fastcall)). The fastcall	1
cc[size] ); //	1
fistpl %0 "	1
VML and SVML.	1
Bridge) because it	1
mmintrin.h SSE xmmintrin.h	1
long, double. Misaligned	1
wastes several clock	1
inexact if b	1
odd-sized vector data.	1
1./4.790016E8, 1./6.22702E9, 1./8.71782E10,	1
thread-like scheduling in	1
T+5, then it	1
Itanium systems. The	1
Relocation. All pointers	1
brands, and one	1
2056 38.1 97	1
NUMROWS; row++) for	1
Lists of instruction	1
module2.cpp int Func2()	1
12.8b. Sum of	1
0.29 0.28 strlen	1
14.18c double a,	1
xmmintrin.h SSE2 emmintrin.h	1
blocking: int r1,	1
0.27 strlen 128	1
0.22 memcpy 16kB	1
((C & 3)	1
((B & 3)	1
Func(a[i]); } The	1
creates or modifies	1
work-around can be	1
results, which may	1
log) inside the	1
a*b*c=a*(b*c) a+b+c+d =	1
non-vector library. 119	1
recycled? There is	1
carry) instructions where	1
OS. See page	1
FactorialTable in example	1
timediff[i]); } The	1
can. It is	1
JNZ). This solution	1
chain, especially on	1
to) the time	1
!(a<b)=(a>=b) (a<b &&	1
134. The table	1
shows, the method	1
feeds a branch	1
1.0) { ...	1
improvements in microprocessor	1
introduced in Linux	1
Hence, it is	1
x86) of the	1
8.2a double a,	1
8.2b a =	1
alternately FuncA and	1
routines and device	1
billions of times	1
1.09 1.25 1.61	1
x4∙xn-4. There is	1
103), but the	1
1980 where RAM	1
14.7b, we are	1
14.7b. Testing multiple	1
Ignoring virtualization. The	1
affected by __fastcall.	1
x.d = y.d	1
x.f = 2.0f;	1
7.9b char a	1
7.9a bool a,	1
identical. For example,	1
somewhere in F1?	1
!b = !(a	1
bus is saturated.	1
(FIFO) basis then	1
practice, of course,	1
8.24 can be	1
8.25 void Func	1
disassembler. Note that	1
&&, ||, !	1
8.20 module1.cpp int	1
(critical stride) =	1
8.22 #ifdef __GNUC__	1
smart. They can	1
12.9a. Taylor series	1
SSE2, preferably 32	1
r.b;} The three	1
Multiplying by a	1
post-increment operator i++	1
bugs, compatibility problems,	1
C1::f. But an	1
F32vec8 F64vec4 Table	1
Will be called	1
overkill. Don't use	1
8.3b a =	1
ordinary procedure linkage	1
paying the performance	1
Journal Vol. 11,	1
-1.0E8, b =	1
imprecision in some	1
provide the best	1
in-between the floating	1
__intel_cpu_feature_indicator_x. You can	1
recovery information for	1
(WTL). A WTL	1
2.8. Asmlib: v.	1
indicates a specific	1
46 A common	1
(WTL): // Example	1
44 In some	1
decision. 13.4 Test	1
42 If you	1
indicated by the	1
workstations and scientific	1
41 Float to	1
230.7 513 513	1
faster, except perhaps	1
(cc[i] + 2)	1
85 ; eax	1
/Qipo -ipo No	1
indeed. It is	1
a[1] = 2;	1
6); Or, if	1
hackers. It is	1
exact. Multiple divisions	1
(row = 0;	1
friendly. It is	1
predictable, then it	1
(OnIdle in Windows	1
abusing the update	1
Leaf functions are	1
"Delta" }; if	1
0x10, Friday =	1
................................................................................................................ 48 7.15	1
C2::Disp() is done	1
sleep mode. See	1
(SIMD) operations. The	1
if-else structure), the	1
(); __asm__ (".type	1
feeding an array	1
----x---x a/1=a xxxxxxxxx	1
violate or circumvent	1
34. In some	1
1.19 13 Asmlib	1
(a&&b)||(a&&!b)=a x--xx---- (a&&b)	1
mathe- matical applications.	1
VHDL or Verilog.	1
postponed until the	1
rise to some	1
u[2]} a[size]; unsigned	1
browsing that previously	1
counter: // Example	1
0.3, -2.0, 4.4,	1
Henry S. Warren,	1
encounter another problem.	1
Bit-fields of sizes	1
unacceptable. Each of	1
live-ranges do not	1
0.30 4.5 0.82	1
Serialize // Prevent	1
Reference Manual". developer.intel.com.	1
consuming, especially if	1
problems, usability problems	1
(GOT) in order	1
0.38 0.44 0.40	1
----x---- !(a<b)=(a>=b) (a<b	1
created, deleted, copied	1
transpose(matrix); } }	1
contention. You may	1
powN<(N1&(N1-1))==0,N1>::p(x) * powN<true,N-N1>::p(x);	1
(r1 = 0;	1
wrapping the vectors	1
omitted, of course,	1
p->a + p->b;}	1
newer. The CPU	1
consisting of digital	1
estimated calculation time	1
Underestimating the cost	1
edx. Furthermore, this	1
Z. Each dependency	1
Architectures Optimization Reference	1
hide them for	1
specification to F1	1
decoding and perhaps	1
abort(), _endthread(), etc.	1
others. While some	1
Z; Z +=	1
memory................................................................. 120 12.9	1
considered. A realistic	1
general. Assume that	1
7.38a. Multiple inheritance	1
hundreds of different	1
Func2(double x) {	1
studio 2008, v.	1
reinvent the wheel.	1
yesterday's big mainframe	1
4.5.2, July 2011).	1
NEAR ; parameter	1
CodeGear, Codeplay and	1
http://www.agner.org/optimize/asmlib.zip contains complete	1
compiler) integer parameters	1
2040 38.7 512	1
7.43a. Runtime polymorphism	1
recursive templates. The	1
Trying to read	1
29. Each cache	1
returning. F1 is	1
sizeof(b)); 47 Most	1
scheduler. This can	1
summarizes the different	1
(b*c) overflows, even	1
prints an appropriate	1
optimization", Coriolis group	1
(2.0f); b =	1
list[i & 15]	1
pow(x,N) where N	1
[eax+400] DWORD PTR	1
-156. Surprisingly, we	1
speeded up significantly	1
y.d + 4.;	1
used: // Example	1
m. The advantage	1
m) { return	1
y.a + 1.;	1
y.b + 2.;	1
y.c + 3.;	1
Coriolis group books	1
...). We can	1
m> int MultiplyBy	1
...)) { ...	1
oldest Pentium CPUs	1
correspondingly two different	1
excellent support for	1
(float)i; f =	1
grandparent class: class	1
Vec4q Vec4uq Vec4f	1
ebx,1 adds this	1
(u.i[1] < 0)	1
simplicity. But a	1
Actually, only the	1
geometry and other	1
Vec4i 32 4	1
saves time for	1
aliased #pragma optimize("a",	1
Vec4d 16 16	1
(MS Visual Studio	1
scheduling in an	1
PowerPC). We can	1
guarantee that all	1
Virtualization is becoming	1
algorithm. The choice	1
compete for the	1
searches of the	1
both, while the	1
writes. If the	1
p->member is equally	1
confirmed this by	1
hence higher speed.	1
EXCEPTION_CONTINUE_SEARCH) { //	1
14.21. // Only	1
versatile. Fortran is	1
systematization of the	1
footprint. If, for	1
memcpy: // Example	1
summing up the	1
ports, etc. of	1
Assume, for example,	1
ultimate solution would	1
organized. Floating point	1
parsing are provided	1
© 2004 -	1
official C standard	1
fragmentation of the	1
construction in example	1
modified, if necessary,	1
40% more time	1
9.0 CodeGear Borland	1
suppress. GOT and	1
reflected, first and	1
137, respectively. Increment	1
terminates the program	1
26). Variables stored	1
perfectly. As explained	1
16.4 65 65	1
-fwhole- program /Qipo	1
terminated and the	1
. The value	1
backwards. Copying or	1
"Gamma", "Delta" };	1
often, but such	1
history, etc. may	1
c1() : x(0)	1
integer-to-float conversion takes	1
arraysize = 1000;	1
Vec16us Vec8i Vec8ui	1
---xxx-x- a+0=a x-xxxxxx-	1
subexpressions, and induction	1
unreferenced functions. It	1
non-recursing template specialization,	1
puts the programmer	1
15.0) is using	1
identifier names. We	1
gained remarkably in	1
stage that a	1
i++,i2+=2.0f)a[i]=i2; 41 Float	1
(byte code). The	1
asmlib.. // or	1
combining multiple .cpp	1
scope. A macro	1
selecting optimize performance	1
............................................................. 96 9.11	1
connections, etc. The	1
(temp = &list[0];	1
added. This method	1
Namespaces There is	1
merge the multiple	1
142). 30 Overflow	1
flush and fence	1
ASP and UNIX	1
documented. The examples	1
standards. Such schemes	1
pointers.......................................................................................................37 7.9 Smart	1
correctness must be	1
(rather than pointers	1
(zero with sign	1
CriticalFunction_Dispatch(int parm1, int	1
BTB can cause	1
profile-guided optimization. This	1
PROC NEAR ;	1
0x3FF unsigned int	1
7.32a double x,	1
(*p != 0)	1
issues, and I	1
coding rules apply	1
F2(float x[]); void	1
options....................................................................................... 160 19	1
0x3FFF unsigned int	1
$B1$3: pop ret	1
0.0; // copy	1
rewritten with the	1
mutexes and message	1
_mm256_i64gather_epi32 unlimited 8	1
attack for hackers.	1
clock. This gives	1
exp, sin, etc.	1
rights. Software should	1
fluctuating and it	1
combine the multiple	1
b<c && a<c)	1
incur a large	1
included. Combining the	1
compiler-specific. You cannot	1
security, but may	1
reinterpret_cast operator is	1
CPU-dispatcher that checks	1
1.5f; is efficient	1
Sum1, Sum2 and	1
(*.ini files). 20	1
returned. There is	1
1.25 1.61 n.a.	1
1.21 0.57 0.44	1
(also called properties)	1
mechanisms. Modern microprocessors	1
Warren, Jr.: "Hacker's	1
matrix[i][j] += x;	1
pass a pointer	1
mechanisms, and some	1
Constantfolding xxxxxxxxx Codeplay	1
&CriticalFunction_Dispatch; // Lowest	1
traditionally considered a	1
Database queries can	1
upon the double.	1
isolated into a	1
thorough analysis of	1
EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)	1
isolates the least	1
ball reveals that	1
intrin.h (MS) x86intrin.h	1
Convert to unsigned	1
pow, log, exp,	1
denominator can even	1
int)(max - min))	1
pattern, while Pentium	1
of. Big runtime	1
Float to integer	1
Sort the array	1
excessively so. These	1
inlined, or optimized	1
1024/4 = 256	1
max) { ...	1
/QaxAVX or -axAVX.	1
delaying process is	1
/Ox -O3 or	1
/Oy -fomit- frame-	1
reorganize the code	1
intranet for automatic	1
v.i * 2)	1
(2,2,2,2), and store	1
directly: Library exp	1
INVALID_HANDLE_VALUE && WriteFile(handle,	1
(Embarcadero/CodeGear/Borland C++ Builder	1
/Oa -fno-alias Non-strict	1
/Og Whole program	1
54. It is	1
micro-operation breakdowns for	1
||, ! and	1
Bit vector algebra	1
inputs. Let's take	1
infinity, and this	1
infinity. A typical	1
utilizing its out-of-	1
solution, but it	1
Larger data types:	1
criticized for code	1
PathScale. 2. Use	1
reduction. For example,	1
label. It uses	1
despite the extra	1
/O2 or /Ox	1
reinstall a software	1
framework, during start	1
SSE3. // (This	1
situation, but the	1
modulo. For example,	1
5.0f; b =	1
a[0] = 1;	1
hard-to-find errors, and	1
new. The purpose	1
/fp:fast /fp:fast=2 -fp-model	1
adjusted if you	1
dominating. At least,	1
discriminating between CPU	1
36. There may	1
Contents 1 Introduction	1
Asmlib: v. 2.00.	1
zero-terminated ASCII string	1
pipelined, as explained	1
polymorphous class? This	1
_mm_free. A more	1
discovers that it	1
_mm_stream_pd SSE2 Store	1
streams with different	1
_mm_stream_pi SSE Store	1
2.20, glibc version	1
intervals. Some programs	1
81). 77 Pointer	1
cycles). Floating point	1
16is calculated asa	1
non-constant references require	1
taken. A const	1
irregular response times.	1
extracts the functions	1
taken, i.e. if	1
games and animations	1
lrint(d); // Rounding	1
Is32vec4 Vec4i 32	1
Is32vec2 32 64	1
microcontrollers: Smaller microcontrollers	1
(other than log)	1
-ipo No exception	1
x[]) { int	1
a[arraysize], b[arraysize], c[arraysize];	1
printf("Delta"); break; }	1
1.2 in this	1
ends the recursion	1
quickly to keyboard	1
restriction, but it	1
email and web	1
(Windows, Linux, BSD,	1
i*sizeof(S1). This is	1
end. The reason	1
147 14.12 Position-independent	1
packed into a	1
0x2F00, 0x3700, 0x3F00	1
(Windows: /Gy, Linux:	1
(!a&&b) = a	1
temp2. Modern CPUs	1
edition is available	1
stride, as explained	1
stride. Variables whose	1
stride) = (number	1
temporarily lock a	1
teachers to recommend	1
stopping threads. Don't	1
0x2C so that	1
(CGrandParent) contains any	1
caches. Typically, there	1
positive. It will	1
Booth: "Inner Loops:	1
Libraries for high	1
Because the C++	1
Find numerically largest	1
2016. The same	1
!(!a)=a x-xxxxxxx ---x-----	1
NAN. Avoiding the	1
Interrupt service routines	1
platform-independent and compact.	1
strcat, strlen, sprintf,	1
(bit scan forward)	1
required, but in	1
numerical data is	1
characters '?', '@'	1
made) then it	1
matrices. An efficient	1
Thursday, Friday, Saturday	1
counterparts. In general,	1
90. 15 Metaprogramming	1
double..................................................................................... 140 14.8	1
(Of course there	1
language...................................................... 14 3	1
64). You may	1
STL. Some STL	1
matters: Division by	1
0= 0 -	1
advance, because a	1
operators............................................................................... 29 7.3	1
84). The compiler	1
(Visual Studio 2005).	1
13.1. Instruction sets	1
new/delete or malloc/free	1
14.22b unsigned int	1
14.22a unsigned int	1
technological point of	1
matters, which few	1
interprets the intermediate	1
Run multiple processes	1
vectorizing mathematical code.	1
400, last byte	1
www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf. OpenMP.	1
15.1d. Integer power	1
Taking the logarithm	1
reloaded eight times	1
features: The code	1
Nerds at Wikibooks.	1
user-written code with	1
59 third generations	1
amd_vrd2_exp Agner's vector	1
5; to int	1
clearly better. The	1
-fno-alias Non-strict floating	1
ingenious things to	1
57 Templates are	1
denominator: // Example	1
Func1(double) pure_function ;	1
later) instruction set	1
Denmark. Copyright ©	1
StoreNTD(double * dest,	1
(Both use 32	1
5, 2009). Intel	1
two: // Example	1
14.18a float a,	1
14.18b float a,	1
53. 7.24 Unions	1
two, b *	1
Slongdouble { unsigned	1
9.2b void F3(bool	1
9.2a void F1(int	1
Much of the	1
evicted. Don't mix	1
advertise new versions	1
(-a>-b)=(a<b) ---xx---x Divide	1
short. In Windows,	1
45. This may	1
1./39916800., 1./4.790016E8, 1./6.22702E9,	1
occurrences of ArraySize	1
Connecting several standard	1
134) return FactorialTable[n];	1
12.1a, the compiler	1
memset, or mathematical	1
destroyed. In 50	1
have: // Example	1
memset: // Example	1
etc.). Older operating	1
9.2, such as	1
things. Looking at	1
limitation and other	1
8.24. Integer constant	1
attacks and other	1
7.32b double x,	1
undocumented Intel library	1
surely rely on	1
-1. The bitwise	1
met: the object	1
shut down and	1
sections. 3.3 Program	1
behaviors. Arrays are	1
Very poor performance	1
assembly-like intrinsic functions,	1
Addison- Wesley 1997.	1
following: 130 Compile	1
difference, let's say	1
bottleneck. Organize the	1
sequence. If you	1
__declspec(__align(64)) double matrix[SIZE][SIZE];	1
rounds a floating	1
expansions. Programmers do,	1
temp1 and temp2.	1
0x40) % 0x20	1
temp. The compiler	1
printf("\nResults:"); for (i	1
Low-level languages are	1
0x0F) | ((B	1
........................................................................... 54 7.22	1
powN<true,N/2>::p(x) * powN<true,N/2>::p(x);	1
version) in the	1
memcpy(b, a, sizeof(b));	1
b[arraysize], c[arraysize]; //	1
truth depends on	1
ADX instructions for	1
ADC (add with	1
realize that such	1
Contain one or	1
objects, respectively (MS	1
I64vec2 Vec2q 64	1
mitigated by making	1
-axSSE3, etc. (Intel	1
objects) are possible	1
2015 or 2016.	1
r+i/2 could be	1
lag. Thinking in	1
tedious. The code	1
design. The ultimate	1
design, it is	1
scratch. This would	1
0.63 0.75 0.18	1
---xxx--- a/a=1 --------x	1
Programmable logic devices	1
producer will try	1
says. A code	1
-ffunction-sections) which allows	1
re-allocated every time	1
nn ifbit=1 bitofn	1
DEC, JNZ). This	1
whereas 64-bit Linux,	1
Faster, but risk	1
(Linux only). Specifies	1
ns = 250	1
Effective C++". Addison-Wesley,	1
XOP ammintrin.h (MS)	1
XOR b Bit	1
stand alone compiler	1
-fp-model fast, -fp-	1
class? This chapter	1
free) causes the	1
1./2.09227E13}; float x2	1
135). This extra	1
caching, but it	1
fprintf // define	1
Sum3. Whether you	1
block: 62 __try	1
clients that depend	1
1.4, 2005. Codeplay	1
column++) matrix[row][column] =	1
occurred anywhere in	1
tool. 7 The	1
iterator in some	1
illegal operation that	1
8.6a int a,	1
8.6b int a,	1
zip file of	1
7.15a. Array with	1
33% when the	1
signed. Be sure	1
signed, or by	1
7.5. Set flush-to-zero	1
s0, s1, s2	1
remarkably in popularity	1
Today (2013) both	1
great lengths to	1
files). 20 3.9	1
/QaxSSE3, etc. -msse3	1
(www.agner.org/optimize/testp.zip). A particularly	1
everything, which is	1
Security. The vulnerability	1
standard. An implementation	1
methods: Instrumentation: The	1
respectively (MS Visual	1
v.10.3 & later	1
v.10.2 & earlier	1
tiling. This technique	1
doubles: union {double	1
Next, we are	1
alternative. The theoretical	1
Library) and other	1
lea $B2$2: mov	1
StoreVectorA(void * d,	1
emphasized that the	1
*.so) that belong	1
en.wikipedia.org/wiki/Compiler_optimization. ISO/IEC TR	1
wmmintrin.h AVX immintrin.h	1
flip-flops, multiplexers, arithmetic	1
Microsoft's .NET framework	1
(/FAs or -fsource-asm).	1
standards for the	1
140. Avoid conversions	1
for(i=0,i2=0; i<100; i++,i2+=2.0f)a[i]=i2;	1
(Division is slow,	1
i<301; i+=3){ list[i]	1
valid) can possibly	1
CPU’s. Another function	1
ab[i].b = Func(ab[i].a);	1
forwards, not backwards.	1
elimination. The method	1
unreliable. They sometimes	1
port to different	1
Currently includes optimized	1
cheap, in relation	1
Library. The multiple	1
(www.intel.com/technology/itj/). 10.1 Hyperthreading	1
timing, assembly language	1
520 and leave	1
properties) are always	1
result, true (1)	1
reply about investigation	1
14.17b double a1,	1
52; // fractional	1
costless in terms	1
penalty. Branches are	1
fetching, decoding and	1
afterwards. The clock	1
123; are equally	1
groups of four	1
_mm_load_si128((__m128i const*)p); }	1
sent me corrections	1
(less than 65	1
_mm_exp_ps _mm_exp_pd AMD	1
noticeable but not	1
_mm_exp_pd AMD Core	1
Step (1) is	1
__declspec(cpu_dispatch(...)). See the	1
c[size]; float register	1
bb[i]*cc[i] is AND'ed	1
memset(list, 0, sizeof(list));	1
broader perspective of	1
NUMCOLUMNS; column++) matrix[row][column]	1
semicolons in a	1
toggle multiple bits	1
14.7a. Testing multiple	1
Today's microprocessors have	1
holes of unused	1
12.1. Vector classes	1
Therefore the compiler	1
output, which is	1
i=0; has been	1
session. But lazy	1
algorithm, then you	1
2014. Last updated	1
a[i+2]; s3 +=	1
anda * 17is	1
deviate from the	1
Background services. Many	1
"instrset_detect.cpp" // instrset_detect	1
12.1b to 12.1a.	1
_mm_add_epi16(a,b). Two libraries	1
EXCLUSIVE OR operator	1
8.26b: ; Example	1
list[16]; int i;	1
formalism that requires	1
full-size execution units.	1
graceful way. You	1
changes. A branch	1
(ATL) and Windows	1
-parallel -openmp -static	1
n++) { sum	1
(Examples can be	1
Friday)) { DoThisThreeTimesAWeek();	1
relaxed floating point	1
and) will cut	1
Family 15h Processors".	1
fprintf(stderr, "\nError: Instruction	1
16.1. This code	1
handle. Waiting for	1
Uses debug version	1
modifies many strings.	1
specifically for the	1
controversies over the	1
F1(int x[]); void	1
representation, except in	1
Thus, we will	1
http://www.agner.org/optimize/ - vectorclass	1
80.9 512 512	1
80.8 65 65	1
intelligible way by	1
computational power of	1
__attribute__((aligned(16))). Specifies alignment	1
measurement. If time	1
obscured in optimized	1
considerations. It is	1
dictates that an	1
crashes the program.	1
83 called faster	1
Look at Exception	1
17.9: "Moving blocks	1
multiplexers, arithmetic units,	1
next. The carry	1
representations in two	1
deallocate the space	1
_mm_store_si128((__m128i *)d, x);	1
completely. For example:	1
different. 64-bit Windows	1
succeeded in applying	1
little-endian storage, but	1
chapter. Using the	1
Vec16c 8 16	1
125 for this	1
14.16a double y,	1
if-branch in example	1
mainly on my	1
132. Unfortunately, table	1
size_t is 32	1
FILO manner? If	1
Higher inputs give	1
86 add add	1
coordinates // default	1
b2 * reciprocal_divisor;	1
b1 * reciprocal_divisor;	1
"Macro loops" chapter	1
b. But in	1
VIA. The next	1
happened to be	1
Polymorphism is one	1
32-62. This can	1
motion. See page	1
(www.boost.org). The "Intel	1
(seconds < 5)	1
continue in dispatched	1
Intel/x86-compatible microprocessors. The	1
7.26b float a[100];	1
Journal, 2002). In	1
(parallel composer) This	1
7.26a float a[100];	1
possibilities for optimization.	1
subtasks is necessary.	1
bottleneck, it is	1
analysis. If the	1
speed.............................................................................................................. 153 16.1	1
difference. Newest instruction	1
nmmintrin.h (MS) smmintrin.h	1
const, or #define	1
SVML. The IPP	1
non-object oriented programs.	1
catching hardware exceptions.	1
F1(); } catch	1
used). You may	1
2.6.30 and later.	1
contentions, as explained	1
causing return addresses	1
StoreNTD(&a[c][r], b[r][c]); }	1
F1. However, if	1
("fldl %1 \n	1
8.19. Devirtualization class	1
micro- processors have	1
15.1b, and in	1
module1.cpp int Func1(int	1
memory-intensive functions such	1
F1? Then we	1
account. You can	1
project. Some of	1
project, it is	1
recoverable and non-recoverable	1
3.x. These systems	1
checking, as illustrated	1
checking. Any task	1
8.10b a =	1
8.10a if (true)	1
yet. Supports both	1
0.59 0.27 strlen	1
DontSkip; long long	1
(&a); The compiler	1
During the history	1
---xx---x Divide by	1
view the software	1
discontinued Object Windows	1
Address calculation is	1
virtually no cost	1
satisfactory. The following	1
87. This will	1
-fp- model fast=2	1
.................................................................... 155 16.2	1
fetching a cache	1
i2; for(i=0,i2=0; i<100;	1
zero(0,0,0,0,0,0,0,0); // Make	1
card. Some systems	1
Func1, while other	1
convention says that	1
(OWL). Several graphical	1
<, <=, >	1
<. The result	1
PHP, ASP and	1
non-reduced expression better	1
level. My recommendation	1
released when the	1
address: // Example	1
Enterprise editions). Do	1
Vec2uq 8 32	1
statements............................................................................. 43 7.13	1
Mac, BSD Instruction	1
www.agner.org/optimize/testp.zip. This tool	1
CString. This is	1
receive new relevant	1
Mac: Darwin8 g++	1
expanded like a	1
solutions. Patches should	1
solutions, depending on	1
(a+1); c =	1
7.30b int i;	1
7.30a int i;	1
return; } //	1
published by Intel	1
GetProcessAffinityMask in Windows).	1
reinstalled and user	1
emulated processors and	1
map. Do objects	1
/Qparallel -parallel -openmp	1
fffff is the	1
Basic, etc. But	1
OneOrTwo5[b & 1];	1
Basic. A compiler	1
fastest. The typical	1
square(x) + 1.0f;}	1
fastest: // Example	1
max(T const &	1
late. You should	1
<float, 100> list;	1
closer to the	1
static_cast operator does	1
performance/price ratio. The	1
improvement in performance	1
runtime, if only	1
x^2, x^3, x^4	1
set). We can	1
corresponds to 16	1
icon signaling the	1
3"); or __debugbreak();.	1
1.61 n.a. 2.23	1
38). Is the	1
__attribute__((aligned(16))) #endif const	1
Documentation". Included with	1
connection with reading	1
satisfactorily on a	1
(SDK or PSDK).	1
alloca: // Example	1
Linear arrays are	1
list[301]; int i;	1
code.................................................................................. 148 14.13	1
Server 2008 R2	1
Comments All of	1
synchronizing and communicating	1
redesigning a program	1
alloca, because it	1
brushes, etc. Locked	1
_mm_cvtss_si32(_mm_load_ss(&x));} static inline	1
mind, that many	1
addressing. In 32-bit	1
Optimized function libraries	1
multi-threaded software are	1
7.3. Explain volatile	1
Fog The present	1
;edx=addressinr ; ecx	1
//=DeltaY // Store	1
Similar operations on	1
Alignment? Some applications	1
startup code and	1
1.5f}; a =	1
doesn’t. The undocumented	1
7.39 union {	1
12.8a to 12.8b	1
12.8b automatically and	1
"how many elements	1
7.35 page 52.	1
7.37 class S3	1
#) are costless	1
connections rather than	1
7.36 class S2	1
MAX(f(x), g(x)); In	1
add_horizontal) static inline	1
violates the strict	1
8*x + 2	1
www.agner.org/optimize and the	1
write: y =	1
exploited. A good	1
closely follows the	1
foremost, in the	1
remedy is memory	1
dependent and therefore	1
c1::*MemberPointer; Here, the	1
i--) *(p++) |=	1
list[i].b. It can	1
removable media such	1
ignore, then the	1
atomic. It doesn't	1
5). As soon	1
87) is likely	1
distributed. The intermediate	1
degrades performance for	1
Explain volatile volatile	1
(VML, MKL). Works	1
IsPowerOf2, int N>	1
Func(ab[i].a); } There	1
(NetBurst) CPU is	1
understands only the	1
6! The speed	1
ArraySize; i++) List[i]++;	1
poorly. It is	1
habit, it is	1
log(2.0); ... }	1
M processor may	1
period and by	1
flexibility, while execution	1
fashion. It is	1
3A and 3B.	1
CPU-time in library	1
62 __try {	1
CLR, to produce	1
0.95 0.6 1.19	1
exponent: // Example	1
operands: minimum, maximum,	1
67 The maximum	1
68 else {	1
69 } else	1
details). The Intel	1
4.0.1. Gnu: Glibc	1
DLLs, configuration files,	1
Incrementing or decrementing	1
conversion. The constructor	1
browsers, different platforms,	1
50; float matrix[rows][columns];	1
unrealistic that you	1
identification. Such schemes	1
500 clock cycles.	1
between. It is	1
consult the general	1
iteration. This allows	1
event, the clock	1
helpful for later	1
costs. The time	1
protocols and standardized	1
instead: // Example	1
(char, short int)	1
moderately well. Supports	1
aa, int *	1
overflows, even if	1
12.3. Intrinsic functions	1
brutally interrupted. Now	1
sign(i) ; shift	1
occur: if (SIZE	1
bcc, v. 5.5	1
#undef N1 }	1
1.fffff, where is	1
"Technical Report on	1
converts a zero-terminated	1
sizeof(float)) = 8	1
Sfloat { unsigned	1
erroneously called with	1
Subtractions use the	1
Builder 5, 2009).	1
as(a << 4)	1
shifts one place	1
intrinsics and automatic	1
$B2$3: ret ALIGN	1
Vec2d Vec8f Vec4d	1
breakdown. Many copy	1
subtasks, but it	1
y?" then you	1
driver involves the	1
producers keep adding	1
Vec2q 64 2	1
parts: one for	1
Is8vec8 8 8	1
prototypes for each	1
manuals: 1. Optimizing	1
(int)(&list[0]) + 100*16,	1
If, for example,	1
breakdowns for Intel,	1
minimize the amount	1
uint16_t unsigned int	1
32767 int16_t int	1
parts, for example	1
IPP library does	1
courses in programming	1
fma4intrin.h (Gnu) all	1
all, it will	1
bodies above, it	1
eax,1 is the	1
Loading data into	1
(SIZE > 256	1
Michael Abrash: "Zen	1
actions like a	1
risking to insert	1
sign, eee is	1
MathLoop() { const	1
heuristic guidelines. Most	1
(n!) as an	1
root, RGB color	1
GOT, and finally	1
7.2). This library	1
130. It is	1
ameliorated by using	1
installed can take	1
Gauss elimination. The	1
blog for details.	1
Dobbs Journal, 2002).	1
fundamental laws of	1
[eax+4], ecx 86	1
dest, double const	1
("CriticalFunction"); typeof(CriticalFunction) *	1
Change this to:	1
scheduled in a	1
-fwrapv or -fno-strict-overflow.	1
conversions. It does	1
educational purposes is	1
state. This penalty	1
i/2 in ebx	1
__vrd2_exp AMD LIBM	1
traffic and a	1
address) / (line	1
Compatibility problems. All	1
conversions: // Example	1
confined to a	1
glitches in the	1
funda- mentally flawed	1
matrix[SIZE][SIZE]; transpose(matrix); }	1
FUNCNAME(short int aa[],	1
matrix[c][r]. // Example	1
__declspec(align(64)) int BigArray[1024];	1
\n fistpl %0	1
MultiplyBy<8>(10); a and	1
accept expressions as	1
suggestions for my	1
Since most development	1
impacts on program	1
(with new or	1
Your measurement code	1
learn from this	1
compatibility, second source,	1
c1+TILESIZE; c2++) {	1
slice are quite	1
division...................................................................................................... 137 14.6	1
_mm_shuffle_epi8 16 1	1
__svml_expf4 __svml_exp2 Intel	1
Complicated code is	1
temp->b = 2.0;	1
list[x]; } The	1
temp->a = 1.0;	1
subexpressions that contain	1
(addition, multiplication, etc.)	1
guess, that compiler	1
12.1b. Vectorization with	1
12.1b, the compiler	1
&SelectAddMul_SSE2; // Error:	1
imprecisions should be	1
(Intel) #include <pmmintrin.h>	1
__svml_exp2 Intel SVML	1
hardware. Porting such	1
followed by an	1
SelectAddMul_dispatch; // Define	1
branches: one for	1
prior to SSE4.1	1
a+1;. The compiler	1
(but not in	1
__intel_cpu_features_init() sets the	1
low-power CPUs (Intel	1
list[i+1];} sum1 +=	1
IsProcessorFeaturePresent in Windows).	1
names, one global	1
satisfied. The conditions	1
distinctions between RISC	1
i+=3,i_div_3++){ list[i] +=	1
relocation at load	1
hours to install	1
b+a, a*b =	1
satisfied: 1. Use	1
neverthe- less be	1
list[] = {1.1,	1
clause. Comparing an	1
expandable, but it	1
754 (1985). This	1
x2*x, x2, x);	1
Should we try	1
deprecated. This is	1
porting between platforms,	1
amd_vrs4_expf amd_vrd2_exp Agner's	1
hour. Neither is	1
discriminates between CPU	1
applying the various	1
has. Assuming that	1
1023 1 fraction	1
Waiting for user	1
classes: // Example	1
p1->Hello(); CChild2 *	1
_mm_blendv_epi8(bc, c2, mask);	1
8.12a int i,	1
8.12b int a[2];	1
CriticalFunction_Dispatch; // Function	1
(Compile without the	1
Frequent context switches	1
isolating a single	1
strongly recommended to	1
manageable and easier	1
include: Memory allocated	1
totaling up to	1
(5) make the	1
(MOVNT) are designed	1
.NET, which is	1
column-wise manner where	1
exception-safe code Assume	1
spends most of	1
4.5 0.82 0.59	1
Size() { return	1
Sizes of different	1
4.; }; //	1
website. 5 Choosing	1
buttons, dialog boxes,	1
9.5a: 98 int	1
call, and the	1
....................................................................... 77 8.4	1
1./5040., 1./40320., 1./362880.,	1
ReadB() {return b;}	1
printf("\n%2i %10I64i", i,	1
7.1. Sizes of	1
elements? If the	1
(if valid) can	1
caused by random	1
x.f; // will	1
---xx--xx (-a==-b)=(a==b) ---xx----	1
XOP, AMD only	1
First-In-Last-Out access, sort	1
sizeof(float) in order	1
Hardware updating. The	1
tricks Michael Abrash:	1
a= a a	1
a: // Example	1
directory as the	1
"Beta", "Gamma", "Delta"	1
(b*2.0)/3.0 rather than	1
(doubly ended queue)	1
CriticalFunction(b, c); ...	1
unreferen- ced functions)	1
scalar (Scalar means	1
57). It is	1
63; // fractional	1
Scott Meyers: "Effective	1
delays. The easiest	1
Read time You	1
paralleli- zation by	1
uint8_t unsigned short	1
opportunities for parallelization	1
Thursday = 0x10,	1
_mm_i32gather_epi32 unlimited 4	1
gone to great	1
aliasing, but the	1
add_elements(s); // add	1
Dispatcher. Will be	1
void. Returning objects	1
worse kind of	1
((a+b)+c)+d. This is	1
Classes (MFC). A	1
strlen, sprintf, etc.	1
Constructor-style type casting	1
correctness. It is	1
miss. But if	1
higher-priority thread running	1
services. Many services	1
library). The D	1
[esp+4] DWORD PTR	1
N; } T	1
DynamicArray = (float	1
_mm_hadd_ps(x, x); s	1
N) { //	1
design of small	1
(depending on the	1
obvious. See the	1
obvious, then it	1
FuncType(short int aa[],	1
(1. / 1.2345);	1
freely. The loop	1
x-xx--xx- x--x----- --xx-----	1
b[r][c]); } }	1
option) better: -Ofast	1
replacements for switch	1
Performance". www.open- std.org/jtc1/sc22/wg21/docs/TR18015.pdf.	1
handler, even if	1
increment. The three	1
segmentation of the	1
integers: // Example	1
-openmp -static Generate	1
behaviour is implementation	1
XOR'ing it with	1
RTTI then turn	1
divisor. In this	1
a.y);} vector a,	1
r1+1; r2 <	1
increments seconds. A	1
handlers for cleaning	1
references: If the	1
composer) This compiler	1
2-dimensional vector 56	1
-128, and subtracting	1
//=A*x*x+B*x+C //=DeltaY //	1
applications: The cost	1
/Fa for assembly	1
unrecoverable error without	1
Things that may	1
/Fm Generate optimization	1
texts they point	1
redesign. Some software	1
0x3F800000; // Now	1
-fpic. This will	1
research on CPU	1
servicing. A command	1
__cpuid(dummy, 0); DontSkip	1
rows/columns in matrix	1
p->NotPolymorphic(); p->Hello(); p	1
Hoisie, SIAM 2001.	1
e.g.: // Example	1
destroys any memory	1
deque (doubly ended	1
knows that it	1
2010. This feature	1
80x86 / x64	1
restoring registers, and	1
a2/b2; Here we	1
_mm_cvtss_f32(s); } //	1
-read_only_relocs suppress. GOT	1
newsgroups contain useful	1
12.4b, rewritten with	1
12.4b. Vectorized with	1
(rarely 64). You	1
10000, then we	1
b[0], a[1], b[1],	1
72). The compiler	1
dimensions of the	1
v 4.0.1. Gnu:	1
y2, reciprocal_divisor; reciprocal_divisor	1
lightweight processors with	1
;alignby4 ; mangled	1
Coarse time measurement.	1
vectorized: void SelectAddMul(short	1
influenced by the	1
5.5 Mac: Darwin8	1
swapping. Software developers	1
breaking out of	1
Cannot optimize across	1
libmmt.lib and the	1
speeding up 64-bit	1
;a ;r ;	1
_finite()) and redo	1
Functional decomposition here	1
ratio. The CISC	1
unattended. Uninstallation should	1
reflect this or	1
;r ; unused	1
2.5f}; a =	1
61. It is	1
-m64 -static /MT	1
concentrating on important	1
(& and |)	1
preference is for	1
&list[8]); } Here,	1
(6 integer and	1
(0 < 5)	1
(YMM) if the	1
12.4d. Same example,	1
process, and the	1
best-case conditions. All	1
d.x; a.y =	1
a+b=b+a, a*b=b*a x	1
(8 float or	1
(A & 0x0F)	1
(C << 6);	1
developer may choose	1
(B << 4)	1
PREFETCH _mm_prefetch SSE	1
mangling. The characters	1
susceptible to problems	1
Stefan Goedecker and	1
(SSE): #include <xmmintrin.h>	1
inte- ger or	1
/arch:SSE3 -mssse3 /arch:SSSE2	1
sum. The trick	1
ReadB needs to	1
Verilog. Common devices	1
inferior. A model	1
dimension may preferably	1
party security software.	1
Advices on optimization	1
reporting. For example,	1
wired for a	1
14.12a int list[300];	1
refresh the screen.	1
inequality sign must	1
Ready made container	1
types. A disadvantage	1
!a; can be	1
defined(__unix__) || defined(__GNUC__)	1
destructor, if any,	1
destructor. A function	1
wires that connect	1
_mm_clflush intrinsic function.	1
sizes? It is	1
SelectAddMul example (12.4e)	1
--xxxx-xx a*1=a x-xxxxx-x	1
Loops...................................................................................................................... 45 7.14	1
iset = instrset_detect();	1
beginning. ret returns	1
adhere to certain	1
__rdtsc(); return clock;	1
3.0; The compiler	1
Calculations in a	1
loop- carried dependency	1
i++)a[i]=2*i; The conversion	1
non-recoverable errors; make	1
side-effects and its	1
Looking at the	1
loop? Certainly not!	1
Glibc v. 2.7,	1
C1, so it	1
written. This worked	1
Partial template specialization	1
a[] which will	1
modularity and reusable	1
properly. Many CPU	1
fast=2 Simple member	1
aa[size] ); //	1
throws an exception.	1
feed into the	1
former case x	1
bug". The FDIV	1
considerably. Another serious	1
feel that a	1
relate to CPU-intensive	1
b++; will make	1
well-known languages. My	1
6. If arrays	1
antivirus program that	1
sizes, and they	1
pipeline. If the	1
" : "=m"(n)	1
gates, flip-flops, multiplexers,	1
games. Such a	1
FactorialTable[n]; // Table	1
Newer processors are	1
IntegerPower (double x)	1
158. This manual	1
'>') are not	1
18.1. Command line	1
obsolete within the	1
15.1c, but none	1
prediction). 149 All	1
-231 231-1 int32_t	1
information, such as	1
a*b*c*2. It is	1
nagging pop-up messages	1
threads? Container classes	1
7.22. // Example	1
www.yeppp.info And here	1
&list[100]; temp++) {	1
Intel/MASM syntax: __asm	1
Keywords that work	1
requires, of course,	1
workplace and the	1
risky because it	1
"standard stack frame"	1
cached, but several	1
p->f(); // Virtual	1
checking). An error	1
search: // Example	1
instrset_detect function //	1
measure. This is	1
concentrate the optimization	1
double's. It is	1
Inlined functions have	1
a*4 - n.a.	1
this). Use rounding	1
x2; // x^4	1
Runtime, CLR, to	1
multiplications, which can	1
That being said,	1
reach element number	1
x2, x); //	1
76 Boolean XMM	1
75 (a&&b) ||	1
832 256 16	1
job, but it	1
job. You have	1
71 The compilers	1
70 Induction variables	1
www.openmp.org and the	1
down. Remember to	1
79 Floating point	1
CPLDs and FPGAs.	1
coincides with the	1
8.14b int i,	1
press. 19 Avoid	1
8.14a int i,	1
bit-mask which is	1
worried about this	1
"m"(x) : "memory"	1
sign-bit if the	1
7.33a const int	1
stupid. Some common	1
pooling. It is	1
pooling) than to	1
shares the resources	1
modular. The so-called	1
forward) instruction to	1
advantages: The i<20	1
WritePrivateProfileString to read	1
2005). Borland C++	1
try, catch, and	1
multiply-and-add Table 13.1.	1
only, then the	1
triangle is handled	1
x-xxxx-x- x-xxxxxxx xxxxxxxxx	1
Rounding is fast.	1
Quine–McCluskey or Espresso)	1
n-1 multiplications, which	1
laws of algebra.	1
x^0/0! // n	1
semicolons, while multiple	1
(/arch:SSE2, /arch:AVX etc.	1
float(i); f =	1
decimals. It is	1
not! 250 μs	1
together...................................... 88 9.4	1
(live ranges) do	1
-ffast-math /fp:fast /fp:fast=2	1
managing a memory	1
Sum1() {return a	1
rare. Testing for	1
responded to at	1
-100 to -56	1
2.; x.c =	1
pre-calculated table. Even	1
a+b+c=c+b+a a+b+c+d =	1
devirtualization (see page	1
invoked with automatic	1
128- bit vector	1
9.5b. // Example	1
printer or other	1
Uninstallation should also	1
Half size execution	1
Important features 80386	1
Func2 were in	1
say that you	1
12.3a, for example,	1
......................... 142 14.10	1
reads. The same	1
1./120., 1./720., 1./5040.,	1
unions rather than	1
Pascal, Fortran and	1
namely the two	1
structure, data flow	1
Multidimensional arrays should	1
'this'. We can	1
AVX2, or two	1
<asmlib.h> void CriticalFunction();	1
16-bit, 32-bit and	1
u.i[1] ^= 0x80000000;	1
much. Excessive loop	1
(eax) which contains	1
on) __restrict __restrict	1
attention of software	1
level- 1 cache.	1
maintainability of C++	1
f=i; f =	1
0x7F unsigned int	1
relying on the	1
setup. on Intel	1
Monday = 2,	1
n'th degree polynomial	1
"Register usage in	1
a&b&c&d = (a&b)&(c&d)	1
clause are separated	1
ignored if the	1
union, as in	1
i<20 loop control	1
<=, > and	1
relational operators (e.g.	1
*x; double x4	1
Primitives" library contains	1
finds the numerically	1
false: // Example	1
square: // Example	1
protection. Some copy	1
iterative in nature,	1
objects), resource files,	1
tricky. I have	1
opposite: Don't put	1
for-loop: i++; }	1
complication that the	1
++b; the compiler	1
square. // This	1
SelectAddMul_SSE41, SelectAddMul_AVX2, SelectAddMul_dispatch;	1
strategy for saving	1
AND'ing it with	1
xplus2() { The	1
X?" rather than	1
Specifications, Dr Dobbs	1
million times less	1
(new and delete).	1
reason. A program	1
reason, you can	1
-fopenmp /Qopenmp -m32	1
squares and handle	1
Best-case testing is	1
investigation of the	1
disguise. Enums are	1
route. This mechanism	1
small, then it	1
compactness of the	1
overhead. Example: //	1
//=2*A //=A*x*x+B*x+C //=DeltaY	1
2.6f; The ?:	1
%10I64i", i, timediff[i]);	1
point-to-integer conversions in	1
set?". A list	1
loop-branch is usually	1
vector(x + a.x,	1
8.8b double x,	1
Encryption, decryption, data	1
8.8a double x,	1
~b = a	1
Firewalls, virus scanners	1
x-xxx--xx a |	1
100*16, and temp++	1
Newest instruction set	1
normalized, if possible,	1
MFC). This method	1
.............................................................................. 65 7.32	1
widely different priority	1
re-calculated every time	1
advise of using	1
Multithreaded programs must	1
year. Ignoring virtualization.	1
Insert an explicit	1
Reducible expressions also	1
vector() {} vector(float	1
decades ago, the	1
decreased when the	1
CPU.............................................................................81 8.5 Compiler	1
(*CriticalFunction)(b, c); ...	1
12.7. Vector class	1
patterns. This can	1
publish a function	1
definitions when used	1
Multiply(10,8); b =	1
"undefined". This allows	1
separately: for (r2	1
[ecx+eax*4],ebx stores this	1
std::unexpected() function in	1
b.x + c.x	1
people. I simply	1
(GetExceptionCode() == EXCEPTION_FLT_OVERFLOW	1
-mveclibabi=svml. This library	1
a[c][r] = b[r][c];	1
uninitialized, if pointer	1
jumps, calls and	1
places. Constant folding	1
computing, but for	1
stress the importance	1
Iu8vec16 Vec16uc 16	1
b[1], ... then	1
strictness is required.	1
2.1. Comparing performance	1
alignment, bytes bool	1
2.00. Intel C++	1
around. Adding 1	1
Why is template	1
access....................................................................................................... 22 3.14	1
arraysize) { //	1
casting. Linked lists	1
casting, but also	1
violations and invalid	1
-mveclibabi -fopenmp /Qopenmp	1
malloc. Handles to	1
Last updated 2014-08-07.	1
malloc) is necessarily	1
*(__m64*)&source); // MOVNTQ	1
231 then convert	1
interval. A hash	1
removed, all resources	1
Func() { S1	1
interval: // Example	1
question: Put in	1
r2; c2++) {	1
violation, integer overflow,	1
incremental or iterative	1
admittedly very kludgy.	1
application- specific instructions	1
collect the functions	1
PC's, workstations and	1
"position-independent code" actually	1
application, while dynamic	1
spots. The test	1
list.Size(); i++) {	1
essential task of	1
r2, c1, c2;	1
xx-xx--x- reciprocal Boolean	1
mirroring is not	1
"function level linking"	1
identified. My test	1
g(x)); In this	1
Time- consuming library	1
originally designed by	1
8*1024/64 = 128.	1
--xxxx--- a &	1
(using Intel vector	1
series: ex xn	1
3.; x.d =	1
v.i) { //	1
select_gt(b, zero, c	1
Prototype for the	1
String constants and	1
IsPowerOf2 = false	1
glibc version 2.11	1
pros and cons	1
matical applications. But	1
............................................................................ 51 7.19	1
stored? If the	1
tends to make	1
leftmost column to	1
Gnu). Other compilers	1
series, vectorized #include	1
series. The exponential	1
(ZMM). Vector operations	1
Command line options	1
2.1.7, 2004. No	1
Square blocking and	1
DelayFiveSeconds function will	1
tortuous and convoluted	1
.......................................................... 107 12.3	1
boxes, etc. should	1
s); return _mm_cvtss_f32(s);	1
yes License license	1
dialog boxes, etc.	1
integer). All intermediate	1
~. The Boolean	1
~(~a) = a	1
matrix, i.e. each	1
xxxxxxx-x xxxxxxxxx x-xxx----	1
Those who are	1
file) should be	1
predictions in the	1
value, n. But	1
x[0] = a;	1
_mm_stream_pi((__m64*)dest, *(__m64*)&source); //	1
OneOrTwo5[(b!=0) ? 1	1
fake an Intel	1
(XMM) if the	1
logically distinct tasks.	1
vendors are offering	1
constant, unless the	1
i[2]; } u;	1
analyze all pointers	1
accomplished by doing	1
catch, and throw.	1
2005; and "More	1
PCLMUL wmmintrin.h AVX	1
wherever appropriate to	1
criteria or lists	1
.............................................................................................................. 54 7.23	1
++i and the	1
repeatedly with the	1
sqrt, pow and	1
__restrict__, if supported	1
raising an exception	1
vectorclass.h Supported compilers	1
section. 12.5 Using	1
section, but it	1
unfavorable, unless the	1
114 #include <dvec.h>	1
................................................................................................................... 56 7.26	1
hasn't thought about	1
1.f); // initialize	1
emmintrin.h SSE3 pmmintrin.h	1
optimal, though. In	1
occurrence is rare.	1
testing, verifying and	1
row. The same	1
(methods)......................................................................... 53 7.20	1
self-styled hacks and	1
ia32intrin.h _mm_exp_ps _mm_exp_pd	1
N-1)==0,N>::p(x); } //	1
minute if the	1
develop. It is	1
Declare the function	1
exact time consumption	1
RAM, a lot	1
circumstances around the	1
powN<true,1> { public:	1
NOT. Instead, you	1
(0x2710 / 0x40)	1
_mm_i64gather_epi32 unlimited 8	1
Embarcadero Comes with	1
lower; and the	1
table-based methods with	1
(a*b*c)+(c*b*a) to a*b*c*2.	1
97 Table 9.1.	1
pow(x,10) with only	1
AMD's profiler is	1
data", where it	1
92 DynamicArray[i] =	1
allowing two data	1
Tips about how	1
vice versa. But	1
generators. In general,	1
x4*x4; double x10	1
tested. The reason	1
c.x + d.x;	1
c.y + d.y;	1
activates critical application-	1
back, where n	1
activated by the	1
Scheduling A compiler	1
7.34b. Replace macro	1
Vectorize #pragma vector	1
comments, in green.	1
variables: // Example	1
80386 32 bit	1
14.16b double y,	1
note: This example	1
Requires binutils version	1
Pentium-II or later	1
Borland's now discontinued	1
xx4; // next	1
__except (GetExceptionCode() ==	1
rounding, but neither	1
issue, as you	1
superfluous code, but	1
b*2.0/3.0 will be	1
mainstream next year.	1
_mm_hadd_ps(s, s); return	1
Perl. Several modern	1
14.17a double a1,	1
15.1c? We took	1
discussions. Turn on	1
unwinding. All functions	1
("int 3"); or	1
relax floating point	1
higher) is enabled.	1
;checkifi<100 ; repeat	1
dealt with in	1
((x2)2)2 a+a+a+a=a*4 -(-a)=a	1
language: An optimization	1
dummy[4]; volatile int	1
model, which quite	1
exist for all	1
14.15a if (a	1
(without member functions)	1
Loopunrolling x-xxxx--x Profile-guided	1
wrong, but it	1
makers assume that	1
textbook on test	1
15; // exponent	1
leaks. It is	1
large. 156 16.3	1
Poor reproducibility. Delays	1
159 18 Overview	1
154 // Print	1
/GR- -fno-rtti Assume	1
152 If you	1
entry. You can	1
inlining. Reducible expressions	1
Object1.Hello(), though future	1
151 15.1c automatically,	1
thought-through approach to	1
vectorize. The pragmas	1
suggests methods for	1
normally. There are	1
_mm256_i32gather_ps unlimited 4	1
Multithreading.............................................................................................................. 101 10.1	1
_endthread(), etc. then	1
ranges) do not	1
analogous to example	1
summation variables sum1	1
system......................................................................................... 6 2.4	1
statement: // Example	1
happy to receive	1
systems" for details	1
Gnu/AT&T syntax: __asm	1
Device drivers, interrupt	1
mainframes, and between	1
device. Any language	1
loops" chapter in	1
www.agner.org/optimize/#vectorclass. The Intel	1
%1 \n fistpl	1
sort and search	1
floata; boolb=0; static	1
updates. Automatic updating	1
updates, remote help	1
(b[i] * c[i]);	1
level-3 cache. If	1
14.00 for 80x86	1
Few compilers are	1
detects an error	1
_alloca) for (int	1
anywhere in the	1
B1, public B2	1
importantly, it requires	1
................................................................................................................. 21 3.11	1
a[1], b[1], ...	1
0.5 ns =	1
Feature bloat. It	1
0.6 1.19 13	1
mask, and bb[i]*cc[i]	1
list[ARRAYSIZE]; if (i	1
Is16vec4 16 4	1
Details about instruction	1
JavaScript, PHP, ASP	1
NUMCOLUMNS = 100;	1
eight) points with	1
First you compile	1
losing precision. The	1
ReadTSC(); CriticalFunction(); timediff[i]	1
cores: Define multiple	1
makers. 4. Instruction	1
panic if you	1
sin function is	1
rebooted. To prevent	1
WritePrivateProfileString, which opens	1
(...) { ...	1
abuse is extremely	1
place. This can	1
FuncCol(int); const int	1
%. Conversion to	1
Const cast The	1
abs(u.f) > abs(v.f)	1
tables: Lists of	1
13) { //	1
Interference from other	1
times: Dispatch on	1
min)) { ...	1
conflicts. But if	1
133 although slightly	1
complicated? Because the	1
131 Note that	1
<math.h> #define EXCEPTION_FLT_OVERFLOW	1
Application programmers rarely	1
people who have	1
disks and USB	1
Further details are	1
single-thread speed. In	1
collection, as mentioned	1
138 A similar	1
tables. The static	1
%0 " :	1
tables, and virtual	1
superior performance/price ratio.	1
powerful. The high	1
newsgroup comp.lang.asm.x86 for	1
activate a particular	1
C2, then we	1
massively parallel vector	1
unique key. Do	1
multithreading that we	1
unlikely that the	1
pending instructions in	1
a[0], b[0], a[1],	1
kb. This corresponds	1
kb, 8 ways.	1
practice to test	1
(RTTI). See page	1
(RTTI), which affects	1
www.agner.org/optimize/testp.zip or get	1
.................................................................................................................... 55 7.25	1
ease of development	1
resized in the	1
Pro instruction set	1
unpredictably at inconvenient	1
................................... 141 14.9	1
Internal references to	1
comparisons. The solution	1
trap integer overflow	1
overridden in Linux	1
Vec4ui 64 2	1
sub-expressions. Why is	1
addresses, or if	1
opinions on which	1
microprocessors, different alignments	1
individually. Example: //	1
p->b;} int Sum3(S3	1
initialisation i=0; has	1
matters rather than	1
tune the code	1
18.3. Predefined macros	1
doubled for this	1
categories: File input/output	1
routines, system core	1
usability. This is	1
0x8040); See page	1
couple of things	1
Parameter transfer is	1
huge). Far storage,	1
13.1, Requires binutils	1
Of course, this	1
131) shows a	1
recompile it. I	1
Main loop for	1
MKL, VML and	1
log(c[i]);. This would	1
said, I must	1
ways). If a	1
tests, the Intel	1
trees, hash maps	1
template: // Example	1
bits). The advantages	1
FactorialTable[b]; ... }	1
Thin clients that	1
_mm_cvtsd_si32(_mm_load_sd(&x));} The code	1
int)i; This conversion	1
tried. The Microsoft,	1
Windows) to determine	1
needed? A matrix	1
2A, 2B, and	1
follows. The first	1
static_cast<float>(i); // Implicit	1
respect. 7.15 Function	1
bulky and difficult	1
light-weight alternative is	1
kilobyte is 1024	1
correction for the	1
supports. An inferior	1
supports, rather than	1
104 } Microprocessors	1
5-10% for some	1
0.5ns. 2GHz A	1
profitable. On the	1
255 uint8_t unsigned	1
MASM assembly language	1
150. Using templates	1
directly, or use	1
directly. The reason	1
argue that it	1
planned solutions. Patches	1
capability: // Example	1
destination, but don't	1
shell script. Interpreted	1
.so). There is	1
range"); or better,	1
reversed if c	1
4.4, 2.5}; return	1
reflecting it at	1
scanf. Violation of	1
isolation have been	1
limiting factors for	1
(signed) address. The	1
exceptions, etc. Event-based	1
measurements: warm up	1
1.0 <= u.f	1
YMM) which can	1
Covers PC's, workstations	1
Wednesday, Thursday, Friday,	1
(XMM or YMM)	1
Iu16vec4 32 2	1
patch. 131 Note	1
1., 1./2., 1./6.,	1
met then it	1
xopintrin.h (Gnu) AMD	1
FuncC(i+1); } This	1
^0 = a	1
C99 standard. An	1
Iu16vec8 Vec8us 32	1
x86intrin.h (Gnu) Table	1
unpacking needed. Predictable	1
-fsource-asm). This option	1
seriously. User complaints	1
__attribute__((aligned(64))); // Linux	1
clash with another	1
nature of the	1
if(!(a || b))	1
requirement. Useful when	1
Advanced book on	1
propagated through a	1
C0::f or C1::f.	1
I64vec1 8 16	1
(CParent<>) contains any	1
dilemma. You may	1
High precision math.	1
Gnu: Glibc v.	1
API's. Memory swapping.	1
workaround. Supports all	1
4.1.0, 2006 (Red	1
_mm_empty(); // EMMS	1
parallel: Using multiple	1
our estimate is	1
8.0f) * x	1
considerable. If two	1
pointer". The standard	1
"Zen of code	1
parameters). The this	1
debate about which	1
Pragmatic Look at	1
Multiplications are done	1
(1,2,3,4), and store	1
146). In the	1
green. It takes	1
candidates for register	1
Preprocessor directives. For	1
Out-of-order execution (chapter	1
he or she	1
thousands of people.	1
menu click becomes	1
chapter, I have	1
shuffling can sometimes	1
a&&b (a&&b) ||	1
arithmetics and pointer	1
Vec32uc Vec16s Vec16us	1
Move the conversions	1
if(!a && !b)	1
(column = 0;	1
gives: // Example	1
100000000. When we	1
formats. Comments All	1
Iss. 4, 2007	1
incomplete information about	1
printf("Alpha"); break; case	1
generations classes contain	1
costless. It is	1
guidelines. Most caches	1
knowing that the	1
7.43b is admittedly	1
18, then the	1
Thinking in terms	1
Relocation is done	1
Typical candidates for	1
int16_t int in	1
shall automatically come	1
p2; p2 =	1
SafeArray() { memset(a,	1
closes the file	1
uint32_t unsigned long	1
2.5f; If we	1
breakpoints at every	1
favor of Intel	1
g++ v 4.0.1.	1
....................................................................................................................... 3 1.1	1
frustrated by unacceptably	1
2.7, 2.8. Asmlib:	1
a[i+3]; } sum	1
columns. Every fourth	1
a[N]; public: SafeArray()	1
Overriding the Intel	1
columns; j++) 39	1
a.x = b.x	1
a.y = b.y	1
conversion, shuffling, packing,	1
responsible for creating	1
i++; } }	1
throw(); This allows	1
i++. cmp eax,	1
tools, rather than	1
precedence, not only	1
__intel_cpu_features_init_x(). In other	1
(Some compilers use	1
well- tested library	1
a=a*2; to return	1
interrupt, e.g. every	1
7.1-4, 2008. Digital	1
truncation, and %	1
old. The CPU	1
232-1 uint32_t unsigned	1
API. In some	1
__m128d defines a	1
Wesley 1997. Mostly	1
73) automatically then	1
73. Runtime polymorphism	1
s(0.f, 0.f, 0.f,	1
Active Template Library	1
subset, giving access	1
remedies against this	1
resultant code will	1
sequence, where r	1
safely assume that	1
1]; Here, I	1
kind: "what is	1
environment, between different	1
point). There are	1
(everything that begins	1
2008, v. 9.0	1
bb) { for	1
2008. Digital Mars	1
intrinsics, automatic vectorization	1
intrinsics. Digital Mars	1
layer of a	1
(FILO) basis then	1
linking" if available.	1
14.2a float a;	1
14.2b float a;	1
FuncC. Unrolling the	1
similarly sets the	1
R2 as well	1
apart. I will	1
FMA3 floating point	1
clarity of the	1
these, it is	1
these. The CodeGear,	1
Porting such an	1
wasted. The consequence	1
memmove, memset, or	1
[esp+12] ; edx	1
reserving memory in	1
tempting to fine-	1
levels of cache	1
DelayFiveSeconds() { seconds	1
mimic the behavior	1
Third Edition, 2005;	1
identifying hot spots	1
disagree with this	1
AQtime, Intel VTune	1
14.29 union {	1
14.24 union {	1
14.25 union {	1
Vectors of 256-bit	1
reciprocal, fast approximate	1
14.20 double d	1
14.21 is faster	1
adapt to the	1
unrelated to each	1
unit- test because	1
SelectAddMul_AVX2 #endif //	1
1.6; int a,	1
fighting with the	1
__intel_new_strlen in library	1
ARM platforms and	1
a[i]. Note how	1
at, rather than	1
overwrite the return	1
seconds. A safer	1
399 int b;	1
immintrin.h AMD SSE4A	1
BSF (bit scan	1
seconds; // incremented	1
1.2f; // Example	1
intended, while the	1
makefile. You can	1
strings. In most	1
supply such a	1
queue. It is	1
queue, list, database,	1
from), function parameters,	1
distinguishing between the	1
queue) allocates one	1
comp.lang.asm.x86 for some	1
9.1b. On the	1
cc[]); // function	1
Coarse-grained parallelism refers	1
term for running	1
wstring or CString	1
symbols, but this	1
consequences. I once	1
activating the very	1
sum2; If the	1
minimized. For example,	1
inserted, one by	1
*(T*)0; } //	1
7.30b. The loop	1
vary dynamically and	1
14.4a const int	1
exceed 2 Gbytes.	1
WriteFile(handle, ...)) {	1
&SelectAddMul_SSE41; (iset >=	1
11, Iss. 4,	1
allocated. If the	1
11. Using the	1
minimized if the	1
alias, if appropriate.	1
115 from bb	1
Atom processors, but	1
100> list; //	1
116 // Set	1
111 } You	1
110 // AND	1
around, (3) trap	1
112 Vectorized table	1
-Wstrict-overflow=2, or (5)	1
FuncB(i+1); FuncC(i+1); }	1
minimum, maximum, saturated	1
118 12.7 Mathematical	1
11; // exponent	1
constant: Unsigned is	1
Jr.: "Hacker's Delight".	1
70). The programmer	1
(&) and the	1
list[300] = 0;	1
(&& and ||).	1
Default version return	1
locked after the	1
1./24., 1./120., 1./720.,	1
executed, cache misses,	1
annoying. We may	1
94 Are objects	1
91 step by	1
9; } Induction	1
98 int r,	1
platform, but also	1
exiting the {}	1
rare cases of	1
occupying a cache	1
_mm_and_si128(c2, mask); 110	1
getting them into	1
Linux). Threads are	1
7.41a class vector	1
7.41b a.x =	1
Zero can be	1
endl; // Output	1
0x20 = 0x1C.	1
[eax], ecx DWORD	1
Alternative to multiple	1
NOT on a	1
reports of which	1
registration database in	1
error; and make	1
calling. __fastcall or	1
(arrays can also	1
__declspec(thread). Such variables	1
2.5; // Use	1
granularity is too	1
&= 0x7FFFFFFF; //	1
accessed. Pointer arithmetic	1
BIOS setup. on	1
quadratic matrix, i.e.	1
d+e, then c	1
re-loaded from memory	1
2.5, which is	1
writeable data. Therefore,	1
malloc/free should be	1
(single precision requires	1
"Gnu indirect function"	1
eax,eax. This is	1
nature, it is	1
/arch:SSSE2 -msse4.1 /arch:SSE4.1	1
27. An array	1
1997. Mostly obsolete.	1
Nowadays, programming textbooks	1
Sandy Bridge) because	1
Primitives". These function	1
;startofFunc ; a	1
meaningless event counts	1
--- - -----	1
disturb the users	1
task-specific part of	1
Temporary files that	1
'1' is not	1
dummy[0]; clock =	1
replaces the PLT	1
a+1; b =	1
reproducible. Such events	1
incredibly stupid things.	1
Efficiency Accessing a	1
Re-interpreting the type	1
inheritance. There may	1
inheritance, virtual functions,	1
Future processors will	1
sub-vector before it	1
(^) may give	1
incurred on all	1
b<c) Multiply by	1
Foundation Classes (MFC).	1
volumes in this	1
12.2. Header files	1
